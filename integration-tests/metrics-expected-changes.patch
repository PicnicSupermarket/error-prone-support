--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/CachedGauge.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/CachedGauge.java
@@ -9,8 +9,8 @@ import java.util.concurrent.TimeUnit;
 /**
  * An annotation for marking a method as a gauge, which caches the result for a specified time.
  *
- * <p>
- * Given a method like this:
+ * <p>Given a method like this:
+ *
  * <pre><code>
  *     {@literal @}CachedGauge(name = "queueSize", timeout = 30, timeoutUnit = TimeUnit.SECONDS)
  *     public int getQueueSize() {
@@ -18,36 +18,34 @@ import java.util.concurrent.TimeUnit;
  *     }
  *
  * </code></pre>
- * <p>
  *
- * A gauge for the defining class with the name queueSize will be created which uses the annotated method's
- * return value as its value, and which caches the result for 30 seconds.
+ * <p>A gauge for the defining class with the name queueSize will be created which uses the
+ * annotated method's return value as its value, and which caches the result for 30 seconds.
  *
  * @since 3.1
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })
+@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
 public @interface CachedGauge {
 
-    /**
-     * @return The name of the counter.
-     */
-    String name() default "";
-
-    /**
-     * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the given name
-     * relative to the annotated class.
-     */
-    boolean absolute() default false;
+  /**
+   * @return The name of the counter.
+   */
+  String name() default "";
 
-    /**
-     * @return The amount of time to cache the result
-     */
-    long timeout();
+  /**
+   * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the
+   *     given name relative to the annotated class.
+   */
+  boolean absolute() default false;
 
-    /**
-     * @return The unit of timeout
-     */
-    TimeUnit timeoutUnit() default TimeUnit.MILLISECONDS;
+  /**
+   * @return The amount of time to cache the result
+   */
+  long timeout();
 
+  /**
+   * @return The unit of timeout
+   */
+  TimeUnit timeoutUnit() default TimeUnit.MILLISECONDS;
 }
--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Counted.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Counted.java
@@ -10,44 +10,47 @@ import java.lang.annotation.Target;
 /**
  * An annotation for marking a method of an annotated object as counted.
  *
- * <p>
- * Given a method like this:
+ * <p>Given a method like this:
+ *
  * <pre><code>
  *     {@literal @}Counted(name = "fancyName")
  *     public String fancyName(String name) {
  *         return "Sir Captain " + name;
  *     }
  * </code></pre>
- * <p>
- * A counter for the defining class with the name {@code fancyName} will be created and each time the
- * {@code #fancyName(String)} method is invoked, the counter will be marked.
+ *
+ * <p>A counter for the defining class with the name {@code fancyName} will be created and each time
+ * the {@code #fancyName(String)} method is invoked, the counter will be marked.
  *
  * @since 3.1
  */
 @Inherited
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
+@Target({
+  ElementType.TYPE,
+  ElementType.CONSTRUCTOR,
+  ElementType.METHOD,
+  ElementType.ANNOTATION_TYPE
+})
 public @interface Counted {
 
-    /**
-     * @return The name of the counter.
-     */
-    String name() default "";
-
-    /**
-     * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the given name
-     * relative to the annotated class. When annotating a class, this must be {@code false}.
-     */
-    boolean absolute() default false;
+  /**
+   * @return The name of the counter.
+   */
+  String name() default "";
 
-    /**
-     * @return 
-     * If {@code false} (default), the counter is decremented when the annotated
-     * method returns, counting current invocations of the annotated method.
-     * If {@code true}, the counter increases monotonically, counting total
-     * invocations of the annotated method.
-     */
-    boolean monotonic() default false;
+  /**
+   * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the
+   *     given name relative to the annotated class. When annotating a class, this must be {@code
+   *     false}.
+   */
+  boolean absolute() default false;
 
+  /**
+   * @return If {@code false} (default), the counter is decremented when the annotated method
+   *     returns, counting current invocations of the annotated method. If {@code true}, the counter
+   *     increases monotonically, counting total invocations of the annotated method.
+   */
+  boolean monotonic() default false;
 }
--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/ExceptionMetered.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/ExceptionMetered.java
@@ -9,57 +9,63 @@ import java.lang.annotation.Target;
 
 /**
  * An annotation for marking a method of an annotated object as metered.
- * <p>
- * Given a method like this:
+ *
+ * <p>Given a method like this:
+ *
  * <pre><code>
  *     {@literal @}ExceptionMetered(name = "fancyName", cause=IllegalArgumentException.class)
  *     public String fancyName(String name) {
  *         return "Sir Captain " + name;
  *     }
  * </code></pre>
- * <p>
- * A meter for the defining class with the name {@code fancyName} will be created and each time the
- * {@code #fancyName(String)} throws an exception of type {@code cause} (or a subclass), the meter
- * will be marked.
- * <p>
- * A name for the metric can be specified as an annotation parameter, otherwise, the metric will be
- * named based on the method name.
- * <p>
- * For instance, given a declaration of
+ *
+ * <p>A meter for the defining class with the name {@code fancyName} will be created and each time
+ * the {@code #fancyName(String)} throws an exception of type {@code cause} (or a subclass), the
+ * meter will be marked.
+ *
+ * <p>A name for the metric can be specified as an annotation parameter, otherwise, the metric will
+ * be named based on the method name.
+ *
+ * <p>For instance, given a declaration of
+ *
  * <pre><code>
  *     {@literal @}ExceptionMetered
  *     public String fancyName(String name) {
  *         return "Sir Captain " + name;
  *     }
  * </code></pre>
- * <p>
- * A meter named {@code fancyName.exceptions} will be created and marked every time an exception is
- * thrown.
+ *
+ * <p>A meter named {@code fancyName.exceptions} will be created and marked every time an exception
+ * is thrown.
  */
 @Inherited
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
+@Target({
+  ElementType.TYPE,
+  ElementType.CONSTRUCTOR,
+  ElementType.METHOD,
+  ElementType.ANNOTATION_TYPE
+})
 public @interface ExceptionMetered {
-    /**
-     * The default suffix for meter names.
-     */
-    String DEFAULT_NAME_SUFFIX = "exceptions";
+  /** The default suffix for meter names. */
+  String DEFAULT_NAME_SUFFIX = "exceptions";
 
-    /**
-     * @return The name of the meter. If not specified, the meter will be given a name based on the method
-     * it decorates and the suffix "Exceptions".
-     */
-    String name() default "";
+  /**
+   * @return The name of the meter. If not specified, the meter will be given a name based on the
+   *     method it decorates and the suffix "Exceptions".
+   */
+  String name() default "";
 
-    /**
-     * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the given name
-     * relative to the annotated class. When annotating a class, this must be {@code false}.
-     */
-    boolean absolute() default false;
+  /**
+   * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the
+   *     given name relative to the annotated class. When annotating a class, this must be {@code
+   *     false}.
+   */
+  boolean absolute() default false;
 
-    /**
-     * @return The type of exceptions that the meter will catch and count.
-     */
-    Class<? extends Throwable> cause() default Exception.class;
+  /**
+   * @return The type of exceptions that the meter will catch and count.
+   */
+  Class<? extends Throwable> cause() default Exception.class;
 }
--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Gauge.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Gauge.java
@@ -7,29 +7,30 @@ import java.lang.annotation.Target;
 
 /**
  * An annotation for marking a method of an annotated object as a gauge.
- * <p>
- * Given a method like this:
+ *
+ * <p>Given a method like this:
+ *
  * <pre><code>
  *     {@literal @}Gauge(name = "queueSize")
  *     public int getQueueSize() {
  *         return queue.size;
  *     }
  * </code></pre>
- * <p>
- * A gauge for the defining class with the name {@code queueSize} will be created which uses the
+ *
+ * <p>A gauge for the defining class with the name {@code queueSize} will be created which uses the
  * annotated method's return value as its value.
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE })
+@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
 public @interface Gauge {
-    /**
-     * @return The gauge's name.
-     */
-    String name() default "";
+  /**
+   * @return The gauge's name.
+   */
+  String name() default "";
 
-    /**
-     * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the given name
-     * relative to the annotated class.
-     */
-    boolean absolute() default false;
+  /**
+   * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the
+   *     given name relative to the annotated class.
+   */
+  boolean absolute() default false;
 }
--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Metered.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Metered.java
@@ -9,31 +9,38 @@ import java.lang.annotation.Target;
 
 /**
  * An annotation for marking a method of an annotated object as metered.
- * <p>
- * Given a method like this:
+ *
+ * <p>Given a method like this:
+ *
  * <pre><code>
  *     {@literal @}Metered(name = "fancyName")
  *     public String fancyName(String name) {
  *         return "Sir Captain " + name;
  *     }
  * </code></pre>
- * <p>
- * A meter for the defining class with the name {@code fancyName} will be created and each time the
- * {@code #fancyName(String)} method is invoked, the meter will be marked.
+ *
+ * <p>A meter for the defining class with the name {@code fancyName} will be created and each time
+ * the {@code #fancyName(String)} method is invoked, the meter will be marked.
  */
 @Inherited
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
+@Target({
+  ElementType.TYPE,
+  ElementType.CONSTRUCTOR,
+  ElementType.METHOD,
+  ElementType.ANNOTATION_TYPE
+})
 public @interface Metered {
-    /**
-     * @return The name of the meter.
-     */
-    String name() default "";
+  /**
+   * @return The name of the meter.
+   */
+  String name() default "";
 
-    /**
-     * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the given name
-     * relative to the annotated class. When annotating a class, this must be {@code false}.
-     */
-    boolean absolute() default false;
+  /**
+   * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the
+   *     given name relative to the annotated class. When annotating a class, this must be {@code
+   *     false}.
+   */
+  boolean absolute() default false;
 }
--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Metric.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Metric.java
@@ -8,41 +8,41 @@ import java.lang.annotation.Target;
 /**
  * An annotation requesting that a metric be injected or registered.
  *
- * <p>
- * Given a field like this:
+ * <p>Given a field like this:
+ *
  * <pre><code>
  *     {@literal @}Metric
  *     public Histogram histogram;
  * </code></pre>
- * <p>
- * A meter of the field's type will be created and injected into managed objects.
- * It will be up to the user to interact with the metric. This annotation
- * can be used on fields of type Meter, Timer, Counter, and Histogram.
  *
- * <p>
- * This may also be used to register a metric, which is useful for creating a histogram with
- * a custom Reservoir.
+ * <p>A meter of the field's type will be created and injected into managed objects. It will be up
+ * to the user to interact with the metric. This annotation can be used on fields of type Meter,
+ * Timer, Counter, and Histogram.
+ *
+ * <p>This may also be used to register a metric, which is useful for creating a histogram with a
+ * custom Reservoir.
+ *
  * <pre><code>
  *     {@literal @}Metric
  *     public Histogram uniformHistogram = new Histogram(new UniformReservoir());
  * </code></pre>
+ *
  * <p>
  *
  * @since 3.1
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE })
+@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
 public @interface Metric {
 
-    /**
-     * @return The name of the metric.
-     */
-    String name() default "";
-
-    /**
-     * @return If {@code true}, use the given name as an absolute name. If {@code false},
-     * use the given name relative to the annotated class.
-     */
-    boolean absolute() default false;
+  /**
+   * @return The name of the metric.
+   */
+  String name() default "";
 
+  /**
+   * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the
+   *     given name relative to the annotated class.
+   */
+  boolean absolute() default false;
 }
--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/ResponseMetered.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/ResponseMetered.java
@@ -9,37 +9,44 @@ import java.lang.annotation.Target;
 
 /**
  * An annotation for marking a method of an annotated object as metered.
- * <p>
- * Given a method like this:
+ *
+ * <p>Given a method like this:
+ *
  * <pre><code>
  *     {@literal @}ResponseMetered(name = "fancyName", level = ResponseMeteredLevel.ALL)
  *     public String fancyName(String name) {
  *         return "Sir Captain " + name;
  *     }
  * </code></pre>
- * <p>
- * Meters for the defining class with the name {@code fancyName} will be created for response codes
- * based on the ResponseMeteredLevel selected. Each time the {@code #fancyName(String)} method is invoked,
- * the appropriate response meter will be marked.
+ *
+ * <p>Meters for the defining class with the name {@code fancyName} will be created for response
+ * codes based on the ResponseMeteredLevel selected. Each time the {@code #fancyName(String)} method
+ * is invoked, the appropriate response meter will be marked.
  */
 @Inherited
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
+@Target({
+  ElementType.TYPE,
+  ElementType.CONSTRUCTOR,
+  ElementType.METHOD,
+  ElementType.ANNOTATION_TYPE
+})
 public @interface ResponseMetered {
-    /**
-     * @return The name of the meter.
-     */
-    String name() default "";
+  /**
+   * @return The name of the meter.
+   */
+  String name() default "";
 
-    /**
-     * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the given name
-     * relative to the annotated class. When annotating a class, this must be {@code false}.
-     */
-    boolean absolute() default false;
+  /**
+   * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the
+   *     given name relative to the annotated class. When annotating a class, this must be {@code
+   *     false}.
+   */
+  boolean absolute() default false;
 
-    /**
-     * @return the ResponseMeteredLevel which decides which response code meters are marked.
-     */
-    ResponseMeteredLevel level() default ResponseMeteredLevel.COARSE;
+  /**
+   * @return the ResponseMeteredLevel which decides which response code meters are marked.
+   */
+  ResponseMeteredLevel level() default ResponseMeteredLevel.COARSE;
 }
--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/ResponseMeteredLevel.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/ResponseMeteredLevel.java
@@ -1,23 +1,19 @@
 package io.dropwizard.metrics5.annotation;
 
 /**
- * {@link ResponseMeteredLevel} is a parameter for the {@link ResponseMetered} annotation.
- * The constants of this enumerated type decide what meters are included when a class
- * or method is annotated with the {@link ResponseMetered} annotation.
+ * {@link ResponseMeteredLevel} is a parameter for the {@link ResponseMetered} annotation. The
+ * constants of this enumerated type decide what meters are included when a class or method is
+ * annotated with the {@link ResponseMetered} annotation.
  */
 public enum ResponseMeteredLevel {
-    /**
-     * Include meters for 1xx/2xx/3xx/4xx/5xx responses
-     */
-    COARSE,
+  /** Include meters for 1xx/2xx/3xx/4xx/5xx responses */
+  COARSE,
 
-    /**
-     * Include meters for every response code (200, 201, 303, 304, 401, 404, 501, etc.)
-     */
-    DETAILED,
+  /** Include meters for every response code (200, 201, 303, 304, 401, 404, 501, etc.) */
+  DETAILED,
 
-    /**
-     * Include meters for every response code in addition to top level 1xx/2xx/3xx/4xx/5xx responses
-     */
-    ALL;
+  /**
+   * Include meters for every response code in addition to top level 1xx/2xx/3xx/4xx/5xx responses
+   */
+  ALL;
 }
--- a/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Timed.java
+++ b/metrics-annotation/src/main/java/io/dropwizard/metrics5/annotation/Timed.java
@@ -9,31 +9,38 @@ import java.lang.annotation.Target;
 
 /**
  * An annotation for marking a method of an annotated object as timed.
- * <p>
- * Given a method like this:
+ *
+ * <p>Given a method like this:
+ *
  * <pre><code>
  *     {@literal @}Timed(name = "fancyName")
  *     public String fancyName(String name) {
  *         return "Sir Captain " + name;
  *     }
  * </code></pre>
- * <p>
- * A timer for the defining class with the name {@code fancyName} will be created and each time the
- * {@code #fancyName(String)} method is invoked, the method's execution will be timed.
+ *
+ * <p>A timer for the defining class with the name {@code fancyName} will be created and each time
+ * the {@code #fancyName(String)} method is invoked, the method's execution will be timed.
  */
 @Inherited
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
+@Target({
+  ElementType.TYPE,
+  ElementType.CONSTRUCTOR,
+  ElementType.METHOD,
+  ElementType.ANNOTATION_TYPE
+})
 public @interface Timed {
-    /**
-     * @return The name of the timer.
-     */
-    String name() default "";
+  /**
+   * @return The name of the timer.
+   */
+  String name() default "";
 
-    /**
-     * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the given name
-     * relative to the annotated class. When annotating a class, this must be {@code false}.
-     */
-    boolean absolute() default false;
+  /**
+   * @return If {@code true}, use the given name as an absolute name. If {@code false}, use the
+   *     given name relative to the annotated class. When annotating a class, this must be {@code
+   *     false}.
+   */
+  boolean absolute() default false;
 }
--- a/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/CachedGaugeBenchmark.java
+++ b/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/CachedGaugeBenchmark.java
@@ -1,6 +1,7 @@
 package io.dropwizard.metrics5.benchmarks;
 
 import io.dropwizard.metrics5.CachedGauge;
+import java.util.concurrent.TimeUnit;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.State;
@@ -10,37 +11,37 @@ import org.openjdk.jmh.runner.RunnerException;
 import org.openjdk.jmh.runner.options.Options;
 import org.openjdk.jmh.runner.options.OptionsBuilder;
 
-import java.util.concurrent.TimeUnit;
-
 @State(Scope.Benchmark)
 public class CachedGaugeBenchmark {
 
-    private CachedGauge<Integer> cachedGauge = new CachedGauge<Integer>(100, TimeUnit.MILLISECONDS) {
+  private CachedGauge<Integer> cachedGauge =
+      new CachedGauge<Integer>(100, TimeUnit.MILLISECONDS) {
         @Override
         protected Integer loadValue() {
-            try {
-                Thread.sleep(10);
-            } catch (InterruptedException e) {
-                throw new RuntimeException("Thread was interrupted", e);
-            }
-            return 12345;
+          try {
+            Thread.sleep(10);
+          } catch (InterruptedException e) {
+            throw new RuntimeException("Thread was interrupted", e);
+          }
+          return 12345;
         }
-    };
+      };
 
-    @Benchmark
-    public void perfGetValue(Blackhole blackhole) {
-        blackhole.consume(cachedGauge.getValue());
-    }
+  @Benchmark
+  public void perfGetValue(Blackhole blackhole) {
+    blackhole.consume(cachedGauge.getValue());
+  }
 
-    public static void main(String[] args) throws RunnerException {
-        Options opt = new OptionsBuilder()
-                .include(".*" + CachedGaugeBenchmark.class.getSimpleName() + ".*")
-                .warmupIterations(3)
-                .measurementIterations(5)
-                .threads(4)
-                .forks(1)
-                .build();
+  public static void main(String[] args) throws RunnerException {
+    Options opt =
+        new OptionsBuilder()
+            .include(".*" + CachedGaugeBenchmark.class.getSimpleName() + ".*")
+            .warmupIterations(3)
+            .measurementIterations(5)
+            .threads(4)
+            .forks(1)
+            .build();
 
-        new Runner(opt).run();
-    }
+    new Runner(opt).run();
+  }
 }
--- a/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/CounterBenchmark.java
+++ b/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/CounterBenchmark.java
@@ -12,27 +12,27 @@ import org.openjdk.jmh.runner.options.OptionsBuilder;
 @State(Scope.Benchmark)
 public class CounterBenchmark {
 
-    private final Counter counter = new Counter();
-
-    // It's intentionally not declared as final to avoid constant folding
-    private long nextValue = 0xFBFBABBA;
-
-    @Benchmark
-    public Object perfIncrement() {
-        counter.inc(nextValue); 
-        return counter;
-    }
-
-    public static void main(String[] args) throws RunnerException {
-        Options opt = new OptionsBuilder()
-                .include(".*" + CounterBenchmark.class.getSimpleName() + ".*")
-                .warmupIterations(3)
-                .measurementIterations(5)
-                .threads(4)
-                .forks(1)
-                .build();
-
-        new Runner(opt).run();
-    }
-
+  private final Counter counter = new Counter();
+
+  // It's intentionally not declared as final to avoid constant folding
+  private long nextValue = 0xFBFBABBA;
+
+  @Benchmark
+  public Object perfIncrement() {
+    counter.inc(nextValue);
+    return counter;
+  }
+
+  public static void main(String[] args) throws RunnerException {
+    Options opt =
+        new OptionsBuilder()
+            .include(".*" + CounterBenchmark.class.getSimpleName() + ".*")
+            .warmupIterations(3)
+            .measurementIterations(5)
+            .threads(4)
+            .forks(1)
+            .build();
+
+    new Runner(opt).run();
+  }
 }
--- a/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/MeterBenchmark.java
+++ b/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/MeterBenchmark.java
@@ -12,27 +12,27 @@ import org.openjdk.jmh.runner.options.OptionsBuilder;
 @State(Scope.Benchmark)
 public class MeterBenchmark {
 
-    private final Meter meter = new Meter();
-
-    // It's intentionally not declared as final to avoid constant folding
-    private long nextValue = 0xFBFBABBA;
-
-    @Benchmark
-    public Object perfMark() {
-        meter.mark(nextValue);
-        return meter;
-    }
-
-    public static void main(String[] args) throws RunnerException {
-        Options opt = new OptionsBuilder()
-                .include(".*" + MeterBenchmark.class.getSimpleName() + ".*")
-                .warmupIterations(3)
-                .measurementIterations(5)
-                .threads(4)
-                .forks(1)
-                .build();
-
-        new Runner(opt).run();
-    }
-
+  private final Meter meter = new Meter();
+
+  // It's intentionally not declared as final to avoid constant folding
+  private long nextValue = 0xFBFBABBA;
+
+  @Benchmark
+  public Object perfMark() {
+    meter.mark(nextValue);
+    return meter;
+  }
+
+  public static void main(String[] args) throws RunnerException {
+    Options opt =
+        new OptionsBuilder()
+            .include(".*" + MeterBenchmark.class.getSimpleName() + ".*")
+            .warmupIterations(3)
+            .measurementIterations(5)
+            .threads(4)
+            .forks(1)
+            .build();
+
+    new Runner(opt).run();
+  }
 }
--- a/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/ReservoirBenchmark.java
+++ b/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/ReservoirBenchmark.java
@@ -7,6 +7,7 @@ import io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir;
 import io.dropwizard.metrics5.SlidingTimeWindowReservoir;
 import io.dropwizard.metrics5.SlidingWindowReservoir;
 import io.dropwizard.metrics5.UniformReservoir;
+import java.util.concurrent.TimeUnit;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Mode;
 import org.openjdk.jmh.annotations.Scope;
@@ -18,59 +19,61 @@ import org.openjdk.jmh.runner.options.Options;
 import org.openjdk.jmh.runner.options.OptionsBuilder;
 import org.openjdk.jmh.runner.options.TimeValue;
 
-import java.util.concurrent.TimeUnit;
-
 @State(Scope.Benchmark)
 public class ReservoirBenchmark {
 
-    private final UniformReservoir uniform = new UniformReservoir();
-    private final ExponentiallyDecayingReservoir exponential = new ExponentiallyDecayingReservoir();
-    private final Reservoir lockFreeExponential = LockFreeExponentiallyDecayingReservoir.builder().build();
-    private final SlidingWindowReservoir sliding = new SlidingWindowReservoir(1000);
-    private final SlidingTimeWindowReservoir slidingTime = new SlidingTimeWindowReservoir(200, TimeUnit.MILLISECONDS);
-    private final SlidingTimeWindowArrayReservoir arrTime = new SlidingTimeWindowArrayReservoir(200, TimeUnit.MILLISECONDS);
+  private final UniformReservoir uniform = new UniformReservoir();
+  private final ExponentiallyDecayingReservoir exponential = new ExponentiallyDecayingReservoir();
+  private final Reservoir lockFreeExponential =
+      LockFreeExponentiallyDecayingReservoir.builder().build();
+  private final SlidingWindowReservoir sliding = new SlidingWindowReservoir(1000);
+  private final SlidingTimeWindowReservoir slidingTime =
+      new SlidingTimeWindowReservoir(200, TimeUnit.MILLISECONDS);
+  private final SlidingTimeWindowArrayReservoir arrTime =
+      new SlidingTimeWindowArrayReservoir(200, TimeUnit.MILLISECONDS);
 
-    // It's intentionally not declared as final to avoid constant folding
-    private long nextValue = 0xFBFBABBA;
+  // It's intentionally not declared as final to avoid constant folding
+  private long nextValue = 0xFBFBABBA;
 
-    @Benchmark
-    public Object perfUniformReservoir() {
-        uniform.update(nextValue);
-        return uniform;
-    }
+  @Benchmark
+  public Object perfUniformReservoir() {
+    uniform.update(nextValue);
+    return uniform;
+  }
 
-    @Benchmark
-    public Object perfSlidingTimeWindowArrayReservoir() {
-        arrTime.update(nextValue);
-        return arrTime;
-    }
+  @Benchmark
+  public Object perfSlidingTimeWindowArrayReservoir() {
+    arrTime.update(nextValue);
+    return arrTime;
+  }
 
-    @Benchmark
-    public Object perfExponentiallyDecayingReservoir() {
-        exponential.update(nextValue);
-        return exponential;
-    }
+  @Benchmark
+  public Object perfExponentiallyDecayingReservoir() {
+    exponential.update(nextValue);
+    return exponential;
+  }
 
-    @Benchmark
-    public Object perfSlidingWindowReservoir() {
-        sliding.update(nextValue);
-        return sliding;
-    }
+  @Benchmark
+  public Object perfSlidingWindowReservoir() {
+    sliding.update(nextValue);
+    return sliding;
+  }
 
-    @Benchmark
-    public Object perfSlidingTimeWindowReservoir() {
-        slidingTime.update(nextValue);
-        return slidingTime;
-    }
+  @Benchmark
+  public Object perfSlidingTimeWindowReservoir() {
+    slidingTime.update(nextValue);
+    return slidingTime;
+  }
 
-    @Benchmark
-    public Object perfLockFreeExponentiallyDecayingReservoir() {
-        lockFreeExponential.update(nextValue);
-        return lockFreeExponential;
-    }
+  @Benchmark
+  public Object perfLockFreeExponentiallyDecayingReservoir() {
+    lockFreeExponential.update(nextValue);
+    return lockFreeExponential;
+  }
 
-    public static void main(String[] args) throws RunnerException {
-        Options opt = new OptionsBuilder()
+  public static void main(String[] args) throws RunnerException {
+    Options opt =
+        new OptionsBuilder()
             .include(".*" + ReservoirBenchmark.class.getSimpleName() + ".*")
             .warmupIterations(10)
             .measurementIterations(10)
@@ -82,7 +85,6 @@ public class ReservoirBenchmark {
             .forks(1)
             .build();
 
-        new Runner(opt).run();
-    }
-
+    new Runner(opt).run();
+  }
 }
--- a/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/SlidingTimeWindowReservoirsBenchmark.java
+++ b/metrics-benchmarks/src/main/java/io/dropwizard/metrics5/benchmarks/SlidingTimeWindowReservoirsBenchmark.java
@@ -2,7 +2,7 @@ package io.dropwizard.metrics5.benchmarks;
 
 import io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir;
 import io.dropwizard.metrics5.SlidingTimeWindowReservoir;
-import io.dropwizard.metrics5.Snapshot;
+import java.util.concurrent.TimeUnit;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Group;
 import org.openjdk.jmh.annotations.GroupThreads;
@@ -16,53 +16,52 @@ import org.openjdk.jmh.runner.options.Options;
 import org.openjdk.jmh.runner.options.OptionsBuilder;
 import org.openjdk.jmh.runner.options.TimeValue;
 
-import java.util.concurrent.TimeUnit;
-
 /**
  * @author bstorozhuk
  */
 @State(Scope.Benchmark)
 public class SlidingTimeWindowReservoirsBenchmark {
-    private final SlidingTimeWindowReservoir slidingTime = new SlidingTimeWindowReservoir(200, TimeUnit.MILLISECONDS);
-    private final SlidingTimeWindowArrayReservoir arrTime = new SlidingTimeWindowArrayReservoir(200, TimeUnit.MILLISECONDS);
+  private final SlidingTimeWindowReservoir slidingTime =
+      new SlidingTimeWindowReservoir(200, TimeUnit.MILLISECONDS);
+  private final SlidingTimeWindowArrayReservoir arrTime =
+      new SlidingTimeWindowArrayReservoir(200, TimeUnit.MILLISECONDS);
 
-    // It's intentionally not declared as final to avoid constant folding
-    private long nextValue = 0xFBFBABBA;
+  // It's intentionally not declared as final to avoid constant folding
+  private long nextValue = 0xFBFBABBA;
 
-    @Benchmark
-    @Group("slidingTime")
-    @GroupThreads(3)
-    public Object slidingTimeAddMeasurement() {
-        slidingTime.update(nextValue);
-        return slidingTime;
-    }
+  @Benchmark
+  @Group("slidingTime")
+  @GroupThreads(3)
+  public Object slidingTimeAddMeasurement() {
+    slidingTime.update(nextValue);
+    return slidingTime;
+  }
 
-    @Benchmark
-    @Group("slidingTime")
-    @GroupThreads(1)
-    public Object slidingTimeRead() {
-        Snapshot snapshot = slidingTime.getSnapshot();
-        return snapshot;
-    }
+  @Benchmark
+  @Group("slidingTime")
+  @GroupThreads(1)
+  public Object slidingTimeRead() {
+    return slidingTime.getSnapshot();
+  }
 
-    @Benchmark
-    @Group("arrTime")
-    @GroupThreads(3)
-    public Object arrTimeAddMeasurement() {
-        arrTime.update(nextValue);
-        return slidingTime;
-    }
+  @Benchmark
+  @Group("arrTime")
+  @GroupThreads(3)
+  public Object arrTimeAddMeasurement() {
+    arrTime.update(nextValue);
+    return slidingTime;
+  }
 
-    @Benchmark
-    @Group("arrTime")
-    @GroupThreads(1)
-    public Object arrTimeRead() {
-        Snapshot snapshot = arrTime.getSnapshot();
-        return snapshot;
-    }
+  @Benchmark
+  @Group("arrTime")
+  @GroupThreads(1)
+  public Object arrTimeRead() {
+    return arrTime.getSnapshot();
+  }
 
-    public static void main(String[] args) throws RunnerException {
-        Options opt = new OptionsBuilder()
+  public static void main(String[] args) throws RunnerException {
+    Options opt =
+        new OptionsBuilder()
             .include(".*" + SlidingTimeWindowReservoirsBenchmark.class.getSimpleName() + ".*")
             .warmupIterations(10)
             .measurementIterations(10)
@@ -73,7 +72,6 @@ public class SlidingTimeWindowReservoirsBenchmark {
             .forks(1)
             .build();
 
-        new Runner(opt).run();
-    }
+    new Runner(opt).run();
+  }
 }
-
--- a/metrics-caffeine3/src/main/java/io/dropwizard/metrics5/caffeine3/MetricsStatsCounter.java
+++ b/metrics-caffeine3/src/main/java/io/dropwizard/metrics5/caffeine3/MetricsStatsCounter.java
@@ -15,6 +15,8 @@
  */
 package io.dropwizard.metrics5.caffeine3;
 
+import static java.util.Objects.requireNonNull;
+
 import com.github.benmanes.caffeine.cache.RemovalCause;
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
 import com.github.benmanes.caffeine.cache.stats.StatsCounter;
@@ -22,13 +24,10 @@ import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Histogram;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
-import org.checkerframework.checker.index.qual.NonNegative;
-
 import java.util.EnumMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.LongAdder;
-
-import static java.util.Objects.requireNonNull;
+import org.checkerframework.checker.index.qual.NonNegative;
 
 /**
  * A {@link StatsCounter} instrumented with Dropwizard Metrics.
@@ -64,8 +63,7 @@ public final class MetricsStatsCounter implements StatsCounter {
     evictionsWithCause = new EnumMap<>(RemovalCause.class);
     for (RemovalCause cause : RemovalCause.values()) {
       evictionsWithCause.put(
-          cause,
-          registry.histogram(MetricRegistry.name(metricsPrefix, "evictions", cause.name())));
+          cause, registry.histogram(MetricRegistry.name(metricsPrefix, "evictions", cause.name())));
     }
   }
 
--- a/metrics-caffeine3/src/test/java/io/dropwizard/metrics5/caffeine3/MetricsStatsCounterTest.java
+++ b/metrics-caffeine3/src/test/java/io/dropwizard/metrics5/caffeine3/MetricsStatsCounterTest.java
@@ -15,19 +15,18 @@
  */
 package io.dropwizard.metrics5.caffeine3;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.LoadingCache;
 import com.github.benmanes.caffeine.cache.RemovalCause;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import io.dropwizard.metrics5.MetricRegistry;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
 /**
- * An example of exporting stats to  <a href="https://metrics.dropwizard.io">Dropwizard Metrics</a>.
+ * An example of exporting stats to <a href="https://metrics.dropwizard.io">Dropwizard Metrics</a>.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  * @author John Karp
@@ -47,9 +46,10 @@ final class MetricsStatsCounterTest {
 
   @Test
   void basicUsage() {
-    LoadingCache<Integer, Integer> cache = Caffeine.newBuilder()
-        .recordStats(() -> new MetricsStatsCounter(registry, PREFIX))
-        .build(key -> key);
+    LoadingCache<Integer, Integer> cache =
+        Caffeine.newBuilder()
+            .recordStats(() -> new MetricsStatsCounter(registry, PREFIX))
+            .build(key -> key);
 
     // Perform application work
     for (int i = 0; i < 4; i++) {
--- a/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/CollectdReporter.java
+++ b/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/CollectdReporter.java
@@ -1,5 +1,21 @@
 package io.dropwizard.metrics5.collectd;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static io.dropwizard.metrics5.MetricAttribute.COUNT;
+import static io.dropwizard.metrics5.MetricAttribute.M15_RATE;
+import static io.dropwizard.metrics5.MetricAttribute.M1_RATE;
+import static io.dropwizard.metrics5.MetricAttribute.M5_RATE;
+import static io.dropwizard.metrics5.MetricAttribute.MEAN;
+import static io.dropwizard.metrics5.MetricAttribute.MEAN_RATE;
+import static io.dropwizard.metrics5.MetricAttribute.P50;
+import static io.dropwizard.metrics5.MetricAttribute.P75;
+import static io.dropwizard.metrics5.MetricAttribute.P95;
+import static io.dropwizard.metrics5.MetricAttribute.P98;
+import static io.dropwizard.metrics5.MetricAttribute.P99;
+import static io.dropwizard.metrics5.MetricAttribute.P999;
+import static io.dropwizard.metrics5.MetricAttribute.STDDEV;
+
+import com.google.common.collect.ImmutableSet;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
@@ -12,326 +28,337 @@ import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.ScheduledReporter;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.IOException;
 import java.net.InetAddress;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.MetricAttribute.COUNT;
-import static io.dropwizard.metrics5.MetricAttribute.M15_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.M1_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.M5_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.MAX;
-import static io.dropwizard.metrics5.MetricAttribute.MEAN;
-import static io.dropwizard.metrics5.MetricAttribute.MEAN_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.MIN;
-import static io.dropwizard.metrics5.MetricAttribute.P50;
-import static io.dropwizard.metrics5.MetricAttribute.P75;
-import static io.dropwizard.metrics5.MetricAttribute.P95;
-import static io.dropwizard.metrics5.MetricAttribute.P98;
-import static io.dropwizard.metrics5.MetricAttribute.P99;
-import static io.dropwizard.metrics5.MetricAttribute.P999;
-import static io.dropwizard.metrics5.MetricAttribute.STDDEV;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A reporter which publishes metric values to a Collectd server.
  *
- * @see <a href="https://collectd.org">collectd – The system statistics
- * collection daemon</a>
+ * @see <a href="https://collectd.org">collectd – The system statistics collection daemon</a>
  */
 public class CollectdReporter extends ScheduledReporter {
 
-    /**
-     * Returns a builder for the specified registry.
-     * <p>
-     * The default settings are:
-     * <ul>
-     * <li>hostName: InetAddress.getLocalHost().getHostName()</li>
-     * <li>executor: default executor created by {@code ScheduledReporter}</li>
-     * <li>shutdownExecutorOnStop: true</li>
-     * <li>clock: Clock.defaultClock()</li>
-     * <li>rateUnit: TimeUnit.SECONDS</li>
-     * <li>durationUnit: TimeUnit.MILLISECONDS</li>
-     * <li>filter: MetricFilter.ALL</li>
-     * <li>securityLevel: NONE</li>
-     * <li>username: ""</li>
-     * <li>password: ""</li>
-     * </ul>
-     */
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
+  /**
+   * Returns a builder for the specified registry.
+   *
+   * <p>The default settings are:
+   *
+   * <ul>
+   *   <li>hostName: InetAddress.getLocalHost().getHostName()
+   *   <li>executor: default executor created by {@code ScheduledReporter}
+   *   <li>shutdownExecutorOnStop: true
+   *   <li>clock: Clock.defaultClock()
+   *   <li>rateUnit: TimeUnit.SECONDS
+   *   <li>durationUnit: TimeUnit.MILLISECONDS
+   *   <li>filter: MetricFilter.ALL
+   *   <li>securityLevel: NONE
+   *   <li>username: ""
+   *   <li>password: ""
+   * </ul>
+   */
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
+
+  public static class Builder {
+
+    private final MetricRegistry registry;
+    private String hostName;
+    private ScheduledExecutorService executor;
+    private boolean shutdownExecutorOnStop = true;
+    private Clock clock = Clock.defaultClock();
+    private TimeUnit rateUnit = TimeUnit.SECONDS;
+    private TimeUnit durationUnit = TimeUnit.MILLISECONDS;
+    private MetricFilter filter = MetricFilter.ALL;
+    private SecurityLevel securityLevel = SecurityLevel.NONE;
+    private String username = "";
+    private String password = "";
+    private Set<MetricAttribute> disabledMetricAttributes = ImmutableSet.of();
+    private int maxLength = Sanitize.DEFAULT_MAX_LENGTH;
+
+    private Builder(MetricRegistry registry) {
+      this.registry = registry;
     }
 
-    public static class Builder {
-
-        private final MetricRegistry registry;
-        private String hostName;
-        private ScheduledExecutorService executor;
-        private boolean shutdownExecutorOnStop = true;
-        private Clock clock = Clock.defaultClock();
-        private TimeUnit rateUnit = TimeUnit.SECONDS;
-        private TimeUnit durationUnit = TimeUnit.MILLISECONDS;
-        private MetricFilter filter = MetricFilter.ALL;
-        private SecurityLevel securityLevel = SecurityLevel.NONE;
-        private String username = "";
-        private String password = "";
-        private Set<MetricAttribute> disabledMetricAttributes = Collections.emptySet();
-        private int maxLength = Sanitize.DEFAULT_MAX_LENGTH;
-
-        private Builder(MetricRegistry registry) {
-            this.registry = registry;
-        }
-
-        public Builder withHostName(String hostName) {
-            this.hostName = hostName;
-            return this;
-        }
-
-        public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            this.shutdownExecutorOnStop = shutdownExecutorOnStop;
-            return this;
-        }
-
-        public Builder scheduleOn(ScheduledExecutorService executor) {
-            this.executor = executor;
-            return this;
-        }
-
-        public Builder withClock(Clock clock) {
-            this.clock = clock;
-            return this;
-        }
-
-        public Builder convertRatesTo(TimeUnit rateUnit) {
-            this.rateUnit = rateUnit;
-            return this;
-        }
-
-        public Builder convertDurationsTo(TimeUnit durationUnit) {
-            this.durationUnit = durationUnit;
-            return this;
-        }
-
-        public Builder filter(MetricFilter filter) {
-            this.filter = filter;
-            return this;
-        }
-
-        public Builder withUsername(String username) {
-            this.username = username;
-            return this;
-        }
-
-        public Builder withPassword(String password) {
-            this.password = password;
-            return this;
-        }
-
-        public Builder withSecurityLevel(SecurityLevel securityLevel) {
-            this.securityLevel = securityLevel;
-            return this;
-        }
-
-        public Builder disabledMetricAttributes(Set<MetricAttribute> attributes) {
-            this.disabledMetricAttributes = attributes;
-            return this;
-        }
-
-        public Builder withMaxLength(int maxLength) {
-            this.maxLength = maxLength;
-            return this;
-        }
-
-        public CollectdReporter build(Sender sender) {
-            if (securityLevel != SecurityLevel.NONE) {
-                if (username.isEmpty()) {
-                    throw new IllegalArgumentException("username is required for securityLevel: " + securityLevel);
-                }
-                if (password.isEmpty()) {
-                    throw new IllegalArgumentException("password is required for securityLevel: " + securityLevel);
-                }
-            }
-            return new CollectdReporter(registry,
-                    hostName, sender,
-                    executor, shutdownExecutorOnStop,
-                    clock, rateUnit, durationUnit,
-                    filter, disabledMetricAttributes,
-                    username, password, securityLevel, new Sanitize(maxLength));
-        }
+    public Builder withHostName(String hostName) {
+      this.hostName = hostName;
+      return this;
     }
 
-    private static final Logger LOG = LoggerFactory.getLogger(CollectdReporter.class);
-    private static final String REPORTER_NAME = "collectd-reporter";
-    private static final String FALLBACK_HOST_NAME = "localhost";
-    private static final String COLLECTD_TYPE_GAUGE = "gauge";
-
-    private String hostName;
-    private final Sender sender;
-    private final Clock clock;
-    private long period;
-    private final PacketWriter writer;
-    private final Sanitize sanitize;
-
-    private CollectdReporter(MetricRegistry registry,
-                             String hostname, Sender sender,
-                             ScheduledExecutorService executor, boolean shutdownExecutorOnStop,
-                             Clock clock, TimeUnit rateUnit, TimeUnit durationUnit,
-                             MetricFilter filter, Set<MetricAttribute> disabledMetricAttributes,
-                             String username, String password,
-                             SecurityLevel securityLevel, Sanitize sanitize) {
-        super(registry, REPORTER_NAME, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop,
-                disabledMetricAttributes);
-        this.hostName = (hostname != null) ? hostname : resolveHostName();
-        this.sender = sender;
-        this.clock = clock;
-        this.sanitize = sanitize;
-        writer = new PacketWriter(sender, username, password, securityLevel);
+    public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      this.shutdownExecutorOnStop = shutdownExecutorOnStop;
+      return this;
     }
 
-    private String resolveHostName() {
-        try {
-            return InetAddress.getLocalHost().getHostName();
-        } catch (Exception e) {
-            LOG.error("Failed to lookup local host name: {}", e.getMessage(), e);
-            return FALLBACK_HOST_NAME;
-        }
+    public Builder scheduleOn(ScheduledExecutorService executor) {
+      this.executor = executor;
+      return this;
     }
 
-    @Override
-    public void start(long period, TimeUnit unit) {
-        this.period = period;
-        super.start(period, unit);
+    public Builder withClock(Clock clock) {
+      this.clock = clock;
+      return this;
     }
 
-    @Override
-    public void report(SortedMap<MetricName, Gauge<?>> gauges, SortedMap<MetricName, Counter> counters,
-                       SortedMap<MetricName, Histogram> histograms, SortedMap<MetricName, Meter> meters,
-                       SortedMap<MetricName, Timer> timers) {
-        MetaData.Builder metaData = new MetaData.Builder(sanitize, hostName, clock.getTime() / 1000, period)
-                .type(COLLECTD_TYPE_GAUGE);
-        try {
-            connect(sender);
-            for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
-                serializeGauge(metaData.plugin(entry.getKey().getKey()), entry.getValue());
-            }
-            for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
-                serializeCounter(metaData.plugin(entry.getKey().getKey()), entry.getValue());
-            }
-            for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
-                serializeHistogram(metaData.plugin(entry.getKey().getKey()), entry.getValue());
-            }
-            for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
-                serializeMeter(metaData.plugin(entry.getKey().getKey()), entry.getValue());
-            }
-            for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
-                serializeTimer(metaData.plugin(entry.getKey().getKey()), entry.getValue());
-            }
-        } catch (IOException e) {
-            LOG.warn("Unable to report to Collectd", e);
-        } finally {
-            disconnect(sender);
-        }
+    public Builder convertRatesTo(TimeUnit rateUnit) {
+      this.rateUnit = rateUnit;
+      return this;
     }
 
-    private void connect(Sender sender) throws IOException {
-        if (!sender.isConnected()) {
-            sender.connect();
-        }
+    public Builder convertDurationsTo(TimeUnit durationUnit) {
+      this.durationUnit = durationUnit;
+      return this;
     }
 
-    private void disconnect(Sender sender) {
-        try {
-            sender.disconnect();
-        } catch (Exception e) {
-            LOG.warn("Error disconnecting from Collectd", e);
-        }
+    public Builder filter(MetricFilter filter) {
+      this.filter = filter;
+      return this;
     }
 
-    private void writeValue(MetaData.Builder metaData, MetricAttribute attribute, Number value) {
-        if (!getDisabledMetricAttributes().contains(attribute)) {
-            write(metaData.typeInstance(attribute.getCode()).get(), value);
-        }
+    public Builder withUsername(String username) {
+      this.username = username;
+      return this;
     }
 
-    private void writeRate(MetaData.Builder metaData, MetricAttribute attribute, double rate) {
-        writeValue(metaData, attribute, convertRate(rate));
+    public Builder withPassword(String password) {
+      this.password = password;
+      return this;
     }
 
-    private void writeDuration(MetaData.Builder metaData, MetricAttribute attribute, double duration) {
-        writeValue(metaData, attribute, convertDuration(duration));
+    public Builder withSecurityLevel(SecurityLevel securityLevel) {
+      this.securityLevel = securityLevel;
+      return this;
     }
 
-    private void write(MetaData metaData, Number value) {
-        try {
-            writer.write(metaData, value);
-        } catch (RuntimeException e) {
-            LOG.warn("Failed to process metric '" + metaData.getPlugin() + "': " + e.getMessage());
-        } catch (IOException e) {
-            LOG.error("Failed to send metric to collectd", e);
-        }
+    public Builder disabledMetricAttributes(Set<MetricAttribute> attributes) {
+      this.disabledMetricAttributes = attributes;
+      return this;
     }
 
-    private void serializeGauge(MetaData.Builder metaData, Gauge metric) {
-        if (metric.getValue() instanceof Number) {
-            write(metaData.typeInstance("value").get(), (Number) metric.getValue());
-        } else if (metric.getValue() instanceof Boolean) {
-            write(metaData.typeInstance("value").get(), ((Boolean) metric.getValue()) ? 1 : 0);
-        } else {
-            LOG.warn("Failed to process metric '{}'. Unsupported gauge of type: {} ", metaData.get().getPlugin(),
-                    metric.getValue().getClass().getName());
-        }
+    public Builder withMaxLength(int maxLength) {
+      this.maxLength = maxLength;
+      return this;
     }
 
-    private void serializeMeter(MetaData.Builder metaData, Meter metric) {
-        writeValue(metaData, COUNT, (double) metric.getCount());
-        writeRate(metaData, M1_RATE, metric.getOneMinuteRate());
-        writeRate(metaData, M5_RATE, metric.getFiveMinuteRate());
-        writeRate(metaData, M15_RATE, metric.getFifteenMinuteRate());
-        writeRate(metaData, MEAN_RATE, metric.getMeanRate());
+    public CollectdReporter build(Sender sender) {
+      if (securityLevel != SecurityLevel.NONE) {
+        checkArgument(
+            !username.isEmpty(), "username is required for securityLevel: %s", securityLevel);
+        checkArgument(
+            !password.isEmpty(), "password is required for securityLevel: %s", securityLevel);
+      }
+      return new CollectdReporter(
+          registry,
+          hostName,
+          sender,
+          executor,
+          shutdownExecutorOnStop,
+          clock,
+          rateUnit,
+          durationUnit,
+          filter,
+          disabledMetricAttributes,
+          username,
+          password,
+          securityLevel,
+          new Sanitize(maxLength));
+    }
+  }
+
+  private static final Logger LOG = LoggerFactory.getLogger(CollectdReporter.class);
+  private static final String REPORTER_NAME = "collectd-reporter";
+  private static final String FALLBACK_HOST_NAME = "localhost";
+  private static final String COLLECTD_TYPE_GAUGE = "gauge";
+
+  private String hostName;
+  private final Sender sender;
+  private final Clock clock;
+  private long period;
+  private final PacketWriter writer;
+  private final Sanitize sanitize;
+
+  private CollectdReporter(
+      MetricRegistry registry,
+      String hostname,
+      Sender sender,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Clock clock,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      MetricFilter filter,
+      Set<MetricAttribute> disabledMetricAttributes,
+      String username,
+      String password,
+      SecurityLevel securityLevel,
+      Sanitize sanitize) {
+    super(
+        registry,
+        REPORTER_NAME,
+        filter,
+        rateUnit,
+        durationUnit,
+        executor,
+        shutdownExecutorOnStop,
+        disabledMetricAttributes);
+    this.hostName = (hostname != null) ? hostname : resolveHostName();
+    this.sender = sender;
+    this.clock = clock;
+    this.sanitize = sanitize;
+    writer = new PacketWriter(sender, username, password, securityLevel);
+  }
+
+  private String resolveHostName() {
+    try {
+      return InetAddress.getLocalHost().getHostName();
+    } catch (Exception e) {
+      LOG.error("Failed to lookup local host name: {}", e.getMessage(), e);
+      return FALLBACK_HOST_NAME;
+    }
+  }
+
+  @Override
+  public void start(long period, TimeUnit unit) {
+    this.period = period;
+    super.start(period, unit);
+  }
+
+  @Override
+  public void report(
+      SortedMap<MetricName, Gauge<?>> gauges,
+      SortedMap<MetricName, Counter> counters,
+      SortedMap<MetricName, Histogram> histograms,
+      SortedMap<MetricName, Meter> meters,
+      SortedMap<MetricName, Timer> timers) {
+    MetaData.Builder metaData =
+        new MetaData.Builder(sanitize, hostName, clock.getTime() / 1000, period)
+            .type(COLLECTD_TYPE_GAUGE);
+    try {
+      connect(sender);
+      for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
+        serializeGauge(metaData.plugin(entry.getKey().getKey()), entry.getValue());
+      }
+      for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
+        serializeCounter(metaData.plugin(entry.getKey().getKey()), entry.getValue());
+      }
+      for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
+        serializeHistogram(metaData.plugin(entry.getKey().getKey()), entry.getValue());
+      }
+      for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
+        serializeMeter(metaData.plugin(entry.getKey().getKey()), entry.getValue());
+      }
+      for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
+        serializeTimer(metaData.plugin(entry.getKey().getKey()), entry.getValue());
+      }
+    } catch (IOException e) {
+      LOG.warn("Unable to report to Collectd", e);
+    } finally {
+      disconnect(sender);
     }
+  }
 
-    private void serializeCounter(MetaData.Builder metaData, Counter metric) {
-        writeValue(metaData, COUNT, (double) metric.getCount());
+  private void connect(Sender sender) throws IOException {
+    if (!sender.isConnected()) {
+      sender.connect();
     }
+  }
 
-    private void serializeHistogram(MetaData.Builder metaData, Histogram metric) {
-        final Snapshot snapshot = metric.getSnapshot();
-        writeValue(metaData, COUNT, (double) metric.getCount());
-        writeValue(metaData, MAX, (double) snapshot.getMax());
-        writeValue(metaData, MEAN, snapshot.getMean());
-        writeValue(metaData, MIN, (double) snapshot.getMin());
-        writeValue(metaData, STDDEV, snapshot.getStdDev());
-        writeValue(metaData, P50, snapshot.getMedian());
-        writeValue(metaData, P75, snapshot.get75thPercentile());
-        writeValue(metaData, P95, snapshot.get95thPercentile());
-        writeValue(metaData, P98, snapshot.get98thPercentile());
-        writeValue(metaData, P99, snapshot.get99thPercentile());
-        writeValue(metaData, P999, snapshot.get999thPercentile());
+  private void disconnect(Sender sender) {
+    try {
+      sender.disconnect();
+    } catch (Exception e) {
+      LOG.warn("Error disconnecting from Collectd", e);
     }
+  }
 
-    private void serializeTimer(MetaData.Builder metaData, Timer metric) {
-        final Snapshot snapshot = metric.getSnapshot();
-        writeValue(metaData, COUNT, (double) metric.getCount());
-        writeDuration(metaData, MAX, (double) snapshot.getMax());
-        writeDuration(metaData, MEAN, snapshot.getMean());
-        writeDuration(metaData, MIN, (double) snapshot.getMin());
-        writeDuration(metaData, STDDEV, snapshot.getStdDev());
-        writeDuration(metaData, P50, snapshot.getMedian());
-        writeDuration(metaData, P75, snapshot.get75thPercentile());
-        writeDuration(metaData, P95, snapshot.get95thPercentile());
-        writeDuration(metaData, P98, snapshot.get98thPercentile());
-        writeDuration(metaData, P99, snapshot.get99thPercentile());
-        writeDuration(metaData, P999, snapshot.get999thPercentile());
-        writeRate(metaData, M1_RATE, metric.getOneMinuteRate());
-        writeRate(metaData, M5_RATE, metric.getFiveMinuteRate());
-        writeRate(metaData, M15_RATE, metric.getFifteenMinuteRate());
-        writeRate(metaData, MEAN_RATE, metric.getMeanRate());
+  private void writeValue(MetaData.Builder metaData, MetricAttribute attribute, Number value) {
+    if (!getDisabledMetricAttributes().contains(attribute)) {
+      write(metaData.typeInstance(attribute.getCode()).get(), value);
+    }
+  }
+
+  private void writeRate(MetaData.Builder metaData, MetricAttribute attribute, double rate) {
+    writeValue(metaData, attribute, convertRate(rate));
+  }
+
+  private void writeDuration(
+      MetaData.Builder metaData, MetricAttribute attribute, double duration) {
+    writeValue(metaData, attribute, convertDuration(duration));
+  }
+
+  private void write(MetaData metaData, Number value) {
+    try {
+      writer.write(metaData, value);
+    } catch (RuntimeException e) {
+      LOG.warn("Failed to process metric '{}': {}", metaData.getPlugin(), e.getMessage());
+    } catch (IOException e) {
+      LOG.error("Failed to send metric to collectd", e);
+    }
+  }
+
+  private void serializeGauge(MetaData.Builder metaData, Gauge metric) {
+    if (metric.getValue() instanceof Number) {
+      write(metaData.typeInstance("value").get(), (Number) metric.getValue());
+    } else if (metric.getValue() instanceof Boolean) {
+      write(metaData.typeInstance("value").get(), ((Boolean) metric.getValue()) ? 1 : 0);
+    } else {
+      LOG.warn(
+          "Failed to process metric '{}'. Unsupported gauge of type: {} ",
+          metaData.get().getPlugin(),
+          metric.getValue().getClass().getName());
     }
+  }
+
+  private void serializeMeter(MetaData.Builder metaData, Meter metric) {
+    writeValue(metaData, COUNT, (double) metric.getCount());
+    writeRate(metaData, M1_RATE, metric.getOneMinuteRate());
+    writeRate(metaData, M5_RATE, metric.getFiveMinuteRate());
+    writeRate(metaData, M15_RATE, metric.getFifteenMinuteRate());
+    writeRate(metaData, MEAN_RATE, metric.getMeanRate());
+  }
+
+  private void serializeCounter(MetaData.Builder metaData, Counter metric) {
+    writeValue(metaData, COUNT, (double) metric.getCount());
+  }
+
+  private void serializeHistogram(MetaData.Builder metaData, Histogram metric) {
+    final Snapshot snapshot = metric.getSnapshot();
+    writeValue(metaData, COUNT, (double) metric.getCount());
+    writeValue(metaData, MetricAttribute.MAX, (double) snapshot.getMax());
+    writeValue(metaData, MEAN, snapshot.getMean());
+    writeValue(metaData, MetricAttribute.MIN, (double) snapshot.getMin());
+    writeValue(metaData, STDDEV, snapshot.getStdDev());
+    writeValue(metaData, P50, snapshot.getMedian());
+    writeValue(metaData, P75, snapshot.get75thPercentile());
+    writeValue(metaData, P95, snapshot.get95thPercentile());
+    writeValue(metaData, P98, snapshot.get98thPercentile());
+    writeValue(metaData, P99, snapshot.get99thPercentile());
+    writeValue(metaData, P999, snapshot.get999thPercentile());
+  }
+
+  private void serializeTimer(MetaData.Builder metaData, Timer metric) {
+    final Snapshot snapshot = metric.getSnapshot();
+    writeValue(metaData, COUNT, (double) metric.getCount());
+    writeDuration(metaData, MetricAttribute.MAX, (double) snapshot.getMax());
+    writeDuration(metaData, MEAN, snapshot.getMean());
+    writeDuration(metaData, MetricAttribute.MIN, (double) snapshot.getMin());
+    writeDuration(metaData, STDDEV, snapshot.getStdDev());
+    writeDuration(metaData, P50, snapshot.getMedian());
+    writeDuration(metaData, P75, snapshot.get75thPercentile());
+    writeDuration(metaData, P95, snapshot.get95thPercentile());
+    writeDuration(metaData, P98, snapshot.get98thPercentile());
+    writeDuration(metaData, P99, snapshot.get99thPercentile());
+    writeDuration(metaData, P999, snapshot.get999thPercentile());
+    writeRate(metaData, M1_RATE, metric.getOneMinuteRate());
+    writeRate(metaData, M5_RATE, metric.getFiveMinuteRate());
+    writeRate(metaData, M15_RATE, metric.getFifteenMinuteRate());
+    writeRate(metaData, MEAN_RATE, metric.getMeanRate());
+  }
 }
--- a/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/MetaData.java
+++ b/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/MetaData.java
@@ -2,97 +2,103 @@ package io.dropwizard.metrics5.collectd;
 
 class MetaData {
 
-    private final String host;
-    private final String plugin;
-    private final String pluginInstance;
-    private final String type;
-    private final String typeInstance;
-    private final long timestamp;
-    private final long period;
-
-    MetaData(String host, String plugin, String pluginInstance, String type, String typeInstance,
-             long timestamp, long period) {
-        this.host = host;
-        this.plugin = plugin;
-        this.pluginInstance = pluginInstance;
-        this.type = type;
-        this.typeInstance = typeInstance;
-        this.timestamp = timestamp;
-        this.period = period;
+  private final String host;
+  private final String plugin;
+  private final String pluginInstance;
+  private final String type;
+  private final String typeInstance;
+  private final long timestamp;
+  private final long period;
+
+  MetaData(
+      String host,
+      String plugin,
+      String pluginInstance,
+      String type,
+      String typeInstance,
+      long timestamp,
+      long period) {
+    this.host = host;
+    this.plugin = plugin;
+    this.pluginInstance = pluginInstance;
+    this.type = type;
+    this.typeInstance = typeInstance;
+    this.timestamp = timestamp;
+    this.period = period;
+  }
+
+  String getHost() {
+    return host;
+  }
+
+  String getPlugin() {
+    return plugin;
+  }
+
+  String getPluginInstance() {
+    return pluginInstance;
+  }
+
+  String getType() {
+    return type;
+  }
+
+  String getTypeInstance() {
+    return typeInstance;
+  }
+
+  long getTimestamp() {
+    return timestamp;
+  }
+
+  long getPeriod() {
+    return period;
+  }
+
+  static class Builder {
+
+    private String host;
+    private String plugin;
+    private String pluginInstance;
+    private String type;
+    private String typeInstance;
+    private long timestamp;
+    private long period;
+    private Sanitize sanitize;
+
+    Builder(String host, long timestamp, long duration) {
+      this(new Sanitize(Sanitize.DEFAULT_MAX_LENGTH), host, timestamp, duration);
     }
 
-    String getHost() {
-        return host;
+    Builder(Sanitize sanitize, String host, long timestamp, long duration) {
+      this.sanitize = sanitize;
+      this.host = sanitize.instanceName(host);
+      this.timestamp = timestamp;
+      period = duration;
     }
 
-    String getPlugin() {
-        return plugin;
+    Builder plugin(String name) {
+      plugin = sanitize.name(name);
+      return this;
     }
 
-    String getPluginInstance() {
-        return pluginInstance;
+    Builder pluginInstance(String name) {
+      pluginInstance = sanitize.instanceName(name);
+      return this;
     }
 
-    String getType() {
-        return type;
+    Builder type(String name) {
+      type = sanitize.name(name);
+      return this;
     }
 
-    String getTypeInstance() {
-        return typeInstance;
+    Builder typeInstance(String name) {
+      typeInstance = sanitize.instanceName(name);
+      return this;
     }
 
-    long getTimestamp() {
-        return timestamp;
-    }
-
-    long getPeriod() {
-        return period;
-    }
-
-    static class Builder {
-
-        private String host;
-        private String plugin;
-        private String pluginInstance;
-        private String type;
-        private String typeInstance;
-        private long timestamp;
-        private long period;
-        private Sanitize sanitize;
-
-        Builder(String host, long timestamp, long duration) {
-            this(new Sanitize(Sanitize.DEFAULT_MAX_LENGTH), host, timestamp, duration);
-        }
-
-        Builder(Sanitize sanitize, String host, long timestamp, long duration) {
-            this.sanitize = sanitize;
-            this.host = sanitize.instanceName(host);
-            this.timestamp = timestamp;
-            period = duration;
-        }
-
-        Builder plugin(String name) {
-            plugin = sanitize.name(name);
-            return this;
-        }
-
-        Builder pluginInstance(String name) {
-            pluginInstance = sanitize.instanceName(name);
-            return this;
-        }
-
-        Builder type(String name) {
-            type = sanitize.name(name);
-            return this;
-        }
-
-        Builder typeInstance(String name) {
-            typeInstance = sanitize.instanceName(name);
-            return this;
-        }
-
-        MetaData get() {
-            return new MetaData(host, plugin, pluginInstance, type, typeInstance, timestamp, period);
-        }
+    MetaData get() {
+      return new MetaData(host, plugin, pluginInstance, type, typeInstance, timestamp, period);
     }
+  }
 }
--- a/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/PacketWriter.java
+++ b/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/PacketWriter.java
@@ -1,275 +1,283 @@
 package io.dropwizard.metrics5.collectd;
 
-import javax.crypto.BadPaddingException;
-import javax.crypto.Cipher;
-import javax.crypto.IllegalBlockSizeException;
-import javax.crypto.Mac;
-import javax.crypto.NoSuchPaddingException;
-import javax.crypto.ShortBufferException;
-import javax.crypto.spec.IvParameterSpec;
-import javax.crypto.spec.SecretKeySpec;
+import static com.google.common.base.Preconditions.checkState;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import com.google.common.base.Strings;
 import java.io.IOException;
 import java.nio.BufferOverflowException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.nio.charset.StandardCharsets;
 import java.security.InvalidKeyException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.spec.InvalidParameterSpecException;
 import java.util.Arrays;
+import javax.crypto.BadPaddingException;
+import javax.crypto.Cipher;
+import javax.crypto.IllegalBlockSizeException;
+import javax.crypto.Mac;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.ShortBufferException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
 
 class PacketWriter {
 
-    private static final int TYPE_HOST = 0;
-    private static final int TYPE_TIME = 1;
-    private static final int TYPE_PLUGIN = 2;
-    private static final int TYPE_PLUGIN_INSTANCE = 3;
-    private static final int TYPE_TYPE = 4;
-    private static final int TYPE_TYPE_INSTANCE = 5;
-    private static final int TYPE_VALUES = 6;
-    private static final int TYPE_INTERVAL = 7;
-    private static final int TYPE_SIGN_SHA256 = 0x0200;
-    private static final int TYPE_ENCR_AES256 = 0x0210;
+  private static final int TYPE_HOST = 0;
+  private static final int TYPE_TIME = 1;
+  private static final int TYPE_PLUGIN = 2;
+  private static final int TYPE_PLUGIN_INSTANCE = 3;
+  private static final int TYPE_TYPE = 4;
+  private static final int TYPE_TYPE_INSTANCE = 5;
+  private static final int TYPE_VALUES = 6;
+  private static final int TYPE_INTERVAL = 7;
+  private static final int TYPE_SIGN_SHA256 = 0x0200;
+  private static final int TYPE_ENCR_AES256 = 0x0210;
 
-    private static final int UINT16_LEN = 2;
-    private static final int UINT32_LEN = UINT16_LEN * 2;
-    private static final int UINT64_LEN = UINT32_LEN * 2;
-    private static final int HEADER_LEN = UINT16_LEN * 2;
-    private static final int BUFFER_SIZE = 1024;
+  private static final int UINT16_LEN = 2;
+  private static final int UINT32_LEN = UINT16_LEN * 2;
+  private static final int UINT64_LEN = UINT32_LEN * 2;
+  private static final int HEADER_LEN = UINT16_LEN * 2;
+  private static final int BUFFER_SIZE = 1024;
 
-    private static final int VALUE_COUNT_LEN = UINT16_LEN;
-    private static final int NUMBER_LEN = HEADER_LEN + UINT64_LEN;
-    private static final int SIGNATURE_LEN = 36;      // 2b Type + 2b Length + 32b Hash
-    private static final int ENCRYPT_DATA_LEN = 22;   // 16b IV + 2b Type + 2b Length + 2b Username length
-    private static final int IV_LENGTH = 16;
-    private static final int SHA1_LENGTH = 20;
+  private static final int VALUE_COUNT_LEN = UINT16_LEN;
+  private static final int NUMBER_LEN = HEADER_LEN + UINT64_LEN;
+  private static final int SIGNATURE_LEN = 36; // 2b Type + 2b Length + 32b Hash
+  private static final int ENCRYPT_DATA_LEN =
+      22; // 16b IV + 2b Type + 2b Length + 2b Username length
+  private static final int IV_LENGTH = 16;
+  private static final int SHA1_LENGTH = 20;
 
-    private static final int VALUE_LEN = 9;
-    private static final byte DATA_TYPE_GAUGE = (byte) 1;
-    private static final byte NULL = (byte) '\0';
-    private static final String HMAC_SHA256_ALGORITHM = "HmacSHA256";
-    private static final String AES_CYPHER = "AES_256/OFB/NoPadding";
-    private static final String AES = "AES";
-    private static final String SHA_256_ALGORITHM = "SHA-256";
-    private static final String SHA_1_ALGORITHM = "SHA1";
+  private static final int VALUE_LEN = 9;
+  private static final byte DATA_TYPE_GAUGE = (byte) 1;
+  private static final byte NULL = (byte) '\0';
+  private static final String HMAC_SHA256_ALGORITHM = "HmacSHA256";
+  private static final String AES_CYPHER = "AES_256/OFB/NoPadding";
+  private static final String AES = "AES";
+  private static final String SHA_256_ALGORITHM = "SHA-256";
+  private static final String SHA_1_ALGORITHM = "SHA1";
 
-    private final Sender sender;
+  private final Sender sender;
 
-    private final SecurityLevel securityLevel;
-    private final byte[] username;
-    private final byte[] password;
+  private final SecurityLevel securityLevel;
+  private final byte[] username;
+  private final byte[] password;
 
-    PacketWriter(Sender sender, String username, String password, SecurityLevel securityLevel) {
-        this.sender = sender;
-        this.securityLevel = securityLevel;
-        this.username = username != null ? username.getBytes(StandardCharsets.UTF_8) : null;
-        this.password = password != null ? password.getBytes(StandardCharsets.UTF_8) : null;
-    }
+  PacketWriter(Sender sender, String username, String password, SecurityLevel securityLevel) {
+    this.sender = sender;
+    this.securityLevel = securityLevel;
+    this.username = username != null ? username.getBytes(UTF_8) : null;
+    this.password = password != null ? password.getBytes(UTF_8) : null;
+  }
 
-    void write(MetaData metaData, Number... values) throws BufferOverflowException, IOException {
-        final ByteBuffer packet = ByteBuffer.allocate(BUFFER_SIZE);
-        write(packet, metaData);
-        write(packet, values);
-        packet.flip();
+  void write(MetaData metaData, Number... values) throws BufferOverflowException, IOException {
+    final ByteBuffer packet = ByteBuffer.allocate(BUFFER_SIZE);
+    write(packet, metaData);
+    write(packet, values);
+    packet.flip();
 
-        switch (securityLevel) {
-            case NONE:
-                sender.send(packet);
-                break;
-            case SIGN:
-                sender.send(signPacket(packet));
-                break;
-            case ENCRYPT:
-                sender.send(encryptPacket(packet));
-                break;
-            default:
-                throw new IllegalArgumentException("Unsupported security level: " + securityLevel);
-        }
+    switch (securityLevel) {
+      case NONE:
+        sender.send(packet);
+        break;
+      case SIGN:
+        sender.send(signPacket(packet));
+        break;
+      case ENCRYPT:
+        sender.send(encryptPacket(packet));
+        break;
+      default:
+        throw new IllegalArgumentException("Unsupported security level: " + securityLevel);
     }
+  }
 
+  private void write(ByteBuffer buffer, MetaData metaData) {
+    writeString(buffer, TYPE_HOST, metaData.getHost());
+    writeNumber(buffer, TYPE_TIME, metaData.getTimestamp());
+    writeString(buffer, TYPE_PLUGIN, metaData.getPlugin());
+    writeString(buffer, TYPE_PLUGIN_INSTANCE, metaData.getPluginInstance());
+    writeString(buffer, TYPE_TYPE, metaData.getType());
+    writeString(buffer, TYPE_TYPE_INSTANCE, metaData.getTypeInstance());
+    writeNumber(buffer, TYPE_INTERVAL, metaData.getPeriod());
+  }
 
-    private void write(ByteBuffer buffer, MetaData metaData) {
-        writeString(buffer, TYPE_HOST, metaData.getHost());
-        writeNumber(buffer, TYPE_TIME, metaData.getTimestamp());
-        writeString(buffer, TYPE_PLUGIN, metaData.getPlugin());
-        writeString(buffer, TYPE_PLUGIN_INSTANCE, metaData.getPluginInstance());
-        writeString(buffer, TYPE_TYPE, metaData.getType());
-        writeString(buffer, TYPE_TYPE_INSTANCE, metaData.getTypeInstance());
-        writeNumber(buffer, TYPE_INTERVAL, metaData.getPeriod());
+  private void write(ByteBuffer buffer, Number... values) {
+    final int numValues = values.length;
+    final int length = HEADER_LEN + VALUE_COUNT_LEN + numValues * VALUE_LEN;
+    writeHeader(buffer, TYPE_VALUES, length);
+    buffer.putShort((short) numValues);
+    buffer.put(nCopies(numValues, DATA_TYPE_GAUGE));
+    buffer.order(ByteOrder.LITTLE_ENDIAN);
+    for (Number value : values) {
+      buffer.putDouble(value.doubleValue());
     }
+    buffer.order(ByteOrder.BIG_ENDIAN);
+  }
 
-    private void write(ByteBuffer buffer, Number... values) {
-        final int numValues = values.length;
-        final int length = HEADER_LEN + VALUE_COUNT_LEN + numValues * VALUE_LEN;
-        writeHeader(buffer, TYPE_VALUES, length);
-        buffer.putShort((short) numValues);
-        buffer.put(nCopies(numValues, DATA_TYPE_GAUGE));
-        buffer.order(ByteOrder.LITTLE_ENDIAN);
-        for (Number value : values) {
-            buffer.putDouble(value.doubleValue());
-        }
-        buffer.order(ByteOrder.BIG_ENDIAN);
-    }
+  private byte[] nCopies(int n, byte value) {
+    final byte[] array = new byte[n];
+    Arrays.fill(array, value);
+    return array;
+  }
 
-    private byte[] nCopies(int n, byte value) {
-        final byte[] array = new byte[n];
-        Arrays.fill(array, value);
-        return array;
+  private void writeString(ByteBuffer buffer, int type, String val) {
+    if (Strings.isNullOrEmpty(val)) {
+      return;
     }
+    int len = HEADER_LEN + val.length() + 1;
+    writeHeader(buffer, type, len);
+    buffer.put(val.getBytes(US_ASCII)).put(NULL);
+  }
 
-    private void writeString(ByteBuffer buffer, int type, String val) {
-        if (val == null || val.length() == 0) {
-            return;
-        }
-        int len = HEADER_LEN + val.length() + 1;
-        writeHeader(buffer, type, len);
-        buffer.put(val.getBytes(StandardCharsets.US_ASCII)).put(NULL);
-    }
+  private void writeNumber(ByteBuffer buffer, int type, long val) {
+    writeHeader(buffer, type, NUMBER_LEN);
+    buffer.putLong(val);
+  }
 
-    private void writeNumber(ByteBuffer buffer, int type, long val) {
-        writeHeader(buffer, type, NUMBER_LEN);
-        buffer.putLong(val);
-    }
+  private void writeHeader(ByteBuffer buffer, int type, int len) {
+    buffer.putShort((short) type);
+    buffer.putShort((short) len);
+  }
 
-    private void writeHeader(ByteBuffer buffer, int type, int len) {
-        buffer.putShort((short) type);
-        buffer.putShort((short) len);
-    }
+  /**
+   * Signs the provided packet, so a CollectD server can verify that its authenticity. Wire format:
+   *
+   * <pre>
+   * +-------------------------------+-------------------------------+
+   * ! Type (0x0200)                 ! Length                        !
+   * +-------------------------------+-------------------------------+
+   * ! Signature (SHA2(username + packet))                           \
+   * +-------------------------------+-------------------------------+
+   * ! Username                      ! Packet                        \
+   * +---------------------------------------------------------------+
+   * </pre>
+   *
+   * @see <a href="https://collectd.org/wiki/index.php/Binary_protocol#Signature_part">Binary
+   *     protocol - CollectD | Signature part</a>
+   */
+  private ByteBuffer signPacket(ByteBuffer packet) {
+    final byte[] signature =
+        sign(
+            password,
+            (ByteBuffer)
+                ByteBuffer.allocate(packet.remaining() + username.length)
+                    .put(username)
+                    .put(packet)
+                    .flip());
+    return (ByteBuffer)
+        ByteBuffer.allocate(BUFFER_SIZE)
+            .putShort((short) TYPE_SIGN_SHA256)
+            .putShort((short) (username.length + SIGNATURE_LEN))
+            .put(signature)
+            .put(username)
+            .put((ByteBuffer) packet.flip())
+            .flip();
+  }
 
-    /**
-     * Signs the provided packet, so a CollectD server can verify that its authenticity.
-     * Wire format:
-     * <pre>
-     * +-------------------------------+-------------------------------+
-     * ! Type (0x0200)                 ! Length                        !
-     * +-------------------------------+-------------------------------+
-     * ! Signature (SHA2(username + packet))                           \
-     * +-------------------------------+-------------------------------+
-     * ! Username                      ! Packet                        \
-     * +---------------------------------------------------------------+
-     * </pre>
-     *
-     * @see <a href="https://collectd.org/wiki/index.php/Binary_protocol#Signature_part">
-     * Binary protocol - CollectD | Signature part</a>
-     */
-    private ByteBuffer signPacket(ByteBuffer packet) {
-        final byte[] signature = sign(password, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + username.length)
-                .put(username)
-                .put(packet)
-                .flip());
-        return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE)
-                .putShort((short) TYPE_SIGN_SHA256)
-                .putShort((short) (username.length + SIGNATURE_LEN))
-                .put(signature)
-                .put(username)
-                .put((ByteBuffer) packet.flip())
-                .flip();
-    }
-
-    /**
-     * Encrypts the provided packet, so it's can't be eavesdropped during a transfer
-     * to a CollectD server. Wire format:
-     * <pre>
-     * +---------------------------------+-------------------------------+
-     * ! Type (0x0210)                   ! Length                        !
-     * +---------------------------------+-------------------------------+
-     * ! Username length in bytes        ! Username                      \
-     * +-----------------------------------------------------------------+
-     * ! Initialization Vector (IV)      !                               \
-     * +---------------------------------+-------------------------------+
-     * ! Encrypted bytes (AES (SHA1(packet) + packet))                   \
-     * +---------------------------------+-------------------------------+
-     * </pre>
-     *
-     * @see <a href="https://collectd.org/wiki/index.php/Binary_protocol#Encrypted_part">
-     * Binary protocol - CollectD | Encrypted part</a>
-     */
-    private ByteBuffer encryptPacket(ByteBuffer packet) {
-        final ByteBuffer payload = (ByteBuffer) ByteBuffer.allocate(SHA1_LENGTH + packet.remaining())
+  /**
+   * Encrypts the provided packet, so it's can't be eavesdropped during a transfer to a CollectD
+   * server. Wire format:
+   *
+   * <pre>
+   * +---------------------------------+-------------------------------+
+   * ! Type (0x0210)                   ! Length                        !
+   * +---------------------------------+-------------------------------+
+   * ! Username length in bytes        ! Username                      \
+   * +-----------------------------------------------------------------+
+   * ! Initialization Vector (IV)      !                               \
+   * +---------------------------------+-------------------------------+
+   * ! Encrypted bytes (AES (SHA1(packet) + packet))                   \
+   * +---------------------------------+-------------------------------+
+   * </pre>
+   *
+   * @see <a href="https://collectd.org/wiki/index.php/Binary_protocol#Encrypted_part">Binary
+   *     protocol - CollectD | Encrypted part</a>
+   */
+  private ByteBuffer encryptPacket(ByteBuffer packet) {
+    final ByteBuffer payload =
+        (ByteBuffer)
+            ByteBuffer.allocate(SHA1_LENGTH + packet.remaining())
                 .put(sha1(packet))
                 .put((ByteBuffer) packet.flip())
                 .flip();
-        final EncryptionResult er = encrypt(password, payload);
-        return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE)
-                .putShort((short) TYPE_ENCR_AES256)
-                .putShort((short) (ENCRYPT_DATA_LEN + username.length + er.output.remaining()))
-                .putShort((short) username.length)
-                .put(username)
-                .put(er.iv)
-                .put(er.output)
-                .flip();
-    }
+    final EncryptionResult er = encrypt(password, payload);
+    return (ByteBuffer)
+        ByteBuffer.allocate(BUFFER_SIZE)
+            .putShort((short) TYPE_ENCR_AES256)
+            .putShort((short) (ENCRYPT_DATA_LEN + username.length + er.output.remaining()))
+            .putShort((short) username.length)
+            .put(username)
+            .put(er.iv)
+            .put(er.output)
+            .flip();
+  }
 
-    private static byte[] sign(byte[] secret, ByteBuffer input) {
-        final Mac mac;
-        try {
-            mac = Mac.getInstance(HMAC_SHA256_ALGORITHM);
-            mac.init(new SecretKeySpec(secret, HMAC_SHA256_ALGORITHM));
-        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
-            throw new RuntimeException(e);
-        }
-        mac.update(input);
-        return mac.doFinal();
+  private static byte[] sign(byte[] secret, ByteBuffer input) {
+    final Mac mac;
+    try {
+      mac = Mac.getInstance(HMAC_SHA256_ALGORITHM);
+      mac.init(new SecretKeySpec(secret, HMAC_SHA256_ALGORITHM));
+    } catch (NoSuchAlgorithmException | InvalidKeyException e) {
+      throw new RuntimeException(e);
     }
+    mac.update(input);
+    return mac.doFinal();
+  }
 
-    private static EncryptionResult encrypt(byte[] password, ByteBuffer input) {
-        final Cipher cipher;
-        try {
-            cipher = Cipher.getInstance(AES_CYPHER);
-            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sha256(password), AES));
-        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e) {
-            throw new RuntimeException(e);
-        }
-        final byte[] iv;
-        try {
-            iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
-        } catch (InvalidParameterSpecException e) {
-            throw new RuntimeException(e);
-        }
-        if (iv.length != IV_LENGTH) {
-            throw new IllegalStateException("Bad initialization vector");
-        }
-        final ByteBuffer output = ByteBuffer.allocate(input.remaining() * 2);
-        try {
-            cipher.doFinal(input, output);
-        } catch (ShortBufferException | IllegalBlockSizeException | BadPaddingException e) {
-            throw new RuntimeException(e);
-        }
-        return new EncryptionResult(iv, (ByteBuffer) output.flip());
+  private static EncryptionResult encrypt(byte[] password, ByteBuffer input) {
+    final Cipher cipher;
+    try {
+      cipher = Cipher.getInstance(AES_CYPHER);
+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sha256(password), AES));
+    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e) {
+      throw new RuntimeException(e);
     }
+    final byte[] iv;
+    try {
+      iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
+    } catch (InvalidParameterSpecException e) {
+      throw new RuntimeException(e);
+    }
+    checkState(iv.length == IV_LENGTH, "Bad initialization vector");
+    final ByteBuffer output = ByteBuffer.allocate(input.remaining() * 2);
+    try {
+      cipher.doFinal(input, output);
+    } catch (ShortBufferException | IllegalBlockSizeException | BadPaddingException e) {
+      throw new RuntimeException(e);
+    }
+    return new EncryptionResult(iv, (ByteBuffer) output.flip());
+  }
 
-    private static byte[] sha256(byte[] input) {
-        try {
-            return MessageDigest.getInstance(SHA_256_ALGORITHM).digest(input);
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e);
-        }
+  private static byte[] sha256(byte[] input) {
+    try {
+      return MessageDigest.getInstance(SHA_256_ALGORITHM).digest(input);
+    } catch (NoSuchAlgorithmException e) {
+      throw new RuntimeException(e);
     }
+  }
 
-    private static byte[] sha1(ByteBuffer input) {
-        try {
-            final MessageDigest digest = MessageDigest.getInstance(SHA_1_ALGORITHM);
-            digest.update(input);
-            final byte[] output = digest.digest();
-            if (output.length != SHA1_LENGTH) {
-                throw new IllegalStateException("Bad SHA1 hash");
-            }
-            return output;
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e);
-        }
+  private static byte[] sha1(ByteBuffer input) {
+    try {
+      final MessageDigest digest = MessageDigest.getInstance(SHA_1_ALGORITHM);
+      digest.update(input);
+      final byte[] output = digest.digest();
+      checkState(output.length == SHA1_LENGTH, "Bad SHA1 hash");
+      return output;
+    } catch (NoSuchAlgorithmException e) {
+      throw new RuntimeException(e);
     }
+  }
 
-    private static class EncryptionResult {
+  private static class EncryptionResult {
 
-        private final byte[] iv;
-        private final ByteBuffer output;
+    private final byte[] iv;
+    private final ByteBuffer output;
 
-        private EncryptionResult(byte[] iv, ByteBuffer output) {
-            this.iv = iv;
-            this.output = output;
-        }
+    private EncryptionResult(byte[] iv, ByteBuffer output) {
+      this.iv = iv;
+      this.output = output;
     }
-
+  }
 }
--- a/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/Sanitize.java
+++ b/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/Sanitize.java
@@ -8,39 +8,38 @@ import java.util.List;
  */
 class Sanitize {
 
-    static final int DEFAULT_MAX_LENGTH = 63;
+  static final int DEFAULT_MAX_LENGTH = 63;
 
-    private static final char DASH = '-';
-    private static final char SLASH = '/';
-    private static final char NULL = '\0';
-    private static final char UNDERSCORE = '_';
+  private static final char DASH = '-';
+  private static final char SLASH = '/';
+  private static final char NULL = '\0';
+  private static final char UNDERSCORE = '_';
 
-    private static final List<Character> INSTANCE_RESERVED = Arrays.asList(SLASH, NULL);
-    private static final List<Character> NAME_RESERVED = Arrays.asList(DASH, SLASH, NULL);
+  private static final List<Character> INSTANCE_RESERVED = Arrays.asList(SLASH, NULL);
+  private static final List<Character> NAME_RESERVED = Arrays.asList(DASH, SLASH, NULL);
 
-    private final int maxLength;
+  private final int maxLength;
 
-    Sanitize(int maxLength) {
-        this.maxLength = maxLength;
-    }
+  Sanitize(int maxLength) {
+    this.maxLength = maxLength;
+  }
 
-    String name(String name) {
-        return sanitize(name, NAME_RESERVED);
-    }
+  String name(String name) {
+    return sanitize(name, NAME_RESERVED);
+  }
 
-    String instanceName(String instanceName) {
-        return sanitize(instanceName, INSTANCE_RESERVED);
-    }
+  String instanceName(String instanceName) {
+    return sanitize(instanceName, INSTANCE_RESERVED);
+  }
 
-    private String sanitize(String string, List<Character> reservedChars) {
-        final StringBuilder buffer = new StringBuilder(string.length());
-        final int len = Math.min(string.length(), maxLength);
-        for (int i = 0; i < len; i++) {
-            final char c = string.charAt(i);
-            final boolean legal = ((int) c) < 128 && !reservedChars.contains(c);
-            buffer.append(legal ? c : UNDERSCORE);
-        }
-        return buffer.toString();
+  private String sanitize(String string, List<Character> reservedChars) {
+    final StringBuilder buffer = new StringBuilder(string.length());
+    final int len = Math.min(string.length(), maxLength);
+    for (int i = 0; i < len; i++) {
+      final char c = string.charAt(i);
+      final boolean legal = ((int) c) < 128 && !reservedChars.contains(c);
+      buffer.append(legal ? c : UNDERSCORE);
     }
-
+    return buffer.toString();
+  }
 }
--- a/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/SecurityConfiguration.java
+++ b/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/SecurityConfiguration.java
@@ -2,29 +2,29 @@ package io.dropwizard.metrics5.collectd;
 
 public class SecurityConfiguration {
 
-    private final byte[] username;
-    private final byte[] password;
-    private final SecurityLevel securityLevel;
+  private final byte[] username;
+  private final byte[] password;
+  private final SecurityLevel securityLevel;
 
-    public SecurityConfiguration(byte[] username, byte[] password, SecurityLevel securityLevel) {
-        this.username = username;
-        this.password = password;
-        this.securityLevel = securityLevel;
-    }
+  public SecurityConfiguration(byte[] username, byte[] password, SecurityLevel securityLevel) {
+    this.username = username;
+    this.password = password;
+    this.securityLevel = securityLevel;
+  }
 
-    public static SecurityConfiguration none() {
-        return new SecurityConfiguration(null, null, SecurityLevel.NONE);
-    }
+  public static SecurityConfiguration none() {
+    return new SecurityConfiguration(null, null, SecurityLevel.NONE);
+  }
 
-    public byte[] getUsername() {
-        return username;
-    }
+  public byte[] getUsername() {
+    return username;
+  }
 
-    public byte[] getPassword() {
-        return password;
-    }
+  public byte[] getPassword() {
+    return password;
+  }
 
-    public SecurityLevel getSecurityLevel() {
-        return securityLevel;
-    }
+  public SecurityLevel getSecurityLevel() {
+    return securityLevel;
+  }
 }
--- a/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/SecurityLevel.java
+++ b/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/SecurityLevel.java
@@ -1,8 +1,7 @@
 package io.dropwizard.metrics5.collectd;
 
 public enum SecurityLevel {
-
-    NONE,
-    SIGN,
-    ENCRYPT
+  NONE,
+  SIGN,
+  ENCRYPT
 }
--- a/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/Sender.java
+++ b/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/Sender.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.collectd;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
@@ -7,44 +9,41 @@ import java.nio.channels.DatagramChannel;
 
 public class Sender {
 
-    private final String host;
-    private final int port;
+  private final String host;
+  private final int port;
 
-    private InetSocketAddress address;
-    private DatagramChannel channel;
+  private InetSocketAddress address;
+  private DatagramChannel channel;
 
-    public Sender(String host, int port) {
-        this.host = host;
-        this.port = port;
-    }
+  public Sender(String host, int port) {
+    this.host = host;
+    this.port = port;
+  }
 
-    public void connect() throws IOException {
-        if (isConnected()) {
-            throw new IllegalStateException("Already connected");
-        }
-        if (host != null) {
-            address = new InetSocketAddress(host, port);
-        }
-        channel = DatagramChannel.open();
+  public void connect() throws IOException {
+    checkState(!isConnected(), "Already connected");
+    if (host != null) {
+      address = new InetSocketAddress(host, port);
     }
+    channel = DatagramChannel.open();
+  }
 
-    public boolean isConnected() {
-        return channel != null && !channel.socket().isClosed();
-    }
+  public boolean isConnected() {
+    return channel != null && !channel.socket().isClosed();
+  }
 
-    public void send(ByteBuffer buffer) throws IOException {
-        channel.send(buffer, address);
-    }
+  public void send(ByteBuffer buffer) throws IOException {
+    channel.send(buffer, address);
+  }
 
-    public void disconnect() throws IOException {
-        if (channel == null) {
-            return;
-        }
-        try {
-            channel.close();
-        } finally {
-            channel = null;
-        }
+  public void disconnect() throws IOException {
+    if (channel == null) {
+      return;
     }
-
+    try {
+      channel.close();
+    } finally {
+      channel = null;
+    }
+  }
 }
--- a/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/CollectdReporterSecurityTest.java
+++ b/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/CollectdReporterSecurityTest.java
@@ -1,33 +1,37 @@
 package io.dropwizard.metrics5.collectd;
 
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
-
-class CollectdReporterSecurityTest {
+final class CollectdReporterSecurityTest {
 
-    private final MetricRegistry registry = new MetricRegistry();
+  private final MetricRegistry registry = new MetricRegistry();
 
-    @Test
-    void testUnableSetSecurityLevelToSignWithoutUsername() {
-        assertThatIllegalArgumentException().isThrownBy(() ->
+  @Test
+  void unableSetSecurityLevelToSignWithoutUsername() {
+    assertThatThrownBy(
+            () ->
                 CollectdReporter.forRegistry(registry)
-                        .withHostName("eddie")
-                        .withSecurityLevel(SecurityLevel.SIGN)
-                        .withPassword("t1_g3r")
-                        .build(new Sender("localhost", 25826)))
-                .withMessage("username is required for securityLevel: SIGN");
-    }
+                    .withHostName("eddie")
+                    .withSecurityLevel(SecurityLevel.SIGN)
+                    .withPassword("t1_g3r")
+                    .build(new Sender("localhost", 25826)))
+        .isInstanceOf(IllegalArgumentException.class)
+        .hasMessage("username is required for securityLevel: SIGN");
+  }
 
-    @Test
-    void testUnableSetSecurityLevelToSignWithoutPassword() {
-        assertThatIllegalArgumentException().isThrownBy(() ->
+  @Test
+  void unableSetSecurityLevelToSignWithoutPassword() {
+    assertThatThrownBy(
+            () ->
                 CollectdReporter.forRegistry(registry)
-                        .withHostName("eddie")
-                        .withSecurityLevel(SecurityLevel.SIGN)
-                        .withUsername("scott")
-                        .build(new Sender("localhost", 25826)))
-                .withMessage("password is required for securityLevel: SIGN");
-    }
+                    .withHostName("eddie")
+                    .withSecurityLevel(SecurityLevel.SIGN)
+                    .withUsername("scott")
+                    .build(new Sender("localhost", 25826)))
+        .isInstanceOf(IllegalArgumentException.class)
+        .hasMessage("password is required for securityLevel: SIGN");
+  }
 }
--- a/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/CollectdReporterTest.java
+++ b/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/CollectdReporterTest.java
@@ -1,5 +1,14 @@
 package io.dropwizard.metrics5.collectd;
 
+import static java.util.Collections.emptySortedMap;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Histogram;
 import io.dropwizard.metrics5.Meter;
@@ -8,315 +17,280 @@ import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-import org.collectd.api.ValueList;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.SortedMap;
 import java.util.TreeMap;
+import org.collectd.api.ValueList;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
 
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-public class CollectdReporterTest {
-    @RegisterExtension
-    public static Receiver receiver = new Receiver(25826);
-
-    private final MetricRegistry registry = new MetricRegistry();
-    private CollectdReporter reporter;
-
-    @BeforeEach
-    void setUp() {
-        reporter = CollectdReporter.forRegistry(registry)
-                .withHostName("eddie")
-                .build(new Sender("localhost", 25826));
-    }
-
-    @Test
-    void reportsByteGauges() throws Exception {
-        reportsGauges((byte) 128);
-    }
-
-    @Test
-    void reportsShortGauges() throws Exception {
-        reportsGauges((short) 2048);
-    }
-
-    @Test
-    void reportsIntegerGauges() throws Exception {
-        reportsGauges(42);
-    }
-
-    @Test
-    void reportsLongGauges() throws Exception {
-        reportsGauges(Long.MAX_VALUE);
-    }
-
-    @Test
-    void reportsFloatGauges() throws Exception {
-        reportsGauges(0.25);
-    }
-
-    @Test
-    void reportsDoubleGauges() throws Exception {
-        reportsGauges(0.125d);
-    }
-
-    private <T extends Number> void reportsGauges(T value) throws Exception {
-        reporter.report(
-                map(MetricName.build("gauge"), () -> value),
-                map(),
-                map(),
-                map(),
-                map());
-
-        assertThat(nextValues(receiver)).containsExactly(value.doubleValue());
-    }
-
-    @Test
-    void reportsBooleanGauges() throws Exception {
-        reporter.report(
-                map(MetricName.build("gauge"), () -> true),
-                map(),
-                map(),
-                map(),
-                map());
-
-        assertThat(nextValues(receiver)).containsExactly(1d);
-
-        reporter.report(
-                map(MetricName.build("gauge"), () -> false),
-                map(),
-                map(),
-                map(),
-                map());
-
-        assertThat(nextValues(receiver)).containsExactly(0d);
-    }
-
-    @Test
-    void doesNotReportStringGauges() throws Exception {
-        reporter.report(
-                map(MetricName.build("unsupported"), () -> "value"),
-                map(),
-                map(),
-                map(),
-                map());
-
-        assertThat(receiver.next()).isNull();
-    }
-
-    @Test
-    void reportsCounters() throws Exception {
-        Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(42L);
-
-        reporter.report(
-                map(),
-                map(MetricName.build("api", "rest", "requests", "count"), counter),
-                map(),
-                map(),
-                map());
-
-        assertThat(nextValues(receiver)).containsExactly(42d);
-    }
-
-    @Test
-    void reportsMeters() throws Exception {
-        Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getOneMinuteRate()).thenReturn(2.0);
-        when(meter.getFiveMinuteRate()).thenReturn(3.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(4.0);
-        when(meter.getMeanRate()).thenReturn(5.0);
-
-        reporter.report(
-                map(),
-                map(),
-                map(),
-                map(MetricName.build("api", "rest", "requests"), meter),
-                map());
-
-        assertThat(nextValues(receiver)).containsExactly(1d);
-        assertThat(nextValues(receiver)).containsExactly(2d);
-        assertThat(nextValues(receiver)).containsExactly(3d);
-        assertThat(nextValues(receiver)).containsExactly(4d);
-        assertThat(nextValues(receiver)).containsExactly(5d);
-    }
-
-    @Test
-    void reportsHistograms() throws Exception {
-        Histogram histogram = mock(Histogram.class);
-        Snapshot snapshot = mock(Snapshot.class);
-        when(histogram.getCount()).thenReturn(1L);
-        when(histogram.getSnapshot()).thenReturn(snapshot);
-        when(snapshot.getMax()).thenReturn(2L);
-        when(snapshot.getMean()).thenReturn(3.0);
-        when(snapshot.getMin()).thenReturn(4L);
-        when(snapshot.getStdDev()).thenReturn(5.0);
-        when(snapshot.getMedian()).thenReturn(6.0);
-        when(snapshot.get75thPercentile()).thenReturn(7.0);
-        when(snapshot.get95thPercentile()).thenReturn(8.0);
-        when(snapshot.get98thPercentile()).thenReturn(9.0);
-        when(snapshot.get99thPercentile()).thenReturn(10.0);
-        when(snapshot.get999thPercentile()).thenReturn(11.0);
-
-        reporter.report(
-                map(),
-                map(),
-                map(MetricName.build("histogram"), histogram),
-                map(),
-                map());
-
-        for (int i = 1; i <= 11; i++) {
-            assertThat(nextValues(receiver)).containsExactly((double) i);
-        }
-    }
-
-    @Test
-    void reportsTimers() throws Exception {
-        Timer timer = mock(Timer.class);
-        Snapshot snapshot = mock(Snapshot.class);
-        when(timer.getSnapshot()).thenReturn(snapshot);
-        when(timer.getCount()).thenReturn(1L);
-        when(timer.getSnapshot()).thenReturn(snapshot);
-        when(snapshot.getMax()).thenReturn(MILLISECONDS.toNanos(100));
-        when(snapshot.getMean()).thenReturn((double) MILLISECONDS.toNanos(200));
-        when(snapshot.getMin()).thenReturn(MILLISECONDS.toNanos(300));
-        when(snapshot.getStdDev()).thenReturn((double) MILLISECONDS.toNanos(400));
-        when(snapshot.getMedian()).thenReturn((double) MILLISECONDS.toNanos(500));
-        when(snapshot.get75thPercentile()).thenReturn((double) MILLISECONDS.toNanos(600));
-        when(snapshot.get95thPercentile()).thenReturn((double) MILLISECONDS.toNanos(700));
-        when(snapshot.get98thPercentile()).thenReturn((double) MILLISECONDS.toNanos(800));
-        when(snapshot.get99thPercentile()).thenReturn((double) MILLISECONDS.toNanos(900));
-        when(snapshot.get999thPercentile()).thenReturn((double) MILLISECONDS.toNanos(1000));
-        when(timer.getOneMinuteRate()).thenReturn(11.0);
-        when(timer.getFiveMinuteRate()).thenReturn(12.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(13.0);
-        when(timer.getMeanRate()).thenReturn(14.0);
-
-        reporter.report(
-                map(),
-                map(),
-                map(),
-                map(),
-                map(MetricName.build("timer"), timer));
-
-        assertThat(nextValues(receiver)).containsExactly(1d);
-        assertThat(nextValues(receiver)).containsExactly(100d);
-        assertThat(nextValues(receiver)).containsExactly(200d);
-        assertThat(nextValues(receiver)).containsExactly(300d);
-        assertThat(nextValues(receiver)).containsExactly(400d);
-        assertThat(nextValues(receiver)).containsExactly(500d);
-        assertThat(nextValues(receiver)).containsExactly(600d);
-        assertThat(nextValues(receiver)).containsExactly(700d);
-        assertThat(nextValues(receiver)).containsExactly(800d);
-        assertThat(nextValues(receiver)).containsExactly(900d);
-        assertThat(nextValues(receiver)).containsExactly(1000d);
-        assertThat(nextValues(receiver)).containsExactly(11d);
-        assertThat(nextValues(receiver)).containsExactly(12d);
-        assertThat(nextValues(receiver)).containsExactly(13d);
-        assertThat(nextValues(receiver)).containsExactly(14d);
-    }
-
-    @Test
-    void doesNotReportDisabledMetricAttributes() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getOneMinuteRate()).thenReturn(2.0);
-        when(meter.getFiveMinuteRate()).thenReturn(3.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(4.0);
-        when(meter.getMeanRate()).thenReturn(5.0);
-
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(11L);
-
-        CollectdReporter reporter = CollectdReporter.forRegistry(registry)
-                .withHostName("eddie")
-                .disabledMetricAttributes(EnumSet.of(MetricAttribute.M5_RATE, MetricAttribute.M15_RATE))
-                .build(new Sender("localhost", 25826));
-
-        reporter.report(
-                map(),
-                map(MetricName.build("counter"), counter),
-                map(),
-                map(MetricName.build("meter"), meter),
-                map());
-
-        assertThat(nextValues(receiver)).containsExactly(11d);
-        assertThat(nextValues(receiver)).containsExactly(1d);
-        assertThat(nextValues(receiver)).containsExactly(2d);
-        assertThat(nextValues(receiver)).containsExactly(5d);
-    }
-
-    @Test
-    void sanitizesMetricName() throws Exception {
-        Counter counter = registry.counter("dash-illegal.slash/illegal");
-        counter.inc();
-
-        reporter.report();
-
-        ValueList values = receiver.next();
-        assertThat(values.getPlugin()).isEqualTo("dash_illegal.slash_illegal");
+final class CollectdReporterTest {
+  @RegisterExtension public static Receiver receiver = new Receiver(25826);
+
+  private final MetricRegistry registry = new MetricRegistry();
+  private CollectdReporter reporter;
+
+  @BeforeEach
+  void setUp() {
+    reporter =
+        CollectdReporter.forRegistry(registry)
+            .withHostName("eddie")
+            .build(new Sender("localhost", 25826));
+  }
+
+  @Test
+  void reportsByteGauges() throws Exception {
+    reportsGauges((byte) 128);
+  }
+
+  @Test
+  void reportsShortGauges() throws Exception {
+    reportsGauges((short) 2048);
+  }
+
+  @Test
+  void reportsIntegerGauges() throws Exception {
+    reportsGauges(42);
+  }
+
+  @Test
+  void reportsLongGauges() throws Exception {
+    reportsGauges(Long.MAX_VALUE);
+  }
+
+  @Test
+  void reportsFloatGauges() throws Exception {
+    reportsGauges(0.25);
+  }
+
+  @Test
+  void reportsDoubleGauges() throws Exception {
+    reportsGauges(0.125d);
+  }
+
+  private <T extends Number> void reportsGauges(T value) throws Exception {
+    reporter.report(map(MetricName.build("gauge"), () -> value), map(), map(), map(), map());
+
+    assertThat(nextValues(receiver)).containsExactly(value.doubleValue());
+  }
+
+  @Test
+  void reportsBooleanGauges() throws Exception {
+    reporter.report(map(MetricName.build("gauge"), () -> true), map(), map(), map(), map());
+
+    assertThat(nextValues(receiver)).containsExactly(1d);
+
+    reporter.report(map(MetricName.build("gauge"), () -> false), map(), map(), map(), map());
+
+    assertThat(nextValues(receiver)).containsExactly(0d);
+  }
+
+  @Test
+  void doesNotReportStringGauges() throws Exception {
+    reporter.report(
+        map(MetricName.build("unsupported"), () -> "value"), map(), map(), map(), map());
+
+    assertThat(receiver.next()).isNull();
+  }
+
+  @Test
+  void reportsCounters() throws Exception {
+    Counter counter = mock();
+    when(counter.getCount()).thenReturn(42L);
+
+    reporter.report(
+        map(),
+        map(MetricName.build("api", "rest", "requests", "count"), counter),
+        map(),
+        map(),
+        map());
+
+    assertThat(nextValues(receiver)).containsExactly(42d);
+  }
+
+  @Test
+  void reportsMeters() throws Exception {
+    Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getOneMinuteRate()).thenReturn(2.0);
+    when(meter.getFiveMinuteRate()).thenReturn(3.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(4.0);
+    when(meter.getMeanRate()).thenReturn(5.0);
+
+    reporter.report(
+        map(), map(), map(), map(MetricName.build("api", "rest", "requests"), meter), map());
+
+    assertThat(nextValues(receiver)).containsExactly(1d);
+    assertThat(nextValues(receiver)).containsExactly(2d);
+    assertThat(nextValues(receiver)).containsExactly(3d);
+    assertThat(nextValues(receiver)).containsExactly(4d);
+    assertThat(nextValues(receiver)).containsExactly(5d);
+  }
+
+  @Test
+  void reportsHistograms() throws Exception {
+    Histogram histogram = mock();
+    Snapshot snapshot = mock();
+    when(histogram.getCount()).thenReturn(1L);
+    when(histogram.getSnapshot()).thenReturn(snapshot);
+    when(snapshot.getMax()).thenReturn(2L);
+    when(snapshot.getMean()).thenReturn(3.0);
+    when(snapshot.getMin()).thenReturn(4L);
+    when(snapshot.getStdDev()).thenReturn(5.0);
+    when(snapshot.getMedian()).thenReturn(6.0);
+    when(snapshot.get75thPercentile()).thenReturn(7.0);
+    when(snapshot.get95thPercentile()).thenReturn(8.0);
+    when(snapshot.get98thPercentile()).thenReturn(9.0);
+    when(snapshot.get99thPercentile()).thenReturn(10.0);
+    when(snapshot.get999thPercentile()).thenReturn(11.0);
+
+    reporter.report(map(), map(), map(MetricName.build("histogram"), histogram), map(), map());
+
+    for (int i = 1; i <= 11; i++) {
+      assertThat(nextValues(receiver)).containsExactly((double) i);
     }
-
-    @Test
-    void testUnableSetSecurityLevelToSignWithoutUsername() {
-        assertThatIllegalArgumentException().isThrownBy(() ->
+  }
+
+  @Test
+  void reportsTimers() throws Exception {
+    Timer timer = mock();
+    Snapshot snapshot = mock();
+    when(timer.getSnapshot()).thenReturn(snapshot);
+    when(timer.getCount()).thenReturn(1L);
+    when(timer.getSnapshot()).thenReturn(snapshot);
+    when(snapshot.getMax()).thenReturn(MILLISECONDS.toNanos(100));
+    when(snapshot.getMean()).thenReturn((double) MILLISECONDS.toNanos(200));
+    when(snapshot.getMin()).thenReturn(MILLISECONDS.toNanos(300));
+    when(snapshot.getStdDev()).thenReturn((double) MILLISECONDS.toNanos(400));
+    when(snapshot.getMedian()).thenReturn((double) MILLISECONDS.toNanos(500));
+    when(snapshot.get75thPercentile()).thenReturn((double) MILLISECONDS.toNanos(600));
+    when(snapshot.get95thPercentile()).thenReturn((double) MILLISECONDS.toNanos(700));
+    when(snapshot.get98thPercentile()).thenReturn((double) MILLISECONDS.toNanos(800));
+    when(snapshot.get99thPercentile()).thenReturn((double) MILLISECONDS.toNanos(900));
+    when(snapshot.get999thPercentile()).thenReturn((double) MILLISECONDS.toNanos(1000));
+    when(timer.getOneMinuteRate()).thenReturn(11.0);
+    when(timer.getFiveMinuteRate()).thenReturn(12.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(13.0);
+    when(timer.getMeanRate()).thenReturn(14.0);
+
+    reporter.report(map(), map(), map(), map(), map(MetricName.build("timer"), timer));
+
+    assertThat(nextValues(receiver)).containsExactly(1d);
+    assertThat(nextValues(receiver)).containsExactly(100d);
+    assertThat(nextValues(receiver)).containsExactly(200d);
+    assertThat(nextValues(receiver)).containsExactly(300d);
+    assertThat(nextValues(receiver)).containsExactly(400d);
+    assertThat(nextValues(receiver)).containsExactly(500d);
+    assertThat(nextValues(receiver)).containsExactly(600d);
+    assertThat(nextValues(receiver)).containsExactly(700d);
+    assertThat(nextValues(receiver)).containsExactly(800d);
+    assertThat(nextValues(receiver)).containsExactly(900d);
+    assertThat(nextValues(receiver)).containsExactly(1000d);
+    assertThat(nextValues(receiver)).containsExactly(11d);
+    assertThat(nextValues(receiver)).containsExactly(12d);
+    assertThat(nextValues(receiver)).containsExactly(13d);
+    assertThat(nextValues(receiver)).containsExactly(14d);
+  }
+
+  @Test
+  void doesNotReportDisabledMetricAttributes() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getOneMinuteRate()).thenReturn(2.0);
+    when(meter.getFiveMinuteRate()).thenReturn(3.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(4.0);
+    when(meter.getMeanRate()).thenReturn(5.0);
+
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(11L);
+
+    CollectdReporter reporter =
+        CollectdReporter.forRegistry(registry)
+            .withHostName("eddie")
+            .disabledMetricAttributes(EnumSet.of(MetricAttribute.M5_RATE, MetricAttribute.M15_RATE))
+            .build(new Sender("localhost", 25826));
+
+    reporter.report(
+        map(),
+        map(MetricName.build("counter"), counter),
+        map(),
+        map(MetricName.build("meter"), meter),
+        map());
+
+    assertThat(nextValues(receiver)).containsExactly(11d);
+    assertThat(nextValues(receiver)).containsExactly(1d);
+    assertThat(nextValues(receiver)).containsExactly(2d);
+    assertThat(nextValues(receiver)).containsExactly(5d);
+  }
+
+  @Test
+  void sanitizesMetricName() throws Exception {
+    Counter counter = registry.counter("dash-illegal.slash/illegal");
+    counter.inc();
+
+    reporter.report();
+
+    ValueList values = receiver.next();
+    assertThat(values.getPlugin()).isEqualTo("dash_illegal.slash_illegal");
+  }
+
+  @Test
+  void unableSetSecurityLevelToSignWithoutUsername() {
+    assertThatThrownBy(
+            () ->
                 CollectdReporter.forRegistry(registry)
-                        .withHostName("eddie")
-                        .withSecurityLevel(SecurityLevel.SIGN)
-                        .withPassword("t1_g3r")
-                        .build(new Sender("localhost", 25826)))
-                .withMessage("username is required for securityLevel: SIGN");
-    }
-
-    @Test
-    void testUnableSetSecurityLevelToSignWithoutPassword() {
-        assertThatIllegalArgumentException().isThrownBy(() ->
+                    .withHostName("eddie")
+                    .withSecurityLevel(SecurityLevel.SIGN)
+                    .withPassword("t1_g3r")
+                    .build(new Sender("localhost", 25826)))
+        .isInstanceOf(IllegalArgumentException.class)
+        .hasMessage("username is required for securityLevel: SIGN");
+  }
+
+  @Test
+  void unableSetSecurityLevelToSignWithoutPassword() {
+    assertThatThrownBy(
+            () ->
                 CollectdReporter.forRegistry(registry)
-                        .withHostName("eddie")
-                        .withSecurityLevel(SecurityLevel.SIGN)
-                        .withUsername("scott")
-                        .build(new Sender("localhost", 25826)))
-                .withMessage("password is required for securityLevel: SIGN");
-    }
-
-    private <T> SortedMap<MetricName, T> map() {
-        return Collections.emptySortedMap();
-    }
-
-    private <T> SortedMap<MetricName, T> map(MetricName name, T metric) {
-        final Map<MetricName, T> map = Collections.singletonMap(name, metric);
-        return new TreeMap<>(map);
-    }
-
-    @Test
-    void sanitizesMetricNameWithCustomMaxLength() throws Exception {
-        CollectdReporter customReporter = CollectdReporter.forRegistry(registry)
-                .withHostName("eddie")
-                .withMaxLength(20)
-                .build(new Sender("localhost", 25826));
-
-        Counter counter = registry.counter("dash-illegal.slash/illegal");
-        counter.inc();
-
-        customReporter.report();
-
-        ValueList values = receiver.next();
-        assertThat(values.getPlugin()).isEqualTo("dash_illegal.slash_i");
-    }
-
-    private List<Number> nextValues(Receiver receiver) throws Exception {
-        final ValueList valueList = receiver.next();
-        return valueList == null ? Collections.emptyList() : valueList.getValues();
-    }
+                    .withHostName("eddie")
+                    .withSecurityLevel(SecurityLevel.SIGN)
+                    .withUsername("scott")
+                    .build(new Sender("localhost", 25826)))
+        .isInstanceOf(IllegalArgumentException.class)
+        .hasMessage("password is required for securityLevel: SIGN");
+  }
+
+  private <T> SortedMap<MetricName, T> map() {
+    return emptySortedMap();
+  }
+
+  private <T> SortedMap<MetricName, T> map(MetricName name, T metric) {
+    final Map<MetricName, T> map = ImmutableMap.of(name, metric);
+    return new TreeMap<>(map);
+  }
+
+  @Test
+  void sanitizesMetricNameWithCustomMaxLength() throws Exception {
+    CollectdReporter customReporter =
+        CollectdReporter.forRegistry(registry)
+            .withHostName("eddie")
+            .withMaxLength(20)
+            .build(new Sender("localhost", 25826));
+
+    Counter counter = registry.counter("dash-illegal.slash/illegal");
+    counter.inc();
+
+    customReporter.report();
+
+    ValueList values = receiver.next();
+    assertThat(values.getPlugin()).isEqualTo("dash_illegal.slash_i");
+  }
+
+  private List<Number> nextValues(Receiver receiver) throws Exception {
+    final ValueList valueList = receiver.next();
+    return valueList == null ? ImmutableList.of() : valueList.getValues();
+  }
 }
--- a/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/PacketWriterTest.java
+++ b/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/PacketWriterTest.java
@@ -1,12 +1,9 @@
 package io.dropwizard.metrics5.collectd;
 
-import io.dropwizard.metrics5.collectd.SecurityLevel;
-import org.junit.jupiter.api.Test;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 
-import javax.crypto.Cipher;
-import javax.crypto.Mac;
-import javax.crypto.spec.IvParameterSpec;
-import javax.crypto.spec.SecretKeySpec;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -14,182 +11,185 @@ import java.security.InvalidKeyException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.crypto.Cipher;
+import javax.crypto.Mac;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+import org.junit.jupiter.api.Test;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-
-class PacketWriterTest {
-
-    private MetaData metaData = new MetaData.Builder("nw-1.alpine.example.com", 1520961345L, 100)
-            .type("gauge")
-            .typeInstance("value")
-            .get();
-    private String username = "scott";
-    private String password = "t1_g$r";
-
-    @Test
-    void testSignRequest() throws Exception {
-        AtomicBoolean packetVerified = new AtomicBoolean();
-        Sender sender = new Sender("localhost", 4009) {
-            @Override
-            public void send(ByteBuffer buffer) throws IOException {
-                short type = buffer.getShort();
-                assertThat(type).isEqualTo((short) 512);
-                short length = buffer.getShort();
-                assertThat(length).isEqualTo((short) 41);
-                byte[] packetSignature = new byte[32];
-                buffer.get(packetSignature, 0, 32);
-
-                byte[] packetUsername = new byte[length - 36];
-                buffer.get(packetUsername, 0, packetUsername.length);
-                assertThat(new String(packetUsername, UTF_8)).isEqualTo(username);
-
-                byte[] packet = new byte[buffer.remaining()];
-                buffer.get(packet);
-
-                byte[] usernameAndPacket = new byte[username.length() + packet.length];
-                System.arraycopy(packetUsername, 0, usernameAndPacket, 0, packetUsername.length);
-                System.arraycopy(packet, 0, usernameAndPacket, packetUsername.length, packet.length);
-                assertThat(sign(usernameAndPacket, password)).isEqualTo(packetSignature);
-
-                verifyPacket(packet);
-                packetVerified.set(true);
-            }
-
-            private byte[] sign(byte[] input, String password) {
-                Mac mac;
-                try {
-                    mac = Mac.getInstance("HmacSHA256");
-                    mac.init(new SecretKeySpec(password.getBytes(UTF_8), "HmacSHA256"));
-                } catch (NoSuchAlgorithmException | InvalidKeyException e) {
-                    throw new RuntimeException(e);
-                }
-                return mac.doFinal(input);
+final class PacketWriterTest {
+
+  private MetaData metaData =
+      new MetaData.Builder("nw-1.alpine.example.com", 1520961345L, 100)
+          .type("gauge")
+          .typeInstance("value")
+          .get();
+  private String username = "scott";
+  private String password = "t1_g$r";
+
+  @Test
+  void signRequest() throws Exception {
+    AtomicBoolean packetVerified = new AtomicBoolean();
+    Sender sender =
+        new Sender("localhost", 4009) {
+          @Override
+          public void send(ByteBuffer buffer) throws IOException {
+            short type = buffer.getShort();
+            assertThat(type).isEqualTo((short) 512);
+            short length = buffer.getShort();
+            assertThat(length).isEqualTo((short) 41);
+            byte[] packetSignature = new byte[32];
+            buffer.get(packetSignature, 0, 32);
+
+            byte[] packetUsername = new byte[length - 36];
+            buffer.get(packetUsername, 0, packetUsername.length);
+            assertThat(new String(packetUsername, UTF_8)).isEqualTo(username);
+
+            byte[] packet = new byte[buffer.remaining()];
+            buffer.get(packet);
+
+            byte[] usernameAndPacket = new byte[username.length() + packet.length];
+            System.arraycopy(packetUsername, 0, usernameAndPacket, 0, packetUsername.length);
+            System.arraycopy(packet, 0, usernameAndPacket, packetUsername.length, packet.length);
+            assertThat(sign(usernameAndPacket, password)).isEqualTo(packetSignature);
+
+            verifyPacket(packet);
+            packetVerified.set(true);
+          }
+
+          private byte[] sign(byte[] input, String password) {
+            Mac mac;
+            try {
+              mac = Mac.getInstance("HmacSHA256");
+              mac.init(new SecretKeySpec(password.getBytes(UTF_8), "HmacSHA256"));
+            } catch (NoSuchAlgorithmException | InvalidKeyException e) {
+              throw new RuntimeException(e);
             }
-
+            return mac.doFinal(input);
+          }
         };
-        PacketWriter packetWriter = new PacketWriter(sender, username, password, SecurityLevel.SIGN);
-        packetWriter.write(metaData, 42);
-        assertThat(packetVerified).isTrue();
-    }
-
-    @Test
-    void testEncryptRequest() throws Exception {
-        AtomicBoolean packetVerified = new AtomicBoolean();
-        Sender sender = new Sender("localhost", 4009) {
-            @Override
-            public void send(ByteBuffer buffer) throws IOException {
-                short type = buffer.getShort();
-                assertThat(type).isEqualTo((short) 0x0210);
-                short length = buffer.getShort();
-                assertThat(length).isEqualTo((short) 134);
-                short usernameLength = buffer.getShort();
-                assertThat(usernameLength).isEqualTo((short) 5);
-                byte[] packetUsername = new byte[usernameLength];
-                buffer.get(packetUsername, 0, packetUsername.length);
-                assertThat(new String(packetUsername, UTF_8)).isEqualTo(username);
-
-                byte[] iv = new byte[16];
-                buffer.get(iv, 0, iv.length);
-                byte[] encryptedPacket = new byte[buffer.remaining()];
-                buffer.get(encryptedPacket);
-
-                byte[] decryptedPacket = decrypt(iv, encryptedPacket);
-                byte[] hash = new byte[20];
-                System.arraycopy(decryptedPacket, 0, hash, 0, 20);
-                byte[] rawData = new byte[decryptedPacket.length - 20];
-                System.arraycopy(decryptedPacket, 20, rawData, 0, decryptedPacket.length - 20);
-                assertThat(sha1(rawData)).isEqualTo(hash);
-
-                verifyPacket(rawData);
-                packetVerified.set(true);
-            }
-
-            private byte[] decrypt(byte[] iv, byte[] input) {
-                try {
-                    Cipher cipher = Cipher.getInstance("AES_256/OFB/NoPadding");
-                    cipher.init(Cipher.DECRYPT_MODE,
-                            new SecretKeySpec(sha256(password.getBytes(UTF_8)), "AES"),
-                            new IvParameterSpec(iv));
-                    return cipher.doFinal(input);
-                } catch (Exception e) {
-                    throw new RuntimeException(e);
-                }
+    PacketWriter packetWriter = new PacketWriter(sender, username, password, SecurityLevel.SIGN);
+    packetWriter.write(metaData, 42);
+    assertThat(packetVerified).isTrue();
+  }
+
+  @Test
+  void encryptRequest() throws Exception {
+    AtomicBoolean packetVerified = new AtomicBoolean();
+    Sender sender =
+        new Sender("localhost", 4009) {
+          @Override
+          public void send(ByteBuffer buffer) throws IOException {
+            short type = buffer.getShort();
+            assertThat(type).isEqualTo((short) 0x0210);
+            short length = buffer.getShort();
+            assertThat(length).isEqualTo((short) 134);
+            short usernameLength = buffer.getShort();
+            assertThat(usernameLength).isEqualTo((short) 5);
+            byte[] packetUsername = new byte[usernameLength];
+            buffer.get(packetUsername, 0, packetUsername.length);
+            assertThat(new String(packetUsername, UTF_8)).isEqualTo(username);
+
+            byte[] iv = new byte[16];
+            buffer.get(iv, 0, iv.length);
+            byte[] encryptedPacket = new byte[buffer.remaining()];
+            buffer.get(encryptedPacket);
+
+            byte[] decryptedPacket = decrypt(iv, encryptedPacket);
+            byte[] hash = new byte[20];
+            System.arraycopy(decryptedPacket, 0, hash, 0, 20);
+            byte[] rawData = new byte[decryptedPacket.length - 20];
+            System.arraycopy(decryptedPacket, 20, rawData, 0, decryptedPacket.length - 20);
+            assertThat(sha1(rawData)).isEqualTo(hash);
+
+            verifyPacket(rawData);
+            packetVerified.set(true);
+          }
+
+          private byte[] decrypt(byte[] iv, byte[] input) {
+            try {
+              Cipher cipher = Cipher.getInstance("AES_256/OFB/NoPadding");
+              cipher.init(
+                  Cipher.DECRYPT_MODE,
+                  new SecretKeySpec(sha256(password.getBytes(UTF_8)), "AES"),
+                  new IvParameterSpec(iv));
+              return cipher.doFinal(input);
+            } catch (Exception e) {
+              throw new RuntimeException(e);
             }
+          }
 
-            private byte[] sha256(byte[] input) {
-                try {
-                    return MessageDigest.getInstance("SHA-256").digest(input);
-                } catch (NoSuchAlgorithmException e) {
-                    throw new RuntimeException(e);
-                }
+          private byte[] sha256(byte[] input) {
+            try {
+              return MessageDigest.getInstance("SHA-256").digest(input);
+            } catch (NoSuchAlgorithmException e) {
+              throw new RuntimeException(e);
             }
+          }
 
-            private byte[] sha1(byte[] input) {
-                try {
-                    return MessageDigest.getInstance("SHA-1").digest(input);
-                } catch (NoSuchAlgorithmException e) {
-                    throw new RuntimeException(e);
-                }
+          private byte[] sha1(byte[] input) {
+            try {
+              return MessageDigest.getInstance("SHA-1").digest(input);
+            } catch (NoSuchAlgorithmException e) {
+              throw new RuntimeException(e);
             }
+          }
         };
-        PacketWriter packetWriter = new PacketWriter(sender, username, password, SecurityLevel.ENCRYPT);
-        packetWriter.write(metaData, 42);
-        assertThat(packetVerified).isTrue();
-    }
-
-    private void verifyPacket(byte[] packetArr) {
-        ByteBuffer packet = ByteBuffer.wrap(packetArr);
-
-        short hostType = packet.getShort();
-        assertThat(hostType).isEqualTo((short) 0);
-        short hostLength = packet.getShort();
-        assertThat(hostLength).isEqualTo((short) 28);
-        byte[] host = new byte[hostLength - 5];
-        packet.get(host, 0, host.length);
-        assertThat(new String(host, UTF_8)).isEqualTo("nw-1.alpine.example.com");
-        assertThat(packet.get()).isEqualTo((byte) 0);
-
-        short timestampType = packet.getShort();
-        assertThat(timestampType).isEqualTo((short) 1);
-        short timestampLength = packet.getShort();
-        assertThat(timestampLength).isEqualTo((short) 12);
-        assertThat(packet.getLong()).isEqualTo(1520961345L);
-
-        short typeType = packet.getShort();
-        assertThat(typeType).isEqualTo((short) 4);
-        short typeLength = packet.getShort();
-        assertThat(typeLength).isEqualTo((short) 10);
-        byte[] type = new byte[typeLength - 5];
-        packet.get(type, 0, type.length);
-        assertThat(new String(type, UTF_8)).isEqualTo("gauge");
-        assertThat(packet.get()).isEqualTo((byte) 0);
-
-        short typeInstanceType = packet.getShort();
-        assertThat(typeInstanceType).isEqualTo((short) 5);
-        short typeInstanceLength = packet.getShort();
-        assertThat(typeInstanceLength).isEqualTo((short) 10);
-        byte[] typeInstance = new byte[typeInstanceLength - 5];
-        packet.get(typeInstance, 0, typeInstance.length);
-        assertThat(new String(typeInstance, UTF_8)).isEqualTo("value");
-        assertThat(packet.get()).isEqualTo((byte) 0);
-
-        short periodType = packet.getShort();
-        assertThat(periodType).isEqualTo((short) 7);
-        short periodLength = packet.getShort();
-        assertThat(periodLength).isEqualTo((short) 12);
-        assertThat(packet.getLong()).isEqualTo(100);
-
-        short valuesType = packet.getShort();
-        assertThat(valuesType).isEqualTo((short) 6);
-        short valuesLength = packet.getShort();
-        assertThat(valuesLength).isEqualTo((short) 15);
-        short amountOfValues = packet.getShort();
-        assertThat(amountOfValues).isEqualTo((short) 1);
-        byte dataType = packet.get();
-        assertThat(dataType).isEqualTo((byte) 1);
-        assertThat(packet.order(ByteOrder.LITTLE_ENDIAN).getDouble()).isEqualTo(42.0, offset(0.01));
-    }
-
-}
\ No newline at end of file
+    PacketWriter packetWriter = new PacketWriter(sender, username, password, SecurityLevel.ENCRYPT);
+    packetWriter.write(metaData, 42);
+    assertThat(packetVerified).isTrue();
+  }
+
+  private void verifyPacket(byte[] packetArr) {
+    ByteBuffer packet = ByteBuffer.wrap(packetArr);
+
+    short hostType = packet.getShort();
+    assertThat(hostType).isEqualTo((short) 0);
+    short hostLength = packet.getShort();
+    assertThat(hostLength).isEqualTo((short) 28);
+    byte[] host = new byte[hostLength - 5];
+    packet.get(host, 0, host.length);
+    assertThat(new String(host, UTF_8)).isEqualTo("nw-1.alpine.example.com");
+    assertThat(packet.get()).isEqualTo((byte) 0);
+
+    short timestampType = packet.getShort();
+    assertThat(timestampType).isEqualTo((short) 1);
+    short timestampLength = packet.getShort();
+    assertThat(timestampLength).isEqualTo((short) 12);
+    assertThat(packet.getLong()).isEqualTo(1520961345L);
+
+    short typeType = packet.getShort();
+    assertThat(typeType).isEqualTo((short) 4);
+    short typeLength = packet.getShort();
+    assertThat(typeLength).isEqualTo((short) 10);
+    byte[] type = new byte[typeLength - 5];
+    packet.get(type, 0, type.length);
+    assertThat(new String(type, UTF_8)).isEqualTo("gauge");
+    assertThat(packet.get()).isEqualTo((byte) 0);
+
+    short typeInstanceType = packet.getShort();
+    assertThat(typeInstanceType).isEqualTo((short) 5);
+    short typeInstanceLength = packet.getShort();
+    assertThat(typeInstanceLength).isEqualTo((short) 10);
+    byte[] typeInstance = new byte[typeInstanceLength - 5];
+    packet.get(typeInstance, 0, typeInstance.length);
+    assertThat(new String(typeInstance, UTF_8)).isEqualTo("value");
+    assertThat(packet.get()).isEqualTo((byte) 0);
+
+    short periodType = packet.getShort();
+    assertThat(periodType).isEqualTo((short) 7);
+    short periodLength = packet.getShort();
+    assertThat(periodLength).isEqualTo((short) 12);
+    assertThat(packet.getLong()).isEqualTo(100);
+
+    short valuesType = packet.getShort();
+    assertThat(valuesType).isEqualTo((short) 6);
+    short valuesLength = packet.getShort();
+    assertThat(valuesLength).isEqualTo((short) 15);
+    short amountOfValues = packet.getShort();
+    assertThat(amountOfValues).isEqualTo((short) 1);
+    byte dataType = packet.get();
+    assertThat(dataType).isEqualTo((byte) 1);
+    assertThat(packet.order(ByteOrder.LITTLE_ENDIAN).getDouble()).isCloseTo(42.0, offset(0.01));
+  }
+}
--- a/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/Receiver.java
+++ b/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/Receiver.java
@@ -1,5 +1,11 @@
 package io.dropwizard.metrics5.collectd;
 
+import java.net.DatagramSocket;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import org.collectd.api.Notification;
 import org.collectd.api.ValueList;
 import org.collectd.protocol.Dispatcher;
@@ -8,59 +14,55 @@ import org.junit.jupiter.api.extension.AfterAllCallback;
 import org.junit.jupiter.api.extension.BeforeAllCallback;
 import org.junit.jupiter.api.extension.ExtensionContext;
 
-import java.net.DatagramSocket;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-
 public final class Receiver implements BeforeAllCallback, AfterAllCallback {
 
-    private final int port;
-
-    private UdpReceiver receiver;
-    private DatagramSocket socket;
-    private final BlockingQueue<ValueList> queue = new LinkedBlockingQueue<>();
+  private final int port;
 
-    public Receiver(int port) {
-        this.port = port;
-    }
+  private UdpReceiver receiver;
+  private DatagramSocket socket;
+  private final BlockingQueue<ValueList> queue = new LinkedBlockingQueue<>();
 
+  public Receiver(int port) {
+    this.port = port;
+  }
 
-    @Override
-    public void afterAll(ExtensionContext context) throws Exception {
-        receiver.shutdown();
-        socket.close();
-    }
+  @Override
+  public void afterAll(ExtensionContext context) throws Exception {
+    receiver.shutdown();
+    socket.close();
+  }
 
-    @Override
-    public void beforeAll(ExtensionContext context) throws Exception {
-        socket = new DatagramSocket(null);
-        socket.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), port));
+  @Override
+  public void beforeAll(ExtensionContext context) throws Exception {
+    socket = new DatagramSocket(null);
+    socket.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), port));
 
-        receiver = new UdpReceiver(new Dispatcher() {
-            @Override
-            public void dispatch(ValueList values) {
+    receiver =
+        new UdpReceiver(
+            new Dispatcher() {
+              @Override
+              public void dispatch(ValueList values) {
                 queue.offer(new ValueList(values));
-            }
+              }
 
-            @Override
-            public void dispatch(Notification notification) {
+              @Override
+              public void dispatch(Notification notification) {
                 throw new UnsupportedOperationException();
-            }
-        });
-        receiver.setPort(port);
-        new Thread(() -> {
-            try {
+              }
+            });
+    receiver.setPort(port);
+    new Thread(
+            () -> {
+              try {
                 receiver.listen(socket);
-            } catch (Exception e) {
+              } catch (Exception e) {
                 e.printStackTrace();
-            }
-        }).start();
-    }
+              }
+            })
+        .start();
+  }
 
-    public ValueList next() throws InterruptedException {
-        return queue.poll(2, TimeUnit.SECONDS);
-    }
+  public ValueList next() throws InterruptedException {
+    return queue.poll(2, TimeUnit.SECONDS);
+  }
 }
--- a/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/SanitizeTest.java
+++ b/metrics-collectd/src/test/java/io/dropwizard/metrics5/collectd/SanitizeTest.java
@@ -1,39 +1,41 @@
 package io.dropwizard.metrics5.collectd;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class SanitizeTest {
-
-    private Sanitize sanitize = new Sanitize(Sanitize.DEFAULT_MAX_LENGTH);
-
-    @Test
-    void replacesIllegalCharactersInName() throws Exception {
-        assertThat(sanitize.name("foo\u0000bar/baz-quux")).isEqualTo("foo_bar_baz_quux");
-    }
-
-    @Test
-    void replacesIllegalCharactersInInstanceName() throws Exception {
-        assertThat(sanitize.instanceName("foo\u0000bar/baz-quux")).isEqualTo("foo_bar_baz-quux");
-    }
-
-    @Test
-    void truncatesNamesExceedingMaxLength() throws Exception {
-        String longName = "01234567890123456789012345678901234567890123456789012345678901234567890123456789";
-        assertThat(sanitize.name(longName)).isEqualTo(longName.substring(0, (Sanitize.DEFAULT_MAX_LENGTH)));
-    }
-
-    @Test
-    void truncatesNamesExceedingCustomMaxLength() throws Exception {
-        Sanitize customSanitize = new Sanitize(70);
-        String longName = "01234567890123456789012345678901234567890123456789012345678901234567890123456789";
-        assertThat(customSanitize.name(longName)).isEqualTo(longName.substring(0, 70));
-    }
-
-    @Test
-    void replacesNonASCIICharacters() throws Exception {
-        assertThat(sanitize.name("M" + '\u00FC' + "nchen")).isEqualTo("M_nchen");
-    }
+import org.junit.jupiter.api.Test;
 
+final class SanitizeTest {
+
+  private Sanitize sanitize = new Sanitize(Sanitize.DEFAULT_MAX_LENGTH);
+
+  @Test
+  void replacesIllegalCharactersInName() throws Exception {
+    assertThat(sanitize.name("foo\u0000bar/baz-quux")).isEqualTo("foo_bar_baz_quux");
+  }
+
+  @Test
+  void replacesIllegalCharactersInInstanceName() throws Exception {
+    assertThat(sanitize.instanceName("foo\u0000bar/baz-quux")).isEqualTo("foo_bar_baz-quux");
+  }
+
+  @Test
+  void truncatesNamesExceedingMaxLength() throws Exception {
+    String longName =
+        "01234567890123456789012345678901234567890123456789012345678901234567890123456789";
+    assertThat(sanitize.name(longName))
+        .isEqualTo(longName.substring(0, (Sanitize.DEFAULT_MAX_LENGTH)));
+  }
+
+  @Test
+  void truncatesNamesExceedingCustomMaxLength() throws Exception {
+    Sanitize customSanitize = new Sanitize(70);
+    String longName =
+        "01234567890123456789012345678901234567890123456789012345678901234567890123456789";
+    assertThat(customSanitize.name(longName)).isEqualTo(longName.substring(0, 70));
+  }
+
+  @Test
+  void replacesNonASCIICharacters() throws Exception {
+    assertThat(sanitize.name("M" + '\u00FC' + "nchen")).isEqualTo("M_nchen");
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/CachedGauge.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/CachedGauge.java
@@ -10,65 +10,65 @@ import java.util.concurrent.atomic.AtomicReference;
  * @param <T> the type of the gauge's value
  */
 public abstract class CachedGauge<T> implements Gauge<T> {
-    private final Clock clock;
-    private final AtomicLong reloadAt;
-    private final long timeoutNS;
-    private final AtomicReference<T> value;
+  private final Clock clock;
+  private final AtomicLong reloadAt;
+  private final long timeoutNS;
+  private final AtomicReference<T> value;
 
-    /**
-     * Creates a new cached gauge with the given timeout period.
-     *
-     * @param timeout     the timeout
-     * @param timeoutUnit the unit of {@code timeout}
-     */
-    protected CachedGauge(long timeout, TimeUnit timeoutUnit) {
-        this(Clock.defaultClock(), timeout, timeoutUnit);
-    }
+  /**
+   * Creates a new cached gauge with the given timeout period.
+   *
+   * @param timeout the timeout
+   * @param timeoutUnit the unit of {@code timeout}
+   */
+  protected CachedGauge(long timeout, TimeUnit timeoutUnit) {
+    this(Clock.defaultClock(), timeout, timeoutUnit);
+  }
 
-    /**
-     * Creates a new cached gauge with the given clock and timeout period.
-     *
-     * @param clock       the clock used to calculate the timeout
-     * @param timeout     the timeout
-     * @param timeoutUnit the unit of {@code timeout}
-     */
-    protected CachedGauge(Clock clock, long timeout, TimeUnit timeoutUnit) {
-        this.clock = clock;
-        this.reloadAt = new AtomicLong(clock.getTick());
-        this.timeoutNS = timeoutUnit.toNanos(timeout);
-        this.value = new AtomicReference<>();
-    }
+  /**
+   * Creates a new cached gauge with the given clock and timeout period.
+   *
+   * @param clock the clock used to calculate the timeout
+   * @param timeout the timeout
+   * @param timeoutUnit the unit of {@code timeout}
+   */
+  protected CachedGauge(Clock clock, long timeout, TimeUnit timeoutUnit) {
+    this.clock = clock;
+    this.reloadAt = new AtomicLong(clock.getTick());
+    this.timeoutNS = timeoutUnit.toNanos(timeout);
+    this.value = new AtomicReference<>();
+  }
 
-    /**
-     * Loads the value and returns it.
-     *
-     * @return the new value
-     */
-    protected abstract T loadValue();
+  /**
+   * Loads the value and returns it.
+   *
+   * @return the new value
+   */
+  protected abstract T loadValue();
 
-    @Override
-    public T getValue() {
-        T currentValue = this.value.get();
-        if (shouldLoad() || currentValue == null) {
-            T newValue = loadValue();
-            if (!this.value.compareAndSet(currentValue, newValue)) {
-                return this.value.get();
-            }
-            return newValue;
-        }
-        return currentValue;
+  @Override
+  public T getValue() {
+    T currentValue = this.value.get();
+    if (shouldLoad() || currentValue == null) {
+      T newValue = loadValue();
+      if (!this.value.compareAndSet(currentValue, newValue)) {
+        return this.value.get();
+      }
+      return newValue;
     }
+    return currentValue;
+  }
 
-    private boolean shouldLoad() {
-        for ( ;; ) {
-            final long time = clock.getTick();
-            final long current = reloadAt.get();
-            if (current > time) {
-                return false;
-            }
-            if (reloadAt.compareAndSet(current, time + timeoutNS)) {
-                return true;
-            }
-        }
+  private boolean shouldLoad() {
+    for (; ; ) {
+      final long time = clock.getTick();
+      final long current = reloadAt.get();
+      if (current > time) {
+        return false;
+      }
+      if (reloadAt.compareAndSet(current, time + timeoutNS)) {
+        return true;
+      }
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/ChunkedAssociativeLongArray.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/ChunkedAssociativeLongArray.java
@@ -1,200 +1,211 @@
 package io.dropwizard.metrics5;
 
+import static java.lang.System.arraycopy;
+import static java.util.Arrays.binarySearch;
+
 import java.lang.ref.SoftReference;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Iterator;
 
-import static java.lang.System.arraycopy;
-import static java.util.Arrays.binarySearch;
-
 class ChunkedAssociativeLongArray {
-    private static final long[] EMPTY = new long[0];
-    private static final int DEFAULT_CHUNK_SIZE = 512;
-    private static final int MAX_CACHE_SIZE = 128;
-
-    private final int defaultChunkSize;
-
-    /*
-     * We use this ArrayDeque as cache to store chunks that are expired and removed from main data structure.
-     * Then instead of allocating new Chunk immediately we are trying to poll one from this deque.
-     * So if you have constant or slowly changing load ChunkedAssociativeLongArray will never
-     * throw away old chunks or allocate new ones which makes this data structure almost garbage free.
-     */
-    private final ArrayDeque<SoftReference<Chunk>> chunksCache = new ArrayDeque<>();
-
-    private final Deque<Chunk> chunks = new ArrayDeque<>();
-
-    ChunkedAssociativeLongArray() {
-        this(DEFAULT_CHUNK_SIZE);
+  private static final long[] EMPTY = new long[0];
+  private static final int DEFAULT_CHUNK_SIZE = 512;
+  private static final int MAX_CACHE_SIZE = 128;
+
+  private final int defaultChunkSize;
+
+  /*
+   * We use this ArrayDeque as cache to store chunks that are expired and removed from main data structure.
+   * Then instead of allocating new Chunk immediately we are trying to poll one from this deque.
+   * So if you have constant or slowly changing load ChunkedAssociativeLongArray will never
+   * throw away old chunks or allocate new ones which makes this data structure almost garbage free.
+   */
+  private final ArrayDeque<SoftReference<Chunk>> chunksCache = new ArrayDeque<>();
+
+  private final Deque<Chunk> chunks = new ArrayDeque<>();
+
+  ChunkedAssociativeLongArray() {
+    this(DEFAULT_CHUNK_SIZE);
+  }
+
+  ChunkedAssociativeLongArray(int chunkSize) {
+    this.defaultChunkSize = chunkSize;
+  }
+
+  private Chunk allocateChunk() {
+    while (true) {
+      final SoftReference<Chunk> chunkRef = chunksCache.pollLast();
+      if (chunkRef == null) {
+        return new Chunk(defaultChunkSize);
+      }
+      final Chunk chunk = chunkRef.get();
+      if (chunk != null) {
+        chunk.cursor = 0;
+        chunk.startIndex = 0;
+        chunk.chunkSize = chunk.keys.length;
+        return chunk;
+      }
     }
+  }
 
-    ChunkedAssociativeLongArray(int chunkSize) {
-        this.defaultChunkSize = chunkSize;
+  private void freeChunk(Chunk chunk) {
+    if (chunksCache.size() < MAX_CACHE_SIZE) {
+      chunksCache.add(new SoftReference<>(chunk));
     }
-
-    private Chunk allocateChunk() {
-        while (true) {
-            final SoftReference<Chunk> chunkRef = chunksCache.pollLast();
-            if (chunkRef == null) {
-                return new Chunk(defaultChunkSize);
-            }
-            final Chunk chunk = chunkRef.get();
-            if (chunk != null) {
-                chunk.cursor = 0;
-                chunk.startIndex = 0;
-                chunk.chunkSize = chunk.keys.length;
-                return chunk;
-            }
-        }
+  }
+
+  synchronized boolean put(long key, long value) {
+    Chunk activeChunk = chunks.peekLast();
+    if (activeChunk != null
+        && activeChunk.cursor != 0
+        && activeChunk.keys[activeChunk.cursor - 1] > key) {
+      // key should be the same as last inserted or bigger
+      return false;
     }
-
-    private void freeChunk(Chunk chunk) {
-        if (chunksCache.size() < MAX_CACHE_SIZE) {
-            chunksCache.add(new SoftReference<>(chunk));
-        }
+    if (activeChunk == null
+        || activeChunk.cursor - activeChunk.startIndex == activeChunk.chunkSize) {
+      // The last chunk doesn't exist or full
+      activeChunk = allocateChunk();
+      chunks.add(activeChunk);
     }
-
-    synchronized boolean put(long key, long value) {
-        Chunk activeChunk = chunks.peekLast();
-        if (activeChunk != null && activeChunk.cursor != 0 && activeChunk.keys[activeChunk.cursor - 1] > key) {
-            // key should be the same as last inserted or bigger
-            return false;
-        }
-        if (activeChunk == null || activeChunk.cursor - activeChunk.startIndex == activeChunk.chunkSize) {
-            // The last chunk doesn't exist or full
-            activeChunk = allocateChunk();
-            chunks.add(activeChunk);
-        }
-        activeChunk.append(key, value);
-        return true;
+    activeChunk.append(key, value);
+    return true;
+  }
+
+  synchronized long[] values() {
+    final int valuesSize = size();
+    if (valuesSize == 0) {
+      return EMPTY;
     }
 
-    synchronized long[] values() {
-        final int valuesSize = size();
-        if (valuesSize == 0) {
-            return EMPTY;
-        }
-
-        final long[] values = new long[valuesSize];
-        int valuesIndex = 0;
-        for (Chunk chunk : chunks) {
-            int length = chunk.cursor - chunk.startIndex;
-            int itemsToCopy = Math.min(valuesSize - valuesIndex, length);
-            arraycopy(chunk.values, chunk.startIndex, values, valuesIndex, itemsToCopy);
-            valuesIndex += length;
-        }
-        return values;
+    final long[] values = new long[valuesSize];
+    int valuesIndex = 0;
+    for (Chunk chunk : chunks) {
+      int length = chunk.cursor - chunk.startIndex;
+      int itemsToCopy = Math.min(valuesSize - valuesIndex, length);
+      arraycopy(chunk.values, chunk.startIndex, values, valuesIndex, itemsToCopy);
+      valuesIndex += length;
     }
+    return values;
+  }
 
-    synchronized int size() {
-        int result = 0;
-        for (Chunk chunk : chunks) {
-            result += chunk.cursor - chunk.startIndex;
-        }
-        return result;
+  synchronized int size() {
+    int result = 0;
+    for (Chunk chunk : chunks) {
+      result += chunk.cursor - chunk.startIndex;
     }
-
-    synchronized String out() {
-        final StringBuilder builder = new StringBuilder();
-        final Iterator<Chunk> iterator = chunks.iterator();
-        while (iterator.hasNext()) {
-            final Chunk chunk = iterator.next();
-            builder.append('[');
-            for (int i = chunk.startIndex; i < chunk.cursor; i++) {
-                builder.append('(').append(chunk.keys[i]).append(": ")
-                        .append(chunk.values[i]).append(')').append(' ');
-            }
-            builder.append(']');
-            if (iterator.hasNext()) {
-                builder.append("->");
-            }
-        }
-        return builder.toString();
+    return result;
+  }
+
+  synchronized String out() {
+    final StringBuilder builder = new StringBuilder();
+    final Iterator<Chunk> iterator = chunks.iterator();
+    while (iterator.hasNext()) {
+      final Chunk chunk = iterator.next();
+      builder.append('[');
+      for (int i = chunk.startIndex; i < chunk.cursor; i++) {
+        builder
+            .append('(')
+            .append(chunk.keys[i])
+            .append(": ")
+            .append(chunk.values[i])
+            .append(')')
+            .append(' ');
+      }
+      builder.append(']');
+      if (iterator.hasNext()) {
+        builder.append("->");
+      }
     }
-
-    /**
-     * Try to trim all beyond specified boundaries.
-     *
-     * @param startKey the start value for which all elements less than it should be removed.
-     * @param endKey   the end value for which all elements greater/equals than it should be removed.
+    return builder.toString();
+  }
+
+  /**
+   * Try to trim all beyond specified boundaries.
+   *
+   * @param startKey the start value for which all elements less than it should be removed.
+   * @param endKey the end value for which all elements greater/equals than it should be removed.
+   */
+  synchronized void trim(long startKey, long endKey) {
+    /*
+     * [3, 4, 5, 9] -> [10, 13, 14, 15] -> [21, 24, 29, 30] -> [31] :: start layout
+     *       |5______________________________23|                    :: trim(5, 23)
+     *       [5, 9] -> [10, 13, 14, 15] -> [21]                     :: result layout
      */
-    synchronized void trim(long startKey, long endKey) {
-        /*
-         * [3, 4, 5, 9] -> [10, 13, 14, 15] -> [21, 24, 29, 30] -> [31] :: start layout
-         *       |5______________________________23|                    :: trim(5, 23)
-         *       [5, 9] -> [10, 13, 14, 15] -> [21]                     :: result layout
-         */
-        final Iterator<Chunk> descendingIterator = chunks.descendingIterator();
-        while (descendingIterator.hasNext()) {
-            final Chunk currentTail = descendingIterator.next();
-            if (isFirstElementIsEmptyOrGreaterEqualThanKey(currentTail, endKey)) {
-                freeChunk(currentTail);
-                descendingIterator.remove();
-            } else {
-                currentTail.cursor = findFirstIndexOfGreaterEqualElements(currentTail.keys, currentTail.startIndex,
-                        currentTail.cursor, endKey);
-                break;
-            }
-        }
+    final Iterator<Chunk> descendingIterator = chunks.descendingIterator();
+    while (descendingIterator.hasNext()) {
+      final Chunk currentTail = descendingIterator.next();
+      if (isFirstElementIsEmptyOrGreaterEqualThanKey(currentTail, endKey)) {
+        freeChunk(currentTail);
+        descendingIterator.remove();
+      } else {
+        currentTail.cursor =
+            findFirstIndexOfGreaterEqualElements(
+                currentTail.keys, currentTail.startIndex, currentTail.cursor, endKey);
+        break;
+      }
+    }
 
-        final Iterator<Chunk> iterator = chunks.iterator();
-        while (iterator.hasNext()) {
-            final Chunk currentHead = iterator.next();
-            if (isLastElementIsLessThanKey(currentHead, startKey)) {
-                freeChunk(currentHead);
-                iterator.remove();
-            } else {
-                final int newStartIndex = findFirstIndexOfGreaterEqualElements(currentHead.keys, currentHead.startIndex,
-                        currentHead.cursor, startKey);
-                if (currentHead.startIndex != newStartIndex) {
-                    currentHead.startIndex = newStartIndex;
-                    currentHead.chunkSize = currentHead.cursor - currentHead.startIndex;
-                }
-                break;
-            }
+    final Iterator<Chunk> iterator = chunks.iterator();
+    while (iterator.hasNext()) {
+      final Chunk currentHead = iterator.next();
+      if (isLastElementIsLessThanKey(currentHead, startKey)) {
+        freeChunk(currentHead);
+        iterator.remove();
+      } else {
+        final int newStartIndex =
+            findFirstIndexOfGreaterEqualElements(
+                currentHead.keys, currentHead.startIndex, currentHead.cursor, startKey);
+        if (currentHead.startIndex != newStartIndex) {
+          currentHead.startIndex = newStartIndex;
+          currentHead.chunkSize = currentHead.cursor - currentHead.startIndex;
         }
+        break;
+      }
     }
+  }
 
-    synchronized void clear() {
-        chunks.clear();
-    }
+  synchronized void clear() {
+    chunks.clear();
+  }
 
-    private boolean isFirstElementIsEmptyOrGreaterEqualThanKey(Chunk chunk, long key) {
-        return chunk.cursor == chunk.startIndex || chunk.keys[chunk.startIndex] >= key;
-    }
+  private boolean isFirstElementIsEmptyOrGreaterEqualThanKey(Chunk chunk, long key) {
+    return chunk.cursor == chunk.startIndex || chunk.keys[chunk.startIndex] >= key;
+  }
 
-    private boolean isLastElementIsLessThanKey(Chunk chunk, long key) {
-        return chunk.cursor == chunk.startIndex || chunk.keys[chunk.cursor - 1] < key;
-    }
+  private boolean isLastElementIsLessThanKey(Chunk chunk, long key) {
+    return chunk.cursor == chunk.startIndex || chunk.keys[chunk.cursor - 1] < key;
+  }
 
-    private int findFirstIndexOfGreaterEqualElements(long[] array, int startIndex, int endIndex, long minKey) {
-        if (endIndex == startIndex || array[startIndex] >= minKey) {
-            return startIndex;
-        }
-        final int keyIndex = binarySearch(array, startIndex, endIndex, minKey);
-        return keyIndex < 0 ? -(keyIndex + 1) : keyIndex;
+  private int findFirstIndexOfGreaterEqualElements(
+      long[] array, int startIndex, int endIndex, long minKey) {
+    if (endIndex == startIndex || array[startIndex] >= minKey) {
+      return startIndex;
     }
+    final int keyIndex = binarySearch(array, startIndex, endIndex, minKey);
+    return keyIndex < 0 ? -(keyIndex + 1) : keyIndex;
+  }
 
-    private static class Chunk {
+  private static class Chunk {
 
-        private final long[] keys;
-        private final long[] values;
+    private final long[] keys;
+    private final long[] values;
 
-        private int chunkSize; // can differ from keys.length after half clear()
-        private int startIndex = 0;
-        private int cursor = 0;
+    private int chunkSize; // can differ from keys.length after half clear()
+    private int startIndex = 0;
+    private int cursor = 0;
 
-        private Chunk(int chunkSize) {
-            this.chunkSize = chunkSize;
-            this.keys = new long[chunkSize];
-            this.values = new long[chunkSize];
-        }
+    private Chunk(int chunkSize) {
+      this.chunkSize = chunkSize;
+      this.keys = new long[chunkSize];
+      this.values = new long[chunkSize];
+    }
 
-        private void append(long key, long value) {
-            keys[cursor] = key;
-            values[cursor] = value;
-            cursor++;
-        }
+    private void append(long key, long value) {
+      keys[cursor] = key;
+      values[cursor] = value;
+      cursor++;
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Clock.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Clock.java
@@ -1,46 +1,42 @@
 package io.dropwizard.metrics5;
 
-/**
- * An abstraction for how time passes. It is passed to {@link Timer} to track timing.
- */
+/** An abstraction for how time passes. It is passed to {@link Timer} to track timing. */
 public abstract class Clock {
-    /**
-     * Returns the current time tick.
-     *
-     * @return time tick in nanoseconds
-     */
-    public abstract long getTick();
+  /**
+   * Returns the current time tick.
+   *
+   * @return time tick in nanoseconds
+   */
+  public abstract long getTick();
 
-    /**
-     * Returns the current time in milliseconds.
-     *
-     * @return time in milliseconds
-     */
-    public long getTime() {
-        return System.currentTimeMillis();
-    }
+  /**
+   * Returns the current time in milliseconds.
+   *
+   * @return time in milliseconds
+   */
+  public long getTime() {
+    return System.currentTimeMillis();
+  }
 
-    /**
-     * The default clock to use.
-     *
-     * @return the default {@link Clock} instance
-     * @see Clock.UserTimeClock
-     */
-    public static Clock defaultClock() {
-        return UserTimeClockHolder.DEFAULT;
-    }
+  /**
+   * The default clock to use.
+   *
+   * @return the default {@link Clock} instance
+   * @see Clock.UserTimeClock
+   */
+  public static Clock defaultClock() {
+    return UserTimeClockHolder.DEFAULT;
+  }
 
-    /**
-     * A clock implementation which returns the current time in epoch nanoseconds.
-     */
-    public static class UserTimeClock extends Clock {
-        @Override
-        public long getTick() {
-            return System.nanoTime();
-        }
+  /** A clock implementation which returns the current time in epoch nanoseconds. */
+  public static class UserTimeClock extends Clock {
+    @Override
+    public long getTick() {
+      return System.nanoTime();
     }
+  }
 
-    private static class UserTimeClockHolder {
-        private static final Clock DEFAULT = new UserTimeClock();
-    }
+  private static class UserTimeClockHolder {
+    private static final Clock DEFAULT = new UserTimeClock();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/ConsoleReporter.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/ConsoleReporter.java
@@ -1,8 +1,8 @@
 package io.dropwizard.metrics5;
 
+import com.google.common.collect.ImmutableSet;
 import java.io.PrintStream;
 import java.text.DateFormat;
-import java.util.Collections;
 import java.util.Date;
 import java.util.Locale;
 import java.util.Map;
@@ -12,349 +12,491 @@ import java.util.TimeZone;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
-/**
- * A reporter which outputs measurements to a {@link PrintStream}, like {@code System.out}.
- */
+/** A reporter which outputs measurements to a {@link PrintStream}, like {@code System.out}. */
 public class ConsoleReporter extends ScheduledReporter {
+  /**
+   * Returns a new {@link Builder} for {@link ConsoleReporter}.
+   *
+   * @param registry the registry to report
+   * @return a {@link Builder} instance for a {@link ConsoleReporter}
+   */
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
+
+  /**
+   * A builder for {@link ConsoleReporter} instances. Defaults to using the default locale and time
+   * zone, writing to {@code System.out}, converting rates to events/second, converting durations to
+   * milliseconds, and not filtering metrics.
+   */
+  public static class Builder {
+    private final MetricRegistry registry;
+    private PrintStream output;
+    private Locale locale;
+    private Clock clock;
+    private TimeZone timeZone;
+    private TimeUnit rateUnit;
+    private TimeUnit durationUnit;
+    private MetricFilter filter;
+    private ScheduledExecutorService executor;
+    private boolean shutdownExecutorOnStop;
+    private Set<MetricAttribute> disabledMetricAttributes;
+
+    private Builder(MetricRegistry registry) {
+      this.registry = registry;
+      this.output = System.out;
+      this.locale = Locale.getDefault();
+      this.clock = Clock.defaultClock();
+      this.timeZone = TimeZone.getDefault();
+      this.rateUnit = TimeUnit.SECONDS;
+      this.durationUnit = TimeUnit.MILLISECONDS;
+      this.filter = MetricFilter.ALL;
+      this.executor = null;
+      this.shutdownExecutorOnStop = true;
+      disabledMetricAttributes = ImmutableSet.of();
+    }
+
     /**
-     * Returns a new {@link Builder} for {@link ConsoleReporter}.
+     * Specifies whether or not, the executor (used for reporting) will be stopped with same time
+     * with reporter. Default value is true. Setting this parameter to false, has the sense in
+     * combining with providing external managed executor via {@link
+     * #scheduleOn(ScheduledExecutorService)}.
      *
-     * @param registry the registry to report
-     * @return a {@link Builder} instance for a {@link ConsoleReporter}
+     * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+     *     reporter
+     * @return {@code this}
      */
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
+    public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      this.shutdownExecutorOnStop = shutdownExecutorOnStop;
+      return this;
     }
 
     /**
-     * A builder for {@link ConsoleReporter} instances. Defaults to using the default locale and
-     * time zone, writing to {@code System.out}, converting rates to events/second, converting
-     * durations to milliseconds, and not filtering metrics.
+     * Specifies the executor to use while scheduling reporting of metrics. Default value is null.
+     * Null value leads to executor will be auto created on start.
+     *
+     * @param executor the executor to use while scheduling reporting of metrics.
+     * @return {@code this}
      */
-    public static class Builder {
-        private final MetricRegistry registry;
-        private PrintStream output;
-        private Locale locale;
-        private Clock clock;
-        private TimeZone timeZone;
-        private TimeUnit rateUnit;
-        private TimeUnit durationUnit;
-        private MetricFilter filter;
-        private ScheduledExecutorService executor;
-        private boolean shutdownExecutorOnStop;
-        private Set<MetricAttribute> disabledMetricAttributes;
-
-        private Builder(MetricRegistry registry) {
-            this.registry = registry;
-            this.output = System.out;
-            this.locale = Locale.getDefault();
-            this.clock = Clock.defaultClock();
-            this.timeZone = TimeZone.getDefault();
-            this.rateUnit = TimeUnit.SECONDS;
-            this.durationUnit = TimeUnit.MILLISECONDS;
-            this.filter = MetricFilter.ALL;
-            this.executor = null;
-            this.shutdownExecutorOnStop = true;
-            disabledMetricAttributes = Collections.emptySet();
-        }
-
-        /**
-         * Specifies whether or not, the executor (used for reporting) will be stopped with same time with reporter.
-         * Default value is true.
-         * Setting this parameter to false, has the sense in combining with providing external managed executor via {@link #scheduleOn(ScheduledExecutorService)}.
-         *
-         * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this reporter
-         * @return {@code this}
-         */
-        public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            this.shutdownExecutorOnStop = shutdownExecutorOnStop;
-            return this;
-        }
-
-        /**
-         * Specifies the executor to use while scheduling reporting of metrics.
-         * Default value is null.
-         * Null value leads to executor will be auto created on start.
-         *
-         * @param executor the executor to use while scheduling reporting of metrics.
-         * @return {@code this}
-         */
-        public Builder scheduleOn(ScheduledExecutorService executor) {
-            this.executor = executor;
-            return this;
-        }
-
-        /**
-         * Write to the given {@link PrintStream}.
-         *
-         * @param output a {@link PrintStream} instance.
-         * @return {@code this}
-         */
-        public Builder outputTo(PrintStream output) {
-            this.output = output;
-            return this;
-        }
-
-        /**
-         * Format numbers for the given {@link Locale}.
-         *
-         * @param locale a {@link Locale}
-         * @return {@code this}
-         */
-        public Builder formattedFor(Locale locale) {
-            this.locale = locale;
-            return this;
-        }
-
-        /**
-         * Use the given {@link Clock} instance for the time.
-         *
-         * @param clock a {@link Clock} instance
-         * @return {@code this}
-         */
-        public Builder withClock(Clock clock) {
-            this.clock = clock;
-            return this;
-        }
-
-        /**
-         * Use the given {@link TimeZone} for the time.
-         *
-         * @param timeZone a {@link TimeZone}
-         * @return {@code this}
-         */
-        public Builder formattedFor(TimeZone timeZone) {
-            this.timeZone = timeZone;
-            return this;
-        }
-
-        /**
-         * Convert rates to the given time unit.
-         *
-         * @param rateUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertRatesTo(TimeUnit rateUnit) {
-            this.rateUnit = rateUnit;
-            return this;
-        }
-
-        /**
-         * Convert durations to the given time unit.
-         *
-         * @param durationUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertDurationsTo(TimeUnit durationUnit) {
-            this.durationUnit = durationUnit;
-            return this;
-        }
-
-        /**
-         * Only report metrics which match the given filter.
-         *
-         * @param filter a {@link MetricFilter}
-         * @return {@code this}
-         */
-        public Builder filter(MetricFilter filter) {
-            this.filter = filter;
-            return this;
-        }
-
-        /**
-         * Don't report the passed metric attributes for all metrics (e.g. "p999", "stddev" or "m15").
-         * See {@link MetricAttribute}.
-         *
-         * @param disabledMetricAttributes a {@link MetricFilter}
-         * @return {@code this}
-         */
-        public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
-            this.disabledMetricAttributes = disabledMetricAttributes;
-            return this;
-        }
-
-        /**
-         * Builds a {@link ConsoleReporter} with the given properties.
-         *
-         * @return a {@link ConsoleReporter}
-         */
-        public ConsoleReporter build() {
-            return new ConsoleReporter(registry,
-                    output,
-                    locale,
-                    clock,
-                    timeZone,
-                    rateUnit,
-                    durationUnit,
-                    filter,
-                    executor,
-                    shutdownExecutorOnStop,
-                    disabledMetricAttributes);
-        }
+    public Builder scheduleOn(ScheduledExecutorService executor) {
+      this.executor = executor;
+      return this;
     }
 
-    private static final int CONSOLE_WIDTH = 80;
-
-    private final PrintStream output;
-    private final Locale locale;
-    private final Clock clock;
-    private final DateFormat dateFormat;
-
-    private ConsoleReporter(MetricRegistry registry,
-                            PrintStream output,
-                            Locale locale,
-                            Clock clock,
-                            TimeZone timeZone,
-                            TimeUnit rateUnit,
-                            TimeUnit durationUnit,
-                            MetricFilter filter,
-                            ScheduledExecutorService executor,
-                            boolean shutdownExecutorOnStop,
-                            Set<MetricAttribute> disabledMetricAttributes) {
-        super(registry, "console-reporter", filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop, disabledMetricAttributes);
-        this.output = output;
-        this.locale = locale;
-        this.clock = clock;
-        this.dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT,
-                DateFormat.MEDIUM,
-                locale);
-        dateFormat.setTimeZone(timeZone);
+    /**
+     * Write to the given {@link PrintStream}.
+     *
+     * @param output a {@link PrintStream} instance.
+     * @return {@code this}
+     */
+    public Builder outputTo(PrintStream output) {
+      this.output = output;
+      return this;
     }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void report(SortedMap<MetricName, Gauge<?>> gauges,
-                       SortedMap<MetricName, Counter> counters,
-                       SortedMap<MetricName, Histogram> histograms,
-                       SortedMap<MetricName, Meter> meters,
-                       SortedMap<MetricName, Timer> timers) {
-        final String dateTime = dateFormat.format(new Date(clock.getTime()));
-        printWithBanner(dateTime, '=');
-        output.println();
-
-        if (!gauges.isEmpty()) {
-            printWithBanner("-- Gauges", '-');
-            for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
-                output.println(entry.getKey());
-                printGauge(entry.getValue());
-            }
-            output.println();
-        }
-
-        if (!counters.isEmpty()) {
-            printWithBanner("-- Counters", '-');
-            for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
-                output.println(entry.getKey());
-                printCounter(entry);
-            }
-            output.println();
-        }
-
-        if (!histograms.isEmpty()) {
-            printWithBanner("-- Histograms", '-');
-            for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
-                output.println(entry.getKey());
-                printHistogram(entry.getValue());
-            }
-            output.println();
-        }
-
-        if (!meters.isEmpty()) {
-            printWithBanner("-- Meters", '-');
-            for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
-                output.println(entry.getKey());
-                printMeter(entry.getValue());
-            }
-            output.println();
-        }
-
-        if (!timers.isEmpty()) {
-            printWithBanner("-- Timers", '-');
-            for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
-                output.println(entry.getKey());
-                printTimer(entry.getValue());
-            }
-            output.println();
-        }
-
-        output.println();
-        output.flush();
+    /**
+     * Format numbers for the given {@link Locale}.
+     *
+     * @param locale a {@link Locale}
+     * @return {@code this}
+     */
+    public Builder formattedFor(Locale locale) {
+      this.locale = locale;
+      return this;
     }
 
-    private void printMeter(Meter meter) {
-        printIfEnabled(MetricAttribute.COUNT, String.format(locale, "             count = %d", meter.getCount()));
-        printIfEnabled(MetricAttribute.SUM, String.format(locale, "               sum = %d", meter.getSum()));
-        printIfEnabled(MetricAttribute.MEAN_RATE, String.format(locale, "         mean rate = %2.2f events/%s", convertRate(meter.getMeanRate()), getRateUnit()));
-        printIfEnabled(MetricAttribute.M1_RATE, String.format(locale, "     1-minute rate = %2.2f events/%s", convertRate(meter.getOneMinuteRate()), getRateUnit()));
-        printIfEnabled(MetricAttribute.M5_RATE, String.format(locale, "     5-minute rate = %2.2f events/%s", convertRate(meter.getFiveMinuteRate()), getRateUnit()));
-        printIfEnabled(MetricAttribute.M15_RATE, String.format(locale, "    15-minute rate = %2.2f events/%s", convertRate(meter.getFifteenMinuteRate()), getRateUnit()));
+    /**
+     * Use the given {@link Clock} instance for the time.
+     *
+     * @param clock a {@link Clock} instance
+     * @return {@code this}
+     */
+    public Builder withClock(Clock clock) {
+      this.clock = clock;
+      return this;
     }
 
-    private void printCounter(Map.Entry<MetricName, Counter> entry) {
-        output.printf(locale, "             count = %d%n", entry.getValue().getCount());
+    /**
+     * Use the given {@link TimeZone} for the time.
+     *
+     * @param timeZone a {@link TimeZone}
+     * @return {@code this}
+     */
+    public Builder formattedFor(TimeZone timeZone) {
+      this.timeZone = timeZone;
+      return this;
     }
 
-    private void printGauge(Gauge<?> gauge) {
-        output.printf(locale, "             value = %s%n", gauge.getValue());
+    /**
+     * Convert rates to the given time unit.
+     *
+     * @param rateUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertRatesTo(TimeUnit rateUnit) {
+      this.rateUnit = rateUnit;
+      return this;
     }
 
-    private void printHistogram(Histogram histogram) {
-        printIfEnabled(MetricAttribute.COUNT, String.format(locale, "             count = %d", histogram.getCount()));
-        printIfEnabled(MetricAttribute.SUM, String.format(locale, "               sum = %d", histogram.getSum()));
-        Snapshot snapshot = histogram.getSnapshot();
-        printIfEnabled(MetricAttribute.MIN, String.format(locale, "               min = %d", snapshot.getMin()));
-        printIfEnabled(MetricAttribute.MAX, String.format(locale, "               max = %d", snapshot.getMax()));
-        printIfEnabled(MetricAttribute.MEAN, String.format(locale, "              mean = %2.2f", snapshot.getMean()));
-        printIfEnabled(MetricAttribute.STDDEV, String.format(locale, "            stddev = %2.2f", snapshot.getStdDev()));
-        printIfEnabled(MetricAttribute.P50, String.format(locale, "            median = %2.2f", snapshot.getMedian()));
-        printIfEnabled(MetricAttribute.P75, String.format(locale, "              75%% <= %2.2f", snapshot.get75thPercentile()));
-        printIfEnabled(MetricAttribute.P95, String.format(locale, "              95%% <= %2.2f", snapshot.get95thPercentile()));
-        printIfEnabled(MetricAttribute.P98, String.format(locale, "              98%% <= %2.2f", snapshot.get98thPercentile()));
-        printIfEnabled(MetricAttribute.P99, String.format(locale, "              99%% <= %2.2f", snapshot.get99thPercentile()));
-        printIfEnabled(MetricAttribute.P999, String.format(locale, "            99.9%% <= %2.2f", snapshot.get999thPercentile()));
+    /**
+     * Convert durations to the given time unit.
+     *
+     * @param durationUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertDurationsTo(TimeUnit durationUnit) {
+      this.durationUnit = durationUnit;
+      return this;
     }
 
-    private void printTimer(Timer timer) {
-        final Snapshot snapshot = timer.getSnapshot();
-        printIfEnabled(MetricAttribute.COUNT, String.format(locale, "             count = %d", timer.getCount()));
-        printIfEnabled(MetricAttribute.SUM, String.format(locale, "               sum = %2.2f", convertDuration(timer.getSum())));
-        printIfEnabled(MetricAttribute.MEAN_RATE, String.format(locale, "         mean rate = %2.2f calls/%s", convertRate(timer.getMeanRate()), getRateUnit()));
-        printIfEnabled(MetricAttribute.M1_RATE, String.format(locale, "     1-minute rate = %2.2f calls/%s", convertRate(timer.getOneMinuteRate()), getRateUnit()));
-        printIfEnabled(MetricAttribute.M5_RATE, String.format(locale, "     5-minute rate = %2.2f calls/%s", convertRate(timer.getFiveMinuteRate()), getRateUnit()));
-        printIfEnabled(MetricAttribute.M15_RATE, String.format(locale, "    15-minute rate = %2.2f calls/%s", convertRate(timer.getFifteenMinuteRate()), getRateUnit()));
-
-        printIfEnabled(MetricAttribute.MIN, String.format(locale, "               min = %2.2f %s", convertDuration(snapshot.getMin()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.MAX, String.format(locale, "               max = %2.2f %s", convertDuration(snapshot.getMax()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.MEAN, String.format(locale, "              mean = %2.2f %s", convertDuration(snapshot.getMean()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.STDDEV, String.format(locale, "            stddev = %2.2f %s", convertDuration(snapshot.getStdDev()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.P50, String.format(locale, "            median = %2.2f %s", convertDuration(snapshot.getMedian()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.P75, String.format(locale, "              75%% <= %2.2f %s", convertDuration(snapshot.get75thPercentile()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.P95, String.format(locale, "              95%% <= %2.2f %s", convertDuration(snapshot.get95thPercentile()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.P98, String.format(locale, "              98%% <= %2.2f %s", convertDuration(snapshot.get98thPercentile()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.P99, String.format(locale, "              99%% <= %2.2f %s", convertDuration(snapshot.get99thPercentile()), getDurationUnit()));
-        printIfEnabled(MetricAttribute.P999, String.format(locale, "            99.9%% <= %2.2f %s", convertDuration(snapshot.get999thPercentile()), getDurationUnit()));
+    /**
+     * Only report metrics which match the given filter.
+     *
+     * @param filter a {@link MetricFilter}
+     * @return {@code this}
+     */
+    public Builder filter(MetricFilter filter) {
+      this.filter = filter;
+      return this;
     }
 
-    private void printWithBanner(String s, char c) {
-        output.print(s);
-        output.print(' ');
-        for (int i = 0; i < (CONSOLE_WIDTH - s.length() - 1); i++) {
-            output.print(c);
-        }
-        output.println();
+    /**
+     * Don't report the passed metric attributes for all metrics (e.g. "p999", "stddev" or "m15").
+     * See {@link MetricAttribute}.
+     *
+     * @param disabledMetricAttributes a {@link MetricFilter}
+     * @return {@code this}
+     */
+    public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
+      this.disabledMetricAttributes = disabledMetricAttributes;
+      return this;
     }
 
     /**
-     * Print only if the attribute is enabled
+     * Builds a {@link ConsoleReporter} with the given properties.
      *
-     * @param type   Metric attribute
-     * @param status Status to be logged
+     * @return a {@link ConsoleReporter}
      */
-    private void printIfEnabled(MetricAttribute type, String status) {
-        if (getDisabledMetricAttributes().contains(type)) {
-            return;
-        }
+    public ConsoleReporter build() {
+      return new ConsoleReporter(
+          registry,
+          output,
+          locale,
+          clock,
+          timeZone,
+          rateUnit,
+          durationUnit,
+          filter,
+          executor,
+          shutdownExecutorOnStop,
+          disabledMetricAttributes);
+    }
+  }
+
+  private static final int CONSOLE_WIDTH = 80;
+
+  private final PrintStream output;
+  private final Locale locale;
+  private final Clock clock;
+  private final DateFormat dateFormat;
+
+  private ConsoleReporter(
+      MetricRegistry registry,
+      PrintStream output,
+      Locale locale,
+      Clock clock,
+      TimeZone timeZone,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      MetricFilter filter,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes) {
+    super(
+        registry,
+        "console-reporter",
+        filter,
+        rateUnit,
+        durationUnit,
+        executor,
+        shutdownExecutorOnStop,
+        disabledMetricAttributes);
+    this.output = output;
+    this.locale = locale;
+    this.clock = clock;
+    this.dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, locale);
+    dateFormat.setTimeZone(timeZone);
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report(
+      SortedMap<MetricName, Gauge<?>> gauges,
+      SortedMap<MetricName, Counter> counters,
+      SortedMap<MetricName, Histogram> histograms,
+      SortedMap<MetricName, Meter> meters,
+      SortedMap<MetricName, Timer> timers) {
+    final String dateTime = dateFormat.format(new Date(clock.getTime()));
+    printWithBanner(dateTime, '=');
+    output.println();
+
+    if (!gauges.isEmpty()) {
+      printWithBanner("-- Gauges", '-');
+      for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
+        output.println(entry.getKey());
+        printGauge(entry.getValue());
+      }
+      output.println();
+    }
 
-        output.println(status);
+    if (!counters.isEmpty()) {
+      printWithBanner("-- Counters", '-');
+      for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
+        output.println(entry.getKey());
+        printCounter(entry);
+      }
+      output.println();
     }
+
+    if (!histograms.isEmpty()) {
+      printWithBanner("-- Histograms", '-');
+      for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
+        output.println(entry.getKey());
+        printHistogram(entry.getValue());
+      }
+      output.println();
+    }
+
+    if (!meters.isEmpty()) {
+      printWithBanner("-- Meters", '-');
+      for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
+        output.println(entry.getKey());
+        printMeter(entry.getValue());
+      }
+      output.println();
+    }
+
+    if (!timers.isEmpty()) {
+      printWithBanner("-- Timers", '-');
+      for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
+        output.println(entry.getKey());
+        printTimer(entry.getValue());
+      }
+      output.println();
+    }
+
+    output.println();
+    output.flush();
+  }
+
+  private void printMeter(Meter meter) {
+    printIfEnabled(
+        MetricAttribute.COUNT, String.format(locale, "             count = %d", meter.getCount()));
+    printIfEnabled(
+        MetricAttribute.SUM, String.format(locale, "               sum = %d", meter.getSum()));
+    printIfEnabled(
+        MetricAttribute.MEAN_RATE,
+        String.format(
+            locale,
+            "         mean rate = %2.2f events/%s",
+            convertRate(meter.getMeanRate()),
+            getRateUnit()));
+    printIfEnabled(
+        MetricAttribute.M1_RATE,
+        String.format(
+            locale,
+            "     1-minute rate = %2.2f events/%s",
+            convertRate(meter.getOneMinuteRate()),
+            getRateUnit()));
+    printIfEnabled(
+        MetricAttribute.M5_RATE,
+        String.format(
+            locale,
+            "     5-minute rate = %2.2f events/%s",
+            convertRate(meter.getFiveMinuteRate()),
+            getRateUnit()));
+    printIfEnabled(
+        MetricAttribute.M15_RATE,
+        String.format(
+            locale,
+            "    15-minute rate = %2.2f events/%s",
+            convertRate(meter.getFifteenMinuteRate()),
+            getRateUnit()));
+  }
+
+  private void printCounter(Map.Entry<MetricName, Counter> entry) {
+    output.printf(locale, "             count = %d%n", entry.getValue().getCount());
+  }
+
+  private void printGauge(Gauge<?> gauge) {
+    output.printf(locale, "             value = %s%n", gauge.getValue());
+  }
+
+  private void printHistogram(Histogram histogram) {
+    printIfEnabled(
+        MetricAttribute.COUNT,
+        String.format(locale, "             count = %d", histogram.getCount()));
+    printIfEnabled(
+        MetricAttribute.SUM, String.format(locale, "               sum = %d", histogram.getSum()));
+    Snapshot snapshot = histogram.getSnapshot();
+    printIfEnabled(
+        MetricAttribute.MIN, String.format(locale, "               min = %d", snapshot.getMin()));
+    printIfEnabled(
+        MetricAttribute.MAX, String.format(locale, "               max = %d", snapshot.getMax()));
+    printIfEnabled(
+        MetricAttribute.MEAN,
+        String.format(locale, "              mean = %2.2f", snapshot.getMean()));
+    printIfEnabled(
+        MetricAttribute.STDDEV,
+        String.format(locale, "            stddev = %2.2f", snapshot.getStdDev()));
+    printIfEnabled(
+        MetricAttribute.P50,
+        String.format(locale, "            median = %2.2f", snapshot.getMedian()));
+    printIfEnabled(
+        MetricAttribute.P75,
+        String.format(locale, "              75%% <= %2.2f", snapshot.get75thPercentile()));
+    printIfEnabled(
+        MetricAttribute.P95,
+        String.format(locale, "              95%% <= %2.2f", snapshot.get95thPercentile()));
+    printIfEnabled(
+        MetricAttribute.P98,
+        String.format(locale, "              98%% <= %2.2f", snapshot.get98thPercentile()));
+    printIfEnabled(
+        MetricAttribute.P99,
+        String.format(locale, "              99%% <= %2.2f", snapshot.get99thPercentile()));
+    printIfEnabled(
+        MetricAttribute.P999,
+        String.format(locale, "            99.9%% <= %2.2f", snapshot.get999thPercentile()));
+  }
+
+  private void printTimer(Timer timer) {
+    final Snapshot snapshot = timer.getSnapshot();
+    printIfEnabled(
+        MetricAttribute.COUNT, String.format(locale, "             count = %d", timer.getCount()));
+    printIfEnabled(
+        MetricAttribute.SUM,
+        String.format(locale, "               sum = %2.2f", convertDuration(timer.getSum())));
+    printIfEnabled(
+        MetricAttribute.MEAN_RATE,
+        String.format(
+            locale,
+            "         mean rate = %2.2f calls/%s",
+            convertRate(timer.getMeanRate()),
+            getRateUnit()));
+    printIfEnabled(
+        MetricAttribute.M1_RATE,
+        String.format(
+            locale,
+            "     1-minute rate = %2.2f calls/%s",
+            convertRate(timer.getOneMinuteRate()),
+            getRateUnit()));
+    printIfEnabled(
+        MetricAttribute.M5_RATE,
+        String.format(
+            locale,
+            "     5-minute rate = %2.2f calls/%s",
+            convertRate(timer.getFiveMinuteRate()),
+            getRateUnit()));
+    printIfEnabled(
+        MetricAttribute.M15_RATE,
+        String.format(
+            locale,
+            "    15-minute rate = %2.2f calls/%s",
+            convertRate(timer.getFifteenMinuteRate()),
+            getRateUnit()));
+
+    printIfEnabled(
+        MetricAttribute.MIN,
+        String.format(
+            locale,
+            "               min = %2.2f %s",
+            convertDuration(snapshot.getMin()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.MAX,
+        String.format(
+            locale,
+            "               max = %2.2f %s",
+            convertDuration(snapshot.getMax()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.MEAN,
+        String.format(
+            locale,
+            "              mean = %2.2f %s",
+            convertDuration(snapshot.getMean()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.STDDEV,
+        String.format(
+            locale,
+            "            stddev = %2.2f %s",
+            convertDuration(snapshot.getStdDev()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.P50,
+        String.format(
+            locale,
+            "            median = %2.2f %s",
+            convertDuration(snapshot.getMedian()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.P75,
+        String.format(
+            locale,
+            "              75%% <= %2.2f %s",
+            convertDuration(snapshot.get75thPercentile()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.P95,
+        String.format(
+            locale,
+            "              95%% <= %2.2f %s",
+            convertDuration(snapshot.get95thPercentile()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.P98,
+        String.format(
+            locale,
+            "              98%% <= %2.2f %s",
+            convertDuration(snapshot.get98thPercentile()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.P99,
+        String.format(
+            locale,
+            "              99%% <= %2.2f %s",
+            convertDuration(snapshot.get99thPercentile()),
+            getDurationUnit()));
+    printIfEnabled(
+        MetricAttribute.P999,
+        String.format(
+            locale,
+            "            99.9%% <= %2.2f %s",
+            convertDuration(snapshot.get999thPercentile()),
+            getDurationUnit()));
+  }
+
+  private void printWithBanner(String s, char c) {
+    output.print(s);
+    output.print(' ');
+    for (int i = 0; i < (CONSOLE_WIDTH - s.length() - 1); i++) {
+      output.print(c);
+    }
+    output.println();
+  }
+
+  /**
+   * Print only if the attribute is enabled
+   *
+   * @param type Metric attribute
+   * @param status Status to be logged
+   */
+  private void printIfEnabled(MetricAttribute type, String status) {
+    if (getDisabledMetricAttributes().contains(type)) {
+      return;
+    }
+
+    output.println(status);
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Counter.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Counter.java
@@ -2,55 +2,49 @@ package io.dropwizard.metrics5;
 
 import java.util.concurrent.atomic.LongAdder;
 
-/**
- * An incrementing and decrementing counter metric.
- */
+/** An incrementing and decrementing counter metric. */
 public class Counter implements Metric, Counting {
-    private final LongAdder count;
-
-    public Counter() {
-        this.count = new LongAdder();
-    }
-
-    /**
-     * Increment the counter by one.
-     */
-    public void inc() {
-        inc(1);
-    }
-
-    /**
-     * Increment the counter by {@code n}.
-     *
-     * @param n the amount by which the counter will be increased
-     */
-    public void inc(long n) {
-        count.add(n);
-    }
-
-    /**
-     * Decrement the counter by one.
-     */
-    public void dec() {
-        dec(1);
-    }
-
-    /**
-     * Decrement the counter by {@code n}.
-     *
-     * @param n the amount by which the counter will be decreased
-     */
-    public void dec(long n) {
-        count.add(-n);
-    }
-
-    /**
-     * Returns the counter's current value.
-     *
-     * @return the counter's current value
-     */
-    @Override
-    public long getCount() {
-        return count.sum();
-    }
+  private final LongAdder count;
+
+  public Counter() {
+    this.count = new LongAdder();
+  }
+
+  /** Increment the counter by one. */
+  public void inc() {
+    inc(1);
+  }
+
+  /**
+   * Increment the counter by {@code n}.
+   *
+   * @param n the amount by which the counter will be increased
+   */
+  public void inc(long n) {
+    count.add(n);
+  }
+
+  /** Decrement the counter by one. */
+  public void dec() {
+    dec(1);
+  }
+
+  /**
+   * Decrement the counter by {@code n}.
+   *
+   * @param n the amount by which the counter will be decreased
+   */
+  public void dec(long n) {
+    count.add(-n);
+  }
+
+  /**
+   * Returns the counter's current value.
+   *
+   * @return the counter's current value
+   */
+  @Override
+  public long getCount() {
+    return count.sum();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Counting.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Counting.java
@@ -1,13 +1,11 @@
 package io.dropwizard.metrics5;
 
-/**
- * An interface for metric types which have counts.
- */
+/** An interface for metric types which have counts. */
 public interface Counting {
-    /**
-     * Returns the current count.
-     *
-     * @return the current count
-     */
-    long getCount();
+  /**
+   * Returns the current count.
+   *
+   * @return the current count
+   */
+  long getCount();
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/CsvFileProvider.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/CsvFileProvider.java
@@ -3,10 +3,10 @@ package io.dropwizard.metrics5;
 import java.io.File;
 
 /**
- * This interface allows a pluggable implementation of what file names
- * the {@link CsvReporter} will write to.
+ * This interface allows a pluggable implementation of what file names the {@link CsvReporter} will
+ * write to.
  */
 public interface CsvFileProvider {
 
-    File getFile(File directory, String metricName);
+  File getFile(File directory, String metricName);
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/CsvReporter.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/CsvReporter.java
@@ -1,7 +1,6 @@
 package io.dropwizard.metrics5;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -13,335 +12,390 @@ import java.util.Map;
 import java.util.SortedMap;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/**
- * A reporter which creates a comma-separated values file of the measurements for each metric.
- */
+/** A reporter which creates a comma-separated values file of the measurements for each metric. */
 public class CsvReporter extends ScheduledReporter {
-    private static final String DEFAULT_SEPARATOR = ",";
+  private static final String DEFAULT_SEPARATOR = ",";
+
+  /**
+   * Returns a new {@link Builder} for {@link CsvReporter}.
+   *
+   * @param registry the registry to report
+   * @return a {@link Builder} instance for a {@link CsvReporter}
+   */
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
+
+  /**
+   * A builder for {@link CsvReporter} instances. Defaults to using the default locale, converting
+   * rates to events/second, converting durations to milliseconds, and not filtering metrics.
+   */
+  public static class Builder {
+    private final MetricRegistry registry;
+    private Locale locale;
+    private String separator;
+    private TimeUnit rateUnit;
+    private TimeUnit durationUnit;
+    private Clock clock;
+    private MetricFilter filter;
+    private ScheduledExecutorService executor;
+    private boolean shutdownExecutorOnStop;
+    private CsvFileProvider csvFileProvider;
+
+    private Builder(MetricRegistry registry) {
+      this.registry = registry;
+      this.locale = Locale.getDefault();
+      this.separator = DEFAULT_SEPARATOR;
+      this.rateUnit = TimeUnit.SECONDS;
+      this.durationUnit = TimeUnit.MILLISECONDS;
+      this.clock = Clock.defaultClock();
+      this.filter = MetricFilter.ALL;
+      this.executor = null;
+      this.shutdownExecutorOnStop = true;
+      this.csvFileProvider = new FixedNameCsvFileProvider();
+    }
 
     /**
-     * Returns a new {@link Builder} for {@link CsvReporter}.
+     * Specifies whether or not, the executor (used for reporting) will be stopped with same time
+     * with reporter. Default value is true. Setting this parameter to false, has the sense in
+     * combining with providing external managed executor via {@link
+     * #scheduleOn(ScheduledExecutorService)}.
      *
-     * @param registry the registry to report
-     * @return a {@link Builder} instance for a {@link CsvReporter}
+     * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+     *     reporter
+     * @return {@code this}
      */
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
+    public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      this.shutdownExecutorOnStop = shutdownExecutorOnStop;
+      return this;
     }
 
     /**
-     * A builder for {@link CsvReporter} instances. Defaults to using the default locale, converting
-     * rates to events/second, converting durations to milliseconds, and not filtering metrics.
+     * Specifies the executor to use while scheduling reporting of metrics. Default value is null.
+     * Null value leads to executor will be auto created on start.
+     *
+     * @param executor the executor to use while scheduling reporting of metrics.
+     * @return {@code this}
      */
-    public static class Builder {
-        private final MetricRegistry registry;
-        private Locale locale;
-        private String separator;
-        private TimeUnit rateUnit;
-        private TimeUnit durationUnit;
-        private Clock clock;
-        private MetricFilter filter;
-        private ScheduledExecutorService executor;
-        private boolean shutdownExecutorOnStop;
-        private CsvFileProvider csvFileProvider;
-
-        private Builder(MetricRegistry registry) {
-            this.registry = registry;
-            this.locale = Locale.getDefault();
-            this.separator = DEFAULT_SEPARATOR;
-            this.rateUnit = TimeUnit.SECONDS;
-            this.durationUnit = TimeUnit.MILLISECONDS;
-            this.clock = Clock.defaultClock();
-            this.filter = MetricFilter.ALL;
-            this.executor = null;
-            this.shutdownExecutorOnStop = true;
-            this.csvFileProvider = new FixedNameCsvFileProvider();
-        }
-
-        /**
-         * Specifies whether or not, the executor (used for reporting) will be stopped with same time with reporter.
-         * Default value is true.
-         * Setting this parameter to false, has the sense in combining with providing external managed executor via {@link #scheduleOn(ScheduledExecutorService)}.
-         *
-         * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this reporter
-         * @return {@code this}
-         */
-        public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            this.shutdownExecutorOnStop = shutdownExecutorOnStop;
-            return this;
-        }
-
-        /**
-         * Specifies the executor to use while scheduling reporting of metrics.
-         * Default value is null.
-         * Null value leads to executor will be auto created on start.
-         *
-         * @param executor the executor to use while scheduling reporting of metrics.
-         * @return {@code this}
-         */
-        public Builder scheduleOn(ScheduledExecutorService executor) {
-            this.executor = executor;
-            return this;
-        }
-
-        /**
-         * Format numbers for the given {@link Locale}.
-         *
-         * @param locale a {@link Locale}
-         * @return {@code this}
-         */
-        public Builder formatFor(Locale locale) {
-            this.locale = locale;
-            return this;
-        }
-
-        /**
-         * Convert rates to the given time unit.
-         *
-         * @param rateUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertRatesTo(TimeUnit rateUnit) {
-            this.rateUnit = rateUnit;
-            return this;
-        }
-
-        /**
-         * Convert durations to the given time unit.
-         *
-         * @param durationUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertDurationsTo(TimeUnit durationUnit) {
-            this.durationUnit = durationUnit;
-            return this;
-        }
-
-        /**
-         * Use the given string to use as the separator for values.
-         *
-         * @param separator the string to use for the separator.
-         * @return {@code this}
-         */
-        public Builder withSeparator(String separator) {
-            this.separator = separator;
-            return this;
-        }
-
-        /**
-         * Use the given {@link Clock} instance for the time.
-         *
-         * @param clock a {@link Clock} instance
-         * @return {@code this}
-         */
-        public Builder withClock(Clock clock) {
-            this.clock = clock;
-            return this;
-        }
-
-        /**
-         * Only report metrics which match the given filter.
-         *
-         * @param filter a {@link MetricFilter}
-         * @return {@code this}
-         */
-        public Builder filter(MetricFilter filter) {
-            this.filter = filter;
-            return this;
-        }
-
-        public Builder withCsvFileProvider(CsvFileProvider csvFileProvider) {
-            this.csvFileProvider = csvFileProvider;
-            return this;
-        }
-
-        /**
-         * Builds a {@link CsvReporter} with the given properties, writing {@code .csv} files to the
-         * given directory.
-         *
-         * @param directory the directory in which the {@code .csv} files will be created
-         * @return a {@link CsvReporter}
-         */
-        public CsvReporter build(File directory) {
-            return new CsvReporter(registry,
-                    directory,
-                    locale,
-                    separator,
-                    rateUnit,
-                    durationUnit,
-                    clock,
-                    filter,
-                    executor,
-                    shutdownExecutorOnStop,
-                    csvFileProvider);
-        }
+    public Builder scheduleOn(ScheduledExecutorService executor) {
+      this.executor = executor;
+      return this;
     }
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(CsvReporter.class);
-
-    private final File directory;
-    private final Locale locale;
-    private final String separator;
-    private final Clock clock;
-    private final CsvFileProvider csvFileProvider;
-
-    private final String histogramFormat;
-    private final String meterFormat;
-    private final String timerFormat;
-
-    private final String timerHeader;
-    private final String meterHeader;
-    private final String histogramHeader;
-
-    private CsvReporter(MetricRegistry registry,
-                        File directory,
-                        Locale locale,
-                        String separator,
-                        TimeUnit rateUnit,
-                        TimeUnit durationUnit,
-                        Clock clock,
-                        MetricFilter filter,
-                        ScheduledExecutorService executor,
-                        boolean shutdownExecutorOnStop,
-                        CsvFileProvider csvFileProvider) {
-        super(registry, "csv-reporter", filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop);
-        this.directory = directory;
-        this.locale = locale;
-        this.separator = separator;
-        this.clock = clock;
-        this.csvFileProvider = csvFileProvider;
-
-        this.histogramFormat = String.join(separator, "%d", "%d", "%d", "%f", "%d", "%f", "%f", "%f", "%f", "%f", "%f", "%f");
-        this.meterFormat = String.join(separator, "%d", "%d", "%f", "%f", "%f", "%f", "events/%s");
-        this.timerFormat = String.join(separator, "%d", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "%f", "calls/%s", "%s");
-
-        this.timerHeader = String.join(separator, "count", "sum", "max", "mean", "min", "stddev", "p50", "p75", "p95", "p98", "p99", "p999", "mean_rate", "m1_rate", "m5_rate", "m15_rate", "rate_unit", "duration_unit");
-        this.meterHeader = String.join(separator, "count", "sum", "mean_rate", "m1_rate", "m5_rate", "m15_rate", "rate_unit");
-        this.histogramHeader = String.join(separator, "count", "sum", "max", "mean", "min", "stddev", "p50", "p75", "p95", "p98", "p99", "p999");
+    /**
+     * Format numbers for the given {@link Locale}.
+     *
+     * @param locale a {@link Locale}
+     * @return {@code this}
+     */
+    public Builder formatFor(Locale locale) {
+      this.locale = locale;
+      return this;
     }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void report(SortedMap<MetricName, Gauge<?>> gauges,
-                       SortedMap<MetricName, Counter> counters,
-                       SortedMap<MetricName, Histogram> histograms,
-                       SortedMap<MetricName, Meter> meters,
-                       SortedMap<MetricName, Timer> timers) {
-        final long timestamp = TimeUnit.MILLISECONDS.toSeconds(clock.getTime());
-
-        for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
-            reportGauge(timestamp, entry.getKey(), entry.getValue());
-        }
+    /**
+     * Convert rates to the given time unit.
+     *
+     * @param rateUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertRatesTo(TimeUnit rateUnit) {
+      this.rateUnit = rateUnit;
+      return this;
+    }
 
-        for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
-            reportCounter(timestamp, entry.getKey(), entry.getValue());
-        }
+    /**
+     * Convert durations to the given time unit.
+     *
+     * @param durationUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertDurationsTo(TimeUnit durationUnit) {
+      this.durationUnit = durationUnit;
+      return this;
+    }
 
-        for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
-            reportHistogram(timestamp, entry.getKey(), entry.getValue());
-        }
+    /**
+     * Use the given string to use as the separator for values.
+     *
+     * @param separator the string to use for the separator.
+     * @return {@code this}
+     */
+    public Builder withSeparator(String separator) {
+      this.separator = separator;
+      return this;
+    }
 
-        for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
-            reportMeter(timestamp, entry.getKey(), entry.getValue());
-        }
+    /**
+     * Use the given {@link Clock} instance for the time.
+     *
+     * @param clock a {@link Clock} instance
+     * @return {@code this}
+     */
+    public Builder withClock(Clock clock) {
+      this.clock = clock;
+      return this;
+    }
 
-        for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
-            reportTimer(timestamp, entry.getKey(), entry.getValue());
-        }
+    /**
+     * Only report metrics which match the given filter.
+     *
+     * @param filter a {@link MetricFilter}
+     * @return {@code this}
+     */
+    public Builder filter(MetricFilter filter) {
+      this.filter = filter;
+      return this;
     }
 
-    private void reportTimer(long timestamp, MetricName name, Timer timer) {
-        final Snapshot snapshot = timer.getSnapshot();
-
-        report(timestamp,
-                name,
-                timerHeader,
-                timerFormat,
-                timer.getCount(),
-                convertDuration(timer.getSum()),
-                convertDuration(snapshot.getMax()),
-                convertDuration(snapshot.getMean()),
-                convertDuration(snapshot.getMin()),
-                convertDuration(snapshot.getStdDev()),
-                convertDuration(snapshot.getMedian()),
-                convertDuration(snapshot.get75thPercentile()),
-                convertDuration(snapshot.get95thPercentile()),
-                convertDuration(snapshot.get98thPercentile()),
-                convertDuration(snapshot.get99thPercentile()),
-                convertDuration(snapshot.get999thPercentile()),
-                convertRate(timer.getMeanRate()),
-                convertRate(timer.getOneMinuteRate()),
-                convertRate(timer.getFiveMinuteRate()),
-                convertRate(timer.getFifteenMinuteRate()),
-                getRateUnit(),
-                getDurationUnit());
+    public Builder withCsvFileProvider(CsvFileProvider csvFileProvider) {
+      this.csvFileProvider = csvFileProvider;
+      return this;
     }
 
-    private void reportMeter(long timestamp, MetricName name, Meter meter) {
-        report(timestamp,
-                name,
-                meterHeader,
-                meterFormat,
-                meter.getCount(),
-                meter.getSum(),
-                convertRate(meter.getMeanRate()),
-                convertRate(meter.getOneMinuteRate()),
-                convertRate(meter.getFiveMinuteRate()),
-                convertRate(meter.getFifteenMinuteRate()),
-                getRateUnit());
+    /**
+     * Builds a {@link CsvReporter} with the given properties, writing {@code .csv} files to the
+     * given directory.
+     *
+     * @param directory the directory in which the {@code .csv} files will be created
+     * @return a {@link CsvReporter}
+     */
+    public CsvReporter build(File directory) {
+      return new CsvReporter(
+          registry,
+          directory,
+          locale,
+          separator,
+          rateUnit,
+          durationUnit,
+          clock,
+          filter,
+          executor,
+          shutdownExecutorOnStop,
+          csvFileProvider);
+    }
+  }
+
+  private static final Logger LOG = LoggerFactory.getLogger(CsvReporter.class);
+
+  private final File directory;
+  private final Locale locale;
+  private final String separator;
+  private final Clock clock;
+  private final CsvFileProvider csvFileProvider;
+
+  private final String histogramFormat;
+  private final String meterFormat;
+  private final String timerFormat;
+
+  private final String timerHeader;
+  private final String meterHeader;
+  private final String histogramHeader;
+
+  private CsvReporter(
+      MetricRegistry registry,
+      File directory,
+      Locale locale,
+      String separator,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      Clock clock,
+      MetricFilter filter,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      CsvFileProvider csvFileProvider) {
+    super(
+        registry, "csv-reporter", filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop);
+    this.directory = directory;
+    this.locale = locale;
+    this.separator = separator;
+    this.clock = clock;
+    this.csvFileProvider = csvFileProvider;
+
+    this.histogramFormat =
+        String.join(
+            separator, "%d", "%d", "%d", "%f", "%d", "%f", "%f", "%f", "%f", "%f", "%f", "%f");
+    this.meterFormat = String.join(separator, "%d", "%d", "%f", "%f", "%f", "%f", "events/%s");
+    this.timerFormat =
+        String.join(
+            separator,
+            "%d",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "%f",
+            "calls/%s",
+            "%s");
+
+    this.timerHeader =
+        String.join(
+            separator,
+            "count",
+            "sum",
+            "max",
+            "mean",
+            "min",
+            "stddev",
+            "p50",
+            "p75",
+            "p95",
+            "p98",
+            "p99",
+            "p999",
+            "mean_rate",
+            "m1_rate",
+            "m5_rate",
+            "m15_rate",
+            "rate_unit",
+            "duration_unit");
+    this.meterHeader =
+        String.join(
+            separator, "count", "sum", "mean_rate", "m1_rate", "m5_rate", "m15_rate", "rate_unit");
+    this.histogramHeader =
+        String.join(
+            separator, "count", "sum", "max", "mean", "min", "stddev", "p50", "p75", "p95", "p98",
+            "p99", "p999");
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report(
+      SortedMap<MetricName, Gauge<?>> gauges,
+      SortedMap<MetricName, Counter> counters,
+      SortedMap<MetricName, Histogram> histograms,
+      SortedMap<MetricName, Meter> meters,
+      SortedMap<MetricName, Timer> timers) {
+    final long timestamp = TimeUnit.MILLISECONDS.toSeconds(clock.getTime());
+
+    for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
+      reportGauge(timestamp, entry.getKey(), entry.getValue());
     }
 
-    private void reportHistogram(long timestamp, MetricName name, Histogram histogram) {
-        final Snapshot snapshot = histogram.getSnapshot();
-
-        report(timestamp,
-                name,
-                histogramHeader,
-                histogramFormat,
-                histogram.getCount(),
-                histogram.getSum(),
-                snapshot.getMax(),
-                snapshot.getMean(),
-                snapshot.getMin(),
-                snapshot.getStdDev(),
-                snapshot.getMedian(),
-                snapshot.get75thPercentile(),
-                snapshot.get95thPercentile(),
-                snapshot.get98thPercentile(),
-                snapshot.get99thPercentile(),
-                snapshot.get999thPercentile());
+    for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
+      reportCounter(timestamp, entry.getKey(), entry.getValue());
     }
 
-    private void reportCounter(long timestamp, MetricName name, Counter counter) {
-        report(timestamp, name, "count", "%d", counter.getCount());
+    for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
+      reportHistogram(timestamp, entry.getKey(), entry.getValue());
     }
 
-    private void reportGauge(long timestamp, MetricName name, Gauge<?> gauge) {
-        report(timestamp, name, "value", "%s", gauge.getValue());
+    for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
+      reportMeter(timestamp, entry.getKey(), entry.getValue());
     }
 
-    private void report(long timestamp, MetricName name, String header, String line, Object... values) {
-        try {
-            final File file = csvFileProvider.getFile(directory, name.getKey());
-            final boolean fileAlreadyExists = file.exists();
-            if (fileAlreadyExists || file.createNewFile()) {
-                try (PrintWriter out = new PrintWriter(new OutputStreamWriter(
-                        new FileOutputStream(file, true), UTF_8))) {
-                    if (!fileAlreadyExists) {
-                        out.println("t" + separator + header);
-                    }
-                    out.printf(locale, String.format(locale, "%d" + separator + "%s%n", timestamp, line), values);
-                }
-            }
-        } catch (IOException e) {
-            LOGGER.warn("Error writing to {}", name, e);
+    for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
+      reportTimer(timestamp, entry.getKey(), entry.getValue());
+    }
+  }
+
+  private void reportTimer(long timestamp, MetricName name, Timer timer) {
+    final Snapshot snapshot = timer.getSnapshot();
+
+    report(
+        timestamp,
+        name,
+        timerHeader,
+        timerFormat,
+        timer.getCount(),
+        convertDuration(timer.getSum()),
+        convertDuration(snapshot.getMax()),
+        convertDuration(snapshot.getMean()),
+        convertDuration(snapshot.getMin()),
+        convertDuration(snapshot.getStdDev()),
+        convertDuration(snapshot.getMedian()),
+        convertDuration(snapshot.get75thPercentile()),
+        convertDuration(snapshot.get95thPercentile()),
+        convertDuration(snapshot.get98thPercentile()),
+        convertDuration(snapshot.get99thPercentile()),
+        convertDuration(snapshot.get999thPercentile()),
+        convertRate(timer.getMeanRate()),
+        convertRate(timer.getOneMinuteRate()),
+        convertRate(timer.getFiveMinuteRate()),
+        convertRate(timer.getFifteenMinuteRate()),
+        getRateUnit(),
+        getDurationUnit());
+  }
+
+  private void reportMeter(long timestamp, MetricName name, Meter meter) {
+    report(
+        timestamp,
+        name,
+        meterHeader,
+        meterFormat,
+        meter.getCount(),
+        meter.getSum(),
+        convertRate(meter.getMeanRate()),
+        convertRate(meter.getOneMinuteRate()),
+        convertRate(meter.getFiveMinuteRate()),
+        convertRate(meter.getFifteenMinuteRate()),
+        getRateUnit());
+  }
+
+  private void reportHistogram(long timestamp, MetricName name, Histogram histogram) {
+    final Snapshot snapshot = histogram.getSnapshot();
+
+    report(
+        timestamp,
+        name,
+        histogramHeader,
+        histogramFormat,
+        histogram.getCount(),
+        histogram.getSum(),
+        snapshot.getMax(),
+        snapshot.getMean(),
+        snapshot.getMin(),
+        snapshot.getStdDev(),
+        snapshot.getMedian(),
+        snapshot.get75thPercentile(),
+        snapshot.get95thPercentile(),
+        snapshot.get98thPercentile(),
+        snapshot.get99thPercentile(),
+        snapshot.get999thPercentile());
+  }
+
+  private void reportCounter(long timestamp, MetricName name, Counter counter) {
+    report(timestamp, name, "count", "%d", counter.getCount());
+  }
+
+  private void reportGauge(long timestamp, MetricName name, Gauge<?> gauge) {
+    report(timestamp, name, "value", "%s", gauge.getValue());
+  }
+
+  private void report(
+      long timestamp, MetricName name, String header, String line, Object... values) {
+    try {
+      final File file = csvFileProvider.getFile(directory, name.getKey());
+      final boolean fileAlreadyExists = file.exists();
+      if (fileAlreadyExists || file.createNewFile()) {
+        try (PrintWriter out =
+            new PrintWriter(new OutputStreamWriter(new FileOutputStream(file, true), UTF_8))) {
+          if (!fileAlreadyExists) {
+            out.println("t" + separator + header);
+          }
+          out.printf(
+              locale, String.format(locale, "%d" + separator + "%s%n", timestamp, line), values);
         }
+      }
+    } catch (IOException e) {
+      LOG.warn("Error writing to {}", name, e);
     }
+  }
 
-    protected String sanitize(MetricName name) {
-        return name.getKey();
-    }
+  protected String sanitize(MetricName name) {
+    return name.getKey();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/DefaultSettableGauge.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/DefaultSettableGauge.java
@@ -4,40 +4,35 @@ package io.dropwizard.metrics5;
  * Similar to {@link Gauge}, but metric value is updated via calling {@link #setValue(T)} instead.
  */
 public class DefaultSettableGauge<T> implements SettableGauge<T> {
-    private volatile T value;
+  private volatile T value;
 
-    /**
-     * Create an instance with no default value.
-     */
-    public DefaultSettableGauge() {
-        this(null);
-    }
+  /** Create an instance with no default value. */
+  public DefaultSettableGauge() {
+    this(null);
+  }
 
-    /**
-     * Create an instance with a default value.
-     *
-     * @param defaultValue default value
-     */
-    public DefaultSettableGauge(T defaultValue) {
-        this.value = defaultValue;
-    }
+  /**
+   * Create an instance with a default value.
+   *
+   * @param defaultValue default value
+   */
+  public DefaultSettableGauge(T defaultValue) {
+    this.value = defaultValue;
+  }
 
-    /**
-     * Set the metric to a new value.
-     */
-    @Override
-    public void setValue(T value) {
-        this.value = value;
-    }
-
-    /**
-     * Returns the current value.
-     *
-     * @return the current value
-     */
-    @Override
-    public T getValue() {
-        return value;
-    }
+  /** Set the metric to a new value. */
+  @Override
+  public void setValue(T value) {
+    this.value = value;
+  }
 
+  /**
+   * Returns the current value.
+   *
+   * @return the current value
+   */
+  @Override
+  public T getValue() {
+    return value;
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/DerivativeGauge.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/DerivativeGauge.java
@@ -7,27 +7,27 @@ package io.dropwizard.metrics5;
  * @param <T> the derivative type
  */
 public abstract class DerivativeGauge<F, T> implements Gauge<T> {
-    private final Gauge<F> base;
+  private final Gauge<F> base;
 
-    /**
-     * Creates a new derivative with the given base gauge.
-     *
-     * @param base the gauge from which to derive this gauge's value
-     */
-    protected DerivativeGauge(Gauge<F> base) {
-        this.base = base;
-    }
+  /**
+   * Creates a new derivative with the given base gauge.
+   *
+   * @param base the gauge from which to derive this gauge's value
+   */
+  protected DerivativeGauge(Gauge<F> base) {
+    this.base = base;
+  }
 
-    @Override
-    public T getValue() {
-        return transform(base.getValue());
-    }
+  @Override
+  public T getValue() {
+    return transform(base.getValue());
+  }
 
-    /**
-     * Transforms the value of the base gauge to the value of this gauge.
-     *
-     * @param value the value of the base gauge
-     * @return this gauge's value
-     */
-    protected abstract T transform(F value);
+  /**
+   * Transforms the value of the base gauge to the value of this gauge.
+   *
+   * @param value the value of the base gauge
+   * @return this gauge's value
+   */
+  protected abstract T transform(F value);
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/EWMA.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/EWMA.java
@@ -1,116 +1,115 @@
 package io.dropwizard.metrics5;
 
+import static java.lang.Math.exp;
+
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.LongAdder;
 
-import static java.lang.Math.exp;
-
 /**
  * An exponentially-weighted moving average.
  *
  * @see <a href="http://www.teamquest.com/pdfs/whitepaper/ldavg1.pdf">UNIX Load Average Part 1: How
- * It Works</a>
+ *     It Works</a>
  * @see <a href="http://www.teamquest.com/pdfs/whitepaper/ldavg2.pdf">UNIX Load Average Part 2: Not
- * Your Average Average</a>
+ *     Your Average Average</a>
  * @see <a href="http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average">EMA</a>
  */
 public class EWMA {
-    private static final int INTERVAL = 5;
-    private static final double SECONDS_PER_MINUTE = 60.0;
-    private static final int ONE_MINUTE = 1;
-    private static final int FIVE_MINUTES = 5;
-    private static final int FIFTEEN_MINUTES = 15;
-    private static final double M1_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / ONE_MINUTE);
-    private static final double M5_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / FIVE_MINUTES);
-    private static final double M15_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / FIFTEEN_MINUTES);
+  private static final int INTERVAL = 5;
+  private static final double SECONDS_PER_MINUTE = 60.0;
+  private static final int ONE_MINUTE = 1;
+  private static final int FIVE_MINUTES = 5;
+  private static final int FIFTEEN_MINUTES = 15;
+  private static final double M1_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / ONE_MINUTE);
+  private static final double M5_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / FIVE_MINUTES);
+  private static final double M15_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / FIFTEEN_MINUTES);
 
-    private volatile boolean initialized = false;
-    private volatile double rate = 0.0;
+  private volatile boolean initialized = false;
+  private volatile double rate = 0.0;
 
-    private final LongAdder uncounted = new LongAdder();
-    private final double alpha, interval;
+  private final LongAdder uncounted = new LongAdder();
+  private final double alpha, interval;
 
-    /**
-     * Creates a new EWMA which is equivalent to the UNIX one minute load average and which expects
-     * to be ticked every 5 seconds.
-     *
-     * @return a one-minute EWMA
-     */
-    public static EWMA oneMinuteEWMA() {
-        return new EWMA(M1_ALPHA, INTERVAL, TimeUnit.SECONDS);
-    }
+  /**
+   * Creates a new EWMA which is equivalent to the UNIX one minute load average and which expects to
+   * be ticked every 5 seconds.
+   *
+   * @return a one-minute EWMA
+   */
+  public static EWMA oneMinuteEWMA() {
+    return new EWMA(M1_ALPHA, INTERVAL, TimeUnit.SECONDS);
+  }
 
-    /**
-     * Creates a new EWMA which is equivalent to the UNIX five minute load average and which expects
-     * to be ticked every 5 seconds.
-     *
-     * @return a five-minute EWMA
-     */
-    public static EWMA fiveMinuteEWMA() {
-        return new EWMA(M5_ALPHA, INTERVAL, TimeUnit.SECONDS);
-    }
+  /**
+   * Creates a new EWMA which is equivalent to the UNIX five minute load average and which expects
+   * to be ticked every 5 seconds.
+   *
+   * @return a five-minute EWMA
+   */
+  public static EWMA fiveMinuteEWMA() {
+    return new EWMA(M5_ALPHA, INTERVAL, TimeUnit.SECONDS);
+  }
 
-    /**
-     * Creates a new EWMA which is equivalent to the UNIX fifteen minute load average and which
-     * expects to be ticked every 5 seconds.
-     *
-     * @return a fifteen-minute EWMA
-     */
-    public static EWMA fifteenMinuteEWMA() {
-        return new EWMA(M15_ALPHA, INTERVAL, TimeUnit.SECONDS);
-    }
+  /**
+   * Creates a new EWMA which is equivalent to the UNIX fifteen minute load average and which
+   * expects to be ticked every 5 seconds.
+   *
+   * @return a fifteen-minute EWMA
+   */
+  public static EWMA fifteenMinuteEWMA() {
+    return new EWMA(M15_ALPHA, INTERVAL, TimeUnit.SECONDS);
+  }
 
-    /**
-     * Create a new EWMA with a specific smoothing constant.
-     *
-     * @param alpha        the smoothing constant
-     * @param interval     the expected tick interval
-     * @param intervalUnit the time unit of the tick interval
-     */
-    public EWMA(double alpha, long interval, TimeUnit intervalUnit) {
-        this.interval = intervalUnit.toNanos(interval);
-        this.alpha = alpha;
-    }
+  /**
+   * Create a new EWMA with a specific smoothing constant.
+   *
+   * @param alpha the smoothing constant
+   * @param interval the expected tick interval
+   * @param intervalUnit the time unit of the tick interval
+   */
+  public EWMA(double alpha, long interval, TimeUnit intervalUnit) {
+    this.interval = intervalUnit.toNanos(interval);
+    this.alpha = alpha;
+  }
 
-    /**
-     * Update the moving average with a new value.
-     *
-     * @param n the new value
-     */
-    public void update(long n) {
-        uncounted.add(n);
-    }
+  /**
+   * Update the moving average with a new value.
+   *
+   * @param n the new value
+   */
+  public void update(long n) {
+    uncounted.add(n);
+  }
 
-    /**
-     * Set the rate to the smallest possible positive value. Used to avoid calling tick a large number of times.
-     */
-    public void reset() {
-        uncounted.reset();
-        rate = Double.MIN_NORMAL;
-    }
+  /**
+   * Set the rate to the smallest possible positive value. Used to avoid calling tick a large number
+   * of times.
+   */
+  public void reset() {
+    uncounted.reset();
+    rate = Double.MIN_NORMAL;
+  }
 
-    /**
-     * Mark the passage of time and decay the current rate accordingly.
-     */
-    public void tick() {
-        final long count = uncounted.sumThenReset();
-        final double instantRate = count / interval;
-        if (initialized) {
-            final double oldRate = this.rate;
-            rate = oldRate + (alpha * (instantRate - oldRate));
-        } else {
-            rate = instantRate;
-            initialized = true;
-        }
+  /** Mark the passage of time and decay the current rate accordingly. */
+  public void tick() {
+    final long count = uncounted.sumThenReset();
+    final double instantRate = count / interval;
+    if (initialized) {
+      final double oldRate = this.rate;
+      rate = oldRate + (alpha * (instantRate - oldRate));
+    } else {
+      rate = instantRate;
+      initialized = true;
     }
+  }
 
-    /**
-     * Returns the rate in the given units of time.
-     *
-     * @param rateUnit the unit of time
-     * @return the rate
-     */
-    public double getRate(TimeUnit rateUnit) {
-        return rate * (double) rateUnit.toNanos(1);
-    }
+  /**
+   * Returns the rate in the given units of time.
+   *
+   * @param rateUnit the unit of time
+   * @return the rate
+   */
+  public double getRate(TimeUnit rateUnit) {
+    return rate * (double) rateUnit.toNanos(1);
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/ExponentialMovingAverages.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/ExponentialMovingAverages.java
@@ -5,110 +5,102 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.LongAdder;
 
 /**
- * A triple (one, five and fifteen minutes) of exponentially-weighted moving average rates as needed by {@link Meter}.
- * <p>
- * The rates have the same exponential decay factor as the fifteen-minute load average in the
+ * A triple (one, five and fifteen minutes) of exponentially-weighted moving average rates as needed
+ * by {@link Meter}.
+ *
+ * <p>The rates have the same exponential decay factor as the fifteen-minute load average in the
  * {@code top} Unix command.
  */
 public class ExponentialMovingAverages implements MovingAverages {
 
-    /**
-     * If ticking would reduce even Long.MAX_VALUE in the 15 minute EWMA below this target then don't bother
-     * ticking in a loop and instead reset all the EWMAs.
-     */
-    private static final double maxTickZeroTarget = 0.0001;
-    private static final int maxTicks;
-    private static final long TICK_INTERVAL = TimeUnit.SECONDS.toNanos(5);
+  /**
+   * If ticking would reduce even Long.MAX_VALUE in the 15 minute EWMA below this target then don't
+   * bother ticking in a loop and instead reset all the EWMAs.
+   */
+  private static final double MAX_TICK_ZERO_TARGET = 0.0001;
 
-    static
-    {
-        int m3Ticks = 1;
-        final EWMA m3 = EWMA.fifteenMinuteEWMA();
-        m3.update(Long.MAX_VALUE);
-        do
-        {
-            m3.tick();
-            m3Ticks++;
-        }
-        while (m3.getRate(TimeUnit.SECONDS) > maxTickZeroTarget);
-        maxTicks = m3Ticks;
-    }
+  private static final int MAX_TICKS;
+  private static final long TICK_INTERVAL = TimeUnit.SECONDS.toNanos(5);
 
-    private final EWMA m1Rate = EWMA.oneMinuteEWMA();
-    private final EWMA m5Rate = EWMA.fiveMinuteEWMA();
-    private final EWMA m15Rate = EWMA.fifteenMinuteEWMA();
-    private final LongAdder sum = new LongAdder();
+  static {
+    int m3Ticks = 1;
+    final EWMA m3 = EWMA.fifteenMinuteEWMA();
+    m3.update(Long.MAX_VALUE);
+    do {
+      m3.tick();
+      m3Ticks++;
+    } while (m3.getRate(TimeUnit.SECONDS) > MAX_TICK_ZERO_TARGET);
+    MAX_TICKS = m3Ticks;
+  }
 
-    private final AtomicLong lastTick;
-    private final Clock clock;
+  private final EWMA m1Rate = EWMA.oneMinuteEWMA();
+  private final EWMA m5Rate = EWMA.fiveMinuteEWMA();
+  private final EWMA m15Rate = EWMA.fifteenMinuteEWMA();
+  private final LongAdder sum = new LongAdder();
 
-    /**
-     * Creates a new {@link ExponentialMovingAverages}.
-     */
-    public ExponentialMovingAverages() {
-        this(Clock.defaultClock());
-    }
+  private final AtomicLong lastTick;
+  private final Clock clock;
 
-    /**
-     * Creates a new {@link ExponentialMovingAverages}.
-     */
-    public ExponentialMovingAverages(Clock clock) {
-        this.clock = clock;
-        this.lastTick = new AtomicLong(this.clock.getTick());
-    }
+  /** Creates a new {@link ExponentialMovingAverages}. */
+  public ExponentialMovingAverages() {
+    this(Clock.defaultClock());
+  }
 
-    @Override
-    public void update(long n) {
-        m1Rate.update(n);
-        m5Rate.update(n);
-        m15Rate.update(n);
-    }
+  /** Creates a new {@link ExponentialMovingAverages}. */
+  public ExponentialMovingAverages(Clock clock) {
+    this.clock = clock;
+    this.lastTick = new AtomicLong(this.clock.getTick());
+  }
 
-    @Override
-    public void tickIfNecessary() {
-        final long oldTick = lastTick.get();
-        final long newTick = clock.getTick();
-        final long age = newTick - oldTick;
-        if (age > TICK_INTERVAL) {
-            final long newIntervalStartTick = newTick - age % TICK_INTERVAL;
-            if (lastTick.compareAndSet(oldTick, newIntervalStartTick)) {
-                sum.add(age);
-                final long requiredTicks = age / TICK_INTERVAL;
-                if (requiredTicks >= maxTicks) {
-                    m1Rate.reset();
-                    m5Rate.reset();
-                    m15Rate.reset();
-                }
-                else
-                {
-                    for (long i = 0; i < requiredTicks; i++)
-                    {
-                        m1Rate.tick();
-                        m5Rate.tick();
-                        m15Rate.tick();
-                    }
-                }
-            }
+  @Override
+  public void update(long n) {
+    m1Rate.update(n);
+    m5Rate.update(n);
+    m15Rate.update(n);
+  }
+
+  @Override
+  public void tickIfNecessary() {
+    final long oldTick = lastTick.get();
+    final long newTick = clock.getTick();
+    final long age = newTick - oldTick;
+    if (age > TICK_INTERVAL) {
+      final long newIntervalStartTick = newTick - age % TICK_INTERVAL;
+      if (lastTick.compareAndSet(oldTick, newIntervalStartTick)) {
+        sum.add(age);
+        final long requiredTicks = age / TICK_INTERVAL;
+        if (requiredTicks >= MAX_TICKS) {
+          m1Rate.reset();
+          m5Rate.reset();
+          m15Rate.reset();
+        } else {
+          for (long i = 0; i < requiredTicks; i++) {
+            m1Rate.tick();
+            m5Rate.tick();
+            m15Rate.tick();
+          }
         }
+      }
     }
+  }
 
-    @Override
-    public double getM1Rate() {
-        return m1Rate.getRate(TimeUnit.SECONDS);
-    }
+  @Override
+  public double getM1Rate() {
+    return m1Rate.getRate(TimeUnit.SECONDS);
+  }
 
-    @Override
-    public double getM5Rate() {
-        return m5Rate.getRate(TimeUnit.SECONDS);
-    }
+  @Override
+  public double getM5Rate() {
+    return m5Rate.getRate(TimeUnit.SECONDS);
+  }
 
-    @Override
-    public double getM15Rate() {
-        return m15Rate.getRate(TimeUnit.SECONDS);
-    }
+  @Override
+  public double getM15Rate() {
+    return m15Rate.getRate(TimeUnit.SECONDS);
+  }
 
-    @Override
-    public long getSum() {
-        return sum.sum();
-    }
+  @Override
+  public long getSum() {
+    return sum.sum();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/ExponentiallyDecayingReservoir.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/ExponentiallyDecayingReservoir.java
@@ -1,6 +1,9 @@
 package io.dropwizard.metrics5;
 
+import static java.lang.Math.exp;
+import static java.lang.Math.min;
 
+import io.dropwizard.metrics5.WeightedSnapshot.WeightedSample;
 import java.util.ArrayList;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.util.concurrent.ThreadLocalRandom;
@@ -8,201 +11,197 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
-import static java.lang.Math.exp;
-import static java.lang.Math.min;
-
-import io.dropwizard.metrics5.WeightedSnapshot.WeightedSample;
-
 /**
  * An exponentially-decaying random reservoir of {@code long}s. Uses Cormode et al's
  * forward-decaying priority reservoir sampling method to produce a statistically representative
  * sampling reservoir, exponentially biased towards newer entries.
  *
- * @see <a href="http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf">
- * Cormode et al. Forward Decay: A Practical Time Decay Model for Streaming Systems. ICDE '09:
- * Proceedings of the 2009 IEEE International Conference on Data Engineering (2009)</a>
+ * @see <a href="http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf">Cormode et al. Forward
+ *     Decay: A Practical Time Decay Model for Streaming Systems. ICDE '09: Proceedings of the 2009
+ *     IEEE International Conference on Data Engineering (2009)</a>
  */
 public class ExponentiallyDecayingReservoir implements Reservoir {
-    private static final int DEFAULT_SIZE = 1028;
-    private static final double DEFAULT_ALPHA = 0.015;
-    private static final long RESCALE_THRESHOLD = TimeUnit.HOURS.toNanos(1);
-
-    private final ConcurrentSkipListMap<Double, WeightedSample> values;
-    private final ReentrantReadWriteLock lock;
-    private final double alpha;
-    private final int size;
-    private final AtomicLong count;
-    private volatile long startTime;
-    private final AtomicLong lastScaleTick;
-    private final Clock clock;
-
-    /**
-     * Creates a new {@link ExponentiallyDecayingReservoir} of 1028 elements, which offers a 99.9%
-     * confidence level with a 5% margin of error assuming a normal distribution, and an alpha
-     * factor of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.
-     */
-    public ExponentiallyDecayingReservoir() {
-        this(DEFAULT_SIZE, DEFAULT_ALPHA);
-    }
-
-    /**
-     * Creates a new {@link ExponentiallyDecayingReservoir}.
-     *
-     * @param size  the number of samples to keep in the sampling reservoir
-     * @param alpha the exponential decay factor; the higher this is, the more biased the reservoir
-     *              will be towards newer values
-     */
-    public ExponentiallyDecayingReservoir(int size, double alpha) {
-        this(size, alpha, Clock.defaultClock());
-    }
-
-    /**
-     * Creates a new {@link ExponentiallyDecayingReservoir}.
-     *
-     * @param size  the number of samples to keep in the sampling reservoir
-     * @param alpha the exponential decay factor; the higher this is, the more biased the reservoir
-     *              will be towards newer values
-     * @param clock the clock used to timestamp samples and track rescaling
-     */
-    public ExponentiallyDecayingReservoir(int size, double alpha, Clock clock) {
-        this.values = new ConcurrentSkipListMap<>();
-        this.lock = new ReentrantReadWriteLock();
-        this.alpha = alpha;
-        this.size = size;
-        this.clock = clock;
-        this.count = new AtomicLong(0);
-        this.startTime = currentTimeInSeconds();
-        this.lastScaleTick = new AtomicLong(clock.getTick());
-    }
-
-    @Override
-    public int size() {
-        return (int) min(size, count.get());
-    }
-
-    @Override
-    public void update(long value) {
-        update(value, currentTimeInSeconds());
-    }
-
-    /**
-     * Adds an old value with a fixed timestamp to the reservoir.
-     *
-     * @param value     the value to be added
-     * @param timestamp the epoch timestamp of {@code value} in seconds
-     */
-    public void update(long value, long timestamp) {
-        rescaleIfNeeded();
-        lockForRegularUsage();
-        try {
-            final double itemWeight = weight(timestamp - startTime);
-            final WeightedSample sample = new WeightedSample(value, itemWeight);
-            final double priority = itemWeight / ThreadLocalRandom.current().nextDouble();
-
-            final long newCount = count.incrementAndGet();
-            if (newCount <= size || values.isEmpty()) {
-                values.put(priority, sample);
-            } else {
-                Double first = values.firstKey();
-                if (first < priority && values.putIfAbsent(priority, sample) == null) {
-                    // ensure we always remove an item
-                    while (values.remove(first) == null) {
-                        first = values.firstKey();
-                    }
-                }
-            }
-        } finally {
-            unlockForRegularUsage();
+  private static final int DEFAULT_SIZE = 1028;
+  private static final double DEFAULT_ALPHA = 0.015;
+  private static final long RESCALE_THRESHOLD = TimeUnit.HOURS.toNanos(1);
+
+  private final ConcurrentSkipListMap<Double, WeightedSample> values;
+  private final ReentrantReadWriteLock lock;
+  private final double alpha;
+  private final int size;
+  private final AtomicLong count;
+  private volatile long startTime;
+  private final AtomicLong lastScaleTick;
+  private final Clock clock;
+
+  /**
+   * Creates a new {@link ExponentiallyDecayingReservoir} of 1028 elements, which offers a 99.9%
+   * confidence level with a 5% margin of error assuming a normal distribution, and an alpha factor
+   * of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.
+   */
+  public ExponentiallyDecayingReservoir() {
+    this(DEFAULT_SIZE, DEFAULT_ALPHA);
+  }
+
+  /**
+   * Creates a new {@link ExponentiallyDecayingReservoir}.
+   *
+   * @param size the number of samples to keep in the sampling reservoir
+   * @param alpha the exponential decay factor; the higher this is, the more biased the reservoir
+   *     will be towards newer values
+   */
+  public ExponentiallyDecayingReservoir(int size, double alpha) {
+    this(size, alpha, Clock.defaultClock());
+  }
+
+  /**
+   * Creates a new {@link ExponentiallyDecayingReservoir}.
+   *
+   * @param size the number of samples to keep in the sampling reservoir
+   * @param alpha the exponential decay factor; the higher this is, the more biased the reservoir
+   *     will be towards newer values
+   * @param clock the clock used to timestamp samples and track rescaling
+   */
+  public ExponentiallyDecayingReservoir(int size, double alpha, Clock clock) {
+    this.values = new ConcurrentSkipListMap<>();
+    this.lock = new ReentrantReadWriteLock();
+    this.alpha = alpha;
+    this.size = size;
+    this.clock = clock;
+    this.count = new AtomicLong(0);
+    this.startTime = currentTimeInSeconds();
+    this.lastScaleTick = new AtomicLong(clock.getTick());
+  }
+
+  @Override
+  public int size() {
+    return (int) min(size, count.get());
+  }
+
+  @Override
+  public void update(long value) {
+    update(value, currentTimeInSeconds());
+  }
+
+  /**
+   * Adds an old value with a fixed timestamp to the reservoir.
+   *
+   * @param value the value to be added
+   * @param timestamp the epoch timestamp of {@code value} in seconds
+   */
+  public void update(long value, long timestamp) {
+    rescaleIfNeeded();
+    lockForRegularUsage();
+    try {
+      final double itemWeight = weight(timestamp - startTime);
+      final WeightedSample sample = new WeightedSample(value, itemWeight);
+      final double priority = itemWeight / ThreadLocalRandom.current().nextDouble();
+
+      final long newCount = count.incrementAndGet();
+      if (newCount <= size || values.isEmpty()) {
+        values.put(priority, sample);
+      } else {
+        Double first = values.firstKey();
+        if (first < priority && values.putIfAbsent(priority, sample) == null) {
+          // ensure we always remove an item
+          while (values.remove(first) == null) {
+            first = values.firstKey();
+          }
         }
+      }
+    } finally {
+      unlockForRegularUsage();
     }
+  }
 
-    private void rescaleIfNeeded() {
-        final long now = clock.getTick();
-        final long lastScaleTickSnapshot = lastScaleTick.get();
-        if (now - lastScaleTickSnapshot >= RESCALE_THRESHOLD) {
-            rescale(now, lastScaleTickSnapshot);
-        }
+  private void rescaleIfNeeded() {
+    final long now = clock.getTick();
+    final long lastScaleTickSnapshot = lastScaleTick.get();
+    if (now - lastScaleTickSnapshot >= RESCALE_THRESHOLD) {
+      rescale(now, lastScaleTickSnapshot);
     }
-
-    @Override
-    public Snapshot getSnapshot() {
-        rescaleIfNeeded();
-        lockForRegularUsage();
-        try {
-            return new WeightedSnapshot(values.values());
-        } finally {
-            unlockForRegularUsage();
-        }
-    }
-
-    private long currentTimeInSeconds() {
-        return TimeUnit.MILLISECONDS.toSeconds(clock.getTime());
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    rescaleIfNeeded();
+    lockForRegularUsage();
+    try {
+      return new WeightedSnapshot(values.values());
+    } finally {
+      unlockForRegularUsage();
     }
-
-    private double weight(long t) {
-        return exp(alpha * t);
-    }
-
-    /* "A common feature of the above techniques—indeed, the key technique that
-     * allows us to track the decayed weights efficiently—is that they maintain
-     * counts and other quantities based on g(ti − L), and only scale by g(t − L)
-     * at query time. But while g(ti −L)/g(t−L) is guaranteed to lie between zero
-     * and one, the intermediate values of g(ti − L) could become very large. For
-     * polynomial functions, these values should not grow too large, and should be
-     * effectively represented in practice by floating point values without loss of
-     * precision. For exponential functions, these values could grow quite large as
-     * new values of (ti − L) become large, and potentially exceed the capacity of
-     * common floating point types. However, since the values stored by the
-     * algorithms are linear combinations of g values (scaled sums), they can be
-     * rescaled relative to a new landmark. That is, by the analysis of exponential
-     * decay in Section III-A, the choice of L does not affect the final result. We
-     * can therefore multiply each value based on L by a factor of exp(−α(L′ − L)),
-     * and obtain the correct value as if we had instead computed relative to a new
-     * landmark L′ (and then use this new L′ at query time). This can be done with
-     * a linear pass over whatever data structure is being used."
-     */
-    private void rescale(long now, long lastTick) {
-        lockForRescale();
-        try {
-            if (lastScaleTick.compareAndSet(lastTick, now)) {
-                final long oldStartTime = startTime;
-                this.startTime = currentTimeInSeconds();
-                final double scalingFactor = exp(-alpha * (startTime - oldStartTime));
-                if (Double.compare(scalingFactor, 0) == 0) {
-                    values.clear();
-                } else {
-                    final ArrayList<Double> keys = new ArrayList<>(values.keySet());
-                    for (Double key : keys) {
-                        final WeightedSample sample = values.remove(key);
-                        final WeightedSample newSample = new WeightedSample(sample.value, sample.weight * scalingFactor);
-                        if (Double.compare(newSample.weight, 0) == 0) {
-                            continue;
-                        }
-                        values.put(key * scalingFactor, newSample);
-                    }
-                }
-
-                // make sure the counter is in sync with the number of stored samples.
-                count.set(values.size());
+  }
+
+  private long currentTimeInSeconds() {
+    return TimeUnit.MILLISECONDS.toSeconds(clock.getTime());
+  }
+
+  private double weight(long t) {
+    return exp(alpha * t);
+  }
+
+  /* "A common feature of the above techniques—indeed, the key technique that
+   * allows us to track the decayed weights efficiently—is that they maintain
+   * counts and other quantities based on g(ti − L), and only scale by g(t − L)
+   * at query time. But while g(ti −L)/g(t−L) is guaranteed to lie between zero
+   * and one, the intermediate values of g(ti − L) could become very large. For
+   * polynomial functions, these values should not grow too large, and should be
+   * effectively represented in practice by floating point values without loss of
+   * precision. For exponential functions, these values could grow quite large as
+   * new values of (ti − L) become large, and potentially exceed the capacity of
+   * common floating point types. However, since the values stored by the
+   * algorithms are linear combinations of g values (scaled sums), they can be
+   * rescaled relative to a new landmark. That is, by the analysis of exponential
+   * decay in Section III-A, the choice of L does not affect the final result. We
+   * can therefore multiply each value based on L by a factor of exp(−α(L′ − L)),
+   * and obtain the correct value as if we had instead computed relative to a new
+   * landmark L′ (and then use this new L′ at query time). This can be done with
+   * a linear pass over whatever data structure is being used."
+   */
+  private void rescale(long now, long lastTick) {
+    lockForRescale();
+    try {
+      if (lastScaleTick.compareAndSet(lastTick, now)) {
+        final long oldStartTime = startTime;
+        this.startTime = currentTimeInSeconds();
+        final double scalingFactor = exp(-alpha * (startTime - oldStartTime));
+        if (Double.compare(scalingFactor, 0) == 0) {
+          values.clear();
+        } else {
+          final ArrayList<Double> keys = new ArrayList<>(values.keySet());
+          for (Double key : keys) {
+            final WeightedSample sample = values.remove(key);
+            final WeightedSample newSample =
+                new WeightedSample(sample.value, sample.weight * scalingFactor);
+            if (Double.compare(newSample.weight, 0) == 0) {
+              continue;
             }
-        } finally {
-            unlockForRescale();
+            values.put(key * scalingFactor, newSample);
+          }
         }
-    }
 
-    private void unlockForRescale() {
-        lock.writeLock().unlock();
+        // make sure the counter is in sync with the number of stored samples.
+        count.set(values.size());
+      }
+    } finally {
+      unlockForRescale();
     }
+  }
 
-    private void lockForRescale() {
-        lock.writeLock().lock();
-    }
+  private void unlockForRescale() {
+    lock.writeLock().unlock();
+  }
 
-    private void lockForRegularUsage() {
-        lock.readLock().lock();
-    }
+  private void lockForRescale() {
+    lock.writeLock().lock();
+  }
 
-    private void unlockForRegularUsage() {
-        lock.readLock().unlock();
-    }
+  private void lockForRegularUsage() {
+    lock.readLock().lock();
+  }
+
+  private void unlockForRegularUsage() {
+    lock.readLock().unlock();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/FixedNameCsvFileProvider.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/FixedNameCsvFileProvider.java
@@ -3,19 +3,19 @@ package io.dropwizard.metrics5;
 import java.io.File;
 
 /**
- * This implementation of the {@link CsvFileProvider} will always return the same name
- * for the same metric. This means the CSV file will grow indefinitely.
+ * This implementation of the {@link CsvFileProvider} will always return the same name for the same
+ * metric. This means the CSV file will grow indefinitely.
  */
 public class FixedNameCsvFileProvider implements CsvFileProvider {
 
-    @Override
-    public File getFile(File directory, String metricName) {
-        return new File(directory, sanitize(metricName) + ".csv");
-    }
+  @Override
+  public File getFile(File directory, String metricName) {
+    return new File(directory, sanitize(metricName) + ".csv");
+  }
 
-    protected String sanitize(String metricName) {
-        //Forward slash character is definitely illegal in both Windows and Linux
-        //https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx
-        return metricName.replaceFirst("^/", "").replaceAll("/", ".");
-    }
+  protected String sanitize(String metricName) {
+    // Forward slash character is definitely illegal in both Windows and Linux
+    // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx
+    return metricName.replaceFirst("^/", "").replaceAll("/", ".");
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Gauge.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Gauge.java
@@ -1,9 +1,9 @@
 package io.dropwizard.metrics5;
 
-
 /**
  * A gauge metric is an instantaneous reading of a particular value. To instrument a queue's depth,
  * for example:<br>
+ *
  * <pre><code>
  * final Queue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;String&gt;();
  * final Gauge&lt;Integer&gt; queueDepth = new Gauge&lt;Integer&gt;() {
@@ -17,10 +17,10 @@ package io.dropwizard.metrics5;
  */
 @FunctionalInterface
 public interface Gauge<T> extends Metric {
-    /**
-     * Returns the metric's current value.
-     *
-     * @return the metric's current value
-     */
-    T getValue();
+  /**
+   * Returns the metric's current value.
+   *
+   * @return the metric's current value
+   */
+  T getValue();
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Histogram.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Histogram.java
@@ -6,66 +6,66 @@ import java.util.concurrent.atomic.LongAdder;
  * A metric which calculates the distribution of a value.
  *
  * @see <a href="http://www.johndcook.com/standard_deviation.html">Accurately computing running
- * variance</a>
+ *     variance</a>
  */
 public class Histogram implements Metric, Sampling, Counting, Summing {
-    private final Reservoir reservoir;
-    private final LongAdder count;
-    private final LongAdder sum;
+  private final Reservoir reservoir;
+  private final LongAdder count;
+  private final LongAdder sum;
 
-    /**
-     * Creates a new {@link Histogram} with the given reservoir.
-     *
-     * @param reservoir the reservoir to create a histogram from
-     */
-    public Histogram(Reservoir reservoir) {
-        this.reservoir = reservoir;
-        this.count = new LongAdder();
-        this.sum = new LongAdder();
-    }
+  /**
+   * Creates a new {@link Histogram} with the given reservoir.
+   *
+   * @param reservoir the reservoir to create a histogram from
+   */
+  public Histogram(Reservoir reservoir) {
+    this.reservoir = reservoir;
+    this.count = new LongAdder();
+    this.sum = new LongAdder();
+  }
 
-    /**
-     * Adds a recorded value.
-     *
-     * @param value the length of the value
-     */
-    public void update(int value) {
-        update((long) value);
-    }
+  /**
+   * Adds a recorded value.
+   *
+   * @param value the length of the value
+   */
+  public void update(int value) {
+    update((long) value);
+  }
 
-    /**
-     * Adds a recorded value.
-     *
-     * @param value the length of the value
-     */
-    public void update(long value) {
-        count.increment();
-        sum.add(value);
-        reservoir.update(value);
-    }
+  /**
+   * Adds a recorded value.
+   *
+   * @param value the length of the value
+   */
+  public void update(long value) {
+    count.increment();
+    sum.add(value);
+    reservoir.update(value);
+  }
 
-    /**
-     * Returns the number of values recorded.
-     *
-     * @return the number of values recorded
-     */
-    @Override
-    public long getCount() {
-        return count.sum();
-    }
+  /**
+   * Returns the number of values recorded.
+   *
+   * @return the number of values recorded
+   */
+  @Override
+  public long getCount() {
+    return count.sum();
+  }
 
-    /**
-     * Returns the sum of values recorded.
-     *
-     * @return the sum of values recorded
-     */
-    @Override
-    public long getSum() {
-        return sum.sum();
-    }
+  /**
+   * Returns the sum of values recorded.
+   *
+   * @return the sum of values recorded
+   */
+  @Override
+  public long getSum() {
+    return sum.sum();
+  }
 
-    @Override
-    public Snapshot getSnapshot() {
-        return reservoir.getSnapshot();
-    }
+  @Override
+  public Snapshot getSnapshot() {
+    return reservoir.getSnapshot();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/InstrumentedExecutorService.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/InstrumentedExecutorService.java
@@ -16,273 +16,259 @@ import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicLong;
 
 /**
- * An {@link ExecutorService} that monitors the number of tasks submitted, running,
- * completed and also keeps a {@link Timer} for the task duration.
- * <p>
- * It will register the metrics using the given (or auto-generated) name as classifier, e.g:
+ * An {@link ExecutorService} that monitors the number of tasks submitted, running, completed and
+ * also keeps a {@link Timer} for the task duration.
+ *
+ * <p>It will register the metrics using the given (or auto-generated) name as classifier, e.g:
  * "your-executor-service.submitted", "your-executor-service.running", etc.
  */
 public class InstrumentedExecutorService implements ExecutorService {
-    private static final AtomicLong NAME_COUNTER = new AtomicLong();
+  private static final AtomicLong NAME_COUNTER = new AtomicLong();
 
-    private final ExecutorService delegate;
-    private final MetricRegistry registry;
-    private final String name;
-    private final Meter submitted;
-    private final Counter running;
-    private final Meter completed;
-    private final Counter rejected;
-    private final Timer idle;
-    private final Timer duration;
+  private final ExecutorService delegate;
+  private final MetricRegistry registry;
+  private final String name;
+  private final Meter submitted;
+  private final Counter running;
+  private final Meter completed;
+  private final Counter rejected;
+  private final Timer idle;
+  private final Timer duration;
 
-    /**
-     * Wraps an {@link ExecutorService} uses an auto-generated default name.
-     *
-     * @param delegate {@link ExecutorService} to wrap.
-     * @param registry {@link MetricRegistry} that will contain the metrics.
-     */
-    public InstrumentedExecutorService(ExecutorService delegate, MetricRegistry registry) {
-        this(delegate, registry, "instrumented-delegate-" + NAME_COUNTER.incrementAndGet());
-    }
+  /**
+   * Wraps an {@link ExecutorService} uses an auto-generated default name.
+   *
+   * @param delegate {@link ExecutorService} to wrap.
+   * @param registry {@link MetricRegistry} that will contain the metrics.
+   */
+  public InstrumentedExecutorService(ExecutorService delegate, MetricRegistry registry) {
+    this(delegate, registry, "instrumented-delegate-" + NAME_COUNTER.incrementAndGet());
+  }
 
-    /**
-     * Wraps an {@link ExecutorService} with an explicit name.
-     *
-     * @param delegate {@link ExecutorService} to wrap.
-     * @param registry {@link MetricRegistry} that will contain the metrics.
-     * @param name     name for this executor service.
-     */
-    public InstrumentedExecutorService(ExecutorService delegate, MetricRegistry registry, String name) {
-        this.delegate = delegate;
-        this.registry = registry;
-        this.name = name;
-        this.submitted = registry.meter(MetricRegistry.name(name, "submitted"));
-        this.running = registry.counter(MetricRegistry.name(name, "running"));
-        this.completed = registry.meter(MetricRegistry.name(name, "completed"));
-        this.rejected = registry.counter(MetricRegistry.name(name, "rejected"));
-        this.idle = registry.timer(MetricRegistry.name(name, "idle"));
-        this.duration = registry.timer(MetricRegistry.name(name, "duration"));
+  /**
+   * Wraps an {@link ExecutorService} with an explicit name.
+   *
+   * @param delegate {@link ExecutorService} to wrap.
+   * @param registry {@link MetricRegistry} that will contain the metrics.
+   * @param name name for this executor service.
+   */
+  public InstrumentedExecutorService(
+      ExecutorService delegate, MetricRegistry registry, String name) {
+    this.delegate = delegate;
+    this.registry = registry;
+    this.name = name;
+    this.submitted = registry.meter(MetricRegistry.name(name, "submitted"));
+    this.running = registry.counter(MetricRegistry.name(name, "running"));
+    this.completed = registry.meter(MetricRegistry.name(name, "completed"));
+    this.rejected = registry.counter(MetricRegistry.name(name, "rejected"));
+    this.idle = registry.timer(MetricRegistry.name(name, "idle"));
+    this.duration = registry.timer(MetricRegistry.name(name, "duration"));
 
-        registerInternalMetrics();
-    }
+    registerInternalMetrics();
+  }
 
-    private void registerInternalMetrics() {
-        if (delegate instanceof ThreadPoolExecutor) {
-            ThreadPoolExecutor executor = (ThreadPoolExecutor) delegate;
-            registry.registerGauge(MetricRegistry.name(name, "pool.size"),
-                    executor::getPoolSize);
-            registry.registerGauge(MetricRegistry.name(name, "pool.core"),
-                    executor::getCorePoolSize);
-            registry.registerGauge(MetricRegistry.name(name, "pool.max"),
-                    executor::getMaximumPoolSize);
-            final BlockingQueue<Runnable> queue = executor.getQueue();
-            registry.registerGauge(MetricRegistry.name(name, "tasks.active"),
-                    executor::getActiveCount);
-            registry.registerGauge(MetricRegistry.name(name, "tasks.completed"),
-                    executor::getCompletedTaskCount);
-            registry.registerGauge(MetricRegistry.name(name, "tasks.queued"),
-                    queue::size);
-            registry.registerGauge(MetricRegistry.name(name, "tasks.capacity"),
-                    queue::remainingCapacity);
-            RejectedExecutionHandler delegateHandler = executor.getRejectedExecutionHandler();
-            executor.setRejectedExecutionHandler(new InstrumentedRejectedExecutionHandler(delegateHandler));
-        } else if (delegate instanceof ForkJoinPool) {
-            ForkJoinPool forkJoinPool = (ForkJoinPool) delegate;
-            registry.registerGauge(MetricRegistry.name(name, "tasks.stolen"),
-                    forkJoinPool::getStealCount);
-            registry.registerGauge(MetricRegistry.name(name, "tasks.queued"),
-                    forkJoinPool::getQueuedTaskCount);
-            registry.registerGauge(MetricRegistry.name(name, "threads.active"),
-                    forkJoinPool::getActiveThreadCount);
-            registry.registerGauge(MetricRegistry.name(name, "threads.running"),
-                    forkJoinPool::getRunningThreadCount);
-        }
+  private void registerInternalMetrics() {
+    if (delegate instanceof ThreadPoolExecutor) {
+      ThreadPoolExecutor executor = (ThreadPoolExecutor) delegate;
+      registry.registerGauge(MetricRegistry.name(name, "pool.size"), executor::getPoolSize);
+      registry.registerGauge(MetricRegistry.name(name, "pool.core"), executor::getCorePoolSize);
+      registry.registerGauge(MetricRegistry.name(name, "pool.max"), executor::getMaximumPoolSize);
+      final BlockingQueue<Runnable> queue = executor.getQueue();
+      registry.registerGauge(MetricRegistry.name(name, "tasks.active"), executor::getActiveCount);
+      registry.registerGauge(
+          MetricRegistry.name(name, "tasks.completed"), executor::getCompletedTaskCount);
+      registry.registerGauge(MetricRegistry.name(name, "tasks.queued"), queue::size);
+      registry.registerGauge(MetricRegistry.name(name, "tasks.capacity"), queue::remainingCapacity);
+      RejectedExecutionHandler delegateHandler = executor.getRejectedExecutionHandler();
+      executor.setRejectedExecutionHandler(
+          new InstrumentedRejectedExecutionHandler(delegateHandler));
+    } else if (delegate instanceof ForkJoinPool) {
+      ForkJoinPool forkJoinPool = (ForkJoinPool) delegate;
+      registry.registerGauge(
+          MetricRegistry.name(name, "tasks.stolen"), forkJoinPool::getStealCount);
+      registry.registerGauge(
+          MetricRegistry.name(name, "tasks.queued"), forkJoinPool::getQueuedTaskCount);
+      registry.registerGauge(
+          MetricRegistry.name(name, "threads.active"), forkJoinPool::getActiveThreadCount);
+      registry.registerGauge(
+          MetricRegistry.name(name, "threads.running"), forkJoinPool::getRunningThreadCount);
     }
+  }
 
-    private void removeInternalMetrics() {
-        if (delegate instanceof ThreadPoolExecutor) {
-            registry.remove(MetricRegistry.name(name, "pool.size"));
-            registry.remove(MetricRegistry.name(name, "pool.core"));
-            registry.remove(MetricRegistry.name(name, "pool.max"));
-            registry.remove(MetricRegistry.name(name, "tasks.active"));
-            registry.remove(MetricRegistry.name(name, "tasks.completed"));
-            registry.remove(MetricRegistry.name(name, "tasks.queued"));
-            registry.remove(MetricRegistry.name(name, "tasks.capacity"));
-        } else if (delegate instanceof ForkJoinPool) {
-            registry.remove(MetricRegistry.name(name, "tasks.stolen"));
-            registry.remove(MetricRegistry.name(name, "tasks.queued"));
-            registry.remove(MetricRegistry.name(name, "threads.active"));
-            registry.remove(MetricRegistry.name(name, "threads.running"));
-        }
+  private void removeInternalMetrics() {
+    if (delegate instanceof ThreadPoolExecutor) {
+      registry.remove(MetricRegistry.name(name, "pool.size"));
+      registry.remove(MetricRegistry.name(name, "pool.core"));
+      registry.remove(MetricRegistry.name(name, "pool.max"));
+      registry.remove(MetricRegistry.name(name, "tasks.active"));
+      registry.remove(MetricRegistry.name(name, "tasks.completed"));
+      registry.remove(MetricRegistry.name(name, "tasks.queued"));
+      registry.remove(MetricRegistry.name(name, "tasks.capacity"));
+    } else if (delegate instanceof ForkJoinPool) {
+      registry.remove(MetricRegistry.name(name, "tasks.stolen"));
+      registry.remove(MetricRegistry.name(name, "tasks.queued"));
+      registry.remove(MetricRegistry.name(name, "threads.active"));
+      registry.remove(MetricRegistry.name(name, "threads.running"));
     }
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void execute(Runnable runnable) {
-        submitted.mark();
-        delegate.execute(new InstrumentedRunnable(runnable));
-    }
+  /** {@inheritDoc} */
+  @Override
+  public void execute(Runnable runnable) {
+    submitted.mark();
+    delegate.execute(new InstrumentedRunnable(runnable));
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<?> submit(Runnable runnable) {
-        submitted.mark();
-        return delegate.submit(new InstrumentedRunnable(runnable));
-    }
+  /** {@inheritDoc} */
+  @Override
+  public Future<?> submit(Runnable runnable) {
+    submitted.mark();
+    return delegate.submit(new InstrumentedRunnable(runnable));
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> Future<T> submit(Runnable runnable, T result) {
-        submitted.mark();
-        return delegate.submit(new InstrumentedRunnable(runnable), result);
-    }
+  /** {@inheritDoc} */
+  @Override
+  public <T> Future<T> submit(Runnable runnable, T result) {
+    submitted.mark();
+    return delegate.submit(new InstrumentedRunnable(runnable), result);
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> Future<T> submit(Callable<T> task) {
-        submitted.mark();
-        return delegate.submit(new InstrumentedCallable<>(task));
-    }
+  /** {@inheritDoc} */
+  @Override
+  public <T> Future<T> submit(Callable<T> task) {
+    submitted.mark();
+    return delegate.submit(new InstrumentedCallable<>(task));
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
-        submitted.mark(tasks.size());
-        Collection<? extends Callable<T>> instrumented = instrument(tasks);
-        return delegate.invokeAll(instrumented);
-    }
+  /** {@inheritDoc} */
+  @Override
+  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    submitted.mark(tasks.size());
+    Collection<? extends Callable<T>> instrumented = instrument(tasks);
+    return delegate.invokeAll(instrumented);
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
-        submitted.mark(tasks.size());
-        Collection<? extends Callable<T>> instrumented = instrument(tasks);
-        return delegate.invokeAll(instrumented, timeout, unit);
-    }
+  /** {@inheritDoc} */
+  @Override
+  public <T> List<Future<T>> invokeAll(
+      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+      throws InterruptedException {
+    submitted.mark(tasks.size());
+    Collection<? extends Callable<T>> instrumented = instrument(tasks);
+    return delegate.invokeAll(instrumented, timeout, unit);
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws ExecutionException, InterruptedException {
-        submitted.mark(tasks.size());
-        Collection<? extends Callable<T>> instrumented = instrument(tasks);
-        return delegate.invokeAny(instrumented);
-    }
+  /** {@inheritDoc} */
+  @Override
+  public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
+      throws ExecutionException, InterruptedException {
+    submitted.mark(tasks.size());
+    Collection<? extends Callable<T>> instrumented = instrument(tasks);
+    return delegate.invokeAny(instrumented);
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
-        submitted.mark(tasks.size());
-        Collection<? extends Callable<T>> instrumented = instrument(tasks);
-        return delegate.invokeAny(instrumented, timeout, unit);
-    }
+  /** {@inheritDoc} */
+  @Override
+  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+      throws ExecutionException, InterruptedException, TimeoutException {
+    submitted.mark(tasks.size());
+    Collection<? extends Callable<T>> instrumented = instrument(tasks);
+    return delegate.invokeAny(instrumented, timeout, unit);
+  }
 
-    private <T> Collection<? extends Callable<T>> instrument(Collection<? extends Callable<T>> tasks) {
-        final List<InstrumentedCallable<T>> instrumented = new ArrayList<>(tasks.size());
-        for (Callable<T> task : tasks) {
-            instrumented.add(new InstrumentedCallable<>(task));
-        }
-        return instrumented;
+  private <T> Collection<? extends Callable<T>> instrument(
+      Collection<? extends Callable<T>> tasks) {
+    final List<InstrumentedCallable<T>> instrumented = new ArrayList<>(tasks.size());
+    for (Callable<T> task : tasks) {
+      instrumented.add(new InstrumentedCallable<>(task));
     }
+    return instrumented;
+  }
 
-    @Override
-    public void shutdown() {
-        delegate.shutdown();
-        removeInternalMetrics();
-    }
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
+    removeInternalMetrics();
+  }
 
-    @Override
-    public List<Runnable> shutdownNow() {
-        List<Runnable> remainingTasks = delegate.shutdownNow();
-        removeInternalMetrics();
-        return remainingTasks;
-    }
+  @Override
+  public List<Runnable> shutdownNow() {
+    List<Runnable> remainingTasks = delegate.shutdownNow();
+    removeInternalMetrics();
+    return remainingTasks;
+  }
 
-    @Override
-    public boolean isShutdown() {
-        return delegate.isShutdown();
-    }
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
 
-    @Override
-    public boolean isTerminated() {
-        return delegate.isTerminated();
-    }
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
+  }
 
-    @Override
-    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {
-        return delegate.awaitTermination(l, timeUnit);
-    }
+  @Override
+  public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {
+    return delegate.awaitTermination(l, timeUnit);
+  }
 
-    private class InstrumentedRejectedExecutionHandler implements RejectedExecutionHandler {
-        private final RejectedExecutionHandler delegateHandler;
+  private class InstrumentedRejectedExecutionHandler implements RejectedExecutionHandler {
+    private final RejectedExecutionHandler delegateHandler;
 
-        public InstrumentedRejectedExecutionHandler(RejectedExecutionHandler delegateHandler) {
-            this.delegateHandler = delegateHandler;
-        }
+    public InstrumentedRejectedExecutionHandler(RejectedExecutionHandler delegateHandler) {
+      this.delegateHandler = delegateHandler;
+    }
 
-        @Override
-        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
-            rejected.inc();
-            this.delegateHandler.rejectedExecution(r, executor);
-        }
+    @Override
+    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
+      rejected.inc();
+      this.delegateHandler.rejectedExecution(r, executor);
     }
+  }
 
-    private class InstrumentedRunnable implements Runnable {
-        private final Runnable task;
-        private final Timer.Context idleContext;
+  private class InstrumentedRunnable implements Runnable {
+    private final Runnable task;
+    private final Timer.Context idleContext;
 
-        InstrumentedRunnable(Runnable task) {
-            this.task = task;
-            this.idleContext = idle.time();
-        }
+    InstrumentedRunnable(Runnable task) {
+      this.task = task;
+      this.idleContext = idle.time();
+    }
 
-        @Override
-        public void run() {
-            idleContext.stop();
-            running.inc();
-            try (Timer.Context durationContext = duration.time()) {
-                task.run();
-            } finally {
-                running.dec();
-                completed.mark();
-            }
-        }
+    @Override
+    public void run() {
+      idleContext.stop();
+      running.inc();
+      try (Timer.Context durationContext = duration.time()) {
+        task.run();
+      } finally {
+        running.dec();
+        completed.mark();
+      }
     }
+  }
 
-    private class InstrumentedCallable<T> implements Callable<T> {
-        private final Callable<T> callable;
-        private final Timer.Context idleContext;
+  private class InstrumentedCallable<T> implements Callable<T> {
+    private final Callable<T> callable;
+    private final Timer.Context idleContext;
 
-        InstrumentedCallable(Callable<T> callable) {
-            this.callable = callable;
-            this.idleContext = idle.time();
-        }
+    InstrumentedCallable(Callable<T> callable) {
+      this.callable = callable;
+      this.idleContext = idle.time();
+    }
 
-        @Override
-        public T call() throws Exception {
-            idleContext.stop();
-            running.inc();
-            try (Timer.Context context = duration.time()) {
-                return callable.call();
-            } finally {
-                running.dec();
-                completed.mark();
-            }
-        }
+    @Override
+    public T call() throws Exception {
+      idleContext.stop();
+      running.inc();
+      try (Timer.Context context = duration.time()) {
+        return callable.call();
+      } finally {
+        running.dec();
+        completed.mark();
+      }
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/InstrumentedScheduledExecutorService.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/InstrumentedScheduledExecutorService.java
@@ -15,283 +15,266 @@ import java.util.concurrent.atomic.AtomicLong;
 /**
  * An {@link ScheduledExecutorService} that monitors the number of tasks submitted, running,
  * completed and also keeps a {@link Timer} for the task duration.
- * <p>
- * It will register the metrics using the given (or auto-generated) name as classifier, e.g:
+ *
+ * <p>It will register the metrics using the given (or auto-generated) name as classifier, e.g:
  * "your-executor-service.submitted", "your-executor-service.running", etc.
  */
 public class InstrumentedScheduledExecutorService implements ScheduledExecutorService {
-    private static final AtomicLong NAME_COUNTER = new AtomicLong();
-
-    private final ScheduledExecutorService delegate;
-
-    private final Meter submitted;
-    private final Counter running;
-    private final Meter completed;
-    private final Timer duration;
-
-    private final Meter scheduledOnce;
-    private final Meter scheduledRepetitively;
-    private final Counter scheduledOverrun;
-    private final Histogram percentOfPeriod;
-
-    /**
-     * Wraps an {@link ScheduledExecutorService} uses an auto-generated default name.
-     *
-     * @param delegate {@link ScheduledExecutorService} to wrap.
-     * @param registry {@link MetricRegistry} that will contain the metrics.
-     */
-    public InstrumentedScheduledExecutorService(ScheduledExecutorService delegate, MetricRegistry registry) {
-        this(delegate, registry, "instrumented-scheduled-executor-service-" + NAME_COUNTER.incrementAndGet());
+  private static final AtomicLong NAME_COUNTER = new AtomicLong();
+
+  private final ScheduledExecutorService delegate;
+
+  private final Meter submitted;
+  private final Counter running;
+  private final Meter completed;
+  private final Timer duration;
+
+  private final Meter scheduledOnce;
+  private final Meter scheduledRepetitively;
+  private final Counter scheduledOverrun;
+  private final Histogram percentOfPeriod;
+
+  /**
+   * Wraps an {@link ScheduledExecutorService} uses an auto-generated default name.
+   *
+   * @param delegate {@link ScheduledExecutorService} to wrap.
+   * @param registry {@link MetricRegistry} that will contain the metrics.
+   */
+  public InstrumentedScheduledExecutorService(
+      ScheduledExecutorService delegate, MetricRegistry registry) {
+    this(
+        delegate,
+        registry,
+        "instrumented-scheduled-executor-service-" + NAME_COUNTER.incrementAndGet());
+  }
+
+  /**
+   * Wraps an {@link ScheduledExecutorService} with an explicit name.
+   *
+   * @param delegate {@link ScheduledExecutorService} to wrap.
+   * @param registry {@link MetricRegistry} that will contain the metrics.
+   * @param name name for this executor service.
+   */
+  public InstrumentedScheduledExecutorService(
+      ScheduledExecutorService delegate, MetricRegistry registry, String name) {
+    this.delegate = delegate;
+
+    this.submitted = registry.meter(MetricRegistry.name(name, "submitted"));
+
+    this.running = registry.counter(MetricRegistry.name(name, "running"));
+    this.completed = registry.meter(MetricRegistry.name(name, "completed"));
+    this.duration = registry.timer(MetricRegistry.name(name, "duration"));
+
+    this.scheduledOnce = registry.meter(MetricRegistry.name(name, "scheduled.once"));
+    this.scheduledRepetitively =
+        registry.meter(MetricRegistry.name(name, "scheduled.repetitively"));
+    this.scheduledOverrun = registry.counter(MetricRegistry.name(name, "scheduled.overrun"));
+    this.percentOfPeriod =
+        registry.histogram(MetricRegistry.name(name, "scheduled.percent-of-period"));
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
+    scheduledOnce.mark();
+    return delegate.schedule(new InstrumentedRunnable(command), delay, unit);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
+    scheduledOnce.mark();
+    return delegate.schedule(new InstrumentedCallable<>(callable), delay, unit);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public ScheduledFuture<?> scheduleAtFixedRate(
+      Runnable command, long initialDelay, long period, TimeUnit unit) {
+    scheduledRepetitively.mark();
+    return delegate.scheduleAtFixedRate(
+        new InstrumentedPeriodicRunnable(command, period, unit), initialDelay, period, unit);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public ScheduledFuture<?> scheduleWithFixedDelay(
+      Runnable command, long initialDelay, long delay, TimeUnit unit) {
+    scheduledRepetitively.mark();
+    return delegate.scheduleWithFixedDelay(
+        new InstrumentedRunnable(command), initialDelay, delay, unit);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public List<Runnable> shutdownNow() {
+    return delegate.shutdownNow();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
+    return delegate.awaitTermination(timeout, unit);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public <T> Future<T> submit(Callable<T> task) {
+    submitted.mark();
+    return delegate.submit(new InstrumentedCallable<>(task));
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public <T> Future<T> submit(Runnable task, T result) {
+    submitted.mark();
+    return delegate.submit(new InstrumentedRunnable(task), result);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Future<?> submit(Runnable task) {
+    submitted.mark();
+    return delegate.submit(new InstrumentedRunnable(task));
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    submitted.mark(tasks.size());
+    Collection<? extends Callable<T>> instrumented = instrument(tasks);
+    return delegate.invokeAll(instrumented);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public <T> List<Future<T>> invokeAll(
+      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+      throws InterruptedException {
+    submitted.mark(tasks.size());
+    Collection<? extends Callable<T>> instrumented = instrument(tasks);
+    return delegate.invokeAll(instrumented, timeout, unit);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
+      throws InterruptedException, ExecutionException {
+    submitted.mark(tasks.size());
+    Collection<? extends Callable<T>> instrumented = instrument(tasks);
+    return delegate.invokeAny(instrumented);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+      throws InterruptedException, ExecutionException, TimeoutException {
+    submitted.mark(tasks.size());
+    Collection<? extends Callable<T>> instrumented = instrument(tasks);
+    return delegate.invokeAny(instrumented, timeout, unit);
+  }
+
+  private <T> Collection<? extends Callable<T>> instrument(
+      Collection<? extends Callable<T>> tasks) {
+    final List<InstrumentedCallable<T>> instrumented = new ArrayList<>(tasks.size());
+    for (Callable<T> task : tasks) {
+      instrumented.add(new InstrumentedCallable<>(task));
     }
+    return instrumented;
+  }
 
-    /**
-     * Wraps an {@link ScheduledExecutorService} with an explicit name.
-     *
-     * @param delegate {@link ScheduledExecutorService} to wrap.
-     * @param registry {@link MetricRegistry} that will contain the metrics.
-     * @param name     name for this executor service.
-     */
-    public InstrumentedScheduledExecutorService(ScheduledExecutorService delegate, MetricRegistry registry, String name) {
-        this.delegate = delegate;
-
-        this.submitted = registry.meter(MetricRegistry.name(name, "submitted"));
-
-        this.running = registry.counter(MetricRegistry.name(name, "running"));
-        this.completed = registry.meter(MetricRegistry.name(name, "completed"));
-        this.duration = registry.timer(MetricRegistry.name(name, "duration"));
-
-        this.scheduledOnce = registry.meter(MetricRegistry.name(name, "scheduled.once"));
-        this.scheduledRepetitively = registry.meter(MetricRegistry.name(name, "scheduled.repetitively"));
-        this.scheduledOverrun = registry.counter(MetricRegistry.name(name, "scheduled.overrun"));
-        this.percentOfPeriod = registry.histogram(MetricRegistry.name(name, "scheduled.percent-of-period"));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
-        scheduledOnce.mark();
-        return delegate.schedule(new InstrumentedRunnable(command), delay, unit);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
-        scheduledOnce.mark();
-        return delegate.schedule(new InstrumentedCallable<>(callable), delay, unit);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
-        scheduledRepetitively.mark();
-        return delegate.scheduleAtFixedRate(new InstrumentedPeriodicRunnable(command, period, unit), initialDelay, period, unit);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
-        scheduledRepetitively.mark();
-        return delegate.scheduleWithFixedDelay(new InstrumentedRunnable(command), initialDelay, delay, unit);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void shutdown() {
-        delegate.shutdown();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public List<Runnable> shutdownNow() {
-        return delegate.shutdownNow();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isShutdown() {
-        return delegate.isShutdown();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isTerminated() {
-        return delegate.isTerminated();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-        return delegate.awaitTermination(timeout, unit);
-    }
+  /** {@inheritDoc} */
+  @Override
+  public void execute(Runnable command) {
+    submitted.mark();
+    delegate.execute(new InstrumentedRunnable(command));
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> Future<T> submit(Callable<T> task) {
-        submitted.mark();
-        return delegate.submit(new InstrumentedCallable<>(task));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> Future<T> submit(Runnable task, T result) {
-        submitted.mark();
-        return delegate.submit(new InstrumentedRunnable(task), result);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<?> submit(Runnable task) {
-        submitted.mark();
-        return delegate.submit(new InstrumentedRunnable(task));
-    }
+  private class InstrumentedRunnable implements Runnable {
+    private final Runnable command;
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
-        submitted.mark(tasks.size());
-        Collection<? extends Callable<T>> instrumented = instrument(tasks);
-        return delegate.invokeAll(instrumented);
+    InstrumentedRunnable(Runnable command) {
+      this.command = command;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
-        submitted.mark(tasks.size());
-        Collection<? extends Callable<T>> instrumented = instrument(tasks);
-        return delegate.invokeAll(instrumented, timeout, unit);
+    public void run() {
+      running.inc();
+      final Timer.Context context = duration.time();
+      try {
+        command.run();
+      } finally {
+        context.stop();
+        running.dec();
+        completed.mark();
+      }
     }
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
-        submitted.mark(tasks.size());
-        Collection<? extends Callable<T>> instrumented = instrument(tasks);
-        return delegate.invokeAny(instrumented);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-        submitted.mark(tasks.size());
-        Collection<? extends Callable<T>> instrumented = instrument(tasks);
-        return delegate.invokeAny(instrumented, timeout, unit);
-    }
+  private class InstrumentedPeriodicRunnable implements Runnable {
+    private final Runnable command;
+    private final long periodInNanos;
 
-    private <T> Collection<? extends Callable<T>> instrument(Collection<? extends Callable<T>> tasks) {
-        final List<InstrumentedCallable<T>> instrumented = new ArrayList<>(tasks.size());
-        for (Callable<T> task : tasks) {
-            instrumented.add(new InstrumentedCallable<>(task));
-        }
-        return instrumented;
+    InstrumentedPeriodicRunnable(Runnable command, long period, TimeUnit unit) {
+      this.command = command;
+      this.periodInNanos = unit.toNanos(period);
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public void execute(Runnable command) {
-        submitted.mark();
-        delegate.execute(new InstrumentedRunnable(command));
-    }
-
-    private class InstrumentedRunnable implements Runnable {
-        private final Runnable command;
-
-        InstrumentedRunnable(Runnable command) {
-            this.command = command;
-        }
-
-        @Override
-        public void run() {
-            running.inc();
-            final Timer.Context context = duration.time();
-            try {
-                command.run();
-            } finally {
-                context.stop();
-                running.dec();
-                completed.mark();
-            }
+    public void run() {
+      running.inc();
+      final Timer.Context context = duration.time();
+      try {
+        command.run();
+      } finally {
+        final long elapsed = context.stop();
+        running.dec();
+        completed.mark();
+        if (elapsed > periodInNanos) {
+          scheduledOverrun.inc();
         }
+        percentOfPeriod.update((100L * elapsed) / periodInNanos);
+      }
     }
+  }
 
-    private class InstrumentedPeriodicRunnable implements Runnable {
-        private final Runnable command;
-        private final long periodInNanos;
-
-        InstrumentedPeriodicRunnable(Runnable command, long period, TimeUnit unit) {
-            this.command = command;
-            this.periodInNanos = unit.toNanos(period);
-        }
+  private class InstrumentedCallable<T> implements Callable<T> {
+    private final Callable<T> task;
 
-        @Override
-        public void run() {
-            running.inc();
-            final Timer.Context context = duration.time();
-            try {
-                command.run();
-            } finally {
-                final long elapsed = context.stop();
-                running.dec();
-                completed.mark();
-                if (elapsed > periodInNanos) {
-                    scheduledOverrun.inc();
-                }
-                percentOfPeriod.update((100L * elapsed) / periodInNanos);
-            }
-        }
+    InstrumentedCallable(Callable<T> task) {
+      this.task = task;
     }
 
-    private class InstrumentedCallable<T> implements Callable<T> {
-        private final Callable<T> task;
-
-        InstrumentedCallable(Callable<T> task) {
-            this.task = task;
-        }
-
-        @Override
-        public T call() throws Exception {
-            running.inc();
-            final Timer.Context context = duration.time();
-            try {
-                return task.call();
-            } finally {
-                context.stop();
-                running.dec();
-                completed.mark();
-            }
-        }
+    @Override
+    public T call() throws Exception {
+      running.inc();
+      final Timer.Context context = duration.time();
+      try {
+        return task.call();
+      } finally {
+        context.stop();
+        running.dec();
+        completed.mark();
+      }
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/InstrumentedThreadFactory.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/InstrumentedThreadFactory.java
@@ -5,69 +5,67 @@ import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * A {@link ThreadFactory} that monitors the number of threads created, running and terminated.
- * <p>
- * It will register the metrics using the given (or auto-generated) name as classifier, e.g:
+ *
+ * <p>It will register the metrics using the given (or auto-generated) name as classifier, e.g:
  * "your-thread-delegate.created", "your-thread-delegate.running", etc.
  */
 public class InstrumentedThreadFactory implements ThreadFactory {
-    private static final AtomicLong NAME_COUNTER = new AtomicLong();
+  private static final AtomicLong NAME_COUNTER = new AtomicLong();
 
-    private final ThreadFactory delegate;
-    private final Meter created;
-    private final Counter running;
-    private final Meter terminated;
+  private final ThreadFactory delegate;
+  private final Meter created;
+  private final Counter running;
+  private final Meter terminated;
 
-    /**
-     * Wraps a {@link ThreadFactory}, uses a default auto-generated name.
-     *
-     * @param delegate {@link ThreadFactory} to wrap.
-     * @param registry {@link MetricRegistry} that will contain the metrics.
-     */
-    public InstrumentedThreadFactory(ThreadFactory delegate, MetricRegistry registry) {
-        this(delegate, registry, "instrumented-thread-delegate-" + NAME_COUNTER.incrementAndGet());
-    }
+  /**
+   * Wraps a {@link ThreadFactory}, uses a default auto-generated name.
+   *
+   * @param delegate {@link ThreadFactory} to wrap.
+   * @param registry {@link MetricRegistry} that will contain the metrics.
+   */
+  public InstrumentedThreadFactory(ThreadFactory delegate, MetricRegistry registry) {
+    this(delegate, registry, "instrumented-thread-delegate-" + NAME_COUNTER.incrementAndGet());
+  }
 
-    /**
-     * Wraps a {@link ThreadFactory} with an explicit name.
-     *
-     * @param delegate {@link ThreadFactory} to wrap.
-     * @param registry {@link MetricRegistry} that will contain the metrics.
-     * @param name     name for this delegate.
-     */
-    public InstrumentedThreadFactory(ThreadFactory delegate, MetricRegistry registry, String name) {
-        this.delegate = delegate;
-        this.created = registry.meter(MetricRegistry.name(name, "created"));
-        this.running = registry.counter(MetricRegistry.name(name, "running"));
-        this.terminated = registry.meter(MetricRegistry.name(name, "terminated"));
-    }
+  /**
+   * Wraps a {@link ThreadFactory} with an explicit name.
+   *
+   * @param delegate {@link ThreadFactory} to wrap.
+   * @param registry {@link MetricRegistry} that will contain the metrics.
+   * @param name name for this delegate.
+   */
+  public InstrumentedThreadFactory(ThreadFactory delegate, MetricRegistry registry, String name) {
+    this.delegate = delegate;
+    this.created = registry.meter(MetricRegistry.name(name, "created"));
+    this.running = registry.counter(MetricRegistry.name(name, "running"));
+    this.terminated = registry.meter(MetricRegistry.name(name, "terminated"));
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Thread newThread(Runnable runnable) {
-        Runnable wrappedRunnable = new InstrumentedRunnable(runnable);
-        Thread thread = delegate.newThread(wrappedRunnable);
-        created.mark();
-        return thread;
-    }
+  /** {@inheritDoc} */
+  @Override
+  public Thread newThread(Runnable runnable) {
+    Runnable wrappedRunnable = new InstrumentedRunnable(runnable);
+    Thread thread = delegate.newThread(wrappedRunnable);
+    created.mark();
+    return thread;
+  }
 
-    private class InstrumentedRunnable implements Runnable {
-        private final Runnable task;
+  private class InstrumentedRunnable implements Runnable {
+    private final Runnable task;
 
-        InstrumentedRunnable(Runnable task) {
-            this.task = task;
-        }
+    InstrumentedRunnable(Runnable task) {
+      this.task = task;
+    }
 
-        @Override
-        public void run() {
-            running.inc();
-            try {
-                task.run();
-            } finally {
-                running.dec();
-                terminated.mark();
-            }
-        }
+    @Override
+    public void run() {
+      running.inc();
+      try {
+        task.run();
+      } finally {
+        running.dec();
+        terminated.mark();
+      }
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/LockFreeExponentiallyDecayingReservoir.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/LockFreeExponentiallyDecayingReservoir.java
@@ -1,9 +1,10 @@
 package io.dropwizard.metrics5;
 
-import io.dropwizard.metrics5.WeightedSnapshot.WeightedSample;
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Objects.requireNonNull;
 
+import io.dropwizard.metrics5.WeightedSnapshot.WeightedSample;
 import java.time.Duration;
-import java.util.Objects;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
@@ -16,255 +17,255 @@ import java.util.function.BiConsumer;
  * sampling reservoir, exponentially biased towards newer entries.
  *
  * @author <a href="mailto:ckozak@ckozak.net">Carter Kozak</a>
- * @see <a href="http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf">
- * Cormode et al. Forward Decay: A Practical Time Decay Model for Streaming Systems. ICDE '09:
- * Proceedings of the 2009 IEEE International Conference on Data Engineering (2009)</a>
- * <p>
- * {@link LockFreeExponentiallyDecayingReservoir} is based closely on the {@link ExponentiallyDecayingReservoir},
- * however it provides looser guarantees while completely avoiding locks.
- * <p>
- * Looser guarantees:
- * <ul>
- *     <li> Updates which occur concurrently with rescaling may be discarded if the orphaned state node is updated after
- *     rescale has replaced it. This condition has a greater probability as the rescale interval is reduced due to the
- *     increased frequency of rescaling. {@link #rescaleThresholdNanos} values below 30 seconds are not recommended.
- *     <li> Given a small rescale threshold, updates may attempt to rescale into a new bucket, but lose the CAS race
- *     and update into a newer bucket than expected. In these cases the measurement weight is reduced accordingly.
- *     <li>In the worst case, all concurrent threads updating the reservoir may attempt to rescale rather than
- *     a single thread holding an exclusive write lock. It's expected that the configuration is set such that
- *     rescaling is substantially less common than updating at peak load. Even so, when size is reasonably small
- *     it can be more efficient to rescale than to park and context switch.
- * </ul>
+ * @see <a href="http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf">Cormode et al. Forward
+ *     Decay: A Practical Time Decay Model for Streaming Systems. ICDE '09: Proceedings of the 2009
+ *     IEEE International Conference on Data Engineering (2009)</a>
+ *     <p>{@link LockFreeExponentiallyDecayingReservoir} is based closely on the {@link
+ *     ExponentiallyDecayingReservoir}, however it provides looser guarantees while completely
+ *     avoiding locks.
+ *     <p>Looser guarantees:
+ *     <ul>
+ *       <li>Updates which occur concurrently with rescaling may be discarded if the orphaned state
+ *           node is updated after rescale has replaced it. This condition has a greater probability
+ *           as the rescale interval is reduced due to the increased frequency of rescaling. {@link
+ *           #rescaleThresholdNanos} values below 30 seconds are not recommended.
+ *       <li>Given a small rescale threshold, updates may attempt to rescale into a new bucket, but
+ *           lose the CAS race and update into a newer bucket than expected. In these cases the
+ *           measurement weight is reduced accordingly.
+ *       <li>In the worst case, all concurrent threads updating the reservoir may attempt to rescale
+ *           rather than a single thread holding an exclusive write lock. It's expected that the
+ *           configuration is set such that rescaling is substantially less common than updating at
+ *           peak load. Even so, when size is reasonably small it can be more efficient to rescale
+ *           than to park and context switch.
+ *     </ul>
  */
 public final class LockFreeExponentiallyDecayingReservoir implements Reservoir {
 
-    private static final double SECONDS_PER_NANO = .000_000_001D;
-    private static final AtomicReferenceFieldUpdater<LockFreeExponentiallyDecayingReservoir, State> stateUpdater =
-            AtomicReferenceFieldUpdater.newUpdater(LockFreeExponentiallyDecayingReservoir.class, State.class, "state");
+  private static final double SECONDS_PER_NANO = .000_000_001D;
+  private static final AtomicReferenceFieldUpdater<LockFreeExponentiallyDecayingReservoir, State>
+      STATE_UPDATER =
+          AtomicReferenceFieldUpdater.newUpdater(
+              LockFreeExponentiallyDecayingReservoir.class, State.class, "state");
+
+  private final int size;
+  private final long rescaleThresholdNanos;
+  private final Clock clock;
+
+  private volatile State state;
+
+  private static final class State {
 
+    private static final AtomicIntegerFieldUpdater<State> COUNT_UPDATER =
+        AtomicIntegerFieldUpdater.newUpdater(State.class, "count");
+
+    private final double alphaNanos;
     private final int size;
-    private final long rescaleThresholdNanos;
-    private final Clock clock;
-
-    private volatile State state;
-
-    private static final class State {
-
-        private static final AtomicIntegerFieldUpdater<State> countUpdater =
-                AtomicIntegerFieldUpdater.newUpdater(State.class, "count");
-
-        private final double alphaNanos;
-        private final int size;
-        private final long startTick;
-        // Count is updated after samples are successfully added to the map.
-        private final ConcurrentSkipListMap<Double, WeightedSample> values;
-
-        private volatile int count;
-
-        State(
-                double alphaNanos,
-                int size,
-                long startTick,
-                int count,
-                ConcurrentSkipListMap<Double, WeightedSample> values) {
-            this.alphaNanos = alphaNanos;
-            this.size = size;
-            this.startTick = startTick;
-            this.values = values;
-            this.count = count;
-        }
-
-        private void update(long value, long timestampNanos) {
-            double itemWeight = weight(timestampNanos - startTick);
-            double priority = itemWeight / ThreadLocalRandom.current().nextDouble();
-            boolean mapIsFull = count >= size;
-            if (!mapIsFull || values.firstKey() < priority) {
-                addSample(priority, value, itemWeight, mapIsFull);
-            }
-        }
-
-        private void addSample(double priority, long value, double itemWeight, boolean bypassIncrement) {
-            if (values.putIfAbsent(priority, new WeightedSample(value, itemWeight)) == null
-                    && (bypassIncrement || countUpdater.incrementAndGet(this) > size)) {
-                values.pollFirstEntry();
-            }
-        }
-
-        /* "A common feature of the above techniques—indeed, the key technique that
-         * allows us to track the decayed weights efficiently—is that they maintain
-         * counts and other quantities based on g(ti − L), and only scale by g(t − L)
-         * at query time. But while g(ti −L)/g(t−L) is guaranteed to lie between zero
-         * and one, the intermediate values of g(ti − L) could become very large. For
-         * polynomial functions, these values should not grow too large, and should be
-         * effectively represented in practice by floating point values without loss of
-         * precision. For exponential functions, these values could grow quite large as
-         * new values of (ti − L) become large, and potentially exceed the capacity of
-         * common floating point types. However, since the values stored by the
-         * algorithms are linear combinations of g values (scaled sums), they can be
-         * rescaled relative to a new landmark. That is, by the analysis of exponential
-         * decay in Section III-A, the choice of L does not affect the final result. We
-         * can therefore multiply each value based on L by a factor of exp(−α(L′ − L)),
-         * and obtain the correct value as if we had instead computed relative to a new
-         * landmark L′ (and then use this new L′ at query time). This can be done with
-         * a linear pass over whatever data structure is being used."
-         */
-        State rescale(long newTick) {
-            long durationNanos = newTick - startTick;
-            double scalingFactor = Math.exp(-alphaNanos * durationNanos);
-            int newCount = 0;
-            ConcurrentSkipListMap<Double, WeightedSample> newValues = new ConcurrentSkipListMap<>();
-            if (Double.compare(scalingFactor, 0) != 0) {
-                RescalingConsumer consumer = new RescalingConsumer(scalingFactor, newValues);
-                values.forEach(consumer);
-                // make sure the counter is in sync with the number of stored samples.
-                newCount = consumer.count;
-            }
-            // It's possible that more values were added while the map was scanned, those with the
-            // minimum priorities are removed.
-            while (newCount > size) {
-                Objects.requireNonNull(newValues.pollFirstEntry(), "Expected an entry");
-                newCount--;
-            }
-            return new State(alphaNanos, size, newTick, newCount, newValues);
-        }
-
-        private double weight(long durationNanos) {
-            return Math.exp(alphaNanos * durationNanos);
-        }
+    private final long startTick;
+    // Count is updated after samples are successfully added to the map.
+    private final ConcurrentSkipListMap<Double, WeightedSample> values;
+
+    private volatile int count;
+
+    State(
+        double alphaNanos,
+        int size,
+        long startTick,
+        int count,
+        ConcurrentSkipListMap<Double, WeightedSample> values) {
+      this.alphaNanos = alphaNanos;
+      this.size = size;
+      this.startTick = startTick;
+      this.values = values;
+      this.count = count;
     }
 
-    private static final class RescalingConsumer implements BiConsumer<Double, WeightedSample> {
-        private final double scalingFactor;
-        private final ConcurrentSkipListMap<Double, WeightedSample> values;
-        private int count;
-
-        RescalingConsumer(double scalingFactor, ConcurrentSkipListMap<Double, WeightedSample> values) {
-            this.scalingFactor = scalingFactor;
-            this.values = values;
-        }
-
-        @Override
-        public void accept(Double priority, WeightedSample sample) {
-            double newWeight = sample.weight * scalingFactor;
-            if (Double.compare(newWeight, 0) == 0) {
-                return;
-            }
-            WeightedSample newSample = new WeightedSample(sample.value, newWeight);
-            if (values.put(priority * scalingFactor, newSample) == null) {
-                count++;
-            }
-        }
+    private void update(long value, long timestampNanos) {
+      double itemWeight = weight(timestampNanos - startTick);
+      double priority = itemWeight / ThreadLocalRandom.current().nextDouble();
+      boolean mapIsFull = count >= size;
+      if (!mapIsFull || values.firstKey() < priority) {
+        addSample(priority, value, itemWeight, mapIsFull);
+      }
     }
 
-    private LockFreeExponentiallyDecayingReservoir(int size, double alpha, Duration rescaleThreshold, Clock clock) {
-        // Scale alpha to nanoseconds
-        double alphaNanos = alpha * SECONDS_PER_NANO;
-        this.size = size;
-        this.clock = clock;
-        this.rescaleThresholdNanos = rescaleThreshold.toNanos();
-        this.state = new State(alphaNanos, size, clock.getTick(), 0, new ConcurrentSkipListMap<>());
+    private void addSample(
+        double priority, long value, double itemWeight, boolean bypassIncrement) {
+      if (values.putIfAbsent(priority, new WeightedSample(value, itemWeight)) == null
+          && (bypassIncrement || COUNT_UPDATER.incrementAndGet(this) > size)) {
+        values.pollFirstEntry();
+      }
     }
 
-    @Override
-    public int size() {
-        return Math.min(size, state.count);
+    /* "A common feature of the above techniques—indeed, the key technique that
+     * allows us to track the decayed weights efficiently—is that they maintain
+     * counts and other quantities based on g(ti − L), and only scale by g(t − L)
+     * at query time. But while g(ti −L)/g(t−L) is guaranteed to lie between zero
+     * and one, the intermediate values of g(ti − L) could become very large. For
+     * polynomial functions, these values should not grow too large, and should be
+     * effectively represented in practice by floating point values without loss of
+     * precision. For exponential functions, these values could grow quite large as
+     * new values of (ti − L) become large, and potentially exceed the capacity of
+     * common floating point types. However, since the values stored by the
+     * algorithms are linear combinations of g values (scaled sums), they can be
+     * rescaled relative to a new landmark. That is, by the analysis of exponential
+     * decay in Section III-A, the choice of L does not affect the final result. We
+     * can therefore multiply each value based on L by a factor of exp(−α(L′ − L)),
+     * and obtain the correct value as if we had instead computed relative to a new
+     * landmark L′ (and then use this new L′ at query time). This can be done with
+     * a linear pass over whatever data structure is being used."
+     */
+    State rescale(long newTick) {
+      long durationNanos = newTick - startTick;
+      double scalingFactor = Math.exp(-alphaNanos * durationNanos);
+      int newCount = 0;
+      ConcurrentSkipListMap<Double, WeightedSample> newValues = new ConcurrentSkipListMap<>();
+      if (Double.compare(scalingFactor, 0) != 0) {
+        RescalingConsumer consumer = new RescalingConsumer(scalingFactor, newValues);
+        values.forEach(consumer);
+        // make sure the counter is in sync with the number of stored samples.
+        newCount = consumer.count;
+      }
+      // It's possible that more values were added while the map was scanned, those with the
+      // minimum priorities are removed.
+      while (newCount > size) {
+        requireNonNull(newValues.pollFirstEntry(), "Expected an entry");
+        newCount--;
+      }
+      return new State(alphaNanos, size, newTick, newCount, newValues);
     }
 
-    @Override
-    public void update(long value) {
-        long now = clock.getTick();
-        rescaleIfNeeded(now).update(value, now);
+    private double weight(long durationNanos) {
+      return Math.exp(alphaNanos * durationNanos);
     }
+  }
 
-    private State rescaleIfNeeded(long currentTick) {
-        // This method is optimized for size so the check may be quickly inlined.
-        // Rescaling occurs substantially less frequently than the check itself.
-        State stateSnapshot = this.state;
-        if (currentTick - stateSnapshot.startTick >= rescaleThresholdNanos) {
-            return doRescale(currentTick, stateSnapshot);
-        }
-        return stateSnapshot;
-    }
+  private static final class RescalingConsumer implements BiConsumer<Double, WeightedSample> {
+    private final double scalingFactor;
+    private final ConcurrentSkipListMap<Double, WeightedSample> values;
+    private int count;
 
-    private State doRescale(long currentTick, State stateSnapshot) {
-        State newState = stateSnapshot.rescale(currentTick);
-        if (stateUpdater.compareAndSet(this, stateSnapshot, newState)) {
-            // newState successfully installed
-            return newState;
-        }
-        // Otherwise another thread has won the race and we can return the result of a volatile read.
-        // It's possible this has taken so long that another update is required, however that's unlikely
-        // and no worse than the standard race between a rescale and update.
-        return this.state;
+    RescalingConsumer(double scalingFactor, ConcurrentSkipListMap<Double, WeightedSample> values) {
+      this.scalingFactor = scalingFactor;
+      this.values = values;
     }
 
     @Override
-    public Snapshot getSnapshot() {
-        State stateSnapshot = rescaleIfNeeded(clock.getTick());
-        return new WeightedSnapshot(stateSnapshot.values.values());
+    public void accept(Double priority, WeightedSample sample) {
+      double newWeight = sample.weight * scalingFactor;
+      if (Double.compare(newWeight, 0) == 0) {
+        return;
+      }
+      WeightedSample newSample = new WeightedSample(sample.value, newWeight);
+      if (values.put(priority * scalingFactor, newSample) == null) {
+        count++;
+      }
     }
+  }
+
+  private LockFreeExponentiallyDecayingReservoir(
+      int size, double alpha, Duration rescaleThreshold, Clock clock) {
+    // Scale alpha to nanoseconds
+    double alphaNanos = alpha * SECONDS_PER_NANO;
+    this.size = size;
+    this.clock = clock;
+    this.rescaleThresholdNanos = rescaleThreshold.toNanos();
+    this.state = new State(alphaNanos, size, clock.getTick(), 0, new ConcurrentSkipListMap<>());
+  }
+
+  @Override
+  public int size() {
+    return Math.min(size, state.count);
+  }
+
+  @Override
+  public void update(long value) {
+    long now = clock.getTick();
+    rescaleIfNeeded(now).update(value, now);
+  }
+
+  private State rescaleIfNeeded(long currentTick) {
+    // This method is optimized for size so the check may be quickly inlined.
+    // Rescaling occurs substantially less frequently than the check itself.
+    State stateSnapshot = this.state;
+    if (currentTick - stateSnapshot.startTick >= rescaleThresholdNanos) {
+      return doRescale(currentTick, stateSnapshot);
+    }
+    return stateSnapshot;
+  }
+
+  private State doRescale(long currentTick, State stateSnapshot) {
+    State newState = stateSnapshot.rescale(currentTick);
+    if (STATE_UPDATER.compareAndSet(this, stateSnapshot, newState)) {
+      // newState successfully installed
+      return newState;
+    }
+    // Otherwise another thread has won the race and we can return the result of a volatile read.
+    // It's possible this has taken so long that another update is required, however that's unlikely
+    // and no worse than the standard race between a rescale and update.
+    return this.state;
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    State stateSnapshot = rescaleIfNeeded(clock.getTick());
+    return new WeightedSnapshot(stateSnapshot.values.values());
+  }
+
+  public static Builder builder() {
+    return new Builder();
+  }
+
+  /**
+   * By default this uses a size of 1028 elements, which offers a 99.9% confidence level with a 5%
+   * margin of error assuming a normal distribution, and an alpha factor of 0.015, which heavily
+   * biases the reservoir to the past 5 minutes of measurements.
+   */
+  public static final class Builder {
+    private static final int DEFAULT_SIZE = 1028;
+    private static final double DEFAULT_ALPHA = 0.015D;
+    private static final Duration DEFAULT_RESCALE_THRESHOLD = Duration.ofHours(1);
+
+    private int size = DEFAULT_SIZE;
+    private double alpha = DEFAULT_ALPHA;
+    private Duration rescaleThreshold = DEFAULT_RESCALE_THRESHOLD;
+    private Clock clock = Clock.defaultClock();
+
+    private Builder() {}
 
-    public static Builder builder() {
-        return new Builder();
+    /**
+     * Maximum number of samples to keep in the reservoir. Once this number is reached older samples
+     * are replaced (based on weight, with some amount of random jitter).
+     */
+    public Builder size(int value) {
+      checkArgument(
+          value > 0, "LockFreeExponentiallyDecayingReservoir size must be positive: %s", value);
+      this.size = value;
+      return this;
     }
 
     /**
-     * By default this uses a size of 1028 elements, which offers a 99.9%
-     * confidence level with a 5% margin of error assuming a normal distribution, and an alpha
-     * factor of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.
+     * Alpha is the exponential decay factor. Higher values bias results more heavily toward newer
+     * values.
      */
-    public static final class Builder {
-        private static final int DEFAULT_SIZE = 1028;
-        private static final double DEFAULT_ALPHA = 0.015D;
-        private static final Duration DEFAULT_RESCALE_THRESHOLD = Duration.ofHours(1);
-
-        private int size = DEFAULT_SIZE;
-        private double alpha = DEFAULT_ALPHA;
-        private Duration rescaleThreshold = DEFAULT_RESCALE_THRESHOLD;
-        private Clock clock = Clock.defaultClock();
-
-        private Builder() {
-        }
-
-        /**
-         * Maximum number of samples to keep in the reservoir. Once this number is reached older samples are
-         * replaced (based on weight, with some amount of random jitter).
-         */
-        public Builder size(int value) {
-            if (value <= 0) {
-                throw new IllegalArgumentException(
-                        "LockFreeExponentiallyDecayingReservoir size must be positive: " + value);
-            }
-            this.size = value;
-            return this;
-        }
-
-        /**
-         * Alpha is the exponential decay factor. Higher values bias results more heavily toward newer values.
-         */
-        public Builder alpha(double value) {
-            this.alpha = value;
-            return this;
-        }
-
-        /**
-         * Interval at which this reservoir is rescaled.
-         */
-        public Builder rescaleThreshold(Duration value) {
-            this.rescaleThreshold = Objects.requireNonNull(value, "rescaleThreshold is required");
-            return this;
-        }
-
-        /**
-         * Clock instance used for decay.
-         */
-        public Builder clock(Clock value) {
-            this.clock = Objects.requireNonNull(value, "clock is required");
-            return this;
-        }
-
-        public Reservoir build() {
-            return new LockFreeExponentiallyDecayingReservoir(size, alpha, rescaleThreshold, clock);
-        }
+    public Builder alpha(double value) {
+      this.alpha = value;
+      return this;
+    }
+
+    /** Interval at which this reservoir is rescaled. */
+    public Builder rescaleThreshold(Duration value) {
+      this.rescaleThreshold = requireNonNull(value, "rescaleThreshold is required");
+      return this;
+    }
+
+    /** Clock instance used for decay. */
+    public Builder clock(Clock value) {
+      this.clock = requireNonNull(value, "clock is required");
+      return this;
+    }
+
+    public Reservoir build() {
+      return new LockFreeExponentiallyDecayingReservoir(size, alpha, rescaleThreshold, clock);
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Meter.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Meter.java
@@ -4,108 +4,104 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.LongAdder;
 
 /**
- * A meter metric which measures mean throughput and one-, five-, and fifteen-minute
- * moving average throughputs.
+ * A meter metric which measures mean throughput and one-, five-, and fifteen-minute moving average
+ * throughputs.
  *
  * @see MovingAverages
  */
 public class Meter implements Metered {
 
-    private final MovingAverages movingAverages;
-    private final LongAdder count = new LongAdder();
-    private final long startTime;
-    private final Clock clock;
+  private final MovingAverages movingAverages;
+  private final LongAdder count = new LongAdder();
+  private final long startTime;
+  private final Clock clock;
 
-    /**
-     * Creates a new {@link Meter}.
-     *
-     * @param movingAverages the {@link MovingAverages} implementation to use
-     */
-    public Meter(MovingAverages movingAverages) {
-        this(movingAverages, Clock.defaultClock());
-    }
+  /**
+   * Creates a new {@link Meter}.
+   *
+   * @param movingAverages the {@link MovingAverages} implementation to use
+   */
+  public Meter(MovingAverages movingAverages) {
+    this(movingAverages, Clock.defaultClock());
+  }
 
-    /**
-     * Creates a new {@link Meter}.
-     */
-    public Meter() {
-        this(Clock.defaultClock());
-    }
+  /** Creates a new {@link Meter}. */
+  public Meter() {
+    this(Clock.defaultClock());
+  }
 
-    /**
-     * Creates a new {@link Meter}.
-     *
-     * @param clock the clock to use for the meter ticks
-     */
-    public Meter(Clock clock) {
-        this(new ExponentialMovingAverages(clock), clock);
-    }
+  /**
+   * Creates a new {@link Meter}.
+   *
+   * @param clock the clock to use for the meter ticks
+   */
+  public Meter(Clock clock) {
+    this(new ExponentialMovingAverages(clock), clock);
+  }
 
-    /**
-     * Creates a new {@link Meter}.
-     *
-     * @param movingAverages the {@link MovingAverages} implementation to use
-     * @param clock          the clock to use for the meter ticks
-     */
-    public Meter(MovingAverages movingAverages, Clock clock) {
-        this.movingAverages = movingAverages;
-        this.clock = clock;
-        this.startTime = this.clock.getTick();
-    }
+  /**
+   * Creates a new {@link Meter}.
+   *
+   * @param movingAverages the {@link MovingAverages} implementation to use
+   * @param clock the clock to use for the meter ticks
+   */
+  public Meter(MovingAverages movingAverages, Clock clock) {
+    this.movingAverages = movingAverages;
+    this.clock = clock;
+    this.startTime = this.clock.getTick();
+  }
 
-    /**
-     * Mark the occurrence of an event.
-     */
-    public void mark() {
-        mark(1);
-    }
+  /** Mark the occurrence of an event. */
+  public void mark() {
+    mark(1);
+  }
 
-    /**
-     * Mark the occurrence of a given number of events.
-     *
-     * @param n the number of events
-     */
-    public void mark(long n) {
-        movingAverages.tickIfNecessary();
-        count.add(n);
-        movingAverages.update(n);
-    }
+  /**
+   * Mark the occurrence of a given number of events.
+   *
+   * @param n the number of events
+   */
+  public void mark(long n) {
+    movingAverages.tickIfNecessary();
+    count.add(n);
+    movingAverages.update(n);
+  }
 
-    @Override
-    public long getCount() {
-        return count.sum();
-    }
+  @Override
+  public long getCount() {
+    return count.sum();
+  }
 
-    @Override
-    public long getSum() {
-        return movingAverages.getSum();
-    }
+  @Override
+  public long getSum() {
+    return movingAverages.getSum();
+  }
 
-    @Override
-    public double getFifteenMinuteRate() {
-        movingAverages.tickIfNecessary();
-        return movingAverages.getM15Rate();
-    }
+  @Override
+  public double getFifteenMinuteRate() {
+    movingAverages.tickIfNecessary();
+    return movingAverages.getM15Rate();
+  }
 
-    @Override
-    public double getFiveMinuteRate() {
-        movingAverages.tickIfNecessary();
-        return movingAverages.getM5Rate();
-    }
+  @Override
+  public double getFiveMinuteRate() {
+    movingAverages.tickIfNecessary();
+    return movingAverages.getM5Rate();
+  }
 
-    @Override
-    public double getMeanRate() {
-        if (getCount() == 0) {
-            return 0.0;
-        } else {
-            final double elapsed = clock.getTick() - startTime;
-            return getCount() / elapsed * TimeUnit.SECONDS.toNanos(1);
-        }
+  @Override
+  public double getMeanRate() {
+    if (getCount() == 0) {
+      return 0.0;
+    } else {
+      final double elapsed = clock.getTick() - startTime;
+      return getCount() / elapsed * TimeUnit.SECONDS.toNanos(1);
     }
+  }
 
-    @Override
-    public double getOneMinuteRate() {
-        movingAverages.tickIfNecessary();
-        return movingAverages.getM1Rate();
-    }
+  @Override
+  public double getOneMinuteRate() {
+    movingAverages.tickIfNecessary();
+    return movingAverages.getM1Rate();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Metered.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Metered.java
@@ -1,56 +1,54 @@
 package io.dropwizard.metrics5;
 
-/**
- * An object which maintains mean and moving average rates.
- */
+/** An object which maintains mean and moving average rates. */
 public interface Metered extends Metric, Counting, Summing {
-    /**
-     * Returns the number of events which have been marked.
-     *
-     * @return the number of events which have been marked
-     */
-    @Override
-    long getCount();
+  /**
+   * Returns the number of events which have been marked.
+   *
+   * @return the number of events which have been marked
+   */
+  @Override
+  long getCount();
 
-    /**
-     * Returns the sum of events which have been marked.
-     *
-     * @return the sum of events which have been marked
-     */
-    @Override
-    long getSum();
+  /**
+   * Returns the sum of events which have been marked.
+   *
+   * @return the sum of events which have been marked
+   */
+  @Override
+  long getSum();
 
-    /**
-     * Returns the fifteen-minute moving average rate at which events have
-     * occurred since the meter was created.
-     *
-     * @return the fifteen-minute moving average rate at which events have
-     * occurred since the meter was created
-     */
-    double getFifteenMinuteRate();
+  /**
+   * Returns the fifteen-minute moving average rate at which events have occurred since the meter
+   * was created.
+   *
+   * @return the fifteen-minute moving average rate at which events have occurred since the meter
+   *     was created
+   */
+  double getFifteenMinuteRate();
 
-    /**
-     * Returns the five-minute moving average rate at which events have
-     * occurred since the meter was created.
-     *
-     * @return the five-minute moving average rate at which events have
-     * occurred since the meter was created
-     */
-    double getFiveMinuteRate();
+  /**
+   * Returns the five-minute moving average rate at which events have occurred since the meter was
+   * created.
+   *
+   * @return the five-minute moving average rate at which events have occurred since the meter was
+   *     created
+   */
+  double getFiveMinuteRate();
 
-    /**
-     * Returns the mean rate at which events have occurred since the meter was created.
-     *
-     * @return the mean rate at which events have occurred since the meter was created
-     */
-    double getMeanRate();
+  /**
+   * Returns the mean rate at which events have occurred since the meter was created.
+   *
+   * @return the mean rate at which events have occurred since the meter was created
+   */
+  double getMeanRate();
 
-    /**
-     * Returns the one-minute moving average rate at which events have
-     * occurred since the meter was created.
-     *
-     * @return the one-minute moving average rate at which events have
-     * occurred since the meter was created
-     */
-    double getOneMinuteRate();
+  /**
+   * Returns the one-minute moving average rate at which events have occurred since the meter was
+   * created.
+   *
+   * @return the one-minute moving average rate at which events have occurred since the meter was
+   *     created
+   */
+  double getOneMinuteRate();
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Metric.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Metric.java
@@ -1,8 +1,4 @@
 package io.dropwizard.metrics5;
 
-/**
- * A tag interface to indicate that a class is a metric.
- */
-public interface Metric {
-
-}
+/** A tag interface to indicate that a class is a metric. */
+public interface Metric {}
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/MetricAttribute.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/MetricAttribute.java
@@ -1,34 +1,31 @@
 package io.dropwizard.metrics5;
 
-/**
- * Represents attributes of metrics which can be reported.
- */
+/** Represents attributes of metrics which can be reported. */
 public enum MetricAttribute {
+  MAX("max"),
+  MEAN("mean"),
+  MIN("min"),
+  STDDEV("stddev"),
+  P50("p50"),
+  P75("p75"),
+  P95("p95"),
+  P98("p98"),
+  P99("p99"),
+  P999("p999"),
+  COUNT("count"),
+  SUM("sum"),
+  M1_RATE("m1_rate"),
+  M5_RATE("m5_rate"),
+  M15_RATE("m15_rate"),
+  MEAN_RATE("mean_rate");
 
-    MAX("max"),
-    MEAN("mean"),
-    MIN("min"),
-    STDDEV("stddev"),
-    P50("p50"),
-    P75("p75"),
-    P95("p95"),
-    P98("p98"),
-    P99("p99"),
-    P999("p999"),
-    COUNT("count"),
-    SUM("sum"),
-    M1_RATE("m1_rate"),
-    M5_RATE("m5_rate"),
-    M15_RATE("m15_rate"),
-    MEAN_RATE("mean_rate");
+  private final String code;
 
-    private final String code;
+  MetricAttribute(String code) {
+    this.code = code;
+  }
 
-    MetricAttribute(String code) {
-        this.code = code;
-    }
-
-    public String getCode() {
-        return code;
-    }
+  public String getCode() {
+    return code;
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/MetricFilter.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/MetricFilter.java
@@ -1,32 +1,28 @@
 package io.dropwizard.metrics5;
 
-/**
- * A filter used to determine whether or not a metric should be reported, among other things.
- */
+/** A filter used to determine whether or not a metric should be reported, among other things. */
 public interface MetricFilter {
-    /**
-     * Matches all metrics, regardless of type or name.
-     */
-    MetricFilter ALL = (name, metric) -> true;
+  /** Matches all metrics, regardless of type or name. */
+  MetricFilter ALL = (name, metric) -> true;
 
-    static MetricFilter startsWith(String prefix) {
-        return (name, metric) -> name.getKey().startsWith(prefix);
-    }
+  static MetricFilter startsWith(String prefix) {
+    return (name, metric) -> name.getKey().startsWith(prefix);
+  }
 
-    static MetricFilter endsWith(String suffix) {
-        return (name, metric) -> name.getKey().endsWith(suffix);
-    }
+  static MetricFilter endsWith(String suffix) {
+    return (name, metric) -> name.getKey().endsWith(suffix);
+  }
 
-    static MetricFilter contains(String substring) {
-        return (name, metric) -> name.getKey().contains(substring);
-    }
+  static MetricFilter contains(String substring) {
+    return (name, metric) -> name.getKey().contains(substring);
+  }
 
-    /**
-     * Returns {@code true} if the metric matches the filter; {@code false} otherwise.
-     *
-     * @param name   the metric's name
-     * @param metric the metric
-     * @return {@code true} if the metric matches the filter
-     */
-    boolean matches(MetricName name, Metric metric);
+  /**
+   * Returns {@code true} if the metric matches the filter; {@code false} otherwise.
+   *
+   * @param name the metric's name
+   * @param metric the metric
+   * @return {@code true} if the metric matches the filter
+   */
+  boolean matches(MetricName name, Metric metric);
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/MetricName.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/MetricName.java
@@ -1,213 +1,212 @@
 package io.dropwizard.metrics5;
 
-import java.util.Collections;
-import java.util.Comparator;
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Map.Entry.comparingByKey;
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.joining;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableMap;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Objects;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
- * A metric name with the ability to include semantic tags.
- * This replaces the previous style where metric names where strictly dot-separated strings.
+ * A metric name with the ability to include semantic tags. This replaces the previous style where
+ * metric names where strictly dot-separated strings.
  */
 public class MetricName implements Comparable<MetricName> {
 
-    private static final String SEPARATOR = ".";
-    private static final Map<String, String> EMPTY_TAGS = Collections.emptyMap();
-    static final MetricName EMPTY = new MetricName("", EMPTY_TAGS);
-
-    /**
-     * Returns an empty metric name.
-     *
-     * @return an empty metric name.
-     */
-    public static MetricName empty() {
-        return EMPTY;
+  private static final String SEPARATOR = ".";
+  private static final Map<String, String> EMPTY_TAGS = ImmutableMap.of();
+  static final MetricName EMPTY = new MetricName("", EMPTY_TAGS);
+
+  /**
+   * Returns an empty metric name.
+   *
+   * @return an empty metric name.
+   */
+  public static MetricName empty() {
+    return EMPTY;
+  }
+
+  private final String key;
+  private final Map<String, String> tags;
+
+  public MetricName(String key, Map<String, String> tags) {
+    this.key = requireNonNull(key);
+    this.tags = tags.isEmpty() ? EMPTY_TAGS : unmodifiableSortedCopy(tags);
+  }
+
+  public String getKey() {
+    return key;
+  }
+
+  /**
+   * Returns the tags, sorted by key.
+   *
+   * @return the tags (immutable), sorted by key.
+   */
+  public Map<String, String> getTags() {
+    return tags;
+  }
+
+  /**
+   * Build the MetricName that is this with another path appended to it. The new MetricName inherits
+   * the tags of this one.
+   *
+   * @param parts The extra path elements to add to the new metric.
+   * @return A new metric name relative to the original by the path specified in parts.
+   */
+  public MetricName resolve(String... parts) {
+    if (parts == null || parts.length == 0) {
+      return this;
     }
 
-    private final String key;
-    private final Map<String, String> tags;
-
-    public MetricName(String key, Map<String, String> tags) {
-        this.key = Objects.requireNonNull(key);
-        this.tags = tags.isEmpty() ? EMPTY_TAGS : unmodifiableSortedCopy(tags);
-    }
-
-    public String getKey() {
-        return key;
-    }
-
-    /**
-     * Returns the tags, sorted by key.
-     *
-     * @return the tags (immutable), sorted by key.
-     */
-    public Map<String, String> getTags() {
-        return tags;
+    String newKey =
+        Stream.concat(Stream.of(key), Arrays.stream(parts))
+            .filter(s -> !Strings.isNullOrEmpty(s))
+            .collect(joining(SEPARATOR));
+    return new MetricName(newKey, tags);
+  }
+
+  /**
+   * Add tags to a metric name and return the newly created MetricName.
+   *
+   * @param add Tags to add.
+   * @return A newly created metric name with the specified tags associated with it.
+   */
+  public MetricName tagged(Map<String, String> add) {
+    final Map<String, String> newTags = new HashMap<>();
+    newTags.putAll(tags);
+    newTags.putAll(add);
+    return new MetricName(key, newTags);
+  }
+
+  /**
+   * Same as {@link #tagged(Map)}, but takes a variadic list of arguments.
+   *
+   * @param pairs An even list of strings acting as key-value pairs.
+   * @return A newly created metric name with the specified tags associated with it.
+   * @see #tagged(Map)
+   */
+  public MetricName tagged(String... pairs) {
+    if (pairs == null || pairs.length == 0) {
+      return this;
     }
 
-    /**
-     * Build the MetricName that is this with another path appended to it.
-     * The new MetricName inherits the tags of this one.
-     *
-     * @param parts The extra path elements to add to the new metric.
-     * @return A new metric name relative to the original by the path specified
-     * in parts.
-     */
-    public MetricName resolve(String... parts) {
-        if (parts == null || parts.length == 0) {
-            return this;
-        }
-
-        String newKey = Stream.concat(Stream.of(key), Stream.of(parts))
-                .filter(s -> s != null && !s.isEmpty())
-                .collect(Collectors.joining(SEPARATOR));
-        return new MetricName(newKey, tags);
-    }
+    checkArgument(pairs.length % 2 == 0, "Argument count must be even");
 
-    /**
-     * Add tags to a metric name and return the newly created MetricName.
-     *
-     * @param add Tags to add.
-     * @return A newly created metric name with the specified tags associated with it.
-     */
-    public MetricName tagged(Map<String, String> add) {
-        final Map<String, String> newTags = new HashMap<>();
-        newTags.putAll(tags);
-        newTags.putAll(add);
-        return new MetricName(key, newTags);
+    final Map<String, String> add = new HashMap<>();
+    for (int i = 0; i < pairs.length; i += 2) {
+      add.put(pairs[i], pairs[i + 1]);
     }
 
-    /**
-     * Same as {@link #tagged(Map)}, but takes a variadic list of arguments.
-     *
-     * @param pairs An even list of strings acting as key-value pairs.
-     * @return A newly created metric name with the specified tags associated with it.
-     * @see #tagged(Map)
-     */
-    public MetricName tagged(String... pairs) {
-        if (pairs == null || pairs.length == 0) {
-            return this;
-        }
-
-        if (pairs.length % 2 != 0) {
-            throw new IllegalArgumentException("Argument count must be even");
-        }
-
-        final Map<String, String> add = new HashMap<>();
-        for (int i = 0; i < pairs.length; i += 2) {
-            add.put(pairs[i], pairs[i + 1]);
-        }
-
-        return tagged(add);
+    return tagged(add);
+  }
+
+  /**
+   * Build the MetricName that is this with another path and tags appended to it.
+   *
+   * <p>Semantically equivalent to: <br>
+   * <code>this.resolve(append.getKey()).tagged(append.getTags());</code>
+   *
+   * @param append The extra name element to add to the new metric.
+   * @return A new metric name with path appended to the original, and tags included from both
+   *     names.
+   */
+  public MetricName append(MetricName append) {
+    return resolve(append.key).tagged(append.tags);
+  }
+
+  /**
+   * Build a new metric name using the specific path components.
+   *
+   * <p>Equivalent to:<br>
+   * <code>MetricName.empty().resolve(parts);</code>
+   *
+   * @param parts Path of the new metric name.
+   * @return A newly created metric name with the specified path.
+   */
+  public static MetricName build(String... parts) {
+    return EMPTY.resolve(parts);
+  }
+
+  @Override
+  public String toString() {
+    return tags.isEmpty() ? key : key + tags;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
     }
-
-    /**
-     * Build the MetricName that is this with another path and tags appended to it.
-     *
-     * <p>
-     * Semantically equivalent to: <br>
-     * <code>this.resolve(append.getKey()).tagged(append.getTags());</code>
-     *
-     * @param append The extra name element to add to the new metric.
-     * @return A new metric name with path appended to the original,
-     * and tags included from both names.
-     */
-    public MetricName append(MetricName append) {
-        return resolve(append.key).tagged(append.tags);
+    if (!(o instanceof MetricName)) {
+      return false;
     }
-
-    /**
-     * Build a new metric name using the specific path components.
-     *
-     * <p>
-     * Equivalent to:<br>
-     * <code>MetricName.empty().resolve(parts);</code>
-     *
-     * @param parts Path of the new metric name.
-     * @return A newly created metric name with the specified path.
-     **/
-    public static MetricName build(String... parts) {
-        return EMPTY.resolve(parts);
+    MetricName that = (MetricName) o;
+    return Objects.equals(key, that.key) && Objects.equals(tags, that.tags);
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(key, tags);
+  }
+
+  @Override
+  public int compareTo(MetricName o) {
+    int c = key.compareTo(o.getKey());
+    if (c != 0) {
+      return c;
     }
 
-    @Override
-    public String toString() {
-        return tags.isEmpty() ? key : key + tags;
+    return compareTags(tags, o.getTags());
+  }
+
+  private int compareTags(Map<String, String> left, Map<String, String> right) {
+    Iterator<Map.Entry<String, String>> lit = left.entrySet().iterator();
+    Iterator<Map.Entry<String, String>> rit = right.entrySet().iterator();
+
+    while (lit.hasNext() && rit.hasNext()) {
+      Map.Entry<String, String> l = lit.next();
+      Map.Entry<String, String> r = rit.next();
+      int c = l.getKey().compareTo(r.getKey());
+      if (c != 0) {
+        return c;
+      }
+      if (l.getValue() == null && r.getValue() == null) {
+        return 0;
+      } else if (l.getValue() == null) {
+        return -1;
+      } else if (r.getValue() == null) {
+        return 1;
+      } else {
+        c = l.getValue().compareTo(r.getValue());
+      }
+      if (c != 0) {
+        return c;
+      }
     }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (!(o instanceof MetricName)) {
-            return false;
-        }
-        MetricName that = (MetricName) o;
-        return Objects.equals(key, that.key) &&
-                Objects.equals(tags, that.tags);
+    if (lit.hasNext()) {
+      return 1;
+    } else if (rit.hasNext()) {
+      return -1;
+    } else {
+      return 0;
     }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(key, tags);
-    }
-
-    @Override
-    public int compareTo(MetricName o) {
-        int c = key.compareTo(o.getKey());
-        if (c != 0) {
-            return c;
-        }
-
-        return compareTags(tags, o.getTags());
-    }
-
-    private int compareTags(Map<String, String> left, Map<String, String> right) {
-        Iterator<Map.Entry<String, String>> lit = left.entrySet().iterator();
-        Iterator<Map.Entry<String, String>> rit = right.entrySet().iterator();
-
-        while (lit.hasNext() && rit.hasNext()) {
-            Map.Entry<String, String> l = lit.next();
-            Map.Entry<String, String> r = rit.next();
-            int c = l.getKey().compareTo(r.getKey());
-            if (c != 0) {
-                return c;
-            }
-            if (l.getValue() == null && r.getValue() == null) {
-                return 0;
-            } else if (l.getValue() == null) {
-                return -1;
-            } else if (r.getValue() == null) {
-                return 1;
-            } else {
-                c = l.getValue().compareTo(r.getValue());
-            }
-            if (c != 0) {
-                return c;
-            }
-        }
-        if (lit.hasNext()) {
-            return 1;
-        } else if (rit.hasNext()) {
-            return -1;
-        } else {
-            return 0;
-        }
-    }
-
-    private static <K extends Comparable<K>, V> Map<K, V> unmodifiableSortedCopy(Map<K, V> map) {
-        LinkedHashMap<K, V> sorted = new LinkedHashMap<>();
-        map.entrySet()
-                .stream()
-                .sorted(Comparator.comparing(Map.Entry::getKey))
-                .forEach(e -> sorted.put(e.getKey(), e.getValue()));
-        return Collections.unmodifiableMap(sorted);
-    }
-
+  }
+
+  private static <K extends Comparable<K>, V> Map<K, V> unmodifiableSortedCopy(Map<K, V> map) {
+    LinkedHashMap<K, V> sorted = new LinkedHashMap<>();
+    map.entrySet().stream()
+        .sorted(comparingByKey())
+        .forEach(e -> sorted.put(e.getKey(), e.getValue()));
+    return unmodifiableMap(sorted);
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/MetricRegistry.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/MetricRegistry.java
@@ -1,6 +1,10 @@
 package io.dropwizard.metrics5;
 
-import java.util.Collections;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Collections.unmodifiableSortedMap;
+import static java.util.Collections.unmodifiableSortedSet;
+import static java.util.Objects.requireNonNull;
+
 import java.util.List;
 import java.util.Map;
 import java.util.SortedMap;
@@ -11,701 +15,698 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 
-/**
- * A registry of metric instances.
- */
+/** A registry of metric instances. */
 public class MetricRegistry implements MetricSet {
 
-    /**
-     * Concatenates elements to form a dotted name, eliding any null values or empty strings.
-     *
-     * @param name  the first element of the name
-     * @param names the remaining elements of the name
-     * @return {@code name} and {@code names} concatenated by periods
-     */
-    public static MetricName name(String name, String... names) {
-        if (names == null) {
-            return MetricName.build(name);
-        }
-
-        final String[] parts = new String[names.length + 1];
-        parts[0] = name;
-        System.arraycopy(names, 0, parts, 1, names.length);
-        return MetricName.build(parts);
-    }
-
-    /**
-     * Concatenates a class name and elements to form a dotted name, eliding any null values or
-     * empty strings.
-     *
-     * @param klass the first element of the name
-     * @param names the remaining elements of the name
-     * @return {@code klass} and {@code names} concatenated by periods
-     */
-    public static MetricName name(Class<?> klass, String... names) {
-        return name(klass.getName(), names);
-    }
-
-    private final ConcurrentMap<MetricName, Metric> metrics;
-    private final List<MetricRegistryListener> listeners;
-
-    /**
-     * Creates a new {@link MetricRegistry}.
-     */
-    public MetricRegistry() {
-        this.metrics = buildMap();
-        this.listeners = new CopyOnWriteArrayList<>();
-    }
-
-    /**
-     * Creates a new {@link ConcurrentMap} implementation for use inside the registry. Override this
-     * to create a {@link MetricRegistry} with space- or time-bounded metric lifecycles, for
-     * example.
-     *
-     * @return a new {@link ConcurrentMap}
-     */
-    protected ConcurrentMap<MetricName, Metric> buildMap() {
-        return new ConcurrentHashMap<>();
-    }
-
-    /**
-     * See {@link #registerGauge(MetricName, Gauge)}
-     */
-    public <T> Gauge<T> registerGauge(String name, Gauge<T> metric) throws IllegalArgumentException {
-        return register(MetricName.build(name), metric);
-    }
-
-    /**
-     * Given a {@link Gauge}, registers it under the given name and returns it
-     *
-     * @param name the name of the gauge
-     * @param <T>  the type of the gauge's value
-     * @return the registered {@link Gauge}
-     * @since 4.2.10
-     */
-    public <T> Gauge<T> registerGauge(MetricName name, Gauge<T> metric) throws IllegalArgumentException {
-        return register(name, metric);
-    }
-
-    /**
-     * Given a {@link Metric}, registers it under the given name.
-     *
-     * @param name   the name of the metric
-     * @param metric the metric
-     * @param <T>    the type of the metric
-     * @return {@code metric}
-     * @throws IllegalArgumentException if the name is already registered or metric variable is null
-     */
-    public <T extends Metric> T register(MetricName name, T metric) throws IllegalArgumentException {
-        if (metric == null) {
-            throw new NullPointerException("metric == null");
-        }
-
-        if (metric instanceof MetricRegistry) {
-            final MetricRegistry childRegistry = (MetricRegistry) metric;
-            final MetricName childName = name;
-            childRegistry.addListener(new MetricRegistryListener() {
-                @Override
-                public void onGaugeAdded(MetricName name, Gauge<?> gauge) {
-                    register(childName.append(name), gauge);
-                }
-
-                @Override
-                public void onGaugeRemoved(MetricName name) {
-                    remove(childName.append(name));
-                }
-
-                @Override
-                public void onCounterAdded(MetricName name, Counter counter) {
-                    register(childName.append(name), counter);
-                }
-
-                @Override
-                public void onCounterRemoved(MetricName name) {
-                    remove(childName.append(name));
-                }
-
-                @Override
-                public void onHistogramAdded(MetricName name, Histogram histogram) {
-                    register(childName.append(name), histogram);
-                }
-
-                @Override
-                public void onHistogramRemoved(MetricName name) {
-                    remove(childName.append(name));
-                }
-
-                @Override
-                public void onMeterAdded(MetricName name, Meter meter) {
-                    register(childName.append(name), meter);
-                }
-
-                @Override
-                public void onMeterRemoved(MetricName name) {
-                    remove(childName.append(name));
-                }
-
-                @Override
-                public void onTimerAdded(MetricName name, Timer timer) {
-                    register(childName.append(name), timer);
-                }
-
-                @Override
-                public void onTimerRemoved(MetricName name) {
-                    remove(childName.append(name));
-                }
-            });
-        } else if (metric instanceof MetricSet) {
-            registerAll(name, (MetricSet) metric);
-        } else {
-            final Metric existing = metrics.putIfAbsent(name, metric);
-            if (existing == null) {
-                onMetricAdded(name, metric);
-            } else {
-                throw new IllegalArgumentException("A metric named " + name + " already exists");
-            }
-        }
-        return metric;
-    }
-
-    /**
-     * Given a metric set, registers them.
-     *
-     * @param metrics a set of metrics
-     * @throws IllegalArgumentException if any of the names are already registered
-     */
-    public void registerAll(MetricSet metrics) throws IllegalArgumentException {
-        registerAll(null, metrics);
-    }
-
-    /**
-     * See {@link #counter(MetricName)}
-     */
-    public Counter counter(String name) {
-        return getOrAdd(MetricName.build(name), MetricBuilder.COUNTERS);
-    }
-
-    /**
-     * Return the {@link Counter} registered under this name; or create and register
-     * a new {@link Counter} if none is registered.
-     *
-     * @param name the name of the metric
-     * @return a new or pre-existing {@link Counter}
-     */
-    public Counter counter(MetricName name) {
-        return getOrAdd(name, MetricBuilder.COUNTERS);
-    }
-
-    /**
-     * See {@link #histogram(MetricName)}
-     */
-    public Histogram histogram(String name) {
-        return getOrAdd(MetricName.build(name), MetricBuilder.HISTOGRAMS);
-    }
-
-    /**
-     * Return the {@link Counter} registered under this name; or create and register
-     * a new {@link Counter} using the provided MetricSupplier if none is registered.
-     *
-     * @param name     the name of the metric
-     * @param supplier a MetricSupplier that can be used to manufacture a counter.
-     * @return a new or pre-existing {@link Counter}
-     */
-    public <T extends Counter> T counter(MetricName name, final MetricSupplier<T> supplier) {
-        return getOrAdd(name, new MetricBuilder<T>() {
+  /**
+   * Concatenates elements to form a dotted name, eliding any null values or empty strings.
+   *
+   * @param name the first element of the name
+   * @param names the remaining elements of the name
+   * @return {@code name} and {@code names} concatenated by periods
+   */
+  public static MetricName name(String name, String... names) {
+    if (names == null) {
+      return MetricName.build(name);
+    }
+
+    final String[] parts = new String[names.length + 1];
+    parts[0] = name;
+    System.arraycopy(names, 0, parts, 1, names.length);
+    return MetricName.build(parts);
+  }
+
+  /**
+   * Concatenates a class name and elements to form a dotted name, eliding any null values or empty
+   * strings.
+   *
+   * @param klass the first element of the name
+   * @param names the remaining elements of the name
+   * @return {@code klass} and {@code names} concatenated by periods
+   */
+  public static MetricName name(Class<?> klass, String... names) {
+    return name(klass.getName(), names);
+  }
+
+  private final ConcurrentMap<MetricName, Metric> metrics;
+  private final List<MetricRegistryListener> listeners;
+
+  /** Creates a new {@link MetricRegistry}. */
+  public MetricRegistry() {
+    this.metrics = buildMap();
+    this.listeners = new CopyOnWriteArrayList<>();
+  }
+
+  /**
+   * Creates a new {@link ConcurrentMap} implementation for use inside the registry. Override this
+   * to create a {@link MetricRegistry} with space- or time-bounded metric lifecycles, for example.
+   *
+   * @return a new {@link ConcurrentMap}
+   */
+  protected ConcurrentMap<MetricName, Metric> buildMap() {
+    return new ConcurrentHashMap<>();
+  }
+
+  /** See {@link #registerGauge(MetricName, Gauge)} */
+  public <T> Gauge<T> registerGauge(String name, Gauge<T> metric) throws IllegalArgumentException {
+    return register(MetricName.build(name), metric);
+  }
+
+  /**
+   * Given a {@link Gauge}, registers it under the given name and returns it
+   *
+   * @param name the name of the gauge
+   * @param <T> the type of the gauge's value
+   * @return the registered {@link Gauge}
+   * @since 4.2.10
+   */
+  public <T> Gauge<T> registerGauge(MetricName name, Gauge<T> metric)
+      throws IllegalArgumentException {
+    return register(name, metric);
+  }
+
+  /**
+   * Given a {@link Metric}, registers it under the given name.
+   *
+   * @param name the name of the metric
+   * @param metric the metric
+   * @param <T> the type of the metric
+   * @return {@code metric}
+   * @throws IllegalArgumentException if the name is already registered or metric variable is null
+   */
+  public <T extends Metric> T register(MetricName name, T metric) throws IllegalArgumentException {
+    requireNonNull(metric, "metric == null");
+
+    if (metric instanceof MetricRegistry) {
+      final MetricRegistry childRegistry = (MetricRegistry) metric;
+      final MetricName childName = name;
+      childRegistry.addListener(
+          new MetricRegistryListener() {
             @Override
-            public T newMetric() {
-                return supplier.newMetric();
+            public void onGaugeAdded(MetricName name, Gauge<?> gauge) {
+              register(childName.append(name), gauge);
             }
 
             @Override
-            public boolean isInstance(Metric metric) {
-                return Counter.class.isInstance(metric);
+            public void onGaugeRemoved(MetricName name) {
+              remove(childName.append(name));
             }
-        });
-    }
-
-    /**
-     * Return the {@link Histogram} registered under this name; or create and register
-     * a new {@link Histogram} if none is registered.
-     *
-     * @param name the name of the metric
-     * @return a new or pre-existing {@link Histogram}
-     */
-    public Histogram histogram(MetricName name) {
-        return getOrAdd(name, MetricBuilder.HISTOGRAMS);
-    }
 
-    /**
-     * See {@link #meter(MetricName)}
-     */
-    public Meter meter(String name) {
-        return getOrAdd(MetricName.build(name), MetricBuilder.METERS);
-    }
-
-    /**
-     * Return the {@link Histogram} registered under this name; or create and register
-     * a new {@link Histogram} using the provided MetricSupplier if none is registered.
-     *
-     * @param name     the name of the metric
-     * @param supplier a MetricSupplier that can be used to manufacture a histogram
-     * @return a new or pre-existing {@link Histogram}
-     */
-    public Histogram histogram(MetricName name, final MetricSupplier<Histogram> supplier) {
-        return getOrAdd(name, new MetricBuilder<Histogram>() {
             @Override
-            public Histogram newMetric() {
-                return supplier.newMetric();
+            public void onCounterAdded(MetricName name, Counter counter) {
+              register(childName.append(name), counter);
             }
 
             @Override
-            public boolean isInstance(Metric metric) {
-                return Histogram.class.isInstance(metric);
+            public void onCounterRemoved(MetricName name) {
+              remove(childName.append(name));
             }
-        });
-    }
 
-    /**
-     * Return the {@link Meter} registered under this name; or create and register
-     * a new {@link Meter} if none is registered.
-     *
-     * @param name the name of the metric
-     * @return a new or pre-existing {@link Meter}
-     */
-    public Meter meter(MetricName name) {
-        return getOrAdd(name, MetricBuilder.METERS);
-    }
-
-    /**
-     * See {@link #timer(MetricName)}
-     */
-    public Timer timer(String name) {
-        return getOrAdd(MetricName.build(name), MetricBuilder.TIMERS);
-    }
-
-    /**
-     * Return the {@link Meter} registered under this name; or create and register
-     * a new {@link Meter} using the provided MetricSupplier if none is registered.
-     *
-     * @param name     the name of the metric
-     * @param supplier a MetricSupplier that can be used to manufacture a Meter
-     * @return a new or pre-existing {@link Meter}
-     */
-    public Meter meter(MetricName name, final MetricSupplier<Meter> supplier) {
-        return getOrAdd(name, new MetricBuilder<Meter>() {
             @Override
-            public Meter newMetric() {
-                return supplier.newMetric();
+            public void onHistogramAdded(MetricName name, Histogram histogram) {
+              register(childName.append(name), histogram);
             }
 
             @Override
-            public boolean isInstance(Metric metric) {
-                return Meter.class.isInstance(metric);
+            public void onHistogramRemoved(MetricName name) {
+              remove(childName.append(name));
             }
-        });
-    }
-
-    /**
-     * Return the {@link Timer} registered under this name; or create and register
-     * a new {@link Timer} if none is registered.
-     *
-     * @param name the name of the metric
-     * @return a new or pre-existing {@link Timer}
-     */
-    public Timer timer(MetricName name) {
-        return getOrAdd(name, MetricBuilder.TIMERS);
-    }
 
-    /**
-     * Return the {@link Timer} registered under this name; or create and register
-     * a new {@link Timer} using the provided MetricSupplier if none is registered.
-     *
-     * @param name     the name of the metric
-     * @param supplier a MetricSupplier that can be used to manufacture a Timer
-     * @return a new or pre-existing {@link Timer}
-     */
-    public Timer timer(MetricName name, final MetricSupplier<Timer> supplier) {
-        return getOrAdd(name, new MetricBuilder<Timer>() {
             @Override
-            public Timer newMetric() {
-                return supplier.newMetric();
+            public void onMeterAdded(MetricName name, Meter meter) {
+              register(childName.append(name), meter);
             }
 
             @Override
-            public boolean isInstance(Metric metric) {
-                return Timer.class.isInstance(metric);
+            public void onMeterRemoved(MetricName name) {
+              remove(childName.append(name));
             }
-        });
-    }
 
-    /**
-     * Return the {@link Gauge} registered under this name; or create and register
-     * a new {@link SettableGauge} if none is registered.
-     *
-     * @param name the name of the metric
-     * @return a pre-existing {@link Gauge} or a new {@link SettableGauge}
-     * @since 4.2
-     */
-    @SuppressWarnings({"rawtypes", "unchecked"})
-    public <T extends Gauge> T gauge(MetricName name) {
-        return (T) getOrAdd(name, MetricBuilder.GAUGES);
-    }
-
-    /**
-     * Return the {@link Gauge} registered under this name; or create and register
-     * a new {@link Gauge} using the provided MetricSupplier if none is registered.
-     *
-     * @param name     the name of the metric
-     * @param supplier a MetricSupplier that can be used to manufacture a Gauge
-     * @return a new or pre-existing {@link Gauge}
-     */
-    @SuppressWarnings("rawtypes")
-    public <T extends Gauge> T gauge(MetricName name, final MetricSupplier<T> supplier) {
-        return getOrAdd(name, new MetricBuilder<T>() {
             @Override
-            public T newMetric() {
-                return supplier.newMetric();
+            public void onTimerAdded(MetricName name, Timer timer) {
+              register(childName.append(name), timer);
             }
 
             @Override
-            public boolean isInstance(Metric metric) {
-                return Gauge.class.isInstance(metric);
+            public void onTimerRemoved(MetricName name) {
+              remove(childName.append(name));
             }
+          });
+    } else if (metric instanceof MetricSet) {
+      registerAll(name, (MetricSet) metric);
+    } else {
+      final Metric existing = metrics.putIfAbsent(name, metric);
+      if (existing == null) {
+        onMetricAdded(name, metric);
+      } else {
+        throw new IllegalArgumentException("A metric named " + name + " already exists");
+      }
+    }
+    return metric;
+  }
+
+  /**
+   * Given a metric set, registers them.
+   *
+   * @param metrics a set of metrics
+   * @throws IllegalArgumentException if any of the names are already registered
+   */
+  public void registerAll(MetricSet metrics) throws IllegalArgumentException {
+    registerAll(null, metrics);
+  }
+
+  /** See {@link #counter(MetricName)} */
+  public Counter counter(String name) {
+    return getOrAdd(MetricName.build(name), MetricBuilder.COUNTERS);
+  }
+
+  /**
+   * Return the {@link Counter} registered under this name; or create and register a new {@link
+   * Counter} if none is registered.
+   *
+   * @param name the name of the metric
+   * @return a new or pre-existing {@link Counter}
+   */
+  public Counter counter(MetricName name) {
+    return getOrAdd(name, MetricBuilder.COUNTERS);
+  }
+
+  /** See {@link #histogram(MetricName)} */
+  public Histogram histogram(String name) {
+    return getOrAdd(MetricName.build(name), MetricBuilder.HISTOGRAMS);
+  }
+
+  /**
+   * Return the {@link Counter} registered under this name; or create and register a new {@link
+   * Counter} using the provided MetricSupplier if none is registered.
+   *
+   * @param name the name of the metric
+   * @param supplier a MetricSupplier that can be used to manufacture a counter.
+   * @return a new or pre-existing {@link Counter}
+   */
+  public <T extends Counter> T counter(MetricName name, final MetricSupplier<T> supplier) {
+    return getOrAdd(
+        name,
+        new MetricBuilder<T>() {
+          @Override
+          public T newMetric() {
+            return supplier.newMetric();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Counter;
+          }
         });
-    }
-
-
-    /**
-     * Removes the metric with the given name.
-     *
-     * @param name the name of the metric
-     * @return whether or not the metric was removed
-     */
-    public boolean remove(MetricName name) {
-        final Metric metric = metrics.remove(name);
-        if (metric != null) {
-            onMetricRemoved(name, metric);
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Removes all metrics which match the given filter.
-     *
-     * @param filter a filter
-     */
-    public void removeMatching(MetricFilter filter) {
-        for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
-            if (filter.matches(entry.getKey(), entry.getValue())) {
-                remove(entry.getKey());
-            }
-        }
-    }
-
-    /**
-     * Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on
-     * metric creation.  Listeners will be notified in the order in which they are added.
-     * <p>
-     * <b>N.B.:</b> The listener will be notified of all existing metrics when it first registers.
-     *
-     * @param listener the listener that will be notified
-     */
-    public void addListener(MetricRegistryListener listener) {
-        listeners.add(listener);
-
-        for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
-            notifyListenerOfAddedMetric(listener, entry.getValue(), entry.getKey());
-        }
-    }
-
-    /**
-     * Removes a {@link MetricRegistryListener} from this registry's collection of listeners.
-     *
-     * @param listener the listener that will be removed
-     */
-    public void removeListener(MetricRegistryListener listener) {
-        listeners.remove(listener);
-    }
-
-    /**
-     * Returns a set of the names of all the metrics in the registry.
-     *
-     * @return the names of all the metrics
-     */
-    public SortedSet<MetricName> getNames() {
-        return Collections.unmodifiableSortedSet(new TreeSet<>(metrics.keySet()));
-    }
-
-    /**
-     * Returns a map of all the gauges in the registry and their names.
-     *
-     * @return all the gauges in the registry
-     */
-    public SortedMap<MetricName, Gauge<?>> getGauges() {
-        return getGauges(MetricFilter.ALL);
-    }
-
-    /**
-     * Returns a map of all the gauges in the registry and their names which match the given filter.
-     *
-     * @param filter the metric filter to match
-     * @return all the gauges in the registry
-     */
-    public SortedMap<MetricName, Gauge<?>> getGauges(MetricFilter filter) {
-        final SortedMap<MetricName, Gauge<?>> timers = new TreeMap<>();
-        for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
-            if (entry.getValue() instanceof Gauge && filter.matches(entry.getKey(),
-                    entry.getValue())) {
-                timers.put(entry.getKey(), (Gauge<?>) entry.getValue());
-            }
-        }
-        return Collections.unmodifiableSortedMap(timers);
-    }
-
-    /**
-     * Returns a map of all the counters in the registry and their names.
-     *
-     * @return all the counters in the registry
-     */
-    public SortedMap<MetricName, Counter> getCounters() {
-        return getCounters(MetricFilter.ALL);
-    }
-
-    /**
-     * Returns a map of all the counters in the registry and their names which match the given
-     * filter.
-     *
-     * @param filter the metric filter to match
-     * @return all the counters in the registry
-     */
-    public SortedMap<MetricName, Counter> getCounters(MetricFilter filter) {
-        return getMetrics(Counter.class, filter);
-    }
-
-    /**
-     * Returns a map of all the histograms in the registry and their names.
-     *
-     * @return all the histograms in the registry
-     */
-    public SortedMap<MetricName, Histogram> getHistograms() {
-        return getHistograms(MetricFilter.ALL);
-    }
-
-    /**
-     * Returns a map of all the histograms in the registry and their names which match the given
-     * filter.
-     *
-     * @param filter the metric filter to match
-     * @return all the histograms in the registry
-     */
-    public SortedMap<MetricName, Histogram> getHistograms(MetricFilter filter) {
-        return getMetrics(Histogram.class, filter);
-    }
-
-    /**
-     * Returns a map of all the meters in the registry and their names.
-     *
-     * @return all the meters in the registry
-     */
-    public SortedMap<MetricName, Meter> getMeters() {
-        return getMeters(MetricFilter.ALL);
-    }
-
-    /**
-     * Returns a map of all the meters in the registry and their names which match the given filter.
-     *
-     * @param filter the metric filter to match
-     * @return all the meters in the registry
-     */
-    public SortedMap<MetricName, Meter> getMeters(MetricFilter filter) {
-        return getMetrics(Meter.class, filter);
-    }
-
-    /**
-     * Returns a map of all the timers in the registry and their names.
-     *
-     * @return all the timers in the registry
-     */
-    public SortedMap<MetricName, Timer> getTimers() {
-        return getTimers(MetricFilter.ALL);
-    }
-
-    /**
-     * Returns a map of all the timers in the registry and their names which match the given filter.
-     *
-     * @param filter the metric filter to match
-     * @return all the timers in the registry
-     */
-    public SortedMap<MetricName, Timer> getTimers(MetricFilter filter) {
-        return getMetrics(Timer.class, filter);
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T extends Metric> T getOrAdd(MetricName name, MetricBuilder<T> builder) {
-        final Metric metric = metrics.get(name);
-        if (builder.isInstance(metric)) {
-            return (T) metric;
-        } else if (metric == null) {
-            try {
-                return register(name, builder.newMetric());
-            } catch (IllegalArgumentException e) {
-                final Metric added = metrics.get(name);
-                if (builder.isInstance(added)) {
-                    return (T) added;
-                }
-            }
-        }
-        throw new IllegalArgumentException(name + " is already used for a different type of metric");
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T extends Metric> SortedMap<MetricName, T> getMetrics(Class<T> klass, MetricFilter filter) {
-        final SortedMap<MetricName, T> timers = new TreeMap<>();
-        for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
-            if (klass.isInstance(entry.getValue()) && filter.matches(entry.getKey(),
-                    entry.getValue())) {
-                timers.put(entry.getKey(), (T) entry.getValue());
-            }
-        }
-        return Collections.unmodifiableSortedMap(timers);
-    }
-
-    private void onMetricAdded(MetricName name, Metric metric) {
-        for (MetricRegistryListener listener : listeners) {
-            notifyListenerOfAddedMetric(listener, metric, name);
-        }
-    }
-
-    private void notifyListenerOfAddedMetric(MetricRegistryListener listener, Metric metric, MetricName name) {
-        if (metric instanceof Gauge) {
-            listener.onGaugeAdded(name, (Gauge<?>) metric);
-        } else if (metric instanceof Counter) {
-            listener.onCounterAdded(name, (Counter) metric);
-        } else if (metric instanceof Histogram) {
-            listener.onHistogramAdded(name, (Histogram) metric);
-        } else if (metric instanceof Meter) {
-            listener.onMeterAdded(name, (Meter) metric);
-        } else if (metric instanceof Timer) {
-            listener.onTimerAdded(name, (Timer) metric);
-        } else {
-            throw new IllegalArgumentException("Unknown metric type: " + metric.getClass());
-        }
-    }
-
-    private void onMetricRemoved(MetricName name, Metric metric) {
-        for (MetricRegistryListener listener : listeners) {
-            notifyListenerOfRemovedMetric(name, metric, listener);
-        }
-    }
-
-    private void notifyListenerOfRemovedMetric(MetricName name, Metric metric, MetricRegistryListener listener) {
-        if (metric instanceof Gauge) {
-            listener.onGaugeRemoved(name);
-        } else if (metric instanceof Counter) {
-            listener.onCounterRemoved(name);
-        } else if (metric instanceof Histogram) {
-            listener.onHistogramRemoved(name);
-        } else if (metric instanceof Meter) {
-            listener.onMeterRemoved(name);
-        } else if (metric instanceof Timer) {
-            listener.onTimerRemoved(name);
-        } else {
-            throw new IllegalArgumentException("Unknown metric type: " + metric.getClass());
-        }
-    }
-
-    public void registerAll(MetricName prefix, MetricSet metrics) throws IllegalArgumentException {
-        if (prefix == null) {
-            prefix = MetricName.EMPTY;
-        }
-
-        for (Map.Entry<MetricName, Metric> entry : metrics.getMetrics().entrySet()) {
-            if (entry.getValue() instanceof MetricSet) {
-                registerAll(prefix.append(entry.getKey()), (MetricSet) entry.getValue());
-            } else {
-                register(prefix.append(entry.getKey()), entry.getValue());
-            }
+  }
+
+  /**
+   * Return the {@link Histogram} registered under this name; or create and register a new {@link
+   * Histogram} if none is registered.
+   *
+   * @param name the name of the metric
+   * @return a new or pre-existing {@link Histogram}
+   */
+  public Histogram histogram(MetricName name) {
+    return getOrAdd(name, MetricBuilder.HISTOGRAMS);
+  }
+
+  /** See {@link #meter(MetricName)} */
+  public Meter meter(String name) {
+    return getOrAdd(MetricName.build(name), MetricBuilder.METERS);
+  }
+
+  /**
+   * Return the {@link Histogram} registered under this name; or create and register a new {@link
+   * Histogram} using the provided MetricSupplier if none is registered.
+   *
+   * @param name the name of the metric
+   * @param supplier a MetricSupplier that can be used to manufacture a histogram
+   * @return a new or pre-existing {@link Histogram}
+   */
+  public Histogram histogram(MetricName name, final MetricSupplier<Histogram> supplier) {
+    return getOrAdd(
+        name,
+        new MetricBuilder<Histogram>() {
+          @Override
+          public Histogram newMetric() {
+            return supplier.newMetric();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Histogram;
+          }
+        });
+  }
+
+  /**
+   * Return the {@link Meter} registered under this name; or create and register a new {@link Meter}
+   * if none is registered.
+   *
+   * @param name the name of the metric
+   * @return a new or pre-existing {@link Meter}
+   */
+  public Meter meter(MetricName name) {
+    return getOrAdd(name, MetricBuilder.METERS);
+  }
+
+  /** See {@link #timer(MetricName)} */
+  public Timer timer(String name) {
+    return getOrAdd(MetricName.build(name), MetricBuilder.TIMERS);
+  }
+
+  /**
+   * Return the {@link Meter} registered under this name; or create and register a new {@link Meter}
+   * using the provided MetricSupplier if none is registered.
+   *
+   * @param name the name of the metric
+   * @param supplier a MetricSupplier that can be used to manufacture a Meter
+   * @return a new or pre-existing {@link Meter}
+   */
+  public Meter meter(MetricName name, final MetricSupplier<Meter> supplier) {
+    return getOrAdd(
+        name,
+        new MetricBuilder<Meter>() {
+          @Override
+          public Meter newMetric() {
+            return supplier.newMetric();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Meter;
+          }
+        });
+  }
+
+  /**
+   * Return the {@link Timer} registered under this name; or create and register a new {@link Timer}
+   * if none is registered.
+   *
+   * @param name the name of the metric
+   * @return a new or pre-existing {@link Timer}
+   */
+  public Timer timer(MetricName name) {
+    return getOrAdd(name, MetricBuilder.TIMERS);
+  }
+
+  /**
+   * Return the {@link Timer} registered under this name; or create and register a new {@link Timer}
+   * using the provided MetricSupplier if none is registered.
+   *
+   * @param name the name of the metric
+   * @param supplier a MetricSupplier that can be used to manufacture a Timer
+   * @return a new or pre-existing {@link Timer}
+   */
+  public Timer timer(MetricName name, final MetricSupplier<Timer> supplier) {
+    return getOrAdd(
+        name,
+        new MetricBuilder<Timer>() {
+          @Override
+          public Timer newMetric() {
+            return supplier.newMetric();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Timer;
+          }
+        });
+  }
+
+  /**
+   * Return the {@link Gauge} registered under this name; or create and register a new {@link
+   * SettableGauge} if none is registered.
+   *
+   * @param name the name of the metric
+   * @return a pre-existing {@link Gauge} or a new {@link SettableGauge}
+   * @since 4.2
+   */
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  public <T extends Gauge> T gauge(MetricName name) {
+    return (T) getOrAdd(name, MetricBuilder.GAUGES);
+  }
+
+  /**
+   * Return the {@link Gauge} registered under this name; or create and register a new {@link Gauge}
+   * using the provided MetricSupplier if none is registered.
+   *
+   * @param name the name of the metric
+   * @param supplier a MetricSupplier that can be used to manufacture a Gauge
+   * @return a new or pre-existing {@link Gauge}
+   */
+  @SuppressWarnings("rawtypes")
+  public <T extends Gauge> T gauge(MetricName name, final MetricSupplier<T> supplier) {
+    return getOrAdd(
+        name,
+        new MetricBuilder<T>() {
+          @Override
+          public T newMetric() {
+            return supplier.newMetric();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Gauge;
+          }
+        });
+  }
+
+  /**
+   * Removes the metric with the given name.
+   *
+   * @param name the name of the metric
+   * @return whether or not the metric was removed
+   */
+  public boolean remove(MetricName name) {
+    final Metric metric = metrics.remove(name);
+    if (metric != null) {
+      onMetricRemoved(name, metric);
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Removes all metrics which match the given filter.
+   *
+   * @param filter a filter
+   */
+  public void removeMatching(MetricFilter filter) {
+    for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
+      if (filter.matches(entry.getKey(), entry.getValue())) {
+        remove(entry.getKey());
+      }
+    }
+  }
+
+  /**
+   * Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on
+   * metric creation. Listeners will be notified in the order in which they are added.
+   *
+   * <p><b>N.B.:</b> The listener will be notified of all existing metrics when it first registers.
+   *
+   * @param listener the listener that will be notified
+   */
+  public void addListener(MetricRegistryListener listener) {
+    listeners.add(listener);
+
+    for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
+      notifyListenerOfAddedMetric(listener, entry.getValue(), entry.getKey());
+    }
+  }
+
+  /**
+   * Removes a {@link MetricRegistryListener} from this registry's collection of listeners.
+   *
+   * @param listener the listener that will be removed
+   */
+  public void removeListener(MetricRegistryListener listener) {
+    listeners.remove(listener);
+  }
+
+  /**
+   * Returns a set of the names of all the metrics in the registry.
+   *
+   * @return the names of all the metrics
+   */
+  public SortedSet<MetricName> getNames() {
+    return unmodifiableSortedSet(new TreeSet<>(metrics.keySet()));
+  }
+
+  /**
+   * Returns a map of all the gauges in the registry and their names.
+   *
+   * @return all the gauges in the registry
+   */
+  public SortedMap<MetricName, Gauge<?>> getGauges() {
+    return getGauges(MetricFilter.ALL);
+  }
+
+  /**
+   * Returns a map of all the gauges in the registry and their names which match the given filter.
+   *
+   * @param filter the metric filter to match
+   * @return all the gauges in the registry
+   */
+  public SortedMap<MetricName, Gauge<?>> getGauges(MetricFilter filter) {
+    final SortedMap<MetricName, Gauge<?>> timers = new TreeMap<>();
+    for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
+      if (entry.getValue() instanceof Gauge && filter.matches(entry.getKey(), entry.getValue())) {
+        timers.put(entry.getKey(), (Gauge<?>) entry.getValue());
+      }
+    }
+    return unmodifiableSortedMap(timers);
+  }
+
+  /**
+   * Returns a map of all the counters in the registry and their names.
+   *
+   * @return all the counters in the registry
+   */
+  public SortedMap<MetricName, Counter> getCounters() {
+    return getCounters(MetricFilter.ALL);
+  }
+
+  /**
+   * Returns a map of all the counters in the registry and their names which match the given filter.
+   *
+   * @param filter the metric filter to match
+   * @return all the counters in the registry
+   */
+  public SortedMap<MetricName, Counter> getCounters(MetricFilter filter) {
+    return getMetrics(Counter.class, filter);
+  }
+
+  /**
+   * Returns a map of all the histograms in the registry and their names.
+   *
+   * @return all the histograms in the registry
+   */
+  public SortedMap<MetricName, Histogram> getHistograms() {
+    return getHistograms(MetricFilter.ALL);
+  }
+
+  /**
+   * Returns a map of all the histograms in the registry and their names which match the given
+   * filter.
+   *
+   * @param filter the metric filter to match
+   * @return all the histograms in the registry
+   */
+  public SortedMap<MetricName, Histogram> getHistograms(MetricFilter filter) {
+    return getMetrics(Histogram.class, filter);
+  }
+
+  /**
+   * Returns a map of all the meters in the registry and their names.
+   *
+   * @return all the meters in the registry
+   */
+  public SortedMap<MetricName, Meter> getMeters() {
+    return getMeters(MetricFilter.ALL);
+  }
+
+  /**
+   * Returns a map of all the meters in the registry and their names which match the given filter.
+   *
+   * @param filter the metric filter to match
+   * @return all the meters in the registry
+   */
+  public SortedMap<MetricName, Meter> getMeters(MetricFilter filter) {
+    return getMetrics(Meter.class, filter);
+  }
+
+  /**
+   * Returns a map of all the timers in the registry and their names.
+   *
+   * @return all the timers in the registry
+   */
+  public SortedMap<MetricName, Timer> getTimers() {
+    return getTimers(MetricFilter.ALL);
+  }
+
+  /**
+   * Returns a map of all the timers in the registry and their names which match the given filter.
+   *
+   * @param filter the metric filter to match
+   * @return all the timers in the registry
+   */
+  public SortedMap<MetricName, Timer> getTimers(MetricFilter filter) {
+    return getMetrics(Timer.class, filter);
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T extends Metric> T getOrAdd(MetricName name, MetricBuilder<T> builder) {
+    final Metric metric = metrics.get(name);
+    if (builder.isInstance(metric)) {
+      return (T) metric;
+    } else if (metric == null) {
+      try {
+        return register(name, builder.newMetric());
+      } catch (IllegalArgumentException e) {
+        final Metric added = metrics.get(name);
+        if (builder.isInstance(added)) {
+          return (T) added;
         }
-    }
-
-    @Override
-    public Map<MetricName, Metric> getMetrics() {
-        return Collections.unmodifiableMap(metrics);
-    }
-
-    @FunctionalInterface
-    public interface MetricSupplier<T extends Metric> {
-        T newMetric();
-    }
-
-    /**
-     * A quick and easy way of capturing the notion of default metrics.
-     */
-    private interface MetricBuilder<T extends Metric> {
-        MetricBuilder<Counter> COUNTERS = new MetricBuilder<Counter>() {
-            @Override
-            public Counter newMetric() {
-                return new Counter();
-            }
-
-            @Override
-            public boolean isInstance(Metric metric) {
-                return Counter.class.isInstance(metric);
-            }
+      }
+    }
+    throw new IllegalArgumentException(name + " is already used for a different type of metric");
+  }
+
+  @SuppressWarnings("unchecked")
+  private <T extends Metric> SortedMap<MetricName, T> getMetrics(
+      Class<T> klass, MetricFilter filter) {
+    final SortedMap<MetricName, T> timers = new TreeMap<>();
+    for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
+      if (klass.isInstance(entry.getValue()) && filter.matches(entry.getKey(), entry.getValue())) {
+        timers.put(entry.getKey(), (T) entry.getValue());
+      }
+    }
+    return unmodifiableSortedMap(timers);
+  }
+
+  private void onMetricAdded(MetricName name, Metric metric) {
+    for (MetricRegistryListener listener : listeners) {
+      notifyListenerOfAddedMetric(listener, metric, name);
+    }
+  }
+
+  private void notifyListenerOfAddedMetric(
+      MetricRegistryListener listener, Metric metric, MetricName name) {
+    if (metric instanceof Gauge) {
+      listener.onGaugeAdded(name, (Gauge<?>) metric);
+    } else if (metric instanceof Counter) {
+      listener.onCounterAdded(name, (Counter) metric);
+    } else if (metric instanceof Histogram) {
+      listener.onHistogramAdded(name, (Histogram) metric);
+    } else if (metric instanceof Meter) {
+      listener.onMeterAdded(name, (Meter) metric);
+    } else if (metric instanceof Timer) {
+      listener.onTimerAdded(name, (Timer) metric);
+    } else {
+      throw new IllegalArgumentException("Unknown metric type: " + metric.getClass());
+    }
+  }
+
+  private void onMetricRemoved(MetricName name, Metric metric) {
+    for (MetricRegistryListener listener : listeners) {
+      notifyListenerOfRemovedMetric(name, metric, listener);
+    }
+  }
+
+  private void notifyListenerOfRemovedMetric(
+      MetricName name, Metric metric, MetricRegistryListener listener) {
+    if (metric instanceof Gauge) {
+      listener.onGaugeRemoved(name);
+    } else if (metric instanceof Counter) {
+      listener.onCounterRemoved(name);
+    } else if (metric instanceof Histogram) {
+      listener.onHistogramRemoved(name);
+    } else if (metric instanceof Meter) {
+      listener.onMeterRemoved(name);
+    } else if (metric instanceof Timer) {
+      listener.onTimerRemoved(name);
+    } else {
+      throw new IllegalArgumentException("Unknown metric type: " + metric.getClass());
+    }
+  }
+
+  public void registerAll(MetricName prefix, MetricSet metrics) throws IllegalArgumentException {
+    if (prefix == null) {
+      prefix = MetricName.EMPTY;
+    }
+
+    for (Map.Entry<MetricName, Metric> entry : metrics.getMetrics().entrySet()) {
+      if (entry.getValue() instanceof MetricSet) {
+        registerAll(prefix.append(entry.getKey()), (MetricSet) entry.getValue());
+      } else {
+        register(prefix.append(entry.getKey()), entry.getValue());
+      }
+    }
+  }
+
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    return unmodifiableMap(metrics);
+  }
+
+  @FunctionalInterface
+  public interface MetricSupplier<T extends Metric> {
+    T newMetric();
+  }
+
+  /** A quick and easy way of capturing the notion of default metrics. */
+  private interface MetricBuilder<T extends Metric> {
+    MetricBuilder<Counter> COUNTERS =
+        new MetricBuilder<Counter>() {
+          @Override
+          public Counter newMetric() {
+            return new Counter();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Counter;
+          }
         };
 
-        MetricBuilder<Histogram> HISTOGRAMS = new MetricBuilder<Histogram>() {
-            @Override
-            public Histogram newMetric() {
-                return new Histogram(new ExponentiallyDecayingReservoir());
-            }
-
-            @Override
-            public boolean isInstance(Metric metric) {
-                return Histogram.class.isInstance(metric);
-            }
+    MetricBuilder<Histogram> HISTOGRAMS =
+        new MetricBuilder<Histogram>() {
+          @Override
+          public Histogram newMetric() {
+            return new Histogram(new ExponentiallyDecayingReservoir());
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Histogram;
+          }
         };
 
-        MetricBuilder<Meter> METERS = new MetricBuilder<Meter>() {
-            @Override
-            public Meter newMetric() {
-                return new Meter();
-            }
-
-            @Override
-            public boolean isInstance(Metric metric) {
-                return Meter.class.isInstance(metric);
-            }
+    MetricBuilder<Meter> METERS =
+        new MetricBuilder<Meter>() {
+          @Override
+          public Meter newMetric() {
+            return new Meter();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Meter;
+          }
         };
 
-        MetricBuilder<Timer> TIMERS = new MetricBuilder<Timer>() {
-            @Override
-            public Timer newMetric() {
-                return new Timer();
-            }
-
-            @Override
-            public boolean isInstance(Metric metric) {
-                return Timer.class.isInstance(metric);
-            }
+    MetricBuilder<Timer> TIMERS =
+        new MetricBuilder<Timer>() {
+          @Override
+          public Timer newMetric() {
+            return new Timer();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Timer;
+          }
         };
 
-        @SuppressWarnings("rawtypes")
-        MetricBuilder<Gauge> GAUGES = new MetricBuilder<Gauge>() {
-            @Override
-            public Gauge newMetric() {
-                return new DefaultSettableGauge<>();
-            }
-
-            @Override
-            public boolean isInstance(Metric metric) {
-                return Gauge.class.isInstance(metric);
-            }
+    @SuppressWarnings("rawtypes")
+    MetricBuilder<Gauge> GAUGES =
+        new MetricBuilder<Gauge>() {
+          @Override
+          public Gauge newMetric() {
+            return new DefaultSettableGauge<>();
+          }
+
+          @Override
+          public boolean isInstance(Metric metric) {
+            return metric instanceof Gauge;
+          }
         };
 
-        T newMetric();
+    T newMetric();
 
-        boolean isInstance(Metric metric);
-    }
+    boolean isInstance(Metric metric);
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/MetricRegistryListener.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/MetricRegistryListener.java
@@ -2,127 +2,113 @@ package io.dropwizard.metrics5;
 
 import java.util.EventListener;
 
-/**
- * Listeners for events from the registry.  Listeners must be thread-safe.
- */
+/** Listeners for events from the registry. Listeners must be thread-safe. */
 public interface MetricRegistryListener extends EventListener {
-    /**
-     * A no-op implementation of {@link MetricRegistryListener}.
-     */
-    abstract class Base implements MetricRegistryListener {
-        @Override
-        public void onGaugeAdded(MetricName name, Gauge<?> gauge) {
-        }
-
-        @Override
-        public void onGaugeRemoved(MetricName name) {
-        }
-
-        @Override
-        public void onCounterAdded(MetricName name, Counter counter) {
-        }
-
-        @Override
-        public void onCounterRemoved(MetricName name) {
-        }
-
-        @Override
-        public void onHistogramAdded(MetricName name, Histogram histogram) {
-        }
-
-        @Override
-        public void onHistogramRemoved(MetricName name) {
-        }
-
-        @Override
-        public void onMeterAdded(MetricName name, Meter meter) {
-        }
-
-        @Override
-        public void onMeterRemoved(MetricName name) {
-        }
-
-        @Override
-        public void onTimerAdded(MetricName name, Timer timer) {
-        }
-
-        @Override
-        public void onTimerRemoved(MetricName name) {
-        }
-    }
-
-    /**
-     * Called when a {@link Gauge} is added to the registry.
-     *
-     * @param name  the gauge's name
-     * @param gauge the gauge
-     */
-    void onGaugeAdded(MetricName name, Gauge<?> gauge);
-
-    /**
-     * Called when a {@link Gauge} is removed from the registry.
-     *
-     * @param name the gauge's name
-     */
-    void onGaugeRemoved(MetricName name);
-
-    /**
-     * Called when a {@link Counter} is added to the registry.
-     *
-     * @param name    the counter's name
-     * @param counter the counter
-     */
-    void onCounterAdded(MetricName name, Counter counter);
-
-    /**
-     * Called when a {@link Counter} is removed from the registry.
-     *
-     * @param name the counter's name
-     */
-    void onCounterRemoved(MetricName name);
-
-    /**
-     * Called when a {@link Histogram} is added to the registry.
-     *
-     * @param name      the histogram's name
-     * @param histogram the histogram
-     */
-    void onHistogramAdded(MetricName name, Histogram histogram);
-
-    /**
-     * Called when a {@link Histogram} is removed from the registry.
-     *
-     * @param name the histogram's name
-     */
-    void onHistogramRemoved(MetricName name);
-
-    /**
-     * Called when a {@link Meter} is added to the registry.
-     *
-     * @param name  the meter's name
-     * @param meter the meter
-     */
-    void onMeterAdded(MetricName name, Meter meter);
-
-    /**
-     * Called when a {@link Meter} is removed from the registry.
-     *
-     * @param name the meter's name
-     */
-    void onMeterRemoved(MetricName name);
-
-    /**
-     * Called when a {@link Timer} is added to the registry.
-     *
-     * @param name  the timer's name
-     * @param timer the timer
-     */
-    void onTimerAdded(MetricName name, Timer timer);
-
-    /**
-     * Called when a {@link Timer} is removed from the registry.
-     *
-     * @param name the timer's name
-     */
-    void onTimerRemoved(MetricName name);
+  /** A no-op implementation of {@link MetricRegistryListener}. */
+  abstract class Base implements MetricRegistryListener {
+    @Override
+    public void onGaugeAdded(MetricName name, Gauge<?> gauge) {}
+
+    @Override
+    public void onGaugeRemoved(MetricName name) {}
+
+    @Override
+    public void onCounterAdded(MetricName name, Counter counter) {}
+
+    @Override
+    public void onCounterRemoved(MetricName name) {}
+
+    @Override
+    public void onHistogramAdded(MetricName name, Histogram histogram) {}
+
+    @Override
+    public void onHistogramRemoved(MetricName name) {}
+
+    @Override
+    public void onMeterAdded(MetricName name, Meter meter) {}
+
+    @Override
+    public void onMeterRemoved(MetricName name) {}
+
+    @Override
+    public void onTimerAdded(MetricName name, Timer timer) {}
+
+    @Override
+    public void onTimerRemoved(MetricName name) {}
+  }
+
+  /**
+   * Called when a {@link Gauge} is added to the registry.
+   *
+   * @param name the gauge's name
+   * @param gauge the gauge
+   */
+  void onGaugeAdded(MetricName name, Gauge<?> gauge);
+
+  /**
+   * Called when a {@link Gauge} is removed from the registry.
+   *
+   * @param name the gauge's name
+   */
+  void onGaugeRemoved(MetricName name);
+
+  /**
+   * Called when a {@link Counter} is added to the registry.
+   *
+   * @param name the counter's name
+   * @param counter the counter
+   */
+  void onCounterAdded(MetricName name, Counter counter);
+
+  /**
+   * Called when a {@link Counter} is removed from the registry.
+   *
+   * @param name the counter's name
+   */
+  void onCounterRemoved(MetricName name);
+
+  /**
+   * Called when a {@link Histogram} is added to the registry.
+   *
+   * @param name the histogram's name
+   * @param histogram the histogram
+   */
+  void onHistogramAdded(MetricName name, Histogram histogram);
+
+  /**
+   * Called when a {@link Histogram} is removed from the registry.
+   *
+   * @param name the histogram's name
+   */
+  void onHistogramRemoved(MetricName name);
+
+  /**
+   * Called when a {@link Meter} is added to the registry.
+   *
+   * @param name the meter's name
+   * @param meter the meter
+   */
+  void onMeterAdded(MetricName name, Meter meter);
+
+  /**
+   * Called when a {@link Meter} is removed from the registry.
+   *
+   * @param name the meter's name
+   */
+  void onMeterRemoved(MetricName name);
+
+  /**
+   * Called when a {@link Timer} is added to the registry.
+   *
+   * @param name the timer's name
+   * @param timer the timer
+   */
+  void onTimerAdded(MetricName name, Timer timer);
+
+  /**
+   * Called when a {@link Timer} is removed from the registry.
+   *
+   * @param name the timer's name
+   */
+  void onTimerRemoved(MetricName name);
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/MetricSet.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/MetricSet.java
@@ -8,10 +8,10 @@ import java.util.Map;
  * @see MetricRegistry#registerAll(MetricSet)
  */
 public interface MetricSet extends Metric {
-    /**
-     * A map of metric names to metrics.
-     *
-     * @return the metrics
-     */
-    Map<MetricName, Metric> getMetrics();
+  /**
+   * A map of metric names to metrics.
+   *
+   * @return the metrics
+   */
+  Map<MetricName, Metric> getMetrics();
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/MovingAverages.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/MovingAverages.java
@@ -1,50 +1,52 @@
 package io.dropwizard.metrics5;
 
 /**
- * A triple of moving averages (one-, five-, and fifteen-minute
- * moving average) as needed by {@link Meter}.
- * <p>
- * Included implementations are:
+ * A triple of moving averages (one-, five-, and fifteen-minute moving average) as needed by {@link
+ * Meter}.
+ *
+ * <p>Included implementations are:
+ *
  * <ul>
- * <li>{@link ExponentialMovingAverages} exponential decaying average similar to the {@code top} Unix command.
- * <li>{@link SlidingTimeWindowMovingAverages} simple (unweighted) moving average
+ *   <li>{@link ExponentialMovingAverages} exponential decaying average similar to the {@code top}
+ *       Unix command.
+ *   <li>{@link SlidingTimeWindowMovingAverages} simple (unweighted) moving average
  * </ul>
  */
 public interface MovingAverages {
 
-    /**
-     * Tick the internal clock of the MovingAverages implementation if needed
-     * (according to the internal ticking interval)
-     */
-    void tickIfNecessary();
+  /**
+   * Tick the internal clock of the MovingAverages implementation if needed (according to the
+   * internal ticking interval)
+   */
+  void tickIfNecessary();
 
-    /**
-     * Update all three moving averages with n events having occurred since the last update.
-     *
-     * @param n
-     */
-    void update(long n);
+  /**
+   * Update all three moving averages with n events having occurred since the last update.
+   *
+   * @param n
+   */
+  void update(long n);
 
-    /**
-     * Returns the one-minute moving average rate
-     *
-     * @return the one-minute moving average rate
-     */
-    double getM1Rate();
+  /**
+   * Returns the one-minute moving average rate
+   *
+   * @return the one-minute moving average rate
+   */
+  double getM1Rate();
 
-    /**
-     * Returns the five-minute moving average rate
-     *
-     * @return the five-minute moving average rate
-     */
-    double getM5Rate();
+  /**
+   * Returns the five-minute moving average rate
+   *
+   * @return the five-minute moving average rate
+   */
+  double getM5Rate();
 
-    /**
-     * Returns the fifteen-minute moving average rate
-     *
-     * @return the fifteen-minute moving average rate
-     */
-    double getM15Rate();
+  /**
+   * Returns the fifteen-minute moving average rate
+   *
+   * @return the fifteen-minute moving average rate
+   */
+  double getM15Rate();
 
-    long getSum();
+  long getSum();
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/NoopMetricRegistry.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/NoopMetricRegistry.java
@@ -1,9 +1,14 @@
 package io.dropwizard.metrics5;
 
+import static java.util.Collections.emptySortedMap;
+import static java.util.Collections.emptySortedSet;
+import static java.util.Objects.requireNonNull;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import java.io.OutputStream;
 import java.time.Duration;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
@@ -13,817 +18,634 @@ import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
-import static java.util.Objects.requireNonNull;
-
 /**
- * A registry of metric instances which never creates or registers any metrics and returns no-op implementations of any metric type.
+ * A registry of metric instances which never creates or registers any metrics and returns no-op
+ * implementations of any metric type.
  *
  * @since 4.1.17
  */
 public final class NoopMetricRegistry extends MetricRegistry {
-    private static final EmptyConcurrentMap<MetricName, Metric> EMPTY_CONCURRENT_MAP = new EmptyConcurrentMap<>();
+  private static final EmptyConcurrentMap<MetricName, Metric> EMPTY_CONCURRENT_MAP =
+      new EmptyConcurrentMap<>();
+
+  /**
+   * {@inheritDoc}
+   *
+   * @return
+   */
+  @Override
+  protected ConcurrentMap<MetricName, Metric> buildMap() {
+    return EMPTY_CONCURRENT_MAP;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void registerAll(MetricSet metrics) throws IllegalArgumentException {
+    // NOP
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Counter counter(String name) {
+    return NoopCounter.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Counter counter(MetricName name) {
+    return NoopCounter.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  @SuppressWarnings("unchecked")
+  public <T extends Counter> T counter(MetricName name, final MetricSupplier<T> supplier) {
+    return (T) NoopCounter.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Histogram histogram(String name) {
+    return NoopHistogram.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Histogram histogram(MetricName name) {
+    return NoopHistogram.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Histogram histogram(MetricName name, MetricSupplier<Histogram> supplier) {
+    return NoopHistogram.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Meter meter(String name) {
+    return NoopMeter.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Meter meter(MetricName name) {
+    return NoopMeter.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Meter meter(MetricName name, MetricSupplier<Meter> supplier) {
+    return NoopMeter.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Timer timer(String name) {
+    return NoopTimer.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Timer timer(MetricName name) {
+    return NoopTimer.INSTANCE;
+  }
+
+  /**
+   * {@inheritDoc}
+   *
+   * @since 4.2
+   */
+  @Override
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  public <T extends Gauge> T gauge(MetricName name) {
+    return (T) NoopGauge.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Timer timer(MetricName name, MetricSupplier<Timer> supplier) {
+    return NoopTimer.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  public <T extends Gauge> T gauge(MetricName name, final MetricSupplier<T> supplier) {
+    return (T) NoopGauge.INSTANCE;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public boolean remove(MetricName name) {
+    return false;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void removeMatching(MetricFilter filter) {
+    // NOP
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void addListener(MetricRegistryListener listener) {
+    // NOP
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void removeListener(MetricRegistryListener listener) {
+    // NOP
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedSet<MetricName> getNames() {
+    return emptySortedSet();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Gauge<?>> getGauges() {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Gauge<?>> getGauges(MetricFilter filter) {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Counter> getCounters() {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Counter> getCounters(MetricFilter filter) {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Histogram> getHistograms() {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Histogram> getHistograms(MetricFilter filter) {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Meter> getMeters() {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Meter> getMeters(MetricFilter filter) {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Timer> getTimers() {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public SortedMap<MetricName, Timer> getTimers(MetricFilter filter) {
+    return emptySortedMap();
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void registerAll(MetricName prefix, MetricSet metrics) throws IllegalArgumentException {
+    // NOP
+  }
 
-    /**
-     * {@inheritDoc}
-     * @return
-     */
+  /** {@inheritDoc} */
+  @Override
+  public <T extends Metric> T register(MetricName name, T metric) throws IllegalArgumentException {
+    return requireNonNull(metric, "metric == null");
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    return ImmutableMap.of();
+  }
+
+  static final class NoopMetric implements Metric {
+    private static final NoopMetric INSTANCE = new NoopMetric();
+  }
+
+  static final class NoopGauge<T> implements Gauge<T> {
+    private static final NoopGauge<?> INSTANCE = new NoopGauge<>();
+
+    /** {@inheritDoc} */
     @Override
-    protected ConcurrentMap<MetricName, Metric> buildMap() {
-        return EMPTY_CONCURRENT_MAP;
+    public T getValue() {
+      return null;
     }
+  }
 
-    /**
-     * {@inheritDoc}
-     */
+  private static final class EmptySnapshot extends Snapshot {
+    private static final EmptySnapshot INSTANCE = new EmptySnapshot();
+    private static final long[] EMPTY_LONG_ARRAY = new long[0];
+
+    /** {@inheritDoc} */
     @Override
-    public void registerAll(MetricSet metrics) throws IllegalArgumentException {
-        // NOP
+    public double getValue(double quantile) {
+      return 0D;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Counter counter(String name) {
-        return NoopCounter.INSTANCE;
+    public long[] getValues() {
+      return EMPTY_LONG_ARRAY;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Counter counter(MetricName name) {
-        return NoopCounter.INSTANCE;
+    public int size() {
+      return 0;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    @SuppressWarnings("unchecked")
-    public <T extends Counter> T counter(MetricName name, final MetricSupplier<T> supplier) {
-        return (T) NoopCounter.INSTANCE;
+    public long getMax() {
+      return 0L;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Histogram histogram(String name) {
-        return NoopHistogram.INSTANCE;
+    public double getMean() {
+      return 0D;
     }
 
-
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Histogram histogram(MetricName name) {
-        return NoopHistogram.INSTANCE;
+    public long getMin() {
+      return 0L;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Histogram histogram(MetricName name, MetricSupplier<Histogram> supplier) {
-        return NoopHistogram.INSTANCE;
+    public double getStdDev() {
+      return 0D;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Meter meter(String name) {
-        return NoopMeter.INSTANCE;
+    public void dump(OutputStream output) {
+      // NOP
     }
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Meter meter(MetricName name) {
-        return NoopMeter.INSTANCE;
+  static final class NoopTimer extends Timer {
+    private static final NoopTimer INSTANCE = new NoopTimer();
+    private static final Timer.Context CONTEXT = new NoopTimer.Context();
+
+    private static class Context extends Timer.Context {
+      private static final Clock CLOCK =
+          new Clock() {
+            /** {@inheritDoc} */
+            @Override
+            public long getTick() {
+              return 0L;
+            }
+
+            /** {@inheritDoc} */
+            @Override
+            public long getTime() {
+              return 0L;
+            }
+          };
+
+      private Context() {
+        super(INSTANCE, CLOCK);
+      }
+
+      /** {@inheritDoc} */
+      @Override
+      public long stop() {
+        return 0L;
+      }
+
+      /** {@inheritDoc} */
+      @Override
+      public void close() {
+        // NOP
+      }
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Meter meter(MetricName name, MetricSupplier<Meter> supplier) {
-        return NoopMeter.INSTANCE;
+    public void update(long duration, TimeUnit unit) {
+      // NOP
     }
 
-
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Timer timer(String name) {
-        return NoopTimer.INSTANCE;
+    public void update(Duration duration) {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Timer timer(MetricName name) {
-        return NoopTimer.INSTANCE;
+    public <T> T time(Callable<T> event) throws Exception {
+      return event.call();
     }
 
-    /**
-     * {@inheritDoc}
-     *
-     * @since 4.2
-     */
+    /** {@inheritDoc} */
     @Override
-    @SuppressWarnings({"rawtypes", "unchecked"})
-    public <T extends Gauge> T gauge(MetricName name) {
-        return (T) NoopGauge.INSTANCE;
+    public <T> T timeSupplier(Supplier<T> event) {
+      return event.get();
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Timer timer(MetricName name, MetricSupplier<Timer> supplier) {
-        return NoopTimer.INSTANCE;
+    public void time(Runnable event) {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @SuppressWarnings({"rawtypes", "unchecked"})
-    public <T extends Gauge> T gauge(MetricName name, final MetricSupplier<T> supplier) {
-        return (T) NoopGauge.INSTANCE;
+    /** {@inheritDoc} */
+    @Override
+    public Timer.Context time() {
+      return CONTEXT;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public boolean remove(MetricName name) {
-        return false;
+    public long getCount() {
+      return 0L;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public void removeMatching(MetricFilter filter) {
-        // NOP
+    public double getFifteenMinuteRate() {
+      return 0D;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public void addListener(MetricRegistryListener listener) {
-        // NOP
+    public double getFiveMinuteRate() {
+      return 0D;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public void removeListener(MetricRegistryListener listener) {
-        // NOP
+    public double getMeanRate() {
+      return 0D;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedSet<MetricName> getNames() {
-        return Collections.emptySortedSet();
+    public double getOneMinuteRate() {
+      return 0D;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Gauge<?>> getGauges() {
-        return Collections.emptySortedMap();
+    public Snapshot getSnapshot() {
+      return EmptySnapshot.INSTANCE;
     }
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public SortedMap<MetricName, Gauge<?>> getGauges(MetricFilter filter) {
-        return Collections.emptySortedMap();
+  static final class NoopHistogram extends Histogram {
+    private static final NoopHistogram INSTANCE = new NoopHistogram();
+    private static final Reservoir EMPTY_RESERVOIR =
+        new Reservoir() {
+          /** {@inheritDoc} */
+          @Override
+          public int size() {
+            return 0;
+          }
+
+          /** {@inheritDoc} */
+          @Override
+          public void update(long value) {
+            // NOP
+          }
+
+          /** {@inheritDoc} */
+          @Override
+          public Snapshot getSnapshot() {
+            return EmptySnapshot.INSTANCE;
+          }
+        };
+
+    private NoopHistogram() {
+      super(EMPTY_RESERVOIR);
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Counter> getCounters() {
-        return Collections.emptySortedMap();
+    public void update(int value) {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Counter> getCounters(MetricFilter filter) {
-        return Collections.emptySortedMap();
+    public void update(long value) {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Histogram> getHistograms() {
-        return Collections.emptySortedMap();
+    public long getCount() {
+      return 0L;
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Histogram> getHistograms(MetricFilter filter) {
-        return Collections.emptySortedMap();
+    public Snapshot getSnapshot() {
+      return EmptySnapshot.INSTANCE;
     }
+  }
+
+  static final class NoopCounter extends Counter {
+    private static final NoopCounter INSTANCE = new NoopCounter();
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Meter> getMeters() {
-        return Collections.emptySortedMap();
+    public void inc() {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Meter> getMeters(MetricFilter filter) {
-        return Collections.emptySortedMap();
+    public void inc(long n) {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Timer> getTimers() {
-        return Collections.emptySortedMap();
+    public void dec() {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public SortedMap<MetricName, Timer> getTimers(MetricFilter filter) {
-        return Collections.emptySortedMap();
+    public void dec(long n) {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public void registerAll(MetricName prefix, MetricSet metrics) throws IllegalArgumentException {
-        // NOP
+    public long getCount() {
+      return 0L;
     }
+  }
+
+  static final class NoopMeter extends Meter {
+    private static final NoopMeter INSTANCE = new NoopMeter();
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public <T extends Metric> T register(MetricName name, T metric) throws IllegalArgumentException {
-        return requireNonNull(metric, "metric == null");
+    public void mark() {
+      // NOP
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public Map<MetricName, Metric> getMetrics() {
-        return Collections.emptyMap();
+    public void mark(long n) {
+      // NOP
     }
 
-    static final class NoopMetric implements Metric {
-        private static final NoopMetric INSTANCE = new NoopMetric();
+    /** {@inheritDoc} */
+    @Override
+    public long getCount() {
+      return 0L;
     }
 
-    static final class NoopGauge<T> implements Gauge<T> {
-        private static final NoopGauge<?> INSTANCE = new NoopGauge<>();
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public T getValue() {
-            return null;
-        }
+    /** {@inheritDoc} */
+    @Override
+    public double getFifteenMinuteRate() {
+      return 0D;
     }
 
-    private static final class EmptySnapshot extends Snapshot {
-        private static final EmptySnapshot INSTANCE = new EmptySnapshot();
-        private static final long[] EMPTY_LONG_ARRAY = new long[0];
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getValue(double quantile) {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public long[] getValues() {
-            return EMPTY_LONG_ARRAY;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public int size() {
-            return 0;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public long getMax() {
-            return 0L;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getMean() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public long getMin() {
-            return 0L;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getStdDev() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void dump(OutputStream output) {
-            // NOP
-        }
-    }
-
-    static final class NoopTimer extends Timer {
-        private static final NoopTimer INSTANCE = new NoopTimer();
-        private static final Timer.Context CONTEXT = new NoopTimer.Context();
-
-        private static class Context extends Timer.Context {
-            private static final Clock CLOCK = new Clock() {
-                /**
-                 * {@inheritDoc}
-                 */
-                @Override
-                public long getTick() {
-                    return 0L;
-                }
-
-                /**
-                 * {@inheritDoc}
-                 */
-                @Override
-                public long getTime() {
-                    return 0L;
-                }
-            };
-
-            private Context() {
-                super(INSTANCE, CLOCK);
-            }
-
-            /**
-             * {@inheritDoc}
-             */
-            @Override
-            public long stop() {
-                return 0L;
-            }
-
-            /**
-             * {@inheritDoc}
-             */
-            @Override
-            public void close() {
-                // NOP
-            }
-        }
+    /** {@inheritDoc} */
+    @Override
+    public double getFiveMinuteRate() {
+      return 0D;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void update(long duration, TimeUnit unit) {
-            // NOP
-        }
+    /** {@inheritDoc} */
+    @Override
+    public double getMeanRate() {
+      return 0D;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void update(Duration duration) {
-            // NOP
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public <T> T time(Callable<T> event) throws Exception {
-            return event.call();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public <T> T timeSupplier(Supplier<T> event) {
-            return event.get();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void time(Runnable event) {
-            // NOP
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public Timer.Context time() {
-            return CONTEXT;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public long getCount() {
-            return 0L;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getFifteenMinuteRate() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getFiveMinuteRate() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getMeanRate() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getOneMinuteRate() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public Snapshot getSnapshot() {
-            return EmptySnapshot.INSTANCE;
-        }
+    /** {@inheritDoc} */
+    @Override
+    public double getOneMinuteRate() {
+      return 0D;
     }
+  }
 
-    static final class NoopHistogram extends Histogram {
-        private static final NoopHistogram INSTANCE = new NoopHistogram();
-        private static final Reservoir EMPTY_RESERVOIR = new Reservoir() {
-            /**
-             * {@inheritDoc}
-             */
-            @Override
-            public int size() {
-                return 0;
-            }
+  private static final class EmptyConcurrentMap<K, V> implements ConcurrentMap<K, V> {
+    /** {@inheritDoc} */
+    @Override
+    public V putIfAbsent(K key, V value) {
+      return null;
+    }
 
-            /**
-             * {@inheritDoc}
-             */
-            @Override
-            public void update(long value) {
-                // NOP
-            }
+    /** {@inheritDoc} */
+    @Override
+    public boolean remove(Object key, Object value) {
+      return false;
+    }
 
-            /**
-             * {@inheritDoc}
-             */
-            @Override
-            public Snapshot getSnapshot() {
-                return EmptySnapshot.INSTANCE;
-            }
-        };
+    /** {@inheritDoc} */
+    @Override
+    public boolean replace(K key, V oldValue, V newValue) {
+      return false;
+    }
 
-        private NoopHistogram() {
-            super(EMPTY_RESERVOIR);
-        }
+    /** {@inheritDoc} */
+    @Override
+    public V replace(K key, V value) {
+      return null;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void update(int value) {
-            // NOP
-        }
+    /** {@inheritDoc} */
+    @Override
+    public int size() {
+      return 0;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void update(long value) {
-            // NOP
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public long getCount() {
-            return 0L;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public Snapshot getSnapshot() {
-            return EmptySnapshot.INSTANCE;
-        }
+    /** {@inheritDoc} */
+    @Override
+    public boolean isEmpty() {
+      return true;
     }
 
-    static final class NoopCounter extends Counter {
-        private static final NoopCounter INSTANCE = new NoopCounter();
+    /** {@inheritDoc} */
+    @Override
+    public boolean containsKey(Object key) {
+      return false;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void inc() {
-            // NOP
-        }
+    /** {@inheritDoc} */
+    @Override
+    public boolean containsValue(Object value) {
+      return false;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void inc(long n) {
-            // NOP
-        }
+    /** {@inheritDoc} */
+    @Override
+    public V get(Object key) {
+      return null;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void dec() {
-            // NOP
-        }
+    /** {@inheritDoc} */
+    @Override
+    public V put(K key, V value) {
+      return null;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void dec(long n) {
-            // NOP
-        }
+    /** {@inheritDoc} */
+    @Override
+    public V remove(Object key) {
+      return null;
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public long getCount() {
-            return 0L;
-        }
+    /** {@inheritDoc} */
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+      // NOP
     }
 
-    static final class NoopMeter extends Meter {
-        private static final NoopMeter INSTANCE = new NoopMeter();
+    /** {@inheritDoc} */
+    @Override
+    public void clear() {
+      // NOP
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void mark() {
-            // NOP
-        }
+    /** {@inheritDoc} */
+    @Override
+    public Set<K> keySet() {
+      return ImmutableSet.of();
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void mark(long n) {
-            // NOP
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public long getCount() {
-            return 0L;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getFifteenMinuteRate() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getFiveMinuteRate() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getMeanRate() {
-            return 0D;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public double getOneMinuteRate() {
-            return 0D;
-        }
-    }
-
-    private static final class EmptyConcurrentMap<K, V> implements ConcurrentMap<K, V> {
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public V putIfAbsent(K key, V value) {
-            return null;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public boolean remove(Object key, Object value) {
-            return false;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public boolean replace(K key, V oldValue, V newValue) {
-            return false;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public V replace(K key, V value) {
-            return null;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public int size() {
-            return 0;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public boolean isEmpty() {
-            return true;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public boolean containsKey(Object key) {
-            return false;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public boolean containsValue(Object value) {
-            return false;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public V get(Object key) {
-            return null;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public V put(K key, V value) {
-            return null;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public V remove(Object key) {
-            return null;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void putAll(Map<? extends K, ? extends V> m) {
-            // NOP
-        }
+    /** {@inheritDoc} */
+    @Override
+    public Collection<V> values() {
+      return ImmutableSet.of();
+    }
 
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void clear() {
-            // NOP
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public Set<K> keySet() {
-            return Collections.emptySet();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public Collection<V> values() {
-            return Collections.emptySet();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public Set<Entry<K, V>> entrySet() {
-            return Collections.emptySet();
-        }
+    /** {@inheritDoc} */
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+      return ImmutableSet.of();
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/RatioGauge.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/RatioGauge.java
@@ -5,62 +5,60 @@ import static java.lang.Double.isNaN;
 
 /**
  * A gauge which measures the ratio of one value to another.
- * <p>
- * If the denominator is zero, not a number, or infinite, the resulting ratio is not a number.
+ *
+ * <p>If the denominator is zero, not a number, or infinite, the resulting ratio is not a number.
  */
 public abstract class RatioGauge implements Gauge<Double> {
+  /** A ratio of one quantity to another. */
+  public static class Ratio {
     /**
-     * A ratio of one quantity to another.
+     * Creates a new ratio with the given numerator and denominator.
+     *
+     * @param numerator the numerator of the ratio
+     * @param denominator the denominator of the ratio
+     * @return {@code numerator:denominator}
      */
-    public static class Ratio {
-        /**
-         * Creates a new ratio with the given numerator and denominator.
-         *
-         * @param numerator   the numerator of the ratio
-         * @param denominator the denominator of the ratio
-         * @return {@code numerator:denominator}
-         */
-        public static Ratio of(double numerator, double denominator) {
-            return new Ratio(numerator, denominator);
-        }
-
-        private final double numerator;
-        private final double denominator;
-
-        private Ratio(double numerator, double denominator) {
-            this.numerator = numerator;
-            this.denominator = denominator;
-        }
+    public static Ratio of(double numerator, double denominator) {
+      return new Ratio(numerator, denominator);
+    }
 
-        /**
-         * Returns the ratio, which is either a {@code double} between 0 and 1 (inclusive) or
-         * {@code NaN}.
-         *
-         * @return the ratio
-         */
-        public double getValue() {
-            final double d = denominator;
-            if (isNaN(d) || isInfinite(d) || d == 0) {
-                return Double.NaN;
-            }
-            return numerator / d;
-        }
+    private final double numerator;
+    private final double denominator;
 
-        @Override
-        public String toString() {
-            return numerator + ":" + denominator;
-        }
+    private Ratio(double numerator, double denominator) {
+      this.numerator = numerator;
+      this.denominator = denominator;
     }
 
     /**
-     * Returns the {@link Ratio} which is the gauge's current value.
+     * Returns the ratio, which is either a {@code double} between 0 and 1 (inclusive) or {@code
+     * NaN}.
      *
-     * @return the {@link Ratio} which is the gauge's current value
+     * @return the ratio
      */
-    protected abstract Ratio getRatio();
+    public double getValue() {
+      final double d = denominator;
+      if (isNaN(d) || isInfinite(d) || d == 0) {
+        return Double.NaN;
+      }
+      return numerator / d;
+    }
 
     @Override
-    public Double getValue() {
-        return getRatio().getValue();
+    public String toString() {
+      return numerator + ":" + denominator;
     }
+  }
+
+  /**
+   * Returns the {@link Ratio} which is the gauge's current value.
+   *
+   * @return the {@link Ratio} which is the gauge's current value
+   */
+  protected abstract Ratio getRatio();
+
+  @Override
+  public Double getValue() {
+    return getRatio().getValue();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Reporter.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Reporter.java
@@ -5,6 +5,4 @@ import java.io.Closeable;
 /*
  * A tag interface to indicate that a class is a Reporter.
  */
-public interface Reporter extends Closeable {
-
-}
+public interface Reporter extends Closeable {}
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Reservoir.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Reservoir.java
@@ -1,27 +1,25 @@
 package io.dropwizard.metrics5;
 
-/**
- * A statistically representative reservoir of a data stream.
- */
+/** A statistically representative reservoir of a data stream. */
 public interface Reservoir {
-    /**
-     * Returns the number of values recorded.
-     *
-     * @return the number of values recorded
-     */
-    int size();
+  /**
+   * Returns the number of values recorded.
+   *
+   * @return the number of values recorded
+   */
+  int size();
 
-    /**
-     * Adds a new recorded value to the reservoir.
-     *
-     * @param value a new recorded value
-     */
-    void update(long value);
+  /**
+   * Adds a new recorded value to the reservoir.
+   *
+   * @param value a new recorded value
+   */
+  void update(long value);
 
-    /**
-     * Returns a snapshot of the reservoir's values.
-     *
-     * @return a snapshot of the reservoir's values
-     */
-    Snapshot getSnapshot();
+  /**
+   * Returns a snapshot of the reservoir's values.
+   *
+   * @return a snapshot of the reservoir's values
+   */
+  Snapshot getSnapshot();
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Sampling.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Sampling.java
@@ -1,13 +1,11 @@
 package io.dropwizard.metrics5;
 
-/**
- * An object which samples values.
- */
+/** An object which samples values. */
 public interface Sampling {
-    /**
-     * Returns a snapshot of the values.
-     *
-     * @return a snapshot of the values
-     */
-    Snapshot getSnapshot();
+  /**
+   * Returns a snapshot of the values.
+   *
+   * @return a snapshot of the values
+   */
+  Snapshot getSnapshot();
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/ScheduledReporter.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/ScheduledReporter.java
@@ -1,20 +1,21 @@
 package io.dropwizard.metrics5;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Objects.requireNonNull;
 
+import com.google.common.collect.ImmutableSet;
 import java.io.Closeable;
-import java.util.Collections;
 import java.util.Locale;
 import java.util.Set;
 import java.util.SortedMap;
-import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * The abstract base class for all scheduled reporters (i.e., reporters which process a registry's
@@ -26,312 +27,333 @@ import java.util.concurrent.atomic.AtomicInteger;
  */
 public abstract class ScheduledReporter implements Closeable, Reporter {
 
-    private static final Logger LOG = LoggerFactory.getLogger(ScheduledReporter.class);
-
-    /**
-     * A simple named thread factory.
-     */
-    @SuppressWarnings("NullableProblems")
-    private static class NamedThreadFactory implements ThreadFactory {
-        private final ThreadGroup group;
-        private final AtomicInteger threadNumber = new AtomicInteger(1);
-        private final String namePrefix;
-
-        private NamedThreadFactory(String name) {
-            final SecurityManager s = System.getSecurityManager();
-            this.group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
-            this.namePrefix = "metrics-" + name + "-thread-";
-        }
-
-        @Override
-        public Thread newThread(Runnable r) {
-            final Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
-            t.setDaemon(true);
-            if (t.getPriority() != Thread.NORM_PRIORITY) {
-                t.setPriority(Thread.NORM_PRIORITY);
-            }
-            return t;
-        }
-    }
-
-    private static final AtomicInteger FACTORY_ID = new AtomicInteger();
-
-    private final MetricRegistry registry;
-    private final ScheduledExecutorService executor;
-    private final boolean shutdownExecutorOnStop;
-    private final Set<MetricAttribute> disabledMetricAttributes;
-    private ScheduledFuture<?> scheduledFuture;
-    private final MetricFilter filter;
-    private final long durationFactor;
-    private final String durationUnit;
-    private final long rateFactor;
-    private final String rateUnit;
-
-    /**
-     * Creates a new {@link ScheduledReporter} instance.
-     *
-     * @param registry     the {@link io.dropwizard.metrics5.MetricRegistry} containing the metrics this
-     *                     reporter will report
-     * @param name         the reporter's name
-     * @param filter       the filter for which metrics to report
-     * @param rateUnit     a unit of time
-     * @param durationUnit a unit of time
-     */
-    protected ScheduledReporter(MetricRegistry registry,
-                                String name,
-                                MetricFilter filter,
-                                TimeUnit rateUnit,
-                                TimeUnit durationUnit) {
-        this(registry, name, filter, rateUnit, durationUnit, createDefaultExecutor(name));
-    }
-
-    /**
-     * Creates a new {@link ScheduledReporter} instance.
-     *
-     * @param registry the {@link io.dropwizard.metrics5.MetricRegistry} containing the metrics this
-     *                 reporter will report
-     * @param name     the reporter's name
-     * @param filter   the filter for which metrics to report
-     * @param executor the executor to use while scheduling reporting of metrics.
-     */
-    protected ScheduledReporter(MetricRegistry registry,
-                                String name,
-                                MetricFilter filter,
-                                TimeUnit rateUnit,
-                                TimeUnit durationUnit,
-                                ScheduledExecutorService executor) {
-        this(registry, name, filter, rateUnit, durationUnit, executor, true);
-    }
-
-    /**
-     * Creates a new {@link ScheduledReporter} instance.
-     *
-     * @param registry               the {@link io.dropwizard.metrics5.MetricRegistry} containing the metrics this
-     *                               reporter will report
-     * @param name                   the reporter's name
-     * @param filter                 the filter for which metrics to report
-     * @param executor               the executor to use while scheduling reporting of metrics.
-     * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this reporter
-     */
-    protected ScheduledReporter(MetricRegistry registry,
-                                String name,
-                                MetricFilter filter,
-                                TimeUnit rateUnit,
-                                TimeUnit durationUnit,
-                                ScheduledExecutorService executor,
-                                boolean shutdownExecutorOnStop) {
-        this(registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop, Collections.emptySet());
-    }
-
-    protected ScheduledReporter(MetricRegistry registry,
-                                String name,
-                                MetricFilter filter,
-                                TimeUnit rateUnit,
-                                TimeUnit durationUnit,
-                                ScheduledExecutorService executor,
-                                boolean shutdownExecutorOnStop,
-                                Set<MetricAttribute> disabledMetricAttributes) {
-
-        if (registry == null) {
-            throw new NullPointerException("registry == null");
-        }
+  private static final Logger LOG = LoggerFactory.getLogger(ScheduledReporter.class);
 
-        this.registry = registry;
-        this.filter = filter;
-        this.executor = executor == null ? createDefaultExecutor(name) : executor;
-        this.shutdownExecutorOnStop = shutdownExecutorOnStop;
-        this.rateFactor = rateUnit.toSeconds(1);
-        this.rateUnit = calculateRateUnit(rateUnit);
-        this.durationFactor = durationUnit.toNanos(1);
-        this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);
-        this.disabledMetricAttributes = disabledMetricAttributes != null ? disabledMetricAttributes :
-                Collections.emptySet();
-    }
+  /** A simple named thread factory. */
+  @SuppressWarnings("NullableProblems")
+  private static class NamedThreadFactory implements ThreadFactory {
+    private final ThreadGroup group;
+    private final AtomicInteger threadNumber = new AtomicInteger(1);
+    private final String namePrefix;
 
-    /**
-     * Starts the reporter polling at the given period.
-     *
-     * @param period the amount of time between polls
-     * @param unit   the unit for {@code period}
-     */
-    public void start(long period, TimeUnit unit) {
-        start(period, period, unit);
+    private NamedThreadFactory(String name) {
+      final SecurityManager s = System.getSecurityManager();
+      this.group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
+      this.namePrefix = "metrics-" + name + "-thread-";
     }
 
-    /**
-     * Starts the reporter polling at the given period with the specific runnable action.
-     * Visible only for testing.
-     */
-    synchronized void start(long initialDelay, long period, TimeUnit unit, Runnable runnable) {
-        if (this.scheduledFuture != null) {
-            throw new IllegalArgumentException("Reporter already started");
-        }
-
-        this.scheduledFuture = getScheduledFuture(initialDelay, period, unit, runnable);
-    }
-
-
-    /**
-     * Schedule the task, and return a future.
-     *
-     * @deprecated Use {@link #getScheduledFuture(long, long, TimeUnit, Runnable, ScheduledExecutorService)} instead.
-     */
-    @SuppressWarnings("DeprecatedIsStillUsed")
-    @Deprecated
-    protected ScheduledFuture<?> getScheduledFuture(long initialDelay, long period, TimeUnit unit, Runnable runnable) {
-        return getScheduledFuture(initialDelay, period, unit, runnable, this.executor);
-    }
-
-    /**
-     * Schedule the task, and return a future.
-     * The current implementation uses scheduleWithFixedDelay, replacing scheduleWithFixedRate. This avoids queueing issues, but may
-     * cause some reporters to skip metrics, as scheduleWithFixedDelay introduces a growing delta from the original start point.
-     *
-     * Overriding this in a subclass to revert to the old behavior is permitted.
-     */
-    protected ScheduledFuture<?> getScheduledFuture(long initialDelay, long period, TimeUnit unit, Runnable runnable, ScheduledExecutorService executor) {
-        return executor.scheduleWithFixedDelay(runnable, initialDelay, period, unit);
+    @Override
+    public Thread newThread(Runnable r) {
+      final Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
+      t.setDaemon(true);
+      if (t.getPriority() != Thread.NORM_PRIORITY) {
+        t.setPriority(Thread.NORM_PRIORITY);
+      }
+      return t;
     }
-
-    /**
-     * Starts the reporter polling at the given period.
-     *
-     * @param initialDelay the time to delay the first execution
-     * @param period       the amount of time between polls
-     * @param unit         the unit for {@code period} and {@code initialDelay}
-     */
-    synchronized public void start(long initialDelay, long period, TimeUnit unit) {
-        start(initialDelay, period, unit, () -> {
-            try {
-                report();
-            } catch (Throwable ex) {
-                LOG.error("Exception thrown from {}#report. Exception was suppressed.", ScheduledReporter.this.getClass().getSimpleName(), ex);
-            }
+  }
+
+  private static final AtomicInteger FACTORY_ID = new AtomicInteger();
+
+  private final MetricRegistry registry;
+  private final ScheduledExecutorService executor;
+  private final boolean shutdownExecutorOnStop;
+  private final Set<MetricAttribute> disabledMetricAttributes;
+  private ScheduledFuture<?> scheduledFuture;
+  private final MetricFilter filter;
+  private final long durationFactor;
+  private final String durationUnit;
+  private final long rateFactor;
+  private final String rateUnit;
+
+  /**
+   * Creates a new {@link ScheduledReporter} instance.
+   *
+   * @param registry the {@link io.dropwizard.metrics5.MetricRegistry} containing the metrics this
+   *     reporter will report
+   * @param name the reporter's name
+   * @param filter the filter for which metrics to report
+   * @param rateUnit a unit of time
+   * @param durationUnit a unit of time
+   */
+  protected ScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit) {
+    this(registry, name, filter, rateUnit, durationUnit, createDefaultExecutor(name));
+  }
+
+  /**
+   * Creates a new {@link ScheduledReporter} instance.
+   *
+   * @param registry the {@link io.dropwizard.metrics5.MetricRegistry} containing the metrics this
+   *     reporter will report
+   * @param name the reporter's name
+   * @param filter the filter for which metrics to report
+   * @param executor the executor to use while scheduling reporting of metrics.
+   */
+  protected ScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      ScheduledExecutorService executor) {
+    this(registry, name, filter, rateUnit, durationUnit, executor, true);
+  }
+
+  /**
+   * Creates a new {@link ScheduledReporter} instance.
+   *
+   * @param registry the {@link io.dropwizard.metrics5.MetricRegistry} containing the metrics this
+   *     reporter will report
+   * @param name the reporter's name
+   * @param filter the filter for which metrics to report
+   * @param executor the executor to use while scheduling reporting of metrics.
+   * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+   *     reporter
+   */
+  protected ScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop) {
+    this(
+        registry,
+        name,
+        filter,
+        rateUnit,
+        durationUnit,
+        executor,
+        shutdownExecutorOnStop,
+        ImmutableSet.of());
+  }
+
+  protected ScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes) {
+
+    requireNonNull(registry, "registry == null");
+
+    this.registry = registry;
+    this.filter = filter;
+    this.executor = executor == null ? createDefaultExecutor(name) : executor;
+    this.shutdownExecutorOnStop = shutdownExecutorOnStop;
+    this.rateFactor = rateUnit.toSeconds(1);
+    this.rateUnit = calculateRateUnit(rateUnit);
+    this.durationFactor = durationUnit.toNanos(1);
+    this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);
+    this.disabledMetricAttributes =
+        disabledMetricAttributes != null ? disabledMetricAttributes : ImmutableSet.of();
+  }
+
+  /**
+   * Starts the reporter polling at the given period.
+   *
+   * @param period the amount of time between polls
+   * @param unit the unit for {@code period}
+   */
+  public void start(long period, TimeUnit unit) {
+    start(period, period, unit);
+  }
+
+  /**
+   * Starts the reporter polling at the given period with the specific runnable action. Visible only
+   * for testing.
+   */
+  synchronized void start(long initialDelay, long period, TimeUnit unit, Runnable runnable) {
+    checkArgument(this.scheduledFuture == null, "Reporter already started");
+
+    this.scheduledFuture = getScheduledFuture(initialDelay, period, unit, runnable);
+  }
+
+  /**
+   * Schedule the task, and return a future.
+   *
+   * @deprecated Use {@link #getScheduledFuture(long, long, TimeUnit, Runnable,
+   *     ScheduledExecutorService)} instead.
+   */
+  @Deprecated
+  @SuppressWarnings("DeprecatedIsStillUsed")
+  protected ScheduledFuture<?> getScheduledFuture(
+      long initialDelay, long period, TimeUnit unit, Runnable runnable) {
+    return getScheduledFuture(initialDelay, period, unit, runnable, this.executor);
+  }
+
+  /**
+   * Schedule the task, and return a future. The current implementation uses scheduleWithFixedDelay,
+   * replacing scheduleWithFixedRate. This avoids queueing issues, but may cause some reporters to
+   * skip metrics, as scheduleWithFixedDelay introduces a growing delta from the original start
+   * point.
+   *
+   * <p>Overriding this in a subclass to revert to the old behavior is permitted.
+   */
+  protected ScheduledFuture<?> getScheduledFuture(
+      long initialDelay,
+      long period,
+      TimeUnit unit,
+      Runnable runnable,
+      ScheduledExecutorService executor) {
+    return executor.scheduleWithFixedDelay(runnable, initialDelay, period, unit);
+  }
+
+  /**
+   * Starts the reporter polling at the given period.
+   *
+   * @param initialDelay the time to delay the first execution
+   * @param period the amount of time between polls
+   * @param unit the unit for {@code period} and {@code initialDelay}
+   */
+  public synchronized void start(long initialDelay, long period, TimeUnit unit) {
+    start(
+        initialDelay,
+        period,
+        unit,
+        () -> {
+          try {
+            report();
+          } catch (Throwable ex) {
+            LOG.error(
+                "Exception thrown from {}#report. Exception was suppressed.",
+                ScheduledReporter.this.getClass().getSimpleName(),
+                ex);
+          }
         });
+  }
+
+  /**
+   * Stops the reporter and if shutdownExecutorOnStop is true then shuts down its thread of
+   * execution.
+   *
+   * <p>Uses the shutdown pattern from
+   * http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html
+   */
+  public void stop() {
+    if (shutdownExecutorOnStop) {
+      executor.shutdown(); // Disable new tasks from being submitted
     }
 
-    /**
-     * Stops the reporter and if shutdownExecutorOnStop is true then shuts down its thread of execution.
-     * <p>
-     * Uses the shutdown pattern from http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html
-     */
-    public void stop() {
-        if (shutdownExecutorOnStop) {
-            executor.shutdown(); // Disable new tasks from being submitted
-        }
-
-        if (this.scheduledFuture != null) {
-            // Reporter started, try to report metrics one last time
-            try {
-                report();
-            } catch (Exception e) {
-                LOG.warn("Final reporting of metrics failed.", e);
-            }
-        }
-
-        if (shutdownExecutorOnStop) {
-            try {
-                // Wait a while for existing tasks to terminate
-                if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {
-                    executor.shutdownNow(); // Cancel currently executing tasks
-                    // Wait a while for tasks to respond to being cancelled
-                    if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {
-                        LOG.warn("ScheduledExecutorService did not terminate.");
-                    }
-                }
-            } catch (InterruptedException ie) {
-                // (Re-)Cancel if current thread also interrupted
-                executor.shutdownNow();
-                // Preserve interrupt status
-                Thread.currentThread().interrupt();
-            }
-        } else {
-            // The external manager (like JEE container) responsible for lifecycle of executor
-            cancelScheduledFuture();
-        }
+    if (this.scheduledFuture != null) {
+      // Reporter started, try to report metrics one last time
+      try {
+        report();
+      } catch (Exception e) {
+        LOG.warn("Final reporting of metrics failed.", e);
+      }
     }
 
-    private synchronized void cancelScheduledFuture() {
-        if (this.scheduledFuture == null) {
-            // was never started
-            return;
-        }
-        if (this.scheduledFuture.isCancelled()) {
-            // already cancelled
-            return;
+    if (shutdownExecutorOnStop) {
+      try {
+        // Wait a while for existing tasks to terminate
+        if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {
+          executor.shutdownNow(); // Cancel currently executing tasks
+          // Wait a while for tasks to respond to being cancelled
+          if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {
+            LOG.warn("ScheduledExecutorService did not terminate.");
+          }
         }
-        // just cancel the scheduledFuture and exit
-        this.scheduledFuture.cancel(false);
+      } catch (InterruptedException ie) {
+        // (Re-)Cancel if current thread also interrupted
+        executor.shutdownNow();
+        // Preserve interrupt status
+        Thread.currentThread().interrupt();
+      }
+    } else {
+      // The external manager (like JEE container) responsible for lifecycle of executor
+      cancelScheduledFuture();
     }
+  }
 
-    /**
-     * Stops the reporter and shuts down its thread of execution.
-     */
-    @Override
-    public void close() {
-        stop();
+  private synchronized void cancelScheduledFuture() {
+    if (this.scheduledFuture == null) {
+      // was never started
+      return;
     }
-
-    /**
-     * Report the current values of all metrics in the registry.
-     */
-    public void report() {
-        synchronized (this) {
-            report(registry.getGauges(filter),
-                    registry.getCounters(filter),
-                    registry.getHistograms(filter),
-                    registry.getMeters(filter),
-                    registry.getTimers(filter));
-        }
-    }
-
-    /**
-     * Called periodically by the polling thread. Subclasses should report all the given metrics.
-     *
-     * @param gauges     all of the gauges in the registry
-     * @param counters   all of the counters in the registry
-     * @param histograms all of the histograms in the registry
-     * @param meters     all of the meters in the registry
-     * @param timers     all of the timers in the registry
-     */
-    @SuppressWarnings("rawtypes")
-    public abstract void report(SortedMap<MetricName, Gauge<?>> gauges,
-                                SortedMap<MetricName, Counter> counters,
-                                SortedMap<MetricName, Histogram> histograms,
-                                SortedMap<MetricName, Meter> meters,
-                                SortedMap<MetricName, Timer> timers);
-
-    public String getRateUnit() {
-        return rateUnit;
+    if (this.scheduledFuture.isCancelled()) {
+      // already cancelled
+      return;
     }
-
-    public String getDurationUnit() {
-        return durationUnit;
+    // just cancel the scheduledFuture and exit
+    this.scheduledFuture.cancel(false);
+  }
+
+  /** Stops the reporter and shuts down its thread of execution. */
+  @Override
+  public void close() {
+    stop();
+  }
+
+  /** Report the current values of all metrics in the registry. */
+  public void report() {
+    synchronized (this) {
+      report(
+          registry.getGauges(filter),
+          registry.getCounters(filter),
+          registry.getHistograms(filter),
+          registry.getMeters(filter),
+          registry.getTimers(filter));
     }
-
-    public double convertDuration(double duration) {
-        return duration / durationFactor;
-    }
-
-    public double convertRate(double rate) {
-        return rate * rateFactor;
-    }
-
-    public boolean isShutdownExecutorOnStop() {
-        return shutdownExecutorOnStop;
-    }
-
-    public Set<MetricAttribute> getDisabledMetricAttributes() {
-        return disabledMetricAttributes;
-    }
-
-    private String calculateRateUnit(TimeUnit unit) {
-        final String s = unit.toString().toLowerCase(Locale.US);
-        return s.substring(0, s.length() - 1);
-    }
-
-    private static ScheduledExecutorService createDefaultExecutor(String name) {
-        return Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(name + '-' + FACTORY_ID.incrementAndGet()));
-    }
-
+  }
+
+  /**
+   * Called periodically by the polling thread. Subclasses should report all the given metrics.
+   *
+   * @param gauges all of the gauges in the registry
+   * @param counters all of the counters in the registry
+   * @param histograms all of the histograms in the registry
+   * @param meters all of the meters in the registry
+   * @param timers all of the timers in the registry
+   */
+  @SuppressWarnings("rawtypes")
+  public abstract void report(
+      SortedMap<MetricName, Gauge<?>> gauges,
+      SortedMap<MetricName, Counter> counters,
+      SortedMap<MetricName, Histogram> histograms,
+      SortedMap<MetricName, Meter> meters,
+      SortedMap<MetricName, Timer> timers);
+
+  public String getRateUnit() {
+    return rateUnit;
+  }
+
+  public String getDurationUnit() {
+    return durationUnit;
+  }
+
+  public double convertDuration(double duration) {
+    return duration / durationFactor;
+  }
+
+  public double convertRate(double rate) {
+    return rate * rateFactor;
+  }
+
+  public boolean isShutdownExecutorOnStop() {
+    return shutdownExecutorOnStop;
+  }
+
+  public Set<MetricAttribute> getDisabledMetricAttributes() {
+    return disabledMetricAttributes;
+  }
+
+  private String calculateRateUnit(TimeUnit unit) {
+    final String s = unit.toString().toLowerCase(Locale.US);
+    return s.substring(0, s.length() - 1);
+  }
+
+  private static ScheduledExecutorService createDefaultExecutor(String name) {
+    return Executors.newSingleThreadScheduledExecutor(
+        new NamedThreadFactory(name + '-' + FACTORY_ID.incrementAndGet()));
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/SettableGauge.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/SettableGauge.java
@@ -1,14 +1,10 @@
 package io.dropwizard.metrics5;
 
 /**
- * <p>
  * Similar to {@link Gauge}, but metric value is updated via calling {@link #setValue(T)} instead.
  * See {@link DefaultSettableGauge}.
- * </p>
  */
 public interface SettableGauge<T> extends Gauge<T> {
-    /**
-     * Set the metric to a new value.
-     */
-    void setValue(T value);
+  /** Set the metric to a new value. */
+  void setValue(T value);
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/SharedMetricRegistries.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/SharedMetricRegistries.java
@@ -1,107 +1,106 @@
 package io.dropwizard.metrics5;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicReference;
 
-/**
- * A map of shared, named metric registries.
- */
+/** A map of shared, named metric registries. */
 public class SharedMetricRegistries {
-    private static final ConcurrentMap<String, MetricRegistry> REGISTRIES =
-            new ConcurrentHashMap<>();
+  private static final ConcurrentMap<String, MetricRegistry> REGISTRIES = new ConcurrentHashMap<>();
 
-    private static AtomicReference<String> defaultRegistryName = new AtomicReference<>();
+  private static AtomicReference<String> defaultRegistryName = new AtomicReference<>();
 
-    /* Visible for testing */
-    static void setDefaultRegistryName(AtomicReference<String> defaultRegistryName) {
-        SharedMetricRegistries.defaultRegistryName = defaultRegistryName;
-    }
+  /* Visible for testing */
+  static void setDefaultRegistryName(AtomicReference<String> defaultRegistryName) {
+    SharedMetricRegistries.defaultRegistryName = defaultRegistryName;
+  }
 
-    private SharedMetricRegistries() { /* singleton */ }
+  private SharedMetricRegistries() {
+    /* singleton */
+  }
 
-    public static void clear() {
-        REGISTRIES.clear();
-    }
+  public static void clear() {
+    REGISTRIES.clear();
+  }
 
-    public static Set<String> names() {
-        return REGISTRIES.keySet();
-    }
+  public static Set<String> names() {
+    return REGISTRIES.keySet();
+  }
 
-    public static void remove(String key) {
-        REGISTRIES.remove(key);
-    }
+  public static void remove(String key) {
+    REGISTRIES.remove(key);
+  }
 
-    public static MetricRegistry add(String name, MetricRegistry registry) {
-        return REGISTRIES.putIfAbsent(name, registry);
-    }
+  public static MetricRegistry add(String name, MetricRegistry registry) {
+    return REGISTRIES.putIfAbsent(name, registry);
+  }
 
-    public static MetricRegistry getOrCreate(String name) {
-        final MetricRegistry existing = REGISTRIES.get(name);
-        if (existing == null) {
-            final MetricRegistry created = new MetricRegistry();
-            final MetricRegistry raced = add(name, created);
-            if (raced == null) {
-                return created;
-            }
-            return raced;
-        }
-        return existing;
+  public static MetricRegistry getOrCreate(String name) {
+    final MetricRegistry existing = REGISTRIES.get(name);
+    if (existing == null) {
+      final MetricRegistry created = new MetricRegistry();
+      final MetricRegistry raced = add(name, created);
+      if (raced == null) {
+        return created;
+      }
+      return raced;
     }
+    return existing;
+  }
 
-    /**
-     * Creates a new registry and sets it as the default one under the provided name.
-     *
-     * @param name the registry name
-     * @return the default registry
-     * @throws IllegalStateException if the name has already been set
-     */
-    public synchronized static MetricRegistry setDefault(String name) {
-        final MetricRegistry registry = getOrCreate(name);
-        return setDefault(name, registry);
-    }
+  /**
+   * Creates a new registry and sets it as the default one under the provided name.
+   *
+   * @param name the registry name
+   * @return the default registry
+   * @throws IllegalStateException if the name has already been set
+   */
+  public static synchronized MetricRegistry setDefault(String name) {
+    final MetricRegistry registry = getOrCreate(name);
+    return setDefault(name, registry);
+  }
 
-    /**
-     * Sets the provided registry as the default one under the provided name
-     *
-     * @param name           the default registry name
-     * @param metricRegistry the default registry
-     * @throws IllegalStateException if the default registry has already been set
-     */
-    public static MetricRegistry setDefault(String name, MetricRegistry metricRegistry) {
-        if (defaultRegistryName.compareAndSet(null, name)) {
-            add(name, metricRegistry);
-            return metricRegistry;
-        }
-        throw new IllegalStateException("Default metric registry name is already set.");
+  /**
+   * Sets the provided registry as the default one under the provided name
+   *
+   * @param name the default registry name
+   * @param metricRegistry the default registry
+   * @throws IllegalStateException if the default registry has already been set
+   */
+  public static MetricRegistry setDefault(String name, MetricRegistry metricRegistry) {
+    if (defaultRegistryName.compareAndSet(null, name)) {
+      add(name, metricRegistry);
+      return metricRegistry;
     }
+    throw new IllegalStateException("Default metric registry name is already set.");
+  }
 
-    /**
-     * Gets the name of the default registry, if it has been set
-     *
-     * @return the default registry
-     * @throws IllegalStateException if the default has not been set
-     */
-    public static MetricRegistry getDefault() {
-        MetricRegistry metricRegistry = tryGetDefault();
-        if (metricRegistry == null) {
-            throw new IllegalStateException("Default registry name has not been set.");
-        }
-        return metricRegistry;
-    }
+  /**
+   * Gets the name of the default registry, if it has been set
+   *
+   * @return the default registry
+   * @throws IllegalStateException if the default has not been set
+   */
+  public static MetricRegistry getDefault() {
+    MetricRegistry metricRegistry = tryGetDefault();
+    checkState(metricRegistry != null, "Default registry name has not been set.");
+    return metricRegistry;
+  }
 
-    /**
-     * Same as {@link #getDefault()} except returns null when the default registry has not been set.
-     *
-     * @return the default registry or null
-     */
-    public static MetricRegistry tryGetDefault() {
-        final String name = defaultRegistryName.get();
-        if (name != null) {
-            return getOrCreate(name);
-        } else {
-            return null;
-        }
+  /**
+   * Same as {@link #getDefault()} except returns null when the default registry has not been set.
+   *
+   * @return the default registry or null
+   */
+  public static MetricRegistry tryGetDefault() {
+    final String name = defaultRegistryName.get();
+    if (name != null) {
+      return getOrCreate(name);
+    } else {
+      return null;
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Slf4jReporter.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Slf4jReporter.java
@@ -1,25 +1,11 @@
 package io.dropwizard.metrics5;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.slf4j.Marker;
-
-import java.util.Collections;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.SortedMap;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-
 import static io.dropwizard.metrics5.MetricAttribute.COUNT;
 import static io.dropwizard.metrics5.MetricAttribute.M15_RATE;
 import static io.dropwizard.metrics5.MetricAttribute.M1_RATE;
 import static io.dropwizard.metrics5.MetricAttribute.M5_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.MAX;
 import static io.dropwizard.metrics5.MetricAttribute.MEAN;
 import static io.dropwizard.metrics5.MetricAttribute.MEAN_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.MIN;
 import static io.dropwizard.metrics5.MetricAttribute.P50;
 import static io.dropwizard.metrics5.MetricAttribute.P75;
 import static io.dropwizard.metrics5.MetricAttribute.P95;
@@ -28,6 +14,17 @@ import static io.dropwizard.metrics5.MetricAttribute.P99;
 import static io.dropwizard.metrics5.MetricAttribute.P999;
 import static io.dropwizard.metrics5.MetricAttribute.STDDEV;
 
+import com.google.common.collect.ImmutableSet;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.slf4j.Marker;
+
 /**
  * A reporter class for logging metrics values to a SLF4J {@link Logger} periodically, similar to
  * {@link ConsoleReporter} or {@link CsvReporter}, but using the SLF4J framework instead. It also
@@ -35,482 +32,507 @@ import static io.dropwizard.metrics5.MetricAttribute.STDDEV;
  * for the bound logging toolkit to further process metrics reports.
  */
 public class Slf4jReporter extends ScheduledReporter {
+  /**
+   * Returns a new {@link Builder} for {@link Slf4jReporter}.
+   *
+   * @param registry the registry to report
+   * @return a {@link Builder} instance for a {@link Slf4jReporter}
+   */
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
+
+  public enum LoggingLevel {
+    TRACE,
+    DEBUG,
+    INFO,
+    WARN,
+    ERROR
+  }
+
+  /**
+   * A builder for {@link Slf4jReporter} instances. Defaults to logging to {@code metrics}, not
+   * using a marker, converting rates to events/second, converting durations to milliseconds, and
+   * not filtering metrics.
+   */
+  public static class Builder {
+    private final MetricRegistry registry;
+    private Logger logger;
+    private LoggingLevel loggingLevel;
+    private Marker marker;
+    private String prefix;
+    private TimeUnit rateUnit;
+    private TimeUnit durationUnit;
+    private MetricFilter filter;
+    private ScheduledExecutorService executor;
+    private boolean shutdownExecutorOnStop;
+    private Set<MetricAttribute> disabledMetricAttributes;
+
+    private Builder(MetricRegistry registry) {
+      this.registry = registry;
+      this.logger = LoggerFactory.getLogger("metrics");
+      this.marker = null;
+      this.prefix = "";
+      this.rateUnit = TimeUnit.SECONDS;
+      this.durationUnit = TimeUnit.MILLISECONDS;
+      this.filter = MetricFilter.ALL;
+      this.loggingLevel = LoggingLevel.INFO;
+      this.executor = null;
+      this.shutdownExecutorOnStop = true;
+      this.disabledMetricAttributes = ImmutableSet.of();
+    }
+
     /**
-     * Returns a new {@link Builder} for {@link Slf4jReporter}.
+     * Specifies whether or not, the executor (used for reporting) will be stopped with same time
+     * with reporter. Default value is true. Setting this parameter to false, has the sense in
+     * combining with providing external managed executor via {@link
+     * #scheduleOn(ScheduledExecutorService)}.
      *
-     * @param registry the registry to report
-     * @return a {@link Builder} instance for a {@link Slf4jReporter}
+     * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+     *     reporter
+     * @return {@code this}
      */
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
+    public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      this.shutdownExecutorOnStop = shutdownExecutorOnStop;
+      return this;
     }
 
-    public enum LoggingLevel { TRACE, DEBUG, INFO, WARN, ERROR }
+    /**
+     * Specifies the executor to use while scheduling reporting of metrics. Default value is null.
+     * Null value leads to executor will be auto created on start.
+     *
+     * @param executor the executor to use while scheduling reporting of metrics.
+     * @return {@code this}
+     */
+    public Builder scheduleOn(ScheduledExecutorService executor) {
+      this.executor = executor;
+      return this;
+    }
 
     /**
-     * A builder for {@link Slf4jReporter} instances. Defaults to logging to {@code metrics}, not
-     * using a marker, converting rates to events/second, converting durations to milliseconds, and
-     * not filtering metrics.
+     * Log metrics to the given logger.
+     *
+     * @param logger an SLF4J {@link Logger}
+     * @return {@code this}
      */
-    public static class Builder {
-        private final MetricRegistry registry;
-        private Logger logger;
-        private LoggingLevel loggingLevel;
-        private Marker marker;
-        private String prefix;
-        private TimeUnit rateUnit;
-        private TimeUnit durationUnit;
-        private MetricFilter filter;
-        private ScheduledExecutorService executor;
-        private boolean shutdownExecutorOnStop;
-        private Set<MetricAttribute> disabledMetricAttributes;
-
-        private Builder(MetricRegistry registry) {
-            this.registry = registry;
-            this.logger = LoggerFactory.getLogger("metrics");
-            this.marker = null;
-            this.prefix = "";
-            this.rateUnit = TimeUnit.SECONDS;
-            this.durationUnit = TimeUnit.MILLISECONDS;
-            this.filter = MetricFilter.ALL;
-            this.loggingLevel = LoggingLevel.INFO;
-            this.executor = null;
-            this.shutdownExecutorOnStop = true;
-            this.disabledMetricAttributes = Collections.emptySet();
-        }
-
-        /**
-         * Specifies whether or not, the executor (used for reporting) will be stopped with same time with reporter.
-         * Default value is true.
-         * Setting this parameter to false, has the sense in combining with providing external managed executor via {@link #scheduleOn(ScheduledExecutorService)}.
-         *
-         * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this reporter
-         * @return {@code this}
-         */
-        public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            this.shutdownExecutorOnStop = shutdownExecutorOnStop;
-            return this;
-        }
-
-        /**
-         * Specifies the executor to use while scheduling reporting of metrics.
-         * Default value is null.
-         * Null value leads to executor will be auto created on start.
-         *
-         * @param executor the executor to use while scheduling reporting of metrics.
-         * @return {@code this}
-         */
-        public Builder scheduleOn(ScheduledExecutorService executor) {
-            this.executor = executor;
-            return this;
-        }
-
-        /**
-         * Log metrics to the given logger.
-         *
-         * @param logger an SLF4J {@link Logger}
-         * @return {@code this}
-         */
-        public Builder outputTo(Logger logger) {
-            this.logger = logger;
-            return this;
-        }
-
-        /**
-         * Mark all logged metrics with the given marker.
-         *
-         * @param marker an SLF4J {@link Marker}
-         * @return {@code this}
-         */
-        public Builder markWith(Marker marker) {
-            this.marker = marker;
-            return this;
-        }
-
-        /**
-         * Prefix all metric names with the given string.
-         *
-         * @param prefix the prefix for all metric names
-         * @return {@code this}
-         */
-        public Builder prefixedWith(String prefix) {
-            this.prefix = prefix;
-            return this;
-        }
-
-        /**
-         * Convert rates to the given time unit.
-         *
-         * @param rateUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertRatesTo(TimeUnit rateUnit) {
-            this.rateUnit = rateUnit;
-            return this;
-        }
-
-        /**
-         * Convert durations to the given time unit.
-         *
-         * @param durationUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertDurationsTo(TimeUnit durationUnit) {
-            this.durationUnit = durationUnit;
-            return this;
-        }
-
-        /**
-         * Only report metrics which match the given filter.
-         *
-         * @param filter a {@link MetricFilter}
-         * @return {@code this}
-         */
-        public Builder filter(MetricFilter filter) {
-            this.filter = filter;
-            return this;
-        }
-
-        /**
-         * Use Logging Level when reporting.
-         *
-         * @param loggingLevel a (@link Slf4jReporter.LoggingLevel}
-         * @return {@code this}
-         */
-        public Builder withLoggingLevel(LoggingLevel loggingLevel) {
-            this.loggingLevel = loggingLevel;
-            return this;
-        }
-
-        /**
-         * Don't report the passed metric attributes for all metrics (e.g. "p999", "stddev" or "m15").
-         * See {@link MetricAttribute}.
-         *
-         * @param disabledMetricAttributes a set of {@link MetricAttribute}
-         * @return {@code this}
-         */
-        public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
-            this.disabledMetricAttributes = disabledMetricAttributes;
-            return this;
-        }
-
-        /**
-         * Builds a {@link Slf4jReporter} with the given properties.
-         *
-         * @return a {@link Slf4jReporter}
-         */
-        public Slf4jReporter build() {
-            LoggerProxy loggerProxy;
-            switch (loggingLevel) {
-                case TRACE:
-                    loggerProxy = new TraceLoggerProxy(logger);
-                    break;
-                case INFO:
-                    loggerProxy = new InfoLoggerProxy(logger);
-                    break;
-                case WARN:
-                    loggerProxy = new WarnLoggerProxy(logger);
-                    break;
-                case ERROR:
-                    loggerProxy = new ErrorLoggerProxy(logger);
-                    break;
-                default:
-                case DEBUG:
-                    loggerProxy = new DebugLoggerProxy(logger);
-                    break;
-            }
-            return new Slf4jReporter(registry, loggerProxy, marker, prefix, rateUnit, durationUnit, filter, executor,
-                    shutdownExecutorOnStop, disabledMetricAttributes);
-        }
-    }
-
-    private final LoggerProxy loggerProxy;
-    private final Marker marker;
-    private final MetricName prefix;
-
-    private Slf4jReporter(MetricRegistry registry,
-                          LoggerProxy loggerProxy,
-                          Marker marker,
-                          String prefix,
-                          TimeUnit rateUnit,
-                          TimeUnit durationUnit,
-                          MetricFilter filter,
-                          ScheduledExecutorService executor,
-                          boolean shutdownExecutorOnStop,
-                          Set<MetricAttribute> disabledMetricAttributes) {
-        super(registry, "logger-reporter", filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop,
-                disabledMetricAttributes);
-        this.loggerProxy = loggerProxy;
-        this.marker = marker;
-        this.prefix = MetricName.build(prefix);
+    public Builder outputTo(Logger logger) {
+      this.logger = logger;
+      return this;
     }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void report(SortedMap<MetricName, Gauge<?>> gauges,
-                       SortedMap<MetricName, Counter> counters,
-                       SortedMap<MetricName, Histogram> histograms,
-                       SortedMap<MetricName, Meter> meters,
-                       SortedMap<MetricName, Timer> timers) {
-        if (loggerProxy.isEnabled(marker)) {
-            StringBuilder b = new StringBuilder();
-            for (Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
-                logGauge(b, entry.getKey(), entry.getValue());
-            }
-
-            for (Entry<MetricName, Counter> entry : counters.entrySet()) {
-                logCounter(b, entry.getKey(), entry.getValue());
-            }
-
-            for (Entry<MetricName, Histogram> entry : histograms.entrySet()) {
-                logHistogram(b, entry.getKey(), entry.getValue());
-            }
-
-            for (Entry<MetricName, Meter> entry : meters.entrySet()) {
-                logMeter(b, entry.getKey(), entry.getValue());
-            }
-
-            for (Entry<MetricName, Timer> entry : timers.entrySet()) {
-                logTimer(b, entry.getKey(), entry.getValue());
-            }
-        }
-    }
-
-    private void logTimer(StringBuilder b, MetricName name, Timer timer) {
-        final Snapshot snapshot = timer.getSnapshot();
-        b.setLength(0);
-        b.append("type=TIMER");
-        append(b, "name", prefix(name));
-        appendCountIfEnabled(b, timer);
-        appendLongDurationIfEnabled(b, MIN, snapshot::getMin);
-        appendLongDurationIfEnabled(b, MAX, snapshot::getMax);
-        appendDoubleDurationIfEnabled(b, MEAN, snapshot::getMean);
-        appendDoubleDurationIfEnabled(b, STDDEV, snapshot::getStdDev);
-        appendDoubleDurationIfEnabled(b, P50, snapshot::getMedian);
-        appendDoubleDurationIfEnabled(b, P75, snapshot::get75thPercentile);
-        appendDoubleDurationIfEnabled(b, P95, snapshot::get95thPercentile);
-        appendDoubleDurationIfEnabled(b, P98, snapshot::get98thPercentile);
-        appendDoubleDurationIfEnabled(b, P99, snapshot::get99thPercentile);
-        appendDoubleDurationIfEnabled(b, P999, snapshot::get999thPercentile);
-        appendMetered(b, timer);
-        append(b, "rate_unit", getRateUnit());
-        append(b, "duration_unit", getDurationUnit());
-        loggerProxy.log(marker, b.toString());
-    }
-
-    private void logMeter(StringBuilder b, MetricName name, Meter meter) {
-        b.setLength(0);
-        b.append("type=METER");
-        append(b, "name", prefix(name));
-        appendCountIfEnabled(b, meter);
-        appendMetered(b, meter);
-        append(b, "rate_unit", getRateUnit());
-        loggerProxy.log(marker, b.toString());
-    }
-
-    private void logHistogram(StringBuilder b, MetricName name, Histogram histogram) {
-        final Snapshot snapshot = histogram.getSnapshot();
-        b.setLength(0);
-        b.append("type=HISTOGRAM");
-        append(b, "name", prefix(name));
-        appendCountIfEnabled(b, histogram);
-        appendLongIfEnabled(b, MIN, snapshot::getMin);
-        appendLongIfEnabled(b, MAX, snapshot::getMax);
-        appendDoubleIfEnabled(b, MEAN, snapshot::getMean);
-        appendDoubleIfEnabled(b, STDDEV, snapshot::getStdDev);
-        appendDoubleIfEnabled(b, P50, snapshot::getMedian);
-        appendDoubleIfEnabled(b, P75, snapshot::get75thPercentile);
-        appendDoubleIfEnabled(b, P95, snapshot::get95thPercentile);
-        appendDoubleIfEnabled(b, P98, snapshot::get98thPercentile);
-        appendDoubleIfEnabled(b, P99, snapshot::get99thPercentile);
-        appendDoubleIfEnabled(b, P999, snapshot::get999thPercentile);
-        loggerProxy.log(marker, b.toString());
-    }
-
-    private void logCounter(StringBuilder b, MetricName name, Counter counter) {
-        b.setLength(0);
-        b.append("type=COUNTER");
-        append(b, "name", prefix(name));
-        append(b, COUNT.getCode(), counter.getCount());
-        loggerProxy.log(marker, b.toString());
-    }
-
-    private void logGauge(StringBuilder b, MetricName name, Gauge<?> gauge) {
-        b.setLength(0);
-        b.append("type=GAUGE");
-        append(b, "name", prefix(name));
-        append(b, "value", gauge.getValue());
-        loggerProxy.log(marker, b.toString());
-    }
-
-    private void appendLongDurationIfEnabled(StringBuilder b, MetricAttribute metricAttribute,
-                                             Supplier<Long> durationSupplier) {
-        if (!getDisabledMetricAttributes().contains(metricAttribute)) {
-            append(b, metricAttribute.getCode(), convertDuration(durationSupplier.get()));
-        }
-    }
-
-    private void appendDoubleDurationIfEnabled(StringBuilder b, MetricAttribute metricAttribute,
-                                               Supplier<Double> durationSupplier) {
-        if (!getDisabledMetricAttributes().contains(metricAttribute)) {
-            append(b, metricAttribute.getCode(), convertDuration(durationSupplier.get()));
-        }
+    /**
+     * Mark all logged metrics with the given marker.
+     *
+     * @param marker an SLF4J {@link Marker}
+     * @return {@code this}
+     */
+    public Builder markWith(Marker marker) {
+      this.marker = marker;
+      return this;
     }
 
-    private void appendLongIfEnabled(StringBuilder b, MetricAttribute metricAttribute,
-                                     Supplier<Long> valueSupplier) {
-        if (!getDisabledMetricAttributes().contains(metricAttribute)) {
-            append(b, metricAttribute.getCode(), valueSupplier.get());
-        }
+    /**
+     * Prefix all metric names with the given string.
+     *
+     * @param prefix the prefix for all metric names
+     * @return {@code this}
+     */
+    public Builder prefixedWith(String prefix) {
+      this.prefix = prefix;
+      return this;
     }
 
-    private void appendDoubleIfEnabled(StringBuilder b, MetricAttribute metricAttribute,
-                                       Supplier<Double> valueSupplier) {
-        if (!getDisabledMetricAttributes().contains(metricAttribute)) {
-            append(b, metricAttribute.getCode(), valueSupplier.get());
-        }
+    /**
+     * Convert rates to the given time unit.
+     *
+     * @param rateUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertRatesTo(TimeUnit rateUnit) {
+      this.rateUnit = rateUnit;
+      return this;
     }
 
-    private void appendCountIfEnabled(StringBuilder b, Counting counting) {
-        if (!getDisabledMetricAttributes().contains(COUNT)) {
-            append(b, COUNT.getCode(), counting.getCount());
-        }
+    /**
+     * Convert durations to the given time unit.
+     *
+     * @param durationUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertDurationsTo(TimeUnit durationUnit) {
+      this.durationUnit = durationUnit;
+      return this;
     }
 
-    private void appendMetered(StringBuilder b, Metered meter) {
-        appendRateIfEnabled(b, M1_RATE, meter::getOneMinuteRate);
-        appendRateIfEnabled(b, M5_RATE, meter::getFiveMinuteRate);
-        appendRateIfEnabled(b, M15_RATE,  meter::getFifteenMinuteRate);
-        appendRateIfEnabled(b, MEAN_RATE,  meter::getMeanRate);
+    /**
+     * Only report metrics which match the given filter.
+     *
+     * @param filter a {@link MetricFilter}
+     * @return {@code this}
+     */
+    public Builder filter(MetricFilter filter) {
+      this.filter = filter;
+      return this;
     }
 
-    private void appendRateIfEnabled(StringBuilder b, MetricAttribute metricAttribute, Supplier<Double> rateSupplier) {
-        if (!getDisabledMetricAttributes().contains(metricAttribute)) {
-            append(b, metricAttribute.getCode(), convertRate(rateSupplier.get()));
-        }
+    /**
+     * Use Logging Level when reporting.
+     *
+     * @param loggingLevel a (@link Slf4jReporter.LoggingLevel}
+     * @return {@code this}
+     */
+    public Builder withLoggingLevel(LoggingLevel loggingLevel) {
+      this.loggingLevel = loggingLevel;
+      return this;
     }
 
-    private void append(StringBuilder b, String key, long value) {
-        b.append(", ").append(key).append('=').append(value);
+    /**
+     * Don't report the passed metric attributes for all metrics (e.g. "p999", "stddev" or "m15").
+     * See {@link MetricAttribute}.
+     *
+     * @param disabledMetricAttributes a set of {@link MetricAttribute}
+     * @return {@code this}
+     */
+    public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
+      this.disabledMetricAttributes = disabledMetricAttributes;
+      return this;
     }
 
-    private void append(StringBuilder b, String key, double value) {
-        b.append(", ").append(key).append('=').append(value);
+    /**
+     * Builds a {@link Slf4jReporter} with the given properties.
+     *
+     * @return a {@link Slf4jReporter}
+     */
+    public Slf4jReporter build() {
+      LoggerProxy loggerProxy;
+      switch (loggingLevel) {
+        case TRACE:
+          loggerProxy = new TraceLoggerProxy(logger);
+          break;
+        case INFO:
+          loggerProxy = new InfoLoggerProxy(logger);
+          break;
+        case WARN:
+          loggerProxy = new WarnLoggerProxy(logger);
+          break;
+        case ERROR:
+          loggerProxy = new ErrorLoggerProxy(logger);
+          break;
+        default:
+        case DEBUG:
+          loggerProxy = new DebugLoggerProxy(logger);
+          break;
+      }
+      return new Slf4jReporter(
+          registry,
+          loggerProxy,
+          marker,
+          prefix,
+          rateUnit,
+          durationUnit,
+          filter,
+          executor,
+          shutdownExecutorOnStop,
+          disabledMetricAttributes);
+    }
+  }
+
+  private final LoggerProxy loggerProxy;
+  private final Marker marker;
+  private final MetricName prefix;
+
+  private Slf4jReporter(
+      MetricRegistry registry,
+      LoggerProxy loggerProxy,
+      Marker marker,
+      String prefix,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      MetricFilter filter,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes) {
+    super(
+        registry,
+        "logger-reporter",
+        filter,
+        rateUnit,
+        durationUnit,
+        executor,
+        shutdownExecutorOnStop,
+        disabledMetricAttributes);
+    this.loggerProxy = loggerProxy;
+    this.marker = marker;
+    this.prefix = MetricName.build(prefix);
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report(
+      SortedMap<MetricName, Gauge<?>> gauges,
+      SortedMap<MetricName, Counter> counters,
+      SortedMap<MetricName, Histogram> histograms,
+      SortedMap<MetricName, Meter> meters,
+      SortedMap<MetricName, Timer> timers) {
+    if (loggerProxy.isEnabled(marker)) {
+      StringBuilder b = new StringBuilder();
+      for (Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
+        logGauge(b, entry.getKey(), entry.getValue());
+      }
+
+      for (Entry<MetricName, Counter> entry : counters.entrySet()) {
+        logCounter(b, entry.getKey(), entry.getValue());
+      }
+
+      for (Entry<MetricName, Histogram> entry : histograms.entrySet()) {
+        logHistogram(b, entry.getKey(), entry.getValue());
+      }
+
+      for (Entry<MetricName, Meter> entry : meters.entrySet()) {
+        logMeter(b, entry.getKey(), entry.getValue());
+      }
+
+      for (Entry<MetricName, Timer> entry : timers.entrySet()) {
+        logTimer(b, entry.getKey(), entry.getValue());
+      }
+    }
+  }
+
+  private void logTimer(StringBuilder b, MetricName name, Timer timer) {
+    final Snapshot snapshot = timer.getSnapshot();
+    b.setLength(0);
+    b.append("type=TIMER");
+    append(b, "name", prefix(name));
+    appendCountIfEnabled(b, timer);
+    appendLongDurationIfEnabled(b, MetricAttribute.MIN, snapshot::getMin);
+    appendLongDurationIfEnabled(b, MetricAttribute.MAX, snapshot::getMax);
+    appendDoubleDurationIfEnabled(b, MEAN, snapshot::getMean);
+    appendDoubleDurationIfEnabled(b, STDDEV, snapshot::getStdDev);
+    appendDoubleDurationIfEnabled(b, P50, snapshot::getMedian);
+    appendDoubleDurationIfEnabled(b, P75, snapshot::get75thPercentile);
+    appendDoubleDurationIfEnabled(b, P95, snapshot::get95thPercentile);
+    appendDoubleDurationIfEnabled(b, P98, snapshot::get98thPercentile);
+    appendDoubleDurationIfEnabled(b, P99, snapshot::get99thPercentile);
+    appendDoubleDurationIfEnabled(b, P999, snapshot::get999thPercentile);
+    appendMetered(b, timer);
+    append(b, "rate_unit", getRateUnit());
+    append(b, "duration_unit", getDurationUnit());
+    loggerProxy.log(marker, b.toString());
+  }
+
+  private void logMeter(StringBuilder b, MetricName name, Meter meter) {
+    b.setLength(0);
+    b.append("type=METER");
+    append(b, "name", prefix(name));
+    appendCountIfEnabled(b, meter);
+    appendMetered(b, meter);
+    append(b, "rate_unit", getRateUnit());
+    loggerProxy.log(marker, b.toString());
+  }
+
+  private void logHistogram(StringBuilder b, MetricName name, Histogram histogram) {
+    final Snapshot snapshot = histogram.getSnapshot();
+    b.setLength(0);
+    b.append("type=HISTOGRAM");
+    append(b, "name", prefix(name));
+    appendCountIfEnabled(b, histogram);
+    appendLongIfEnabled(b, MetricAttribute.MIN, snapshot::getMin);
+    appendLongIfEnabled(b, MetricAttribute.MAX, snapshot::getMax);
+    appendDoubleIfEnabled(b, MEAN, snapshot::getMean);
+    appendDoubleIfEnabled(b, STDDEV, snapshot::getStdDev);
+    appendDoubleIfEnabled(b, P50, snapshot::getMedian);
+    appendDoubleIfEnabled(b, P75, snapshot::get75thPercentile);
+    appendDoubleIfEnabled(b, P95, snapshot::get95thPercentile);
+    appendDoubleIfEnabled(b, P98, snapshot::get98thPercentile);
+    appendDoubleIfEnabled(b, P99, snapshot::get99thPercentile);
+    appendDoubleIfEnabled(b, P999, snapshot::get999thPercentile);
+    loggerProxy.log(marker, b.toString());
+  }
+
+  private void logCounter(StringBuilder b, MetricName name, Counter counter) {
+    b.setLength(0);
+    b.append("type=COUNTER");
+    append(b, "name", prefix(name));
+    append(b, COUNT.getCode(), counter.getCount());
+    loggerProxy.log(marker, b.toString());
+  }
+
+  private void logGauge(StringBuilder b, MetricName name, Gauge<?> gauge) {
+    b.setLength(0);
+    b.append("type=GAUGE");
+    append(b, "name", prefix(name));
+    append(b, "value", gauge.getValue());
+    loggerProxy.log(marker, b.toString());
+  }
+
+  private void appendLongDurationIfEnabled(
+      StringBuilder b, MetricAttribute metricAttribute, Supplier<Long> durationSupplier) {
+    if (!getDisabledMetricAttributes().contains(metricAttribute)) {
+      append(b, metricAttribute.getCode(), convertDuration(durationSupplier.get()));
     }
+  }
 
-    private void append(StringBuilder b, String key, String value) {
-        b.append(", ").append(key).append('=').append(value);
+  private void appendDoubleDurationIfEnabled(
+      StringBuilder b, MetricAttribute metricAttribute, Supplier<Double> durationSupplier) {
+    if (!getDisabledMetricAttributes().contains(metricAttribute)) {
+      append(b, metricAttribute.getCode(), convertDuration(durationSupplier.get()));
     }
+  }
 
-    private void append(StringBuilder b, String key, Object value) {
-        b.append(", ").append(key).append('=').append(value);
+  private void appendLongIfEnabled(
+      StringBuilder b, MetricAttribute metricAttribute, Supplier<Long> valueSupplier) {
+    if (!getDisabledMetricAttributes().contains(metricAttribute)) {
+      append(b, metricAttribute.getCode(), valueSupplier.get());
     }
+  }
 
-    @Override
-    public String getRateUnit() {
-        return "events/" + super.getRateUnit();
+  private void appendDoubleIfEnabled(
+      StringBuilder b, MetricAttribute metricAttribute, Supplier<Double> valueSupplier) {
+    if (!getDisabledMetricAttributes().contains(metricAttribute)) {
+      append(b, metricAttribute.getCode(), valueSupplier.get());
     }
+  }
 
-    private String prefix(MetricName metricName) {
-        return prefix.append(metricName).toString();
+  private void appendCountIfEnabled(StringBuilder b, Counting counting) {
+    if (!getDisabledMetricAttributes().contains(COUNT)) {
+      append(b, COUNT.getCode(), counting.getCount());
+    }
+  }
+
+  private void appendMetered(StringBuilder b, Metered meter) {
+    appendRateIfEnabled(b, M1_RATE, meter::getOneMinuteRate);
+    appendRateIfEnabled(b, M5_RATE, meter::getFiveMinuteRate);
+    appendRateIfEnabled(b, M15_RATE, meter::getFifteenMinuteRate);
+    appendRateIfEnabled(b, MEAN_RATE, meter::getMeanRate);
+  }
+
+  private void appendRateIfEnabled(
+      StringBuilder b, MetricAttribute metricAttribute, Supplier<Double> rateSupplier) {
+    if (!getDisabledMetricAttributes().contains(metricAttribute)) {
+      append(b, metricAttribute.getCode(), convertRate(rateSupplier.get()));
     }
+  }
 
-    /* private class to allow logger configuration */
-    static abstract class LoggerProxy {
-        protected final Logger logger;
+  private void append(StringBuilder b, String key, long value) {
+    b.append(", ").append(key).append('=').append(value);
+  }
 
-        public LoggerProxy(Logger logger) {
-            this.logger = logger;
-        }
+  private void append(StringBuilder b, String key, double value) {
+    b.append(", ").append(key).append('=').append(value);
+  }
 
-        abstract void log(Marker marker, String format);
+  private void append(StringBuilder b, String key, String value) {
+    b.append(", ").append(key).append('=').append(value);
+  }
 
-        abstract boolean isEnabled(Marker marker);
+  private void append(StringBuilder b, String key, Object value) {
+    b.append(", ").append(key).append('=').append(value);
+  }
+
+  @Override
+  public String getRateUnit() {
+    return "events/" + super.getRateUnit();
+  }
+
+  private String prefix(MetricName metricName) {
+    return prefix.append(metricName).toString();
+  }
+
+  /* private class to allow logger configuration */
+  abstract static class LoggerProxy {
+    protected final Logger logger;
+
+    public LoggerProxy(Logger logger) {
+      this.logger = logger;
     }
 
-    /* private class to allow logger configuration */
-    private static class DebugLoggerProxy extends LoggerProxy {
-        public DebugLoggerProxy(Logger logger) {
-            super(logger);
-        }
+    abstract void log(Marker marker, String format);
 
-        @Override
-        public void log(Marker marker, String format) {
-            logger.debug(marker, format);
-        }
+    abstract boolean isEnabled(Marker marker);
+  }
 
-        @Override
-        public boolean isEnabled(Marker marker) {
-            return logger.isDebugEnabled(marker);
-        }
+  /* private class to allow logger configuration */
+  private static class DebugLoggerProxy extends LoggerProxy {
+    public DebugLoggerProxy(Logger logger) {
+      super(logger);
     }
 
-    /* private class to allow logger configuration */
-    private static class TraceLoggerProxy extends LoggerProxy {
-        public TraceLoggerProxy(Logger logger) {
-            super(logger);
-        }
+    @Override
+    public void log(Marker marker, String format) {
+      logger.debug(marker, format);
+    }
 
-        @Override
-        public void log(Marker marker, String format) {
-            logger.trace(marker, format);
-        }
+    @Override
+    public boolean isEnabled(Marker marker) {
+      return logger.isDebugEnabled(marker);
+    }
+  }
+
+  /* private class to allow logger configuration */
+  private static class TraceLoggerProxy extends LoggerProxy {
+    public TraceLoggerProxy(Logger logger) {
+      super(logger);
+    }
 
-        @Override
-        public boolean isEnabled(Marker marker) {
-            return logger.isTraceEnabled(marker);
-        }
+    @Override
+    public void log(Marker marker, String format) {
+      logger.trace(marker, format);
     }
 
-    /* private class to allow logger configuration */
-    private static class InfoLoggerProxy extends LoggerProxy {
-        public InfoLoggerProxy(Logger logger) {
-            super(logger);
-        }
+    @Override
+    public boolean isEnabled(Marker marker) {
+      return logger.isTraceEnabled(marker);
+    }
+  }
 
-        @Override
-        public void log(Marker marker, String format) {
-            logger.info(marker, format);
-        }
+  /* private class to allow logger configuration */
+  private static class InfoLoggerProxy extends LoggerProxy {
+    public InfoLoggerProxy(Logger logger) {
+      super(logger);
+    }
 
-        @Override
-        public boolean isEnabled(Marker marker) {
-            return logger.isInfoEnabled(marker);
-        }
+    @Override
+    public void log(Marker marker, String format) {
+      logger.info(marker, format);
     }
 
-    /* private class to allow logger configuration */
-    private static class WarnLoggerProxy extends LoggerProxy {
-        public WarnLoggerProxy(Logger logger) {
-            super(logger);
-        }
+    @Override
+    public boolean isEnabled(Marker marker) {
+      return logger.isInfoEnabled(marker);
+    }
+  }
 
-        @Override
-        public void log(Marker marker, String format) {
-            logger.warn(marker, format);
-        }
+  /* private class to allow logger configuration */
+  private static class WarnLoggerProxy extends LoggerProxy {
+    public WarnLoggerProxy(Logger logger) {
+      super(logger);
+    }
 
-        @Override
-        public boolean isEnabled(Marker marker) {
-            return logger.isWarnEnabled(marker);
-        }
+    @Override
+    public void log(Marker marker, String format) {
+      logger.warn(marker, format);
     }
 
-    /* private class to allow logger configuration */
-    private static class ErrorLoggerProxy extends LoggerProxy {
-        public ErrorLoggerProxy(Logger logger) {
-            super(logger);
-        }
+    @Override
+    public boolean isEnabled(Marker marker) {
+      return logger.isWarnEnabled(marker);
+    }
+  }
 
-        @Override
-        public void log(Marker marker, String format) {
-            logger.error(marker, format);
-        }
+  /* private class to allow logger configuration */
+  private static class ErrorLoggerProxy extends LoggerProxy {
+    public ErrorLoggerProxy(Logger logger) {
+      super(logger);
+    }
 
-        @Override
-        public boolean isEnabled(Marker marker) {
-            return logger.isErrorEnabled(marker);
-        }
+    @Override
+    public void log(Marker marker, String format) {
+      logger.error(marker, format);
     }
 
+    @Override
+    public boolean isEnabled(Marker marker) {
+      return logger.isErrorEnabled(marker);
+    }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoir.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoir.java
@@ -4,98 +4,98 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
 /**
- * A {@link Reservoir} implementation backed by a sliding window that stores only the measurements made
- * in the last {@code N} seconds (or other time unit).
+ * A {@link Reservoir} implementation backed by a sliding window that stores only the measurements
+ * made in the last {@code N} seconds (or other time unit).
  */
 public class SlidingTimeWindowArrayReservoir implements Reservoir {
-    // allow for this many duplicate ticks before overwriting measurements
-    private static final long COLLISION_BUFFER = 256L;
-    // only trim on updating once every N
-    private static final long TRIM_THRESHOLD = 256L;
-    private static final long CLEAR_BUFFER = TimeUnit.HOURS.toNanos(1) * COLLISION_BUFFER;
+  // allow for this many duplicate ticks before overwriting measurements
+  private static final long COLLISION_BUFFER = 256L;
+  // only trim on updating once every N
+  private static final long TRIM_THRESHOLD = 256L;
+  private static final long CLEAR_BUFFER = TimeUnit.HOURS.toNanos(1) * COLLISION_BUFFER;
 
-    private final Clock clock;
-    private final ChunkedAssociativeLongArray measurements;
-    private final long window;
-    private final AtomicLong lastTick;
-    private final AtomicLong count;
-    private final long startTick;
+  private final Clock clock;
+  private final ChunkedAssociativeLongArray measurements;
+  private final long window;
+  private final AtomicLong lastTick;
+  private final AtomicLong count;
+  private final long startTick;
 
-    /**
-     * Creates a new {@link SlidingTimeWindowArrayReservoir} with the given window of time.
-     *
-     * @param window     the window of time
-     * @param windowUnit the unit of {@code window}
-     */
-    public SlidingTimeWindowArrayReservoir(long window, TimeUnit windowUnit) {
-        this(window, windowUnit, Clock.defaultClock());
-    }
-
-    /**
-     * Creates a new {@link SlidingTimeWindowArrayReservoir} with the given clock and window of time.
-     *
-     * @param window     the window of time
-     * @param windowUnit the unit of {@code window}
-     * @param clock      the {@link Clock} to use
-     */
-    public SlidingTimeWindowArrayReservoir(long window, TimeUnit windowUnit, Clock clock) {
-        this.startTick = clock.getTick();
-        this.clock = clock;
-        this.measurements = new ChunkedAssociativeLongArray();
-        this.window = windowUnit.toNanos(window) * COLLISION_BUFFER;
-        this.lastTick = new AtomicLong((clock.getTick() - startTick) * COLLISION_BUFFER);
-        this.count = new AtomicLong();
-    }
+  /**
+   * Creates a new {@link SlidingTimeWindowArrayReservoir} with the given window of time.
+   *
+   * @param window the window of time
+   * @param windowUnit the unit of {@code window}
+   */
+  public SlidingTimeWindowArrayReservoir(long window, TimeUnit windowUnit) {
+    this(window, windowUnit, Clock.defaultClock());
+  }
 
-    @Override
-    public int size() {
-        trim();
-        return measurements.size();
-    }
+  /**
+   * Creates a new {@link SlidingTimeWindowArrayReservoir} with the given clock and window of time.
+   *
+   * @param window the window of time
+   * @param windowUnit the unit of {@code window}
+   * @param clock the {@link Clock} to use
+   */
+  public SlidingTimeWindowArrayReservoir(long window, TimeUnit windowUnit, Clock clock) {
+    this.startTick = clock.getTick();
+    this.clock = clock;
+    this.measurements = new ChunkedAssociativeLongArray();
+    this.window = windowUnit.toNanos(window) * COLLISION_BUFFER;
+    this.lastTick = new AtomicLong((clock.getTick() - startTick) * COLLISION_BUFFER);
+    this.count = new AtomicLong();
+  }
 
-    @Override
-    public void update(long value) {
-        long newTick;
-        do {
-            if (count.incrementAndGet() % TRIM_THRESHOLD == 0L) {
-                trim();
-            }
-            long lastTick = this.lastTick.get();
-            newTick = getTick();
-            boolean longOverflow = newTick < lastTick;
-            if (longOverflow) {
-                measurements.clear();
-            }
-        } while (!measurements.put(newTick, value));
-    }
+  @Override
+  public int size() {
+    trim();
+    return measurements.size();
+  }
 
-    @Override
-    public Snapshot getSnapshot() {
+  @Override
+  public void update(long value) {
+    long newTick;
+    do {
+      if (count.incrementAndGet() % TRIM_THRESHOLD == 0L) {
         trim();
-        return new UniformSnapshot(measurements.values());
-    }
+      }
+      long lastTick = this.lastTick.get();
+      newTick = getTick();
+      boolean longOverflow = newTick < lastTick;
+      if (longOverflow) {
+        measurements.clear();
+      }
+    } while (!measurements.put(newTick, value));
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    trim();
+    return new UniformSnapshot(measurements.values());
+  }
 
-    private long getTick() {
-        for ( ;; ) {
-            final long oldTick = lastTick.get();
-            final long tick = (clock.getTick() - startTick) * COLLISION_BUFFER;
-            // ensure the tick is strictly incrementing even if there are duplicate ticks
-            final long newTick = tick - oldTick > 0L ? tick : oldTick + 1L;
-            if (lastTick.compareAndSet(oldTick, newTick)) {
-                return newTick;
-            }
-        }
+  private long getTick() {
+    for (; ; ) {
+      final long oldTick = lastTick.get();
+      final long tick = (clock.getTick() - startTick) * COLLISION_BUFFER;
+      // ensure the tick is strictly incrementing even if there are duplicate ticks
+      final long newTick = tick - oldTick > 0L ? tick : oldTick + 1L;
+      if (lastTick.compareAndSet(oldTick, newTick)) {
+        return newTick;
+      }
     }
+  }
 
-    void trim() {
-        final long now = getTick();
-        final long windowStart = now - window;
-        final long windowEnd = now + CLEAR_BUFFER;
-        if (windowStart < windowEnd) {
-            measurements.trim(windowStart, windowEnd);
-        } else {
-            // long overflow handling that can happen only after 1 year after class loading
-            measurements.clear();
-        }
+  void trim() {
+    final long now = getTick();
+    final long windowStart = now - window;
+    final long windowEnd = now + CLEAR_BUFFER;
+    if (windowStart < windowEnd) {
+      measurements.trim(windowStart, windowEnd);
+    } else {
+      // long overflow handling that can happen only after 1 year after class loading
+      measurements.clear();
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowMovingAverages.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowMovingAverages.java
@@ -8,197 +8,189 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.LongAdder;
 
 /**
- * A triple of simple moving average rates (one, five and fifteen minutes rates) as needed by {@link Meter}.
- * <p>
- * The averages are unweighted, i.e. they include strictly only the events in the
- * sliding time window, every event having the same weight. Unlike the
- * the more widely used {@link ExponentialMovingAverages} implementation,
- * with this class the moving average rate drops immediately to zero if the last
- * marked event is older than the time window.
- * <p>
- * A {@link Meter} with {@link SlidingTimeWindowMovingAverages} works similarly to
- * a {@link Histogram} with an {@link SlidingTimeWindowArrayReservoir}, but as a Meter
- * needs to keep track only of the count of events (not the events itself), the memory
- * overhead is much smaller. SlidingTimeWindowMovingAverages uses buckets with just one
- * counter to accumulate the number of events (one bucket per seconds, giving 900 buckets
- * for the 15 minutes time window).
+ * A triple of simple moving average rates (one, five and fifteen minutes rates) as needed by {@link
+ * Meter}.
+ *
+ * <p>The averages are unweighted, i.e. they include strictly only the events in the sliding time
+ * window, every event having the same weight. Unlike the the more widely used {@link
+ * ExponentialMovingAverages} implementation, with this class the moving average rate drops
+ * immediately to zero if the last marked event is older than the time window.
+ *
+ * <p>A {@link Meter} with {@link SlidingTimeWindowMovingAverages} works similarly to a {@link
+ * Histogram} with an {@link SlidingTimeWindowArrayReservoir}, but as a Meter needs to keep track
+ * only of the count of events (not the events itself), the memory overhead is much smaller.
+ * SlidingTimeWindowMovingAverages uses buckets with just one counter to accumulate the number of
+ * events (one bucket per seconds, giving 900 buckets for the 15 minutes time window).
  */
 public class SlidingTimeWindowMovingAverages implements MovingAverages {
 
-    private static final long TIME_WINDOW_DURATION_MINUTES = 15;
-    private static final long TICK_INTERVAL = TimeUnit.SECONDS.toNanos(1);
-    private static final Duration TIME_WINDOW_DURATION = Duration.ofMinutes(TIME_WINDOW_DURATION_MINUTES);
-
-    // package private for the benefit of the unit test
-    static final int NUMBER_OF_BUCKETS = (int) (TIME_WINDOW_DURATION.toNanos() / TICK_INTERVAL);
-
-    private final AtomicLong lastTick;
-    private final Clock clock;
-    private final LongAdder sum = new LongAdder();
-
-    /**
-     * One counter per time bucket/slot (i.e. per second, see TICK_INTERVAL) for the entire
-     * time window (i.e. 15 minutes, see TIME_WINDOW_DURATION_MINUTES)
-     */
-    private ArrayList<LongAdder> buckets;
-
-    /**
-     * Index into buckets, pointing at the bucket containing the oldest counts
-     */
-    private int oldestBucketIndex;
-
-    /**
-     * Index into buckets, pointing at the bucket with the count for the current time (tick)
-     */
-    private int currentBucketIndex;
-
-    /**
-     * Instant at creation time of the time window. Used to calculate the currentBucketIndex
-     * for the instant of a given tick (instant modulo time window duration)
-     */
-    private final Instant bucketBaseTime;
-
-    /**
-     * Instant of the bucket with index oldestBucketIndex
-     */
-    Instant oldestBucketTime;
-
-    /**
-     * Creates a new {@link SlidingTimeWindowMovingAverages}.
-     */
-    public SlidingTimeWindowMovingAverages() {
-        this(Clock.defaultClock());
+  private static final long TIME_WINDOW_DURATION_MINUTES = 15;
+  private static final long TICK_INTERVAL = TimeUnit.SECONDS.toNanos(1);
+  private static final Duration TIME_WINDOW_DURATION =
+      Duration.ofMinutes(TIME_WINDOW_DURATION_MINUTES);
+
+  // package private for the benefit of the unit test
+  static final int NUMBER_OF_BUCKETS = (int) (TIME_WINDOW_DURATION.toNanos() / TICK_INTERVAL);
+
+  private final AtomicLong lastTick;
+  private final Clock clock;
+  private final LongAdder sum = new LongAdder();
+
+  /**
+   * One counter per time bucket/slot (i.e. per second, see TICK_INTERVAL) for the entire time
+   * window (i.e. 15 minutes, see TIME_WINDOW_DURATION_MINUTES)
+   */
+  private ArrayList<LongAdder> buckets;
+
+  /** Index into buckets, pointing at the bucket containing the oldest counts */
+  private int oldestBucketIndex;
+
+  /** Index into buckets, pointing at the bucket with the count for the current time (tick) */
+  private int currentBucketIndex;
+
+  /**
+   * Instant at creation time of the time window. Used to calculate the currentBucketIndex for the
+   * instant of a given tick (instant modulo time window duration)
+   */
+  private final Instant bucketBaseTime;
+
+  /** Instant of the bucket with index oldestBucketIndex */
+  Instant oldestBucketTime;
+
+  /** Creates a new {@link SlidingTimeWindowMovingAverages}. */
+  public SlidingTimeWindowMovingAverages() {
+    this(Clock.defaultClock());
+  }
+
+  /**
+   * Creates a new {@link SlidingTimeWindowMovingAverages}.
+   *
+   * @param clock the clock to use for the meter ticks
+   */
+  public SlidingTimeWindowMovingAverages(Clock clock) {
+    this.clock = clock;
+    final long startTime = clock.getTick();
+    lastTick = new AtomicLong(startTime);
+
+    buckets = new ArrayList<>(NUMBER_OF_BUCKETS);
+    for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {
+      buckets.add(new LongAdder());
     }
-
-    /**
-     * Creates a new {@link SlidingTimeWindowMovingAverages}.
-     *
-     * @param clock the clock to use for the meter ticks
-     */
-    public SlidingTimeWindowMovingAverages(Clock clock) {
-        this.clock = clock;
-        final long startTime = clock.getTick();
-        lastTick = new AtomicLong(startTime);
-
-        buckets = new ArrayList<>(NUMBER_OF_BUCKETS);
-        for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {
-            buckets.add(new LongAdder());
-        }
-        bucketBaseTime = Instant.ofEpochSecond(0L, startTime);
-        oldestBucketTime = bucketBaseTime;
-        oldestBucketIndex = 0;
-        currentBucketIndex = 0;
-    }
-
-    @Override
-    public void update(long n) {
-        buckets.get(currentBucketIndex).add(n);
-    }
-
-    @Override
-    public void tickIfNecessary() {
-        final long oldTick = lastTick.get();
-        final long newTick = clock.getTick();
-        final long age = newTick - oldTick;
-        if (age >= TICK_INTERVAL) {
-            // - the newTick doesn't fall into the same slot as the oldTick anymore
-            // - newLastTick is the lower border time of the new currentBucketIndex slot
-            final long newLastTick = newTick - age % TICK_INTERVAL;
-            if (lastTick.compareAndSet(oldTick, newLastTick)) {
-                sum.add(age);
-                Instant currentInstant = Instant.ofEpochSecond(0L, newLastTick);
-                currentBucketIndex = normalizeIndex(calculateIndexOfTick(currentInstant));
-                cleanOldBuckets(currentInstant);
-            }
-        }
-    }
-
-    @Override
-    public double getM15Rate() {
-        return getMinuteRate(15);
-    }
-
-    @Override
-    public double getM5Rate() {
-        return getMinuteRate(5);
-    }
-
-    @Override
-    public double getM1Rate() {
-        return getMinuteRate(1);
-    }
-
-    private double getMinuteRate(int minutes) {
-        Instant now = Instant.ofEpochSecond(0L, lastTick.get());
-        return sumBuckets(now, (int) (TimeUnit.MINUTES.toNanos(minutes) / TICK_INTERVAL));
-    }
-
-    int calculateIndexOfTick(Instant tickTime) {
-        return (int) (Duration.between(bucketBaseTime, tickTime).toNanos() / TICK_INTERVAL);
+    bucketBaseTime = Instant.ofEpochSecond(0L, startTime);
+    oldestBucketTime = bucketBaseTime;
+    oldestBucketIndex = 0;
+    currentBucketIndex = 0;
+  }
+
+  @Override
+  public void update(long n) {
+    buckets.get(currentBucketIndex).add(n);
+  }
+
+  @Override
+  public void tickIfNecessary() {
+    final long oldTick = lastTick.get();
+    final long newTick = clock.getTick();
+    final long age = newTick - oldTick;
+    if (age >= TICK_INTERVAL) {
+      // - the newTick doesn't fall into the same slot as the oldTick anymore
+      // - newLastTick is the lower border time of the new currentBucketIndex slot
+      final long newLastTick = newTick - age % TICK_INTERVAL;
+      if (lastTick.compareAndSet(oldTick, newLastTick)) {
+        sum.add(age);
+        Instant currentInstant = Instant.ofEpochSecond(0L, newLastTick);
+        currentBucketIndex = normalizeIndex(calculateIndexOfTick(currentInstant));
+        cleanOldBuckets(currentInstant);
+      }
     }
-
-    int normalizeIndex(int index) {
-        int mod = index % NUMBER_OF_BUCKETS;
-        return mod >= 0 ? mod : mod + NUMBER_OF_BUCKETS;
+  }
+
+  @Override
+  public double getM15Rate() {
+    return getMinuteRate(15);
+  }
+
+  @Override
+  public double getM5Rate() {
+    return getMinuteRate(5);
+  }
+
+  @Override
+  public double getM1Rate() {
+    return getMinuteRate(1);
+  }
+
+  private double getMinuteRate(int minutes) {
+    Instant now = Instant.ofEpochSecond(0L, lastTick.get());
+    return sumBuckets(now, (int) (TimeUnit.MINUTES.toNanos(minutes) / TICK_INTERVAL));
+  }
+
+  int calculateIndexOfTick(Instant tickTime) {
+    return (int) (Duration.between(bucketBaseTime, tickTime).toNanos() / TICK_INTERVAL);
+  }
+
+  int normalizeIndex(int index) {
+    int mod = index % NUMBER_OF_BUCKETS;
+    return mod >= 0 ? mod : mod + NUMBER_OF_BUCKETS;
+  }
+
+  private void cleanOldBuckets(Instant currentTick) {
+    int newOldestIndex;
+    Instant oldestStillNeededTime =
+        currentTick.minus(TIME_WINDOW_DURATION).plusNanos(TICK_INTERVAL);
+    Instant youngestNotInWindow = oldestBucketTime.plus(TIME_WINDOW_DURATION);
+    if (oldestStillNeededTime.isAfter(youngestNotInWindow)) {
+      // there was no update() call for more than two whole TIME_WINDOW_DURATION
+      newOldestIndex = oldestBucketIndex;
+      oldestBucketTime = currentTick;
+    } else if (oldestStillNeededTime.isAfter(oldestBucketTime)) {
+      newOldestIndex = normalizeIndex(calculateIndexOfTick(oldestStillNeededTime));
+      oldestBucketTime = oldestStillNeededTime;
+    } else {
+      return;
     }
 
-    private void cleanOldBuckets(Instant currentTick) {
-        int newOldestIndex;
-        Instant oldestStillNeededTime = currentTick.minus(TIME_WINDOW_DURATION).plusNanos(TICK_INTERVAL);
-        Instant youngestNotInWindow = oldestBucketTime.plus(TIME_WINDOW_DURATION);
-        if (oldestStillNeededTime.isAfter(youngestNotInWindow)) {
-            // there was no update() call for more than two whole TIME_WINDOW_DURATION
-            newOldestIndex = oldestBucketIndex;
-            oldestBucketTime = currentTick;
-        } else if (oldestStillNeededTime.isAfter(oldestBucketTime)) {
-            newOldestIndex = normalizeIndex(calculateIndexOfTick(oldestStillNeededTime));
-            oldestBucketTime = oldestStillNeededTime;
-        } else {
-            return;
-        }
-
-        cleanBucketRange(oldestBucketIndex, newOldestIndex);
-        oldestBucketIndex = newOldestIndex;
+    cleanBucketRange(oldestBucketIndex, newOldestIndex);
+    oldestBucketIndex = newOldestIndex;
+  }
+
+  private void cleanBucketRange(int fromIndex, int toIndex) {
+    if (fromIndex < toIndex) {
+      for (int i = fromIndex; i < toIndex; i++) {
+        buckets.get(i).reset();
+      }
+    } else {
+      for (int i = fromIndex; i < NUMBER_OF_BUCKETS; i++) {
+        buckets.get(i).reset();
+      }
+      for (int i = 0; i < toIndex; i++) {
+        buckets.get(i).reset();
+      }
     }
-
-    private void cleanBucketRange(int fromIndex, int toIndex) {
-        if (fromIndex < toIndex) {
-            for (int i = fromIndex; i < toIndex; i++) {
-                buckets.get(i).reset();
-            }
-        } else {
-            for (int i = fromIndex; i < NUMBER_OF_BUCKETS; i++) {
-                buckets.get(i).reset();
-            }
-            for (int i = 0; i < toIndex; i++) {
-                buckets.get(i).reset();
-            }
-        }
+  }
+
+  private long sumBuckets(Instant toTime, int numberOfBuckets) {
+
+    // increment toIndex to include the current bucket into the sum
+    int toIndex = normalizeIndex(calculateIndexOfTick(toTime) + 1);
+    int fromIndex = normalizeIndex(toIndex - numberOfBuckets);
+    LongAdder adder = new LongAdder();
+
+    if (fromIndex < toIndex) {
+      buckets.stream()
+          .skip(fromIndex)
+          .limit(toIndex - fromIndex)
+          .mapToLong(LongAdder::longValue)
+          .forEach(adder::add);
+    } else {
+      buckets.stream().limit(toIndex).mapToLong(LongAdder::longValue).forEach(adder::add);
+      buckets.stream().skip(fromIndex).mapToLong(LongAdder::longValue).forEach(adder::add);
     }
+    return adder.longValue();
+  }
 
-    private long sumBuckets(Instant toTime, int numberOfBuckets) {
-
-        // increment toIndex to include the current bucket into the sum
-        int toIndex = normalizeIndex(calculateIndexOfTick(toTime) + 1);
-        int fromIndex = normalizeIndex(toIndex - numberOfBuckets);
-        LongAdder adder = new LongAdder();
-
-        if (fromIndex < toIndex) {
-            buckets.stream()
-                    .skip(fromIndex)
-                    .limit(toIndex - fromIndex)
-                    .mapToLong(LongAdder::longValue)
-                    .forEach(adder::add);
-        } else {
-            buckets.stream().limit(toIndex).mapToLong(LongAdder::longValue).forEach(adder::add);
-            buckets.stream().skip(fromIndex).mapToLong(LongAdder::longValue).forEach(adder::add);
-        }
-        long retval = adder.longValue();
-        return retval;
-    }
-
-    @Override
-    public long getSum() {
-        return sum.sum();
-    }
+  @Override
+  public long getSum() {
+    return sum.sum();
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowReservoir.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowReservoir.java
@@ -5,91 +5,91 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
 /**
- * A {@link Reservoir} implementation backed by a sliding window that stores only the measurements made
- * in the last {@code N} seconds (or other time unit).
+ * A {@link Reservoir} implementation backed by a sliding window that stores only the measurements
+ * made in the last {@code N} seconds (or other time unit).
  */
 public class SlidingTimeWindowReservoir implements Reservoir {
-    // allow for this many duplicate ticks before overwriting measurements
-    private static final int COLLISION_BUFFER = 256;
-    // only trim on updating once every N
-    private static final int TRIM_THRESHOLD = 256;
-    // offsets the front of the time window for the purposes of clearing the buffer in trim
-    private static final long CLEAR_BUFFER = TimeUnit.HOURS.toNanos(1) * COLLISION_BUFFER;
+  // allow for this many duplicate ticks before overwriting measurements
+  private static final int COLLISION_BUFFER = 256;
+  // only trim on updating once every N
+  private static final int TRIM_THRESHOLD = 256;
+  // offsets the front of the time window for the purposes of clearing the buffer in trim
+  private static final long CLEAR_BUFFER = TimeUnit.HOURS.toNanos(1) * COLLISION_BUFFER;
 
-    private final Clock clock;
-    private final ConcurrentSkipListMap<Long, Long> measurements;
-    private final long window;
-    private final AtomicLong lastTick;
-    private final AtomicLong count;
-    private final long startTick;
+  private final Clock clock;
+  private final ConcurrentSkipListMap<Long, Long> measurements;
+  private final long window;
+  private final AtomicLong lastTick;
+  private final AtomicLong count;
+  private final long startTick;
 
-    /**
-     * Creates a new {@link SlidingTimeWindowReservoir} with the given window of time.
-     *
-     * @param window     the window of time
-     * @param windowUnit the unit of {@code window}
-     */
-    public SlidingTimeWindowReservoir(long window, TimeUnit windowUnit) {
-        this(window, windowUnit, Clock.defaultClock());
-    }
+  /**
+   * Creates a new {@link SlidingTimeWindowReservoir} with the given window of time.
+   *
+   * @param window the window of time
+   * @param windowUnit the unit of {@code window}
+   */
+  public SlidingTimeWindowReservoir(long window, TimeUnit windowUnit) {
+    this(window, windowUnit, Clock.defaultClock());
+  }
 
-    /**
-     * Creates a new {@link SlidingTimeWindowReservoir} with the given clock and window of time.
-     *
-     * @param window     the window of time
-     * @param windowUnit the unit of {@code window}
-     * @param clock      the {@link Clock} to use
-     */
-    public SlidingTimeWindowReservoir(long window, TimeUnit windowUnit, Clock clock) {
-        this.startTick = clock.getTick();
-        this.clock = clock;
-        this.measurements = new ConcurrentSkipListMap<>();
-        this.window = windowUnit.toNanos(window) * COLLISION_BUFFER;
-        this.lastTick = new AtomicLong((clock.getTick() - startTick) * COLLISION_BUFFER);
-        this.count = new AtomicLong();
-    }
+  /**
+   * Creates a new {@link SlidingTimeWindowReservoir} with the given clock and window of time.
+   *
+   * @param window the window of time
+   * @param windowUnit the unit of {@code window}
+   * @param clock the {@link Clock} to use
+   */
+  public SlidingTimeWindowReservoir(long window, TimeUnit windowUnit, Clock clock) {
+    this.startTick = clock.getTick();
+    this.clock = clock;
+    this.measurements = new ConcurrentSkipListMap<>();
+    this.window = windowUnit.toNanos(window) * COLLISION_BUFFER;
+    this.lastTick = new AtomicLong((clock.getTick() - startTick) * COLLISION_BUFFER);
+    this.count = new AtomicLong();
+  }
 
-    @Override
-    public int size() {
-        trim();
-        return measurements.size();
-    }
+  @Override
+  public int size() {
+    trim();
+    return measurements.size();
+  }
 
-    @Override
-    public void update(long value) {
-        if (count.incrementAndGet() % TRIM_THRESHOLD == 0) {
-            trim();
-        }
-        measurements.put(getTick(), value);
+  @Override
+  public void update(long value) {
+    if (count.incrementAndGet() % TRIM_THRESHOLD == 0) {
+      trim();
     }
+    measurements.put(getTick(), value);
+  }
 
-    @Override
-    public Snapshot getSnapshot() {
-        trim();
-        return new UniformSnapshot(measurements.values());
-    }
+  @Override
+  public Snapshot getSnapshot() {
+    trim();
+    return new UniformSnapshot(measurements.values());
+  }
 
-    private long getTick() {
-        for ( ;; ) {
-            final long oldTick = lastTick.get();
-            final long tick = (clock.getTick() - startTick) * COLLISION_BUFFER;
-            // ensure the tick is strictly incrementing even if there are duplicate ticks
-            final long newTick = tick - oldTick > 0 ? tick : oldTick + 1;
-            if (lastTick.compareAndSet(oldTick, newTick)) {
-                return newTick;
-            }
-        }
+  private long getTick() {
+    for (; ; ) {
+      final long oldTick = lastTick.get();
+      final long tick = (clock.getTick() - startTick) * COLLISION_BUFFER;
+      // ensure the tick is strictly incrementing even if there are duplicate ticks
+      final long newTick = tick - oldTick > 0 ? tick : oldTick + 1;
+      if (lastTick.compareAndSet(oldTick, newTick)) {
+        return newTick;
+      }
     }
+  }
 
-    private void trim() {
-        final long now = getTick();
-        final long windowStart = now - window;
-        final long windowEnd = now + CLEAR_BUFFER;
-        if (windowStart < windowEnd) {
-            measurements.headMap(windowStart).clear();
-            measurements.tailMap(windowEnd).clear();
-        } else {
-            measurements.subMap(windowEnd, windowStart).clear();
-        }
+  private void trim() {
+    final long now = getTick();
+    final long windowStart = now - window;
+    final long windowEnd = now + CLEAR_BUFFER;
+    if (windowStart < windowEnd) {
+      measurements.headMap(windowStart).clear();
+      measurements.tailMap(windowEnd).clear();
+    } else {
+      measurements.subMap(windowEnd, windowStart).clear();
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/SlidingWindowReservoir.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/SlidingWindowReservoir.java
@@ -7,37 +7,37 @@ import static java.lang.Math.min;
  * measurements.
  */
 public class SlidingWindowReservoir implements Reservoir {
-    private final long[] measurements;
-    private long count;
+  private final long[] measurements;
+  private long count;
 
-    /**
-     * Creates a new {@link SlidingWindowReservoir} which stores the last {@code size} measurements.
-     *
-     * @param size the number of measurements to store
-     */
-    public SlidingWindowReservoir(int size) {
-        this.measurements = new long[size];
-        this.count = 0;
-    }
+  /**
+   * Creates a new {@link SlidingWindowReservoir} which stores the last {@code size} measurements.
+   *
+   * @param size the number of measurements to store
+   */
+  public SlidingWindowReservoir(int size) {
+    this.measurements = new long[size];
+    this.count = 0;
+  }
 
-    @Override
-    public synchronized int size() {
-        return (int) min(count, measurements.length);
-    }
+  @Override
+  public synchronized int size() {
+    return (int) min(count, measurements.length);
+  }
 
-    @Override
-    public synchronized void update(long value) {
-        measurements[(int) (count++ % measurements.length)] = value;
-    }
+  @Override
+  public synchronized void update(long value) {
+    measurements[(int) (count++ % measurements.length)] = value;
+  }
 
-    @Override
-    public Snapshot getSnapshot() {
-        final long[] values = new long[size()];
-        for (int i = 0; i < values.length; i++) {
-            synchronized (this) {
-                values[i] = measurements[i];
-            }
-        }
-        return new UniformSnapshot(values);
+  @Override
+  public Snapshot getSnapshot() {
+    final long[] values = new long[size()];
+    for (int i = 0; i < values.length; i++) {
+      synchronized (this) {
+        values[i] = measurements[i];
+      }
     }
+    return new UniformSnapshot(values);
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Snapshot.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Snapshot.java
@@ -2,120 +2,117 @@ package io.dropwizard.metrics5;
 
 import java.io.OutputStream;
 
-/**
- * A statistical snapshot of a {@link Snapshot}.
- */
+/** A statistical snapshot of a {@link Snapshot}. */
 public abstract class Snapshot {
 
-    /**
-     * Returns the value at the given quantile.
-     *
-     * @param quantile a given quantile, in {@code [0..1]}
-     * @return the value in the distribution at {@code quantile}
-     */
-    public abstract double getValue(double quantile);
-
-    /**
-     * Returns the entire set of values in the snapshot.
-     *
-     * @return the entire set of values
-     */
-    public abstract long[] getValues();
-
-    /**
-     * Returns the number of values in the snapshot.
-     *
-     * @return the number of values
-     */
-    public abstract int size();
-
-    /**
-     * Returns the median value in the distribution.
-     *
-     * @return the median value
-     */
-    public double getMedian() {
-        return getValue(0.5);
-    }
-
-    /**
-     * Returns the value at the 75th percentile in the distribution.
-     *
-     * @return the value at the 75th percentile
-     */
-    public double get75thPercentile() {
-        return getValue(0.75);
-    }
-
-    /**
-     * Returns the value at the 95th percentile in the distribution.
-     *
-     * @return the value at the 95th percentile
-     */
-    public double get95thPercentile() {
-        return getValue(0.95);
-    }
-
-    /**
-     * Returns the value at the 98th percentile in the distribution.
-     *
-     * @return the value at the 98th percentile
-     */
-    public double get98thPercentile() {
-        return getValue(0.98);
-    }
-
-    /**
-     * Returns the value at the 99th percentile in the distribution.
-     *
-     * @return the value at the 99th percentile
-     */
-    public double get99thPercentile() {
-        return getValue(0.99);
-    }
-
-    /**
-     * Returns the value at the 99.9th percentile in the distribution.
-     *
-     * @return the value at the 99.9th percentile
-     */
-    public double get999thPercentile() {
-        return getValue(0.999);
-    }
-
-    /**
-     * Returns the highest value in the snapshot.
-     *
-     * @return the highest value
-     */
-    public abstract long getMax();
-
-    /**
-     * Returns the arithmetic mean of the values in the snapshot.
-     *
-     * @return the arithmetic mean
-     */
-    public abstract double getMean();
-
-    /**
-     * Returns the lowest value in the snapshot.
-     *
-     * @return the lowest value
-     */
-    public abstract long getMin();
-
-    /**
-     * Returns the standard deviation of the values in the snapshot.
-     *
-     * @return the standard value
-     */
-    public abstract double getStdDev();
-
-    /**
-     * Writes the values of the snapshot to the given stream.
-     *
-     * @param output an output stream
-     */
-    public abstract void dump(OutputStream output);
-
+  /**
+   * Returns the value at the given quantile.
+   *
+   * @param quantile a given quantile, in {@code [0..1]}
+   * @return the value in the distribution at {@code quantile}
+   */
+  public abstract double getValue(double quantile);
+
+  /**
+   * Returns the entire set of values in the snapshot.
+   *
+   * @return the entire set of values
+   */
+  public abstract long[] getValues();
+
+  /**
+   * Returns the number of values in the snapshot.
+   *
+   * @return the number of values
+   */
+  public abstract int size();
+
+  /**
+   * Returns the median value in the distribution.
+   *
+   * @return the median value
+   */
+  public double getMedian() {
+    return getValue(0.5);
+  }
+
+  /**
+   * Returns the value at the 75th percentile in the distribution.
+   *
+   * @return the value at the 75th percentile
+   */
+  public double get75thPercentile() {
+    return getValue(0.75);
+  }
+
+  /**
+   * Returns the value at the 95th percentile in the distribution.
+   *
+   * @return the value at the 95th percentile
+   */
+  public double get95thPercentile() {
+    return getValue(0.95);
+  }
+
+  /**
+   * Returns the value at the 98th percentile in the distribution.
+   *
+   * @return the value at the 98th percentile
+   */
+  public double get98thPercentile() {
+    return getValue(0.98);
+  }
+
+  /**
+   * Returns the value at the 99th percentile in the distribution.
+   *
+   * @return the value at the 99th percentile
+   */
+  public double get99thPercentile() {
+    return getValue(0.99);
+  }
+
+  /**
+   * Returns the value at the 99.9th percentile in the distribution.
+   *
+   * @return the value at the 99.9th percentile
+   */
+  public double get999thPercentile() {
+    return getValue(0.999);
+  }
+
+  /**
+   * Returns the highest value in the snapshot.
+   *
+   * @return the highest value
+   */
+  public abstract long getMax();
+
+  /**
+   * Returns the arithmetic mean of the values in the snapshot.
+   *
+   * @return the arithmetic mean
+   */
+  public abstract double getMean();
+
+  /**
+   * Returns the lowest value in the snapshot.
+   *
+   * @return the lowest value
+   */
+  public abstract long getMin();
+
+  /**
+   * Returns the standard deviation of the values in the snapshot.
+   *
+   * @return the standard value
+   */
+  public abstract double getStdDev();
+
+  /**
+   * Writes the values of the snapshot to the given stream.
+   *
+   * @param output an output stream
+   */
+  public abstract void dump(OutputStream output);
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Summing.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Summing.java
@@ -1,14 +1,12 @@
 package io.dropwizard.metrics5;
 
-/**
- * An interface for metric types which aggregate a sum
- */
+/** An interface for metric types which aggregate a sum */
 public interface Summing {
 
-    /**
-     * Return the current sum.
-     *
-     * @return the current sum
-     */
-    long getSum();
+  /**
+   * Return the current sum.
+   *
+   * @return the current sum
+   */
+  long getSum();
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/Timer.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/Timer.java
@@ -10,199 +10,197 @@ import java.util.function.Supplier;
  * throughput statistics via {@link Meter}.
  */
 public class Timer implements Metered, Sampling {
-    /**
-     * A timing context.
-     *
-     * @see Timer#time()
-     */
-    public static class Context implements AutoCloseable {
-        private final Timer timer;
-        private final Clock clock;
-        private final long startTime;
-
-        Context(Timer timer, Clock clock) {
-            this.timer = timer;
-            this.clock = clock;
-            this.startTime = clock.getTick();
-        }
-
-        /**
-         * Updates the timer with the difference between current and start time. Call to this method will
-         * not reset the start time. Multiple calls result in multiple updates.
-         *
-         * @return the elapsed time in nanoseconds
-         */
-        public long stop() {
-            final long elapsed = clock.getTick() - startTime;
-            timer.update(elapsed, TimeUnit.NANOSECONDS);
-            return elapsed;
-        }
-
-        /**
-         * Equivalent to calling {@link #stop()}.
-         */
-        @Override
-        public void close() {
-            stop();
-        }
-    }
-
-    private final Meter meter;
-    private final Histogram histogram;
+  /**
+   * A timing context.
+   *
+   * @see Timer#time()
+   */
+  public static class Context implements AutoCloseable {
+    private final Timer timer;
     private final Clock clock;
+    private final long startTime;
 
-    /**
-     * Creates a new {@link Timer} using an {@link ExponentiallyDecayingReservoir} and the default
-     * {@link Clock}.
-     */
-    public Timer() {
-        this(new ExponentiallyDecayingReservoir());
+    Context(Timer timer, Clock clock) {
+      this.timer = timer;
+      this.clock = clock;
+      this.startTime = clock.getTick();
     }
 
     /**
-     * Creates a new {@link Timer} that uses the given {@link Reservoir}.
+     * Updates the timer with the difference between current and start time. Call to this method
+     * will not reset the start time. Multiple calls result in multiple updates.
      *
-     * @param reservoir the {@link Reservoir} implementation the timer should use
+     * @return the elapsed time in nanoseconds
      */
-    public Timer(Reservoir reservoir) {
-        this(reservoir, Clock.defaultClock());
-    }
-
-    /**
-     * Creates a new {@link Timer} that uses the given {@link Reservoir} and {@link Clock}.
-     *
-     * @param reservoir the {@link Reservoir} implementation the timer should use
-     * @param clock     the {@link Clock} implementation the timer should use
-     */
-    public Timer(Reservoir reservoir, Clock clock) {
-        this(new Meter(clock), new Histogram(reservoir), clock);
-    }
-
-    public Timer(Meter meter, Histogram histogram, Clock clock) {
-        this.meter = meter;
-        this.histogram = histogram;
-        this.clock = clock;
-    }
-
-    /**
-     * Adds a recorded duration.
-     *
-     * @param duration the length of the duration
-     * @param unit     the scale unit of {@code duration}
-     */
-    public void update(long duration, TimeUnit unit) {
-        update(unit.toNanos(duration));
-    }
-
-    /**
-     * Adds a recorded duration.
-     *
-     * @param duration the {@link Duration} to add to the timer. Negative or zero value are ignored.
-     */
-    public void update(Duration duration) {
-        update(duration.toNanos());
-    }
-
-    /**
-     * Times and records the duration of event.
-     *
-     * @param event a {@link Callable} whose {@link Callable#call()} method implements a process
-     *              whose duration should be timed
-     * @param <T>   the type of the value returned by {@code event}
-     * @return the value returned by {@code event}
-     * @throws Exception if {@code event} throws an {@link Exception}
-     */
-    public <T> T time(Callable<T> event) throws Exception {
-        final long startTime = clock.getTick();
-        try {
-            return event.call();
-        } finally {
-            update(clock.getTick() - startTime);
-        }
-    }
-
-    /**
-     * Times and records the duration of event. Should not throw exceptions, for that use the
-     * {@link #time(Callable)} method.
-     *
-     * @param event a {@link Supplier} whose {@link Supplier#get()} method implements a process
-     *              whose duration should be timed
-     * @param <T>   the type of the value returned by {@code event}
-     * @return the value returned by {@code event}
-     */
-    public <T> T timeSupplier(Supplier<T> event) {
-        final long startTime = clock.getTick();
-        try {
-            return event.get();
-        } finally {
-            update(clock.getTick() - startTime);
-        }
-    }
-
-    /**
-     * Times and records the duration of event.
-     *
-     * @param event a {@link Runnable} whose {@link Runnable#run()} method implements a process
-     *              whose duration should be timed
-     */
-    public void time(Runnable event) {
-        final long startTime = clock.getTick();
-        try {
-            event.run();
-        } finally {
-            update(clock.getTick() - startTime);
-        }
-    }
-
-    /**
-     * Returns a new {@link Context}.
-     *
-     * @return a new {@link Context}
-     * @see Context
-     */
-    public Context time() {
-        return new Context(this, clock);
-    }
-
-    @Override
-    public long getCount() {
-        return histogram.getCount();
-    }
-
-    @Override
-    public long getSum() {
-        return histogram.getSum();
-    }
-
-    @Override
-    public double getFifteenMinuteRate() {
-        return meter.getFifteenMinuteRate();
-    }
-
-    @Override
-    public double getFiveMinuteRate() {
-        return meter.getFiveMinuteRate();
-    }
-
-    @Override
-    public double getMeanRate() {
-        return meter.getMeanRate();
-    }
-
-    @Override
-    public double getOneMinuteRate() {
-        return meter.getOneMinuteRate();
+    public long stop() {
+      final long elapsed = clock.getTick() - startTime;
+      timer.update(elapsed, TimeUnit.NANOSECONDS);
+      return elapsed;
     }
 
+    /** Equivalent to calling {@link #stop()}. */
     @Override
-    public Snapshot getSnapshot() {
-        return histogram.getSnapshot();
-    }
-
-    private void update(long duration) {
-        if (duration >= 0) {
-            histogram.update(duration);
-            meter.mark();
-        }
-    }
+    public void close() {
+      stop();
+    }
+  }
+
+  private final Meter meter;
+  private final Histogram histogram;
+  private final Clock clock;
+
+  /**
+   * Creates a new {@link Timer} using an {@link ExponentiallyDecayingReservoir} and the default
+   * {@link Clock}.
+   */
+  public Timer() {
+    this(new ExponentiallyDecayingReservoir());
+  }
+
+  /**
+   * Creates a new {@link Timer} that uses the given {@link Reservoir}.
+   *
+   * @param reservoir the {@link Reservoir} implementation the timer should use
+   */
+  public Timer(Reservoir reservoir) {
+    this(reservoir, Clock.defaultClock());
+  }
+
+  /**
+   * Creates a new {@link Timer} that uses the given {@link Reservoir} and {@link Clock}.
+   *
+   * @param reservoir the {@link Reservoir} implementation the timer should use
+   * @param clock the {@link Clock} implementation the timer should use
+   */
+  public Timer(Reservoir reservoir, Clock clock) {
+    this(new Meter(clock), new Histogram(reservoir), clock);
+  }
+
+  public Timer(Meter meter, Histogram histogram, Clock clock) {
+    this.meter = meter;
+    this.histogram = histogram;
+    this.clock = clock;
+  }
+
+  /**
+   * Adds a recorded duration.
+   *
+   * @param duration the length of the duration
+   * @param unit the scale unit of {@code duration}
+   */
+  public void update(long duration, TimeUnit unit) {
+    update(unit.toNanos(duration));
+  }
+
+  /**
+   * Adds a recorded duration.
+   *
+   * @param duration the {@link Duration} to add to the timer. Negative or zero value are ignored.
+   */
+  public void update(Duration duration) {
+    update(duration.toNanos());
+  }
+
+  /**
+   * Times and records the duration of event.
+   *
+   * @param event a {@link Callable} whose {@link Callable#call()} method implements a process whose
+   *     duration should be timed
+   * @param <T> the type of the value returned by {@code event}
+   * @return the value returned by {@code event}
+   * @throws Exception if {@code event} throws an {@link Exception}
+   */
+  public <T> T time(Callable<T> event) throws Exception {
+    final long startTime = clock.getTick();
+    try {
+      return event.call();
+    } finally {
+      update(clock.getTick() - startTime);
+    }
+  }
+
+  /**
+   * Times and records the duration of event. Should not throw exceptions, for that use the {@link
+   * #time(Callable)} method.
+   *
+   * @param event a {@link Supplier} whose {@link Supplier#get()} method implements a process whose
+   *     duration should be timed
+   * @param <T> the type of the value returned by {@code event}
+   * @return the value returned by {@code event}
+   */
+  public <T> T timeSupplier(Supplier<T> event) {
+    final long startTime = clock.getTick();
+    try {
+      return event.get();
+    } finally {
+      update(clock.getTick() - startTime);
+    }
+  }
+
+  /**
+   * Times and records the duration of event.
+   *
+   * @param event a {@link Runnable} whose {@link Runnable#run()} method implements a process whose
+   *     duration should be timed
+   */
+  public void time(Runnable event) {
+    final long startTime = clock.getTick();
+    try {
+      event.run();
+    } finally {
+      update(clock.getTick() - startTime);
+    }
+  }
+
+  /**
+   * Returns a new {@link Context}.
+   *
+   * @return a new {@link Context}
+   * @see Context
+   */
+  public Context time() {
+    return new Context(this, clock);
+  }
+
+  @Override
+  public long getCount() {
+    return histogram.getCount();
+  }
+
+  @Override
+  public long getSum() {
+    return histogram.getSum();
+  }
+
+  @Override
+  public double getFifteenMinuteRate() {
+    return meter.getFifteenMinuteRate();
+  }
+
+  @Override
+  public double getFiveMinuteRate() {
+    return meter.getFiveMinuteRate();
+  }
+
+  @Override
+  public double getMeanRate() {
+    return meter.getMeanRate();
+  }
+
+  @Override
+  public double getOneMinuteRate() {
+    return meter.getOneMinuteRate();
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    return histogram.getSnapshot();
+  }
+
+  private void update(long duration) {
+    if (duration >= 0) {
+      histogram.update(duration);
+      meter.mark();
+    }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/UniformReservoir.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/UniformReservoir.java
@@ -11,60 +11,60 @@ import java.util.concurrent.atomic.AtomicLongArray;
  * @see <a href="http://www.cs.umd.edu/~samir/498/vitter.pdf">Random Sampling with a Reservoir</a>
  */
 public class UniformReservoir implements Reservoir {
-    private static final int DEFAULT_SIZE = 1028;
-    private final AtomicLong count = new AtomicLong();
-    private final AtomicLongArray values;
+  private static final int DEFAULT_SIZE = 1028;
+  private final AtomicLong count = new AtomicLong();
+  private final AtomicLongArray values;
 
-    /**
-     * Creates a new {@link UniformReservoir} of 1028 elements, which offers a 99.9% confidence level
-     * with a 5% margin of error assuming a normal distribution.
-     */
-    public UniformReservoir() {
-        this(DEFAULT_SIZE);
-    }
+  /**
+   * Creates a new {@link UniformReservoir} of 1028 elements, which offers a 99.9% confidence level
+   * with a 5% margin of error assuming a normal distribution.
+   */
+  public UniformReservoir() {
+    this(DEFAULT_SIZE);
+  }
 
-    /**
-     * Creates a new {@link UniformReservoir}.
-     *
-     * @param size the number of samples to keep in the sampling reservoir
-     */
-    public UniformReservoir(int size) {
-        this.values = new AtomicLongArray(size);
-        for (int i = 0; i < values.length(); i++) {
-            values.set(i, 0);
-        }
-        count.set(0);
+  /**
+   * Creates a new {@link UniformReservoir}.
+   *
+   * @param size the number of samples to keep in the sampling reservoir
+   */
+  public UniformReservoir(int size) {
+    this.values = new AtomicLongArray(size);
+    for (int i = 0; i < values.length(); i++) {
+      values.set(i, 0);
     }
+    count.set(0);
+  }
 
-    @Override
-    public int size() {
-        final long c = count.get();
-        if (c > values.length()) {
-            return values.length();
-        }
-        return (int) c;
+  @Override
+  public int size() {
+    final long c = count.get();
+    if (c > values.length()) {
+      return values.length();
     }
+    return (int) c;
+  }
 
-    @Override
-    public void update(long value) {
-        final long c = count.incrementAndGet();
-        if (c <= values.length()) {
-            values.set((int) c - 1, value);
-        } else {
-            final long r = ThreadLocalRandom.current().nextLong(c);
-            if (r < values.length()) {
-                values.set((int) r, value);
-            }
-        }
+  @Override
+  public void update(long value) {
+    final long c = count.incrementAndGet();
+    if (c <= values.length()) {
+      values.set((int) c - 1, value);
+    } else {
+      final long r = ThreadLocalRandom.current().nextLong(c);
+      if (r < values.length()) {
+        values.set((int) r, value);
+      }
     }
+  }
 
-    @Override
-    public Snapshot getSnapshot() {
-        final int s = size();
-        long[] copy = new long[s];
-        for (int i = 0; i < s; i++) {
-            copy[i] = values.get(i);
-        }
-        return new UniformSnapshot(copy);
+  @Override
+  public Snapshot getSnapshot() {
+    final int s = size();
+    long[] copy = new long[s];
+    for (int i = 0; i < s; i++) {
+      copy[i] = values.get(i);
     }
+    return new UniformSnapshot(copy);
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/UniformSnapshot.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/UniformSnapshot.java
@@ -1,177 +1,178 @@
 package io.dropwizard.metrics5;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.lang.Math.floor;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Collection;
 
-import static java.lang.Math.floor;
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/**
- * A statistical snapshot of a {@link UniformSnapshot}.
- */
+/** A statistical snapshot of a {@link UniformSnapshot}. */
 public class UniformSnapshot extends Snapshot {
 
-    private final long[] values;
-
-    /**
-     * Create a new {@link Snapshot} with the given values.
-     *
-     * @param values an unordered set of values in the reservoir
-     */
-    public UniformSnapshot(Collection<Long> values) {
-        final Object[] copy = values.toArray();
-        this.values = new long[copy.length];
-        for (int i = 0; i < copy.length; i++) {
-            this.values[i] = (Long) copy[i];
-        }
-        Arrays.sort(this.values);
+  private final long[] values;
+
+  /**
+   * Create a new {@link Snapshot} with the given values.
+   *
+   * @param values an unordered set of values in the reservoir
+   */
+  public UniformSnapshot(Collection<Long> values) {
+    final Object[] copy = values.toArray();
+    this.values = new long[copy.length];
+    for (int i = 0; i < copy.length; i++) {
+      this.values[i] = (Long) copy[i];
     }
-
-    /**
-     * Create a new {@link Snapshot} with the given values.
-     *
-     * @param values an unordered set of values in the reservoir that can be used by this class directly
-     */
-    public UniformSnapshot(long[] values) {
-        this.values = Arrays.copyOf(values, values.length);
-        Arrays.sort(this.values);
+    Arrays.sort(this.values);
+  }
+
+  /**
+   * Create a new {@link Snapshot} with the given values.
+   *
+   * @param values an unordered set of values in the reservoir that can be used by this class
+   *     directly
+   */
+  public UniformSnapshot(long[] values) {
+    this.values = Arrays.copyOf(values, values.length);
+    Arrays.sort(this.values);
+  }
+
+  /**
+   * Returns the value at the given quantile.
+   *
+   * @param quantile a given quantile, in {@code [0..1]}
+   * @return the value in the distribution at {@code quantile}
+   */
+  @Override
+  public double getValue(double quantile) {
+    checkArgument(
+        quantile >= 0.0 && quantile <= 1.0 && !Double.isNaN(quantile),
+        "%s is not in [0..1]",
+        quantile);
+
+    if (values.length == 0) {
+      return 0.0;
     }
 
-    /**
-     * Returns the value at the given quantile.
-     *
-     * @param quantile a given quantile, in {@code [0..1]}
-     * @return the value in the distribution at {@code quantile}
-     */
-    @Override
-    public double getValue(double quantile) {
-        if (quantile < 0.0 || quantile > 1.0 || Double.isNaN(quantile)) {
-            throw new IllegalArgumentException(quantile + " is not in [0..1]");
-        }
-
-        if (values.length == 0) {
-            return 0.0;
-        }
-
-        final double pos = quantile * (values.length + 1);
-        final int index = (int) pos;
-
-        if (index < 1) {
-            return values[0];
-        }
-
-        if (index >= values.length) {
-            return values[values.length - 1];
-        }
-
-        final double lower = values[index - 1];
-        final double upper = values[index];
-        return lower + (pos - floor(pos)) * (upper - lower);
-    }
+    final double pos = quantile * (values.length + 1);
+    final int index = (int) pos;
 
-    /**
-     * Returns the number of values in the snapshot.
-     *
-     * @return the number of values
-     */
-    @Override
-    public int size() {
-        return values.length;
+    if (index < 1) {
+      return values[0];
     }
 
-    /**
-     * Returns the entire set of values in the snapshot.
-     *
-     * @return the entire set of values
-     */
-    @Override
-    public long[] getValues() {
-        return Arrays.copyOf(values, values.length);
+    if (index >= values.length) {
+      return values[values.length - 1];
     }
 
-    /**
-     * Returns the highest value in the snapshot.
-     *
-     * @return the highest value
-     */
-    @Override
-    public long getMax() {
-        if (values.length == 0) {
-            return 0;
-        }
-        return values[values.length - 1];
+    final double lower = values[index - 1];
+    final double upper = values[index];
+    return lower + (pos - floor(pos)) * (upper - lower);
+  }
+
+  /**
+   * Returns the number of values in the snapshot.
+   *
+   * @return the number of values
+   */
+  @Override
+  public int size() {
+    return values.length;
+  }
+
+  /**
+   * Returns the entire set of values in the snapshot.
+   *
+   * @return the entire set of values
+   */
+  @Override
+  public long[] getValues() {
+    return Arrays.copyOf(values, values.length);
+  }
+
+  /**
+   * Returns the highest value in the snapshot.
+   *
+   * @return the highest value
+   */
+  @Override
+  public long getMax() {
+    if (values.length == 0) {
+      return 0;
     }
-
-    /**
-     * Returns the lowest value in the snapshot.
-     *
-     * @return the lowest value
-     */
-    @Override
-    public long getMin() {
-        if (values.length == 0) {
-            return 0;
-        }
-        return values[0];
+    return values[values.length - 1];
+  }
+
+  /**
+   * Returns the lowest value in the snapshot.
+   *
+   * @return the lowest value
+   */
+  @Override
+  public long getMin() {
+    if (values.length == 0) {
+      return 0;
+    }
+    return values[0];
+  }
+
+  /**
+   * Returns the arithmetic mean of the values in the snapshot.
+   *
+   * @return the arithmetic mean
+   */
+  @Override
+  public double getMean() {
+    if (values.length == 0) {
+      return 0;
     }
 
-    /**
-     * Returns the arithmetic mean of the values in the snapshot.
-     *
-     * @return the arithmetic mean
-     */
-    @Override
-    public double getMean() {
-        if (values.length == 0) {
-            return 0;
-        }
-
-        double sum = 0;
-        for (long value : values) {
-            sum += value;
-        }
-        return sum / values.length;
+    double sum = 0;
+    for (long value : values) {
+      sum += value;
+    }
+    return sum / values.length;
+  }
+
+  /**
+   * Returns the standard deviation of the values in the snapshot.
+   *
+   * @return the standard deviation value
+   */
+  @Override
+  public double getStdDev() {
+    // two-pass algorithm for variance, avoids numeric overflow
+
+    if (values.length <= 1) {
+      return 0;
     }
 
-    /**
-     * Returns the standard deviation of the values in the snapshot.
-     *
-     * @return the standard deviation value
-     */
-    @Override
-    public double getStdDev() {
-        // two-pass algorithm for variance, avoids numeric overflow
-
-        if (values.length <= 1) {
-            return 0;
-        }
-
-        final double mean = getMean();
-        double sum = 0;
-
-        for (long value : values) {
-            final double diff = value - mean;
-            sum += diff * diff;
-        }
-
-        final double variance = sum / (values.length - 1);
-        return Math.sqrt(variance);
+    final double mean = getMean();
+    double sum = 0;
+
+    for (long value : values) {
+      final double diff = value - mean;
+      sum += diff * diff;
     }
 
-    /**
-     * Writes the values of the snapshot to the given stream.
-     *
-     * @param output an output stream
-     */
-    @Override
-    public void dump(OutputStream output) {
-        try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
-            for (long value : values) {
-                out.printf("%d%n", value);
-            }
-        }
+    final double variance = sum / (values.length - 1);
+    return Math.sqrt(variance);
+  }
+
+  /**
+   * Writes the values of the snapshot to the given stream.
+   *
+   * @param output an output stream
+   */
+  @Override
+  public void dump(OutputStream output) {
+    try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
+      for (long value : values) {
+        out.printf("%d%n", value);
+      }
     }
+  }
 }
--- a/metrics-core/src/main/java/io/dropwizard/metrics5/WeightedSnapshot.java
+++ b/metrics-core/src/main/java/io/dropwizard/metrics5/WeightedSnapshot.java
@@ -1,195 +1,192 @@
 package io.dropwizard.metrics5;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Comparator.comparingLong;
+
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Comparator;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/**
- * A statistical snapshot of a {@link WeightedSnapshot}.
- */
+/** A statistical snapshot of a {@link WeightedSnapshot}. */
 public class WeightedSnapshot extends Snapshot {
 
-    /**
-     * A single sample item with value and its weights for {@link WeightedSnapshot}.
-     */
-    public static class WeightedSample {
-        public final long value;
-        public final double weight;
-
-        public WeightedSample(long value, double weight) {
-            this.value = value;
-            this.weight = weight;
-        }
-    }
+  /** A single sample item with value and its weights for {@link WeightedSnapshot}. */
+  public static class WeightedSample {
+    public final long value;
+    public final double weight;
 
-    private final long[] values;
-    private final double[] normWeights;
-    private final double[] quantiles;
-
-    /**
-     * Create a new {@link Snapshot} with the given values.
-     *
-     * @param values an unordered set of values in the reservoir
-     */
-    public WeightedSnapshot(Collection<WeightedSample> values) {
-        final WeightedSample[] copy = values.toArray(new WeightedSample[]{});
-
-        Arrays.sort(copy, Comparator.comparingLong(w -> w.value));
-
-        this.values = new long[copy.length];
-        this.normWeights = new double[copy.length];
-        this.quantiles = new double[copy.length];
-
-        double sumWeight = 0;
-        for (WeightedSample sample : copy) {
-            sumWeight += sample.weight;
-        }
-
-        for (int i = 0; i < copy.length; i++) {
-            this.values[i] = copy[i].value;
-            this.normWeights[i] = sumWeight != 0 ? copy[i].weight / sumWeight : 0;
-        }
-
-        for (int i = 1; i < copy.length; i++) {
-            this.quantiles[i] = this.quantiles[i - 1] + this.normWeights[i - 1];
-        }
+    public WeightedSample(long value, double weight) {
+      this.value = value;
+      this.weight = weight;
     }
+  }
 
-    /**
-     * Returns the value at the given quantile.
-     *
-     * @param quantile a given quantile, in {@code [0..1]}
-     * @return the value in the distribution at {@code quantile}
-     */
-    @Override
-    public double getValue(double quantile) {
-        if (quantile < 0.0 || quantile > 1.0 || Double.isNaN(quantile)) {
-            throw new IllegalArgumentException(quantile + " is not in [0..1]");
-        }
-
-        if (values.length == 0) {
-            return 0.0;
-        }
-
-        int posx = Arrays.binarySearch(quantiles, quantile);
-        if (posx < 0)
-            posx = ((-posx) - 1) - 1;
-
-        if (posx < 1) {
-            return values[0];
-        }
-
-        if (posx >= values.length) {
-            return values[values.length - 1];
-        }
-
-        return values[posx];
-    }
+  private final long[] values;
+  private final double[] normWeights;
+  private final double[] quantiles;
 
-    /**
-     * Returns the number of values in the snapshot.
-     *
-     * @return the number of values
-     */
-    @Override
-    public int size() {
-        return values.length;
-    }
+  /**
+   * Create a new {@link Snapshot} with the given values.
+   *
+   * @param values an unordered set of values in the reservoir
+   */
+  public WeightedSnapshot(Collection<WeightedSample> values) {
+    final WeightedSample[] copy = values.toArray(new WeightedSample[] {});
+
+    Arrays.sort(copy, comparingLong(w -> w.value));
+
+    this.values = new long[copy.length];
+    this.normWeights = new double[copy.length];
+    this.quantiles = new double[copy.length];
 
-    /**
-     * Returns the entire set of values in the snapshot.
-     *
-     * @return the entire set of values
-     */
-    @Override
-    public long[] getValues() {
-        return Arrays.copyOf(values, values.length);
+    double sumWeight = 0;
+    for (WeightedSample sample : copy) {
+      sumWeight += sample.weight;
     }
 
-    /**
-     * Returns the highest value in the snapshot.
-     *
-     * @return the highest value
-     */
-    @Override
-    public long getMax() {
-        if (values.length == 0) {
-            return 0;
-        }
-        return values[values.length - 1];
+    for (int i = 0; i < copy.length; i++) {
+      this.values[i] = copy[i].value;
+      this.normWeights[i] = sumWeight != 0 ? copy[i].weight / sumWeight : 0;
     }
 
-    /**
-     * Returns the lowest value in the snapshot.
-     *
-     * @return the lowest value
-     */
-    @Override
-    public long getMin() {
-        if (values.length == 0) {
-            return 0;
-        }
-        return values[0];
+    for (int i = 1; i < copy.length; i++) {
+      this.quantiles[i] = this.quantiles[i - 1] + this.normWeights[i - 1];
     }
+  }
+
+  /**
+   * Returns the value at the given quantile.
+   *
+   * @param quantile a given quantile, in {@code [0..1]}
+   * @return the value in the distribution at {@code quantile}
+   */
+  @Override
+  public double getValue(double quantile) {
+    checkArgument(
+        quantile >= 0.0 && quantile <= 1.0 && !Double.isNaN(quantile),
+        "%s is not in [0..1]",
+        quantile);
+
+    if (values.length == 0) {
+      return 0.0;
+    }
+
+    int posx = Arrays.binarySearch(quantiles, quantile);
+    if (posx < 0) posx = ((-posx) - 1) - 1;
 
-    /**
-     * Returns the weighted arithmetic mean of the values in the snapshot.
-     *
-     * @return the weighted arithmetic mean
-     */
-    @Override
-    public double getMean() {
-        if (values.length == 0) {
-            return 0;
-        }
-
-        double sum = 0;
-        for (int i = 0; i < values.length; i++) {
-            sum += values[i] * normWeights[i];
-        }
-        return sum;
+    if (posx < 1) {
+      return values[0];
     }
 
-    /**
-     * Returns the weighted standard deviation of the values in the snapshot.
-     *
-     * @return the weighted standard deviation value
-     */
-    @Override
-    public double getStdDev() {
-        // two-pass algorithm for variance, avoids numeric overflow
+    if (posx >= values.length) {
+      return values[values.length - 1];
+    }
 
-        if (values.length <= 1) {
-            return 0;
-        }
+    return values[posx];
+  }
+
+  /**
+   * Returns the number of values in the snapshot.
+   *
+   * @return the number of values
+   */
+  @Override
+  public int size() {
+    return values.length;
+  }
+
+  /**
+   * Returns the entire set of values in the snapshot.
+   *
+   * @return the entire set of values
+   */
+  @Override
+  public long[] getValues() {
+    return Arrays.copyOf(values, values.length);
+  }
+
+  /**
+   * Returns the highest value in the snapshot.
+   *
+   * @return the highest value
+   */
+  @Override
+  public long getMax() {
+    if (values.length == 0) {
+      return 0;
+    }
+    return values[values.length - 1];
+  }
+
+  /**
+   * Returns the lowest value in the snapshot.
+   *
+   * @return the lowest value
+   */
+  @Override
+  public long getMin() {
+    if (values.length == 0) {
+      return 0;
+    }
+    return values[0];
+  }
+
+  /**
+   * Returns the weighted arithmetic mean of the values in the snapshot.
+   *
+   * @return the weighted arithmetic mean
+   */
+  @Override
+  public double getMean() {
+    if (values.length == 0) {
+      return 0;
+    }
 
-        final double mean = getMean();
-        double variance = 0;
+    double sum = 0;
+    for (int i = 0; i < values.length; i++) {
+      sum += values[i] * normWeights[i];
+    }
+    return sum;
+  }
+
+  /**
+   * Returns the weighted standard deviation of the values in the snapshot.
+   *
+   * @return the weighted standard deviation value
+   */
+  @Override
+  public double getStdDev() {
+    // two-pass algorithm for variance, avoids numeric overflow
+
+    if (values.length <= 1) {
+      return 0;
+    }
 
-        for (int i = 0; i < values.length; i++) {
-            final double diff = values[i] - mean;
-            variance += normWeights[i] * diff * diff;
-        }
+    final double mean = getMean();
+    double variance = 0;
 
-        return Math.sqrt(variance);
+    for (int i = 0; i < values.length; i++) {
+      final double diff = values[i] - mean;
+      variance += normWeights[i] * diff * diff;
     }
 
-    /**
-     * Writes the values of the snapshot to the given stream.
-     *
-     * @param output an output stream
-     */
-    @Override
-    public void dump(OutputStream output) {
-        try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
-            for (long value : values) {
-                out.printf("%d%n", value);
-            }
-        }
+    return Math.sqrt(variance);
+  }
+
+  /**
+   * Writes the values of the snapshot to the given stream.
+   *
+   * @param output an output stream
+   */
+  @Override
+  public void dump(OutputStream output) {
+    try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
+      for (long value : values) {
+        out.printf("%d%n", value);
+      }
     }
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/CachedGaugeTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/CachedGaugeTest.java
@@ -1,8 +1,6 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -12,120 +10,120 @@ import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-class CachedGaugeTest {
-    private static final Logger LOGGER = LoggerFactory.getLogger(CachedGaugeTest.class);
-    private static final int THREAD_COUNT = 10;
-    private static final long RUNNING_TIME_MILLIS = TimeUnit.SECONDS.toMillis(10);
+final class CachedGaugeTest {
+  private static final Logger LOG = LoggerFactory.getLogger(CachedGaugeTest.class);
+  private static final int THREAD_COUNT = 10;
+  private static final long RUNNING_TIME_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
-    private final AtomicInteger value = new AtomicInteger(0);
-    private final Gauge<Integer> gauge = new CachedGauge<Integer>(100, TimeUnit.MILLISECONDS) {
+  private final AtomicInteger value = new AtomicInteger(0);
+  private final Gauge<Integer> gauge =
+      new CachedGauge<Integer>(100, TimeUnit.MILLISECONDS) {
         @Override
         protected Integer loadValue() {
-            return value.incrementAndGet();
+          return value.incrementAndGet();
         }
-    };
-    private final Gauge<Integer> shortTimeoutGauge = new CachedGauge<Integer>(1, TimeUnit.MILLISECONDS) {
+      };
+  private final Gauge<Integer> shortTimeoutGauge =
+      new CachedGauge<Integer>(1, TimeUnit.MILLISECONDS) {
         @Override
         protected Integer loadValue() {
-            try {
-                Thread.sleep(5);
-            } catch (InterruptedException e) {
-                throw new RuntimeException("Thread was interrupted", e);
-            }
-            return value.incrementAndGet();
+          try {
+            Thread.sleep(5);
+          } catch (InterruptedException e) {
+            throw new RuntimeException("Thread was interrupted", e);
+          }
+          return value.incrementAndGet();
         }
-    };
-    private final ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
-
-    @Test
-    void cachesTheValueForTheGivenPeriod() {
-        assertThat(gauge.getValue())
-                .isEqualTo(1);
-        assertThat(gauge.getValue())
-                .isEqualTo(1);
-    }
-
-    @Test
-    void reloadsTheCachedValueAfterTheGivenPeriod() throws Exception {
-        assertThat(gauge.getValue())
-                .isEqualTo(1);
-
-        Thread.sleep(150);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(2);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(2);
-    }
-
-    @Test
-    void reloadsCachedValueInNegativeTime() throws Exception {
-        AtomicLong time = new AtomicLong(-2L);
-        Clock clock = new Clock() {
-            @Override
-            public long getTick() {
-                return time.get();
-            }
+      };
+  private final ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
+
+  @Test
+  void cachesTheValueForTheGivenPeriod() {
+    assertThat(gauge.getValue()).isEqualTo(1);
+    assertThat(gauge.getValue()).isEqualTo(1);
+  }
+
+  @Test
+  void reloadsTheCachedValueAfterTheGivenPeriod() throws Exception {
+    assertThat(gauge.getValue()).isEqualTo(1);
+
+    Thread.sleep(150);
+
+    assertThat(gauge.getValue()).isEqualTo(2);
+
+    assertThat(gauge.getValue()).isEqualTo(2);
+  }
+
+  @Test
+  void reloadsCachedValueInNegativeTime() throws Exception {
+    AtomicLong time = new AtomicLong(-2L);
+    Clock clock =
+        new Clock() {
+          @Override
+          public long getTick() {
+            return time.get();
+          }
         };
-        Gauge<Integer> clockGauge = new CachedGauge<Integer>(clock, 1, TimeUnit.NANOSECONDS) {
-            @Override
-            protected Integer loadValue() {
-                return value.incrementAndGet();
-            }
+    Gauge<Integer> clockGauge =
+        new CachedGauge<Integer>(clock, 1, TimeUnit.NANOSECONDS) {
+          @Override
+          protected Integer loadValue() {
+            return value.incrementAndGet();
+          }
         };
-        assertThat(clockGauge.getValue())
-                .isEqualTo(1);
-        assertThat(clockGauge.getValue())
-                .isEqualTo(1);
+    assertThat(clockGauge.getValue()).isEqualTo(1);
+    assertThat(clockGauge.getValue()).isEqualTo(1);
 
-        time.set(-1L);
+    time.set(-1L);
 
-        assertThat(clockGauge.getValue())
-                .isEqualTo(2);
-        assertThat(clockGauge.getValue())
-                .isEqualTo(2);
-    }
+    assertThat(clockGauge.getValue()).isEqualTo(2);
+    assertThat(clockGauge.getValue()).isEqualTo(2);
+  }
 
-    @Test
-    void multipleThreadAccessReturnsConsistentResults() throws Exception {
-        List<Future<Boolean>> futures = new ArrayList<>(THREAD_COUNT);
+  @Test
+  void multipleThreadAccessReturnsConsistentResults() throws Exception {
+    List<Future<Boolean>> futures = new ArrayList<>(THREAD_COUNT);
 
-        for (int i = 0; i < THREAD_COUNT; i++) {
-            Future<Boolean> future = executor.submit(() -> {
+    for (int i = 0; i < THREAD_COUNT; i++) {
+      Future<Boolean> future =
+          executor.submit(
+              () -> {
                 long startTime = System.currentTimeMillis();
                 int lastValue = 0;
 
                 do {
-                    Integer newValue = shortTimeoutGauge.getValue();
-
-                    if (newValue == null) {
-                        LOGGER.warn("Cached gauge returned null value");
-                        return false;
-                    }
-
-                    if (newValue < lastValue) {
-                        LOGGER.error("Cached gauge returned stale value, last: {}, new: {}", lastValue, newValue);
-                        return false;
-                    }
-
-                    lastValue = newValue;
+                  Integer newValue = shortTimeoutGauge.getValue();
+
+                  if (newValue == null) {
+                    LOG.warn("Cached gauge returned null value");
+                    return false;
+                  }
+
+                  if (newValue < lastValue) {
+                    LOG.error(
+                        "Cached gauge returned stale value, last: {}, new: {}",
+                        lastValue,
+                        newValue);
+                    return false;
+                  }
+
+                  lastValue = newValue;
                 } while (System.currentTimeMillis() - startTime <= RUNNING_TIME_MILLIS);
 
                 return true;
-            });
-
-            futures.add(future);
-        }
+              });
 
-        for (int i = 0; i < futures.size(); i++) {
-            assertTrue(futures.get(i).get(), "Future " + i + " failed");
-        }
+      futures.add(future);
+    }
 
-        executor.shutdown();
+    for (int i = 0; i < futures.size(); i++) {
+      assertThat(futures.get(i).get()).withFailMessage("Future %s failed", i).isTrue();
     }
+
+    executor.shutdown();
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/ChunkedAssociativeLongArrayTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/ChunkedAssociativeLongArrayTest.java
@@ -4,37 +4,32 @@ import static org.assertj.core.api.BDDAssertions.then;
 
 import org.junit.jupiter.api.Test;
 
-class ChunkedAssociativeLongArrayTest {
-
-    @Test
-    void testTrim() {
-        ChunkedAssociativeLongArray array = new ChunkedAssociativeLongArray(3);
-        array.put(-3, 3);
-        array.put(-2, 1);
-        array.put(0, 5);
-        array.put(3, 0);
-        array.put(9, 8);
-        array.put(15, 0);
-        array.put(19, 5);
-        array.put(21, 5);
-        array.put(34, -9);
-        array.put(109, 5);
-
-        then(array.out())
-                .isEqualTo("[(-3: 3) (-2: 1) (0: 5) ]->[(3: 0) (9: 8) (15: 0) ]->[(19: 5) (21: 5) (34: -9) ]->[(109: 5) ]");
-        then(array.values())
-                .isEqualTo(new long[]{3, 1, 5, 0, 8, 0, 5, 5, -9, 5});
-        then(array.size())
-                .isEqualTo(10);
-
-        array.trim(-2, 20);
-
-        then(array.out())
-                .isEqualTo("[(-2: 1) (0: 5) ]->[(3: 0) (9: 8) (15: 0) ]->[(19: 5) ]");
-        then(array.values())
-                .isEqualTo(new long[]{1, 5, 0, 8, 0, 5});
-        then(array.size())
-                .isEqualTo(6);
-
-    }
+final class ChunkedAssociativeLongArrayTest {
+
+  @Test
+  void trim() {
+    ChunkedAssociativeLongArray array = new ChunkedAssociativeLongArray(3);
+    array.put(-3, 3);
+    array.put(-2, 1);
+    array.put(0, 5);
+    array.put(3, 0);
+    array.put(9, 8);
+    array.put(15, 0);
+    array.put(19, 5);
+    array.put(21, 5);
+    array.put(34, -9);
+    array.put(109, 5);
+
+    then(array.out())
+        .isEqualTo(
+            "[(-3: 3) (-2: 1) (0: 5) ]->[(3: 0) (9: 8) (15: 0) ]->[(19: 5) (21: 5) (34: -9) ]->[(109: 5) ]");
+    then(array.values()).isEqualTo(new long[] {3, 1, 5, 0, 8, 0, 5, 5, -9, 5});
+    then(array.size()).isEqualTo(10);
+
+    array.trim(-2, 20);
+
+    then(array.out()).isEqualTo("[(-2: 1) (0: 5) ]->[(3: 0) (9: 8) (15: 0) ]->[(19: 5) ]");
+    then(array.values()).isEqualTo(new long[] {1, 5, 0, 8, 0, 5});
+    then(array.size()).isEqualTo(6);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/ClassMetadataTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/ClassMetadataTest.java
@@ -1,13 +1,13 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class ClassMetadataTest {
-    @Test
-    public void testParameterMetadataIsAvailable() throws NoSuchMethodException {
-        assertThat(DefaultSettableGauge.class.getConstructor(Object.class).getParameters())
-                .allSatisfy(parameter -> assertThat(parameter.isNamePresent()).isTrue());
-    }
-}
\ No newline at end of file
+import org.junit.jupiter.api.Test;
+
+final class ClassMetadataTest {
+  @Test
+  void parameterMetadataIsAvailable() throws NoSuchMethodException {
+    assertThat(DefaultSettableGauge.class.getConstructor(Object.class).getParameters())
+        .allSatisfy(parameter -> assertThat(parameter.isNamePresent()).isTrue());
+  }
+}
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/ClockTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/ClockTest.java
@@ -1,28 +1,23 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.offset;
 
-class ClockTest {
+import org.junit.jupiter.api.Test;
+
+final class ClockTest {
 
-    @Test
-    void userTimeClock() {
-        final Clock.UserTimeClock clock = new Clock.UserTimeClock();
+  @Test
+  void userTimeClock() {
+    final Clock.UserTimeClock clock = new Clock.UserTimeClock();
 
-        assertThat((double) clock.getTime())
-                .isEqualTo(System.currentTimeMillis(),
-                        offset(100.0));
+    assertThat((double) clock.getTime()).isCloseTo(System.currentTimeMillis(), offset(100.0));
 
-        assertThat((double) clock.getTick())
-                .isEqualTo(System.nanoTime(),
-                        offset(1000000.0));
-    }
+    assertThat((double) clock.getTick()).isCloseTo(System.nanoTime(), offset(1000000.0));
+  }
 
-    @Test
-    void defaultsToUserTime() {
-        assertThat(Clock.defaultClock())
-                .isInstanceOf(Clock.UserTimeClock.class);
-    }
+  @Test
+  void defaultsToUserTime() {
+    assertThat(Clock.defaultClock()).isInstanceOf(Clock.UserTimeClock.class);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/ConsoleReporterTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/ConsoleReporterTest.java
@@ -1,9 +1,8 @@
 package io.dropwizard.metrics5;
 
-import org.apache.commons.lang3.JavaVersion;
-import org.apache.commons.lang3.SystemUtils;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
@@ -15,20 +14,221 @@ import java.util.SortedMap;
 import java.util.TimeZone;
 import java.util.TreeMap;
 import java.util.concurrent.TimeUnit;
+import org.apache.commons.lang3.JavaVersion;
+import org.apache.commons.lang3.SystemUtils;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-class ConsoleReporterTest {
-    private final Locale locale = Locale.US;
-    private final TimeZone timeZone = TimeZone.getTimeZone("America/Los_Angeles");
-
-    private final MetricRegistry registry = mock(MetricRegistry.class);
-    private final Clock clock = mock(Clock.class);
-    private final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    private final PrintStream output = new PrintStream(bytes);
-    private final ConsoleReporter reporter = ConsoleReporter.forRegistry(registry)
+final class ConsoleReporterTest {
+  private final Locale locale = Locale.US;
+  private final TimeZone timeZone = TimeZone.getTimeZone("America/Los_Angeles");
+
+  private final MetricRegistry registry = mock();
+  private final Clock clock = mock();
+  private final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+  private final PrintStream output = new PrintStream(bytes);
+  private final ConsoleReporter reporter =
+      ConsoleReporter.forRegistry(registry)
+          .outputTo(output)
+          .formattedFor(locale)
+          .withClock(clock)
+          .formattedFor(timeZone)
+          .convertRatesTo(TimeUnit.SECONDS)
+          .convertDurationsTo(TimeUnit.MILLISECONDS)
+          .filter(MetricFilter.ALL)
+          .build();
+  private String dateHeader;
+
+  @BeforeEach
+  void setUp() throws Exception {
+    when(clock.getTime()).thenReturn(1363568676000L);
+    // JDK9 has changed the java.text.DateFormat API implementation according to Unicode.
+    // See http://mail.openjdk.java.net/pipermail/jdk9-dev/2017-April/005732.html
+    dateHeader =
+        SystemUtils.isJavaVersionAtMost(JavaVersion.JAVA_1_8)
+            ? "3/17/13 6:04:36 PM ============================================================="
+            :
+            // https://bugs.openjdk.org/browse/JDK-8304925
+            SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_20)
+                ? "3/17/13, 6:04:36\u202FPM ============================================================"
+                : "3/17/13, 6:04:36 PM ============================================================";
+  }
+
+  @Test
+  void reportsGaugeValues() throws Exception {
+    final Gauge<Integer> gauge = () -> 1;
+
+    reporter.report(map(MetricName.build("gauge"), gauge), map(), map(), map(), map());
+
+    assertThat(consoleOutput())
+        .isEqualTo(
+            lines(
+                dateHeader,
+                "",
+                "-- Gauges ----------------------------------------------------------------------",
+                "gauge",
+                "             value = 1",
+                "",
+                ""));
+  }
+
+  @Test
+  void reportsCounterValues() throws Exception {
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(100L);
+
+    reporter.report(map(), map(MetricName.build("test.counter"), counter), map(), map(), map());
+
+    assertThat(consoleOutput())
+        .isEqualTo(
+            lines(
+                dateHeader,
+                "",
+                "-- Counters --------------------------------------------------------------------",
+                "test.counter",
+                "             count = 100",
+                "",
+                ""));
+  }
+
+  @Test
+  void reportsHistogramValues() throws Exception {
+    final Histogram histogram = mock();
+    when(histogram.getCount()).thenReturn(1L);
+    when(histogram.getSum()).thenReturn(4L);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(2L);
+    when(snapshot.getMean()).thenReturn(3.0);
+    when(snapshot.getMin()).thenReturn(4L);
+    when(snapshot.getStdDev()).thenReturn(5.0);
+    when(snapshot.getMedian()).thenReturn(6.0);
+    when(snapshot.get75thPercentile()).thenReturn(7.0);
+    when(snapshot.get95thPercentile()).thenReturn(8.0);
+    when(snapshot.get98thPercentile()).thenReturn(9.0);
+    when(snapshot.get99thPercentile()).thenReturn(10.0);
+    when(snapshot.get999thPercentile()).thenReturn(11.0);
+
+    when(histogram.getSnapshot()).thenReturn(snapshot);
+
+    reporter.report(map(), map(), map(MetricName.build("test.histogram"), histogram), map(), map());
+
+    assertThat(consoleOutput())
+        .isEqualTo(
+            lines(
+                dateHeader,
+                "",
+                "-- Histograms ------------------------------------------------------------------",
+                "test.histogram",
+                "             count = 1",
+                "               sum = 4",
+                "               min = 4",
+                "               max = 2",
+                "              mean = 3.00",
+                "            stddev = 5.00",
+                "            median = 6.00",
+                "              75% <= 7.00",
+                "              95% <= 8.00",
+                "              98% <= 9.00",
+                "              99% <= 10.00",
+                "            99.9% <= 11.00",
+                "",
+                ""));
+  }
+
+  @Test
+  void reportsMeterValues() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(3L);
+    when(meter.getMeanRate()).thenReturn(2.0);
+    when(meter.getOneMinuteRate()).thenReturn(3.0);
+    when(meter.getFiveMinuteRate()).thenReturn(4.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(5.0);
+
+    reporter.report(map(), map(), map(), map(MetricName.build("test.meter"), meter), map());
+
+    assertThat(consoleOutput())
+        .isEqualTo(
+            lines(
+                dateHeader,
+                "",
+                "-- Meters ----------------------------------------------------------------------",
+                "test.meter",
+                "             count = 1",
+                "               sum = 3",
+                "         mean rate = 2.00 events/second",
+                "     1-minute rate = 3.00 events/second",
+                "     5-minute rate = 4.00 events/second",
+                "    15-minute rate = 5.00 events/second",
+                "",
+                ""));
+  }
+
+  @Test
+  void reportsTimerValues() throws Exception {
+    final Timer timer = mock();
+    when(timer.getCount()).thenReturn(1L);
+    when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(5));
+    when(timer.getMeanRate()).thenReturn(2.0);
+    when(timer.getOneMinuteRate()).thenReturn(3.0);
+    when(timer.getFiveMinuteRate()).thenReturn(4.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(5.0);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
+    when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
+    when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
+    when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
+    when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
+    when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
+    when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
+    when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
+    when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
+    when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
+
+    when(timer.getSnapshot()).thenReturn(snapshot);
+
+    reporter.report(map(), map(), map(), map(), map(MetricName.build("test.another.timer"), timer));
+
+    assertThat(consoleOutput())
+        .isEqualTo(
+            lines(
+                dateHeader,
+                "",
+                "-- Timers ----------------------------------------------------------------------",
+                "test.another.timer",
+                "             count = 1",
+                "               sum = 5.00",
+                "         mean rate = 2.00 calls/second",
+                "     1-minute rate = 3.00 calls/second",
+                "     5-minute rate = 4.00 calls/second",
+                "    15-minute rate = 5.00 calls/second",
+                "               min = 300.00 milliseconds",
+                "               max = 100.00 milliseconds",
+                "              mean = 200.00 milliseconds",
+                "            stddev = 400.00 milliseconds",
+                "            median = 500.00 milliseconds",
+                "              75% <= 600.00 milliseconds",
+                "              95% <= 700.00 milliseconds",
+                "              98% <= 800.00 milliseconds",
+                "              99% <= 900.00 milliseconds",
+                "            99.9% <= 1000.00 milliseconds",
+                "",
+                ""));
+  }
+
+  @Test
+  void reportMeterWithDisabledAttributes() throws Exception {
+    Set<MetricAttribute> disabledMetricAttributes =
+        EnumSet.of(
+            MetricAttribute.M15_RATE,
+            MetricAttribute.M5_RATE,
+            MetricAttribute.COUNT,
+            MetricAttribute.SUM);
+
+    final ConsoleReporter customReporter =
+        ConsoleReporter.forRegistry(registry)
             .outputTo(output)
             .formattedFor(locale)
             .withClock(clock)
@@ -36,393 +236,178 @@ class ConsoleReporterTest {
             .convertRatesTo(TimeUnit.SECONDS)
             .convertDurationsTo(TimeUnit.MILLISECONDS)
             .filter(MetricFilter.ALL)
+            .disabledMetricAttributes(disabledMetricAttributes)
             .build();
-    private String dateHeader;
-
-    @BeforeEach
-    void setUp() throws Exception {
-        when(clock.getTime()).thenReturn(1363568676000L);
-        // JDK9 has changed the java.text.DateFormat API implementation according to Unicode.
-        // See http://mail.openjdk.java.net/pipermail/jdk9-dev/2017-April/005732.html
-        dateHeader = SystemUtils.isJavaVersionAtMost(JavaVersion.JAVA_1_8) ?
-                "3/17/13 6:04:36 PM =============================================================" :
-                // https://bugs.openjdk.org/browse/JDK-8304925
-                SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_20) ?
-                "3/17/13, 6:04:36\u202FPM ============================================================" :
-                "3/17/13, 6:04:36 PM ============================================================";
-    }
-
-    @Test
-    void reportsGaugeValues() throws Exception {
-        final Gauge<Integer> gauge = () -> 1;
-
-        reporter.report(map(MetricName.build("gauge"), gauge),
-                map(),
-                map(),
-                map(),
-                map());
-
-        assertThat(consoleOutput())
-                .isEqualTo(lines(
-                        dateHeader,
-                        "",
-                        "-- Gauges ----------------------------------------------------------------------",
-                        "gauge",
-                        "             value = 1",
-                        "",
-                        ""
-                ));
-    }
-
-    @Test
-    void reportsCounterValues() throws Exception {
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(100L);
-
-        reporter.report(map(),
-                map(MetricName.build("test.counter"), counter),
-                map(),
-                map(),
-                map());
-
-        assertThat(consoleOutput())
-                .isEqualTo(lines(
-                        dateHeader,
-                        "",
-                        "-- Counters --------------------------------------------------------------------",
-                        "test.counter",
-                        "             count = 100",
-                        "",
-                        ""
-                ));
-    }
-
-    @Test
-    void reportsHistogramValues() throws Exception {
-        final Histogram histogram = mock(Histogram.class);
-        when(histogram.getCount()).thenReturn(1L);
-        when(histogram.getSum()).thenReturn(4L);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(2L);
-        when(snapshot.getMean()).thenReturn(3.0);
-        when(snapshot.getMin()).thenReturn(4L);
-        when(snapshot.getStdDev()).thenReturn(5.0);
-        when(snapshot.getMedian()).thenReturn(6.0);
-        when(snapshot.get75thPercentile()).thenReturn(7.0);
-        when(snapshot.get95thPercentile()).thenReturn(8.0);
-        when(snapshot.get98thPercentile()).thenReturn(9.0);
-        when(snapshot.get99thPercentile()).thenReturn(10.0);
-        when(snapshot.get999thPercentile()).thenReturn(11.0);
-
-        when(histogram.getSnapshot()).thenReturn(snapshot);
-
-        reporter.report(map(),
-                map(),
-                map(MetricName.build("test.histogram"), histogram),
-                map(),
-                map());
-
-        assertThat(consoleOutput())
-                .isEqualTo(lines(
-                        dateHeader,
-                        "",
-                        "-- Histograms ------------------------------------------------------------------",
-                        "test.histogram",
-                        "             count = 1",
-                        "               sum = 4",
-                        "               min = 4",
-                        "               max = 2",
-                        "              mean = 3.00",
-                        "            stddev = 5.00",
-                        "            median = 6.00",
-                        "              75% <= 7.00",
-                        "              95% <= 8.00",
-                        "              98% <= 9.00",
-                        "              99% <= 10.00",
-                        "            99.9% <= 11.00",
-                        "",
-                        ""
-                ));
-    }
-
-    @Test
-    void reportsMeterValues() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(3L);
-        when(meter.getMeanRate()).thenReturn(2.0);
-        when(meter.getOneMinuteRate()).thenReturn(3.0);
-        when(meter.getFiveMinuteRate()).thenReturn(4.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(5.0);
-
-        reporter.report(map(),
-                map(),
-                map(),
-                map(MetricName.build("test.meter"), meter),
-                map());
-
-        assertThat(consoleOutput())
-                .isEqualTo(lines(
-                        dateHeader,
-                        "",
-                        "-- Meters ----------------------------------------------------------------------",
-                        "test.meter",
-                        "             count = 1",
-                        "               sum = 3",
-                        "         mean rate = 2.00 events/second",
-                        "     1-minute rate = 3.00 events/second",
-                        "     5-minute rate = 4.00 events/second",
-                        "    15-minute rate = 5.00 events/second",
-                        "",
-                        ""
-                ));
-    }
-
-    @Test
-    void reportsTimerValues() throws Exception {
-        final Timer timer = mock(Timer.class);
-        when(timer.getCount()).thenReturn(1L);
-        when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(5));
-        when(timer.getMeanRate()).thenReturn(2.0);
-        when(timer.getOneMinuteRate()).thenReturn(3.0);
-        when(timer.getFiveMinuteRate()).thenReturn(4.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(5.0);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
-        when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
-        when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
-        when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
-        when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
-        when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
-        when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
-        when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
-        when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
-        when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS
-                .toNanos(1000));
-
-        when(timer.getSnapshot()).thenReturn(snapshot);
-
-        reporter.report(map(),
-                map(),
-                map(),
-                map(),
-                map(MetricName.build("test.another.timer"), timer));
-
-        assertThat(consoleOutput())
-                .isEqualTo(lines(
-                        dateHeader,
-                        "",
-                        "-- Timers ----------------------------------------------------------------------",
-                        "test.another.timer",
-                        "             count = 1",
-                        "               sum = 5.00",
-                        "         mean rate = 2.00 calls/second",
-                        "     1-minute rate = 3.00 calls/second",
-                        "     5-minute rate = 4.00 calls/second",
-                        "    15-minute rate = 5.00 calls/second",
-                        "               min = 300.00 milliseconds",
-                        "               max = 100.00 milliseconds",
-                        "              mean = 200.00 milliseconds",
-                        "            stddev = 400.00 milliseconds",
-                        "            median = 500.00 milliseconds",
-                        "              75% <= 600.00 milliseconds",
-                        "              95% <= 700.00 milliseconds",
-                        "              98% <= 800.00 milliseconds",
-                        "              99% <= 900.00 milliseconds",
-                        "            99.9% <= 1000.00 milliseconds",
-                        "",
-                        ""
-                ));
-    }
 
-    @Test
-    void reportMeterWithDisabledAttributes() throws Exception {
-        Set<MetricAttribute> disabledMetricAttributes = EnumSet.of(MetricAttribute.M15_RATE, MetricAttribute.M5_RATE, MetricAttribute.COUNT, MetricAttribute.SUM);
-
-        final ConsoleReporter customReporter = ConsoleReporter.forRegistry(registry)
-                .outputTo(output)
-                .formattedFor(locale)
-                .withClock(clock)
-                .formattedFor(timeZone)
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .filter(MetricFilter.ALL)
-                .disabledMetricAttributes(disabledMetricAttributes)
-                .build();
-
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(5L);
-        when(meter.getMeanRate()).thenReturn(2.0);
-        when(meter.getOneMinuteRate()).thenReturn(3.0);
-        when(meter.getFiveMinuteRate()).thenReturn(4.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(5.0);
-
-        customReporter.report(map(),
-                map(),
-                map(),
-                map(MetricName.build("test.meter"), meter),
-                map());
-
-        assertThat(consoleOutput())
-                .isEqualTo(lines(
-                        dateHeader,
-                        "",
-                        "-- Meters ----------------------------------------------------------------------",
-                        "test.meter",
-                        "         mean rate = 2.00 events/second",
-                        "     1-minute rate = 3.00 events/second",
-                        "",
-                        ""
-                ));
-    }
-
-    @Test
-    void reportTimerWithDisabledAttributes() throws Exception {
-        Set<MetricAttribute> disabledMetricAttributes = EnumSet.of(MetricAttribute.P50, MetricAttribute.P999, MetricAttribute.M5_RATE, MetricAttribute.MAX);
-
-        final ConsoleReporter customReporter = ConsoleReporter.forRegistry(registry)
-                .outputTo(output)
-                .formattedFor(locale)
-                .withClock(clock)
-                .formattedFor(timeZone)
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .filter(MetricFilter.ALL)
-                .disabledMetricAttributes(disabledMetricAttributes)
-                .build();
-
-        final Timer timer = mock(Timer.class);
-        when(timer.getCount()).thenReturn(1L);
-        when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(6));
-        when(timer.getMeanRate()).thenReturn(2.0);
-        when(timer.getOneMinuteRate()).thenReturn(3.0);
-        when(timer.getFiveMinuteRate()).thenReturn(4.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(5.0);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
-        when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
-        when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
-        when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
-        when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
-        when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
-        when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
-        when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
-        when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
-        when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS
-                .toNanos(1000));
-
-        when(timer.getSnapshot()).thenReturn(snapshot);
-
-        customReporter.report(map(),
-                map(),
-                map(),
-                map(),
-                map(MetricName.build("test.another.timer"), timer));
-
-        assertThat(consoleOutput())
-                .isEqualTo(lines(
-                        dateHeader,
-                        "",
-                        "-- Timers ----------------------------------------------------------------------",
-                        "test.another.timer",
-                        "             count = 1",
-                        "               sum = 6.00",
-                        "         mean rate = 2.00 calls/second",
-                        "     1-minute rate = 3.00 calls/second",
-                        "    15-minute rate = 5.00 calls/second",
-                        "               min = 300.00 milliseconds",
-                        "              mean = 200.00 milliseconds",
-                        "            stddev = 400.00 milliseconds",
-                        "              75% <= 600.00 milliseconds",
-                        "              95% <= 700.00 milliseconds",
-                        "              98% <= 800.00 milliseconds",
-                        "              99% <= 900.00 milliseconds",
-                        "",
-                        ""
-                ));
-    }
-
-    @Test
-    void reportHistogramWithDisabledAttributes() throws Exception {
-        Set<MetricAttribute> disabledMetricAttributes = EnumSet.of(MetricAttribute.MIN, MetricAttribute.MAX, MetricAttribute.STDDEV, MetricAttribute.P95);
-
-        final ConsoleReporter customReporter = ConsoleReporter.forRegistry(registry)
-                .outputTo(output)
-                .formattedFor(locale)
-                .withClock(clock)
-                .formattedFor(timeZone)
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .filter(MetricFilter.ALL)
-                .disabledMetricAttributes(disabledMetricAttributes)
-                .build();
-
-        final Histogram histogram = mock(Histogram.class);
-        when(histogram.getCount()).thenReturn(1L);
-        when(histogram.getSum()).thenReturn(5L);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(2L);
-        when(snapshot.getMean()).thenReturn(3.0);
-        when(snapshot.getMin()).thenReturn(4L);
-        when(snapshot.getStdDev()).thenReturn(5.0);
-        when(snapshot.getMedian()).thenReturn(6.0);
-        when(snapshot.get75thPercentile()).thenReturn(7.0);
-        when(snapshot.get95thPercentile()).thenReturn(8.0);
-        when(snapshot.get98thPercentile()).thenReturn(9.0);
-        when(snapshot.get99thPercentile()).thenReturn(10.0);
-        when(snapshot.get999thPercentile()).thenReturn(11.0);
-
-        when(histogram.getSnapshot()).thenReturn(snapshot);
-
-        customReporter.report(map(),
-                map(),
-                map(MetricName.build("test.histogram"), histogram),
-                map(),
-                map());
-
-        assertThat(consoleOutput())
-                .isEqualTo(lines(
-                        dateHeader,
-                        "",
-                        "-- Histograms ------------------------------------------------------------------",
-                        "test.histogram",
-                        "             count = 1",
-                        "               sum = 5",
-                        "              mean = 3.00",
-                        "            median = 6.00",
-                        "              75% <= 7.00",
-                        "              98% <= 9.00",
-                        "              99% <= 10.00",
-                        "            99.9% <= 11.00",
-                        "",
-                        ""
-                ));
-    }
-
-    private String lines(String... lines) {
-        final StringBuilder builder = new StringBuilder();
-        for (String line : lines) {
-            builder.append(line).append(String.format("%n"));
-        }
-        return builder.toString();
-    }
-
-    private String consoleOutput() throws UnsupportedEncodingException {
-        return bytes.toString("UTF-8");
-    }
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(5L);
+    when(meter.getMeanRate()).thenReturn(2.0);
+    when(meter.getOneMinuteRate()).thenReturn(3.0);
+    when(meter.getFiveMinuteRate()).thenReturn(4.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(5.0);
+
+    customReporter.report(map(), map(), map(), map(MetricName.build("test.meter"), meter), map());
+
+    assertThat(consoleOutput())
+        .isEqualTo(
+            lines(
+                dateHeader,
+                "",
+                "-- Meters ----------------------------------------------------------------------",
+                "test.meter",
+                "         mean rate = 2.00 events/second",
+                "     1-minute rate = 3.00 events/second",
+                "",
+                ""));
+  }
+
+  @Test
+  void reportTimerWithDisabledAttributes() throws Exception {
+    Set<MetricAttribute> disabledMetricAttributes =
+        EnumSet.of(
+            MetricAttribute.P50,
+            MetricAttribute.P999,
+            MetricAttribute.M5_RATE,
+            MetricAttribute.MAX);
+
+    final ConsoleReporter customReporter =
+        ConsoleReporter.forRegistry(registry)
+            .outputTo(output)
+            .formattedFor(locale)
+            .withClock(clock)
+            .formattedFor(timeZone)
+            .convertRatesTo(TimeUnit.SECONDS)
+            .convertDurationsTo(TimeUnit.MILLISECONDS)
+            .filter(MetricFilter.ALL)
+            .disabledMetricAttributes(disabledMetricAttributes)
+            .build();
 
-    private <T> SortedMap<MetricName, T> map() {
-        return new TreeMap<>();
-    }
+    final Timer timer = mock();
+    when(timer.getCount()).thenReturn(1L);
+    when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(6));
+    when(timer.getMeanRate()).thenReturn(2.0);
+    when(timer.getOneMinuteRate()).thenReturn(3.0);
+    when(timer.getFiveMinuteRate()).thenReturn(4.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(5.0);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
+    when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
+    when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
+    when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
+    when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
+    when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
+    when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
+    when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
+    when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
+    when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
+
+    when(timer.getSnapshot()).thenReturn(snapshot);
+
+    customReporter.report(
+        map(), map(), map(), map(), map(MetricName.build("test.another.timer"), timer));
+
+    assertThat(consoleOutput())
+        .isEqualTo(
+            lines(
+                dateHeader,
+                "",
+                "-- Timers ----------------------------------------------------------------------",
+                "test.another.timer",
+                "             count = 1",
+                "               sum = 6.00",
+                "         mean rate = 2.00 calls/second",
+                "     1-minute rate = 3.00 calls/second",
+                "    15-minute rate = 5.00 calls/second",
+                "               min = 300.00 milliseconds",
+                "              mean = 200.00 milliseconds",
+                "            stddev = 400.00 milliseconds",
+                "              75% <= 600.00 milliseconds",
+                "              95% <= 700.00 milliseconds",
+                "              98% <= 800.00 milliseconds",
+                "              99% <= 900.00 milliseconds",
+                "",
+                ""));
+  }
+
+  @Test
+  void reportHistogramWithDisabledAttributes() throws Exception {
+    Set<MetricAttribute> disabledMetricAttributes =
+        EnumSet.of(
+            MetricAttribute.MIN, MetricAttribute.MAX, MetricAttribute.STDDEV, MetricAttribute.P95);
+
+    final ConsoleReporter customReporter =
+        ConsoleReporter.forRegistry(registry)
+            .outputTo(output)
+            .formattedFor(locale)
+            .withClock(clock)
+            .formattedFor(timeZone)
+            .convertRatesTo(TimeUnit.SECONDS)
+            .convertDurationsTo(TimeUnit.MILLISECONDS)
+            .filter(MetricFilter.ALL)
+            .disabledMetricAttributes(disabledMetricAttributes)
+            .build();
 
-    private <T> SortedMap<MetricName, T> map(MetricName name, T metric) {
-        final TreeMap<MetricName, T> map = new TreeMap<>();
-        map.put(name, metric);
-        return map;
+    final Histogram histogram = mock();
+    when(histogram.getCount()).thenReturn(1L);
+    when(histogram.getSum()).thenReturn(5L);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(2L);
+    when(snapshot.getMean()).thenReturn(3.0);
+    when(snapshot.getMin()).thenReturn(4L);
+    when(snapshot.getStdDev()).thenReturn(5.0);
+    when(snapshot.getMedian()).thenReturn(6.0);
+    when(snapshot.get75thPercentile()).thenReturn(7.0);
+    when(snapshot.get95thPercentile()).thenReturn(8.0);
+    when(snapshot.get98thPercentile()).thenReturn(9.0);
+    when(snapshot.get99thPercentile()).thenReturn(10.0);
+    when(snapshot.get999thPercentile()).thenReturn(11.0);
+
+    when(histogram.getSnapshot()).thenReturn(snapshot);
+
+    customReporter.report(
+        map(), map(), map(MetricName.build("test.histogram"), histogram), map(), map());
+
+    assertThat(consoleOutput())
+        .isEqualTo(
+            lines(
+                dateHeader,
+                "",
+                "-- Histograms ------------------------------------------------------------------",
+                "test.histogram",
+                "             count = 1",
+                "               sum = 5",
+                "              mean = 3.00",
+                "            median = 6.00",
+                "              75% <= 7.00",
+                "              98% <= 9.00",
+                "              99% <= 10.00",
+                "            99.9% <= 11.00",
+                "",
+                ""));
+  }
+
+  private String lines(String... lines) {
+    final StringBuilder builder = new StringBuilder();
+    for (String line : lines) {
+      builder.append(line).append(String.format("%n"));
     }
+    return builder.toString();
+  }
+
+  private String consoleOutput() throws UnsupportedEncodingException {
+    return bytes.toString("UTF-8");
+  }
+
+  private <T> SortedMap<MetricName, T> map() {
+    return new TreeMap<>();
+  }
+
+  private <T> SortedMap<MetricName, T> map(MetricName name, T metric) {
+    final TreeMap<MetricName, T> map = new TreeMap<>();
+    map.put(name, metric);
+    return map;
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/CounterTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/CounterTest.java
@@ -1,63 +1,56 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class CounterTest {
-    private final Counter counter = new Counter();
+import org.junit.jupiter.api.Test;
+
+final class CounterTest {
+  private final Counter counter = new Counter();
 
-    @Test
-    void startsAtZero() {
-        assertThat(counter.getCount())
-                .isZero();
-    }
+  @Test
+  void startsAtZero() {
+    assertThat(counter.getCount()).isEqualTo(0);
+  }
 
-    @Test
-    void incrementsByOne() {
-        counter.inc();
+  @Test
+  void incrementsByOne() {
+    counter.inc();
 
-        assertThat(counter.getCount())
-                .isEqualTo(1);
-    }
+    assertThat(counter.getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void incrementsByAnArbitraryDelta() {
-        counter.inc(12);
+  @Test
+  void incrementsByAnArbitraryDelta() {
+    counter.inc(12);
 
-        assertThat(counter.getCount())
-                .isEqualTo(12);
-    }
+    assertThat(counter.getCount()).isEqualTo(12);
+  }
 
-    @Test
-    void decrementsByOne() {
-        counter.dec();
+  @Test
+  void decrementsByOne() {
+    counter.dec();
 
-        assertThat(counter.getCount())
-                .isEqualTo(-1);
-    }
+    assertThat(counter.getCount()).isEqualTo(-1);
+  }
 
-    @Test
-    void decrementsByAnArbitraryDelta() {
-        counter.dec(12);
+  @Test
+  void decrementsByAnArbitraryDelta() {
+    counter.dec(12);
 
-        assertThat(counter.getCount())
-                .isEqualTo(-12);
-    }
+    assertThat(counter.getCount()).isEqualTo(-12);
+  }
 
-    @Test
-    void incrementByNegativeDelta() {
-        counter.inc(-12);
+  @Test
+  void incrementByNegativeDelta() {
+    counter.inc(-12);
 
-        assertThat(counter.getCount())
-                .isEqualTo(-12);
-    }
+    assertThat(counter.getCount()).isEqualTo(-12);
+  }
 
-    @Test
-    void decrementByNegativeDelta() {
-        counter.dec(-12);
+  @Test
+  void decrementByNegativeDelta() {
+    counter.dec(-12);
 
-        assertThat(counter.getCount())
-                .isEqualTo(12);
-    }
+    assertThat(counter.getCount()).isEqualTo(12);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/CsvReporterTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/CsvReporterTest.java
@@ -1,257 +1,222 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.io.TempDir;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 import java.io.File;
 import java.io.IOException;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.util.Locale;
 import java.util.SortedMap;
 import java.util.TreeMap;
 import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-public class CsvReporterTest {
-    @TempDir
-    public File folder;
-
-    private final MetricRegistry registry = mock(MetricRegistry.class);
-    private final Clock clock = mock(Clock.class);
-
-    private File dataDirectory;
-    private CsvReporter reporter;
-
-    @BeforeEach
-    void setUp() throws Exception {
-        when(clock.getTime()).thenReturn(19910191000L);
-
-        this.dataDirectory = newFolder(folder, "junit");
-
-        this.reporter = CsvReporter.forRegistry(registry)
-                .formatFor(Locale.US)
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .withClock(clock)
-                .filter(MetricFilter.ALL)
-                .build(dataDirectory);
-    }
-
-    @Test
-    void reportsGaugeValues() throws Exception {
-        final Gauge<Integer> gauge = () -> 1;
-
-        reporter.report(map(MetricName.build("gauge"), gauge),
-                map(),
-                map(),
-                map(),
-                map());
-
-        assertThat(fileContents("gauge.csv"))
-                .isEqualTo(csv(
-                        "t,value",
-                        "19910191,1"
-                ));
-    }
-
-    @Test
-    void reportsCounterValues() throws Exception {
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(100L);
-
-        reporter.report(map(),
-                map(MetricName.build("test.counter"), counter),
-                map(),
-                map(),
-                map());
-
-        assertThat(fileContents("test.counter.csv"))
-                .isEqualTo(csv(
-                        "t,count",
-                        "19910191,100"
-                ));
-    }
-
-    @Test
-    void reportsHistogramValues() throws Exception {
-        final Histogram histogram = mock(Histogram.class);
-        when(histogram.getCount()).thenReturn(1L);
-        when(histogram.getSum()).thenReturn(12L);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(2L);
-        when(snapshot.getMean()).thenReturn(3.0);
-        when(snapshot.getMin()).thenReturn(4L);
-        when(snapshot.getStdDev()).thenReturn(5.0);
-        when(snapshot.getMedian()).thenReturn(6.0);
-        when(snapshot.get75thPercentile()).thenReturn(7.0);
-        when(snapshot.get95thPercentile()).thenReturn(8.0);
-        when(snapshot.get98thPercentile()).thenReturn(9.0);
-        when(snapshot.get99thPercentile()).thenReturn(10.0);
-        when(snapshot.get999thPercentile()).thenReturn(11.0);
-
-        when(histogram.getSnapshot()).thenReturn(snapshot);
-
-        reporter.report(map(),
-                map(),
-                map(MetricName.build("test.histogram"), histogram),
-                map(),
-                map());
-
-        assertThat(fileContents("test.histogram.csv"))
-                .isEqualTo(csv(
-                        "t,count,sum,max,mean,min,stddev,p50,p75,p95,p98,p99,p999",
-                        "19910191,1,12,2,3.000000,4,5.000000,6.000000,7.000000,8.000000,9.000000,10.000000,11.000000"
-                ));
-    }
-
-    @Test
-    void reportsMeterValues() throws Exception {
-        final Meter meter = mockMeter();
-
-        reporter.report(map(),
-                map(),
-                map(),
-                map(MetricName.build("test.meter"), meter),
-                map());
-
-        assertThat(fileContents("test.meter.csv"))
-                .isEqualTo(csv(
-                        "t,count,sum,mean_rate,m1_rate,m5_rate,m15_rate,rate_unit",
-                        "19910191,1,6,2.000000,3.000000,4.000000,5.000000,events/second"
-                ));
-    }
-
-    @Test
-    void reportsTimerValues() throws Exception {
-        final Timer timer = mock(Timer.class);
-        when(timer.getCount()).thenReturn(1L);
-        when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(6));
-        when(timer.getMeanRate()).thenReturn(2.0);
-        when(timer.getOneMinuteRate()).thenReturn(3.0);
-        when(timer.getFiveMinuteRate()).thenReturn(4.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(5.0);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
-        when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
-        when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
-        when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
-        when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
-        when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
-        when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
-        when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
-        when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
-        when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
-
-        when(timer.getSnapshot()).thenReturn(snapshot);
-
-        reporter.report(map(),
-                map(),
-                map(),
-                map(),
-                map(MetricName.build("test.another.timer"), timer));
-
-        assertThat(fileContents("test.another.timer.csv"))
-                .isEqualTo(csv(
-                        "t,count,sum,max,mean,min,stddev,p50,p75,p95,p98,p99,p999,mean_rate,m1_rate,m5_rate,m15_rate,rate_unit,duration_unit",
-                        "19910191,1,6.000000,100.000000,200.000000,300.000000,400.000000,500.000000,600.000000,700.000000,800.000000,900.000000,1000.000000,2.000000,3.000000,4.000000,5.000000,calls/second,milliseconds"
-                ));
-    }
-
-    @Test
-    void testCsvFileProviderIsUsed() {
-        CsvFileProvider fileProvider = mock(CsvFileProvider.class);
-        when(fileProvider.getFile(dataDirectory, "gauge")).thenReturn(new File(dataDirectory, "guage.csv"));
-
-        CsvReporter reporter = CsvReporter.forRegistry(registry)
-                .withCsvFileProvider(fileProvider)
-                .build(dataDirectory);
-
-        final Gauge<Integer> gauge = () -> 1;
-
-        reporter.report(map(MetricName.build("gauge"), gauge),
-                map(),
-                map(),
-                map(),
-                map());
-
-        verify(fileProvider).getFile(dataDirectory, "gauge");
-    }
-
-    @Test
-    void itFormatsWithCustomSeparator() throws Exception {
-        final Meter meter = mockMeter();
-
-        CsvReporter customSeparatorReporter = CsvReporter.forRegistry(registry)
-                .formatFor(Locale.US)
-                .withSeparator("|")
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .withClock(clock)
-                .filter(MetricFilter.ALL)
-                .build(dataDirectory);
-
-        customSeparatorReporter.report(map(),
-                map(),
-                map(),
-                map(MetricName.build("test.meter"), meter),
-                map());
-
-        assertThat(fileContents("test.meter.csv"))
-                .isEqualTo(csv(
-                        "t|count|sum|mean_rate|m1_rate|m5_rate|m15_rate|rate_unit",
-                        "19910191|1|6|2.000000|3.000000|4.000000|5.000000|events/second"
-                ));
-    }
-
-    private Meter mockMeter() {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(6L);
-        when(meter.getMeanRate()).thenReturn(2.0);
-        when(meter.getOneMinuteRate()).thenReturn(3.0);
-        when(meter.getFiveMinuteRate()).thenReturn(4.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(5.0);
-
-        return meter;
-    }
-
-    private String csv(String... lines) {
-        final StringBuilder builder = new StringBuilder();
-        for (String line : lines) {
-            builder.append(line).append(String.format("%n"));
-        }
-        return builder.toString();
-    }
-
-    @SuppressWarnings("FilesReadStringWithCharset")
-    private String fileContents(String filename) throws IOException {
-        return new String(Files.readAllBytes(new File(dataDirectory, filename).toPath()), StandardCharsets.UTF_8);
-    }
-
-    private <T> SortedMap<MetricName, T> map() {
-        return new TreeMap<>();
-    }
-
-    private <T> SortedMap<MetricName, T> map(MetricName name, T metric) {
-        final TreeMap<MetricName, T> map = new TreeMap<>();
-        map.put(name, metric);
-        return map;
+final class CsvReporterTest {
+  @TempDir public File folder;
+
+  private final MetricRegistry registry = mock();
+  private final Clock clock = mock();
+
+  private File dataDirectory;
+  private CsvReporter reporter;
+
+  @BeforeEach
+  void setUp() throws Exception {
+    when(clock.getTime()).thenReturn(19910191000L);
+
+    this.dataDirectory = newFolder(folder, "junit");
+
+    this.reporter =
+        CsvReporter.forRegistry(registry)
+            .formatFor(Locale.US)
+            .convertRatesTo(TimeUnit.SECONDS)
+            .convertDurationsTo(TimeUnit.MILLISECONDS)
+            .withClock(clock)
+            .filter(MetricFilter.ALL)
+            .build(dataDirectory);
+  }
+
+  @Test
+  void reportsGaugeValues() throws Exception {
+    final Gauge<Integer> gauge = () -> 1;
+
+    reporter.report(map(MetricName.build("gauge"), gauge), map(), map(), map(), map());
+
+    assertThat(fileContents("gauge.csv")).isEqualTo(csv("t,value", "19910191,1"));
+  }
+
+  @Test
+  void reportsCounterValues() throws Exception {
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(100L);
+
+    reporter.report(map(), map(MetricName.build("test.counter"), counter), map(), map(), map());
+
+    assertThat(fileContents("test.counter.csv")).isEqualTo(csv("t,count", "19910191,100"));
+  }
+
+  @Test
+  void reportsHistogramValues() throws Exception {
+    final Histogram histogram = mock();
+    when(histogram.getCount()).thenReturn(1L);
+    when(histogram.getSum()).thenReturn(12L);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(2L);
+    when(snapshot.getMean()).thenReturn(3.0);
+    when(snapshot.getMin()).thenReturn(4L);
+    when(snapshot.getStdDev()).thenReturn(5.0);
+    when(snapshot.getMedian()).thenReturn(6.0);
+    when(snapshot.get75thPercentile()).thenReturn(7.0);
+    when(snapshot.get95thPercentile()).thenReturn(8.0);
+    when(snapshot.get98thPercentile()).thenReturn(9.0);
+    when(snapshot.get99thPercentile()).thenReturn(10.0);
+    when(snapshot.get999thPercentile()).thenReturn(11.0);
+
+    when(histogram.getSnapshot()).thenReturn(snapshot);
+
+    reporter.report(map(), map(), map(MetricName.build("test.histogram"), histogram), map(), map());
+
+    assertThat(fileContents("test.histogram.csv"))
+        .isEqualTo(
+            csv(
+                "t,count,sum,max,mean,min,stddev,p50,p75,p95,p98,p99,p999",
+                "19910191,1,12,2,3.000000,4,5.000000,6.000000,7.000000,8.000000,9.000000,10.000000,11.000000"));
+  }
+
+  @Test
+  void reportsMeterValues() throws Exception {
+    final Meter meter = mockMeter();
+
+    reporter.report(map(), map(), map(), map(MetricName.build("test.meter"), meter), map());
+
+    assertThat(fileContents("test.meter.csv"))
+        .isEqualTo(
+            csv(
+                "t,count,sum,mean_rate,m1_rate,m5_rate,m15_rate,rate_unit",
+                "19910191,1,6,2.000000,3.000000,4.000000,5.000000,events/second"));
+  }
+
+  @Test
+  void reportsTimerValues() throws Exception {
+    final Timer timer = mock();
+    when(timer.getCount()).thenReturn(1L);
+    when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(6));
+    when(timer.getMeanRate()).thenReturn(2.0);
+    when(timer.getOneMinuteRate()).thenReturn(3.0);
+    when(timer.getFiveMinuteRate()).thenReturn(4.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(5.0);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
+    when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
+    when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
+    when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
+    when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
+    when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
+    when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
+    when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
+    when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
+    when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
+
+    when(timer.getSnapshot()).thenReturn(snapshot);
+
+    reporter.report(map(), map(), map(), map(), map(MetricName.build("test.another.timer"), timer));
+
+    assertThat(fileContents("test.another.timer.csv"))
+        .isEqualTo(
+            csv(
+                "t,count,sum,max,mean,min,stddev,p50,p75,p95,p98,p99,p999,mean_rate,m1_rate,m5_rate,m15_rate,rate_unit,duration_unit",
+                "19910191,1,6.000000,100.000000,200.000000,300.000000,400.000000,500.000000,600.000000,700.000000,800.000000,900.000000,1000.000000,2.000000,3.000000,4.000000,5.000000,calls/second,milliseconds"));
+  }
+
+  @Test
+  void csvFileProviderIsUsed() {
+    CsvFileProvider fileProvider = mock();
+    when(fileProvider.getFile(dataDirectory, "gauge"))
+        .thenReturn(new File(dataDirectory, "guage.csv"));
+
+    CsvReporter reporter =
+        CsvReporter.forRegistry(registry).withCsvFileProvider(fileProvider).build(dataDirectory);
+
+    final Gauge<Integer> gauge = () -> 1;
+
+    reporter.report(map(MetricName.build("gauge"), gauge), map(), map(), map(), map());
+
+    verify(fileProvider).getFile(dataDirectory, "gauge");
+  }
+
+  @Test
+  void itFormatsWithCustomSeparator() throws Exception {
+    final Meter meter = mockMeter();
+
+    CsvReporter customSeparatorReporter =
+        CsvReporter.forRegistry(registry)
+            .formatFor(Locale.US)
+            .withSeparator("|")
+            .convertRatesTo(TimeUnit.SECONDS)
+            .convertDurationsTo(TimeUnit.MILLISECONDS)
+            .withClock(clock)
+            .filter(MetricFilter.ALL)
+            .build(dataDirectory);
+
+    customSeparatorReporter.report(
+        map(), map(), map(), map(MetricName.build("test.meter"), meter), map());
+
+    assertThat(fileContents("test.meter.csv"))
+        .isEqualTo(
+            csv(
+                "t|count|sum|mean_rate|m1_rate|m5_rate|m15_rate|rate_unit",
+                "19910191|1|6|2.000000|3.000000|4.000000|5.000000|events/second"));
+  }
+
+  private Meter mockMeter() {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(6L);
+    when(meter.getMeanRate()).thenReturn(2.0);
+    when(meter.getOneMinuteRate()).thenReturn(3.0);
+    when(meter.getFiveMinuteRate()).thenReturn(4.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(5.0);
+
+    return meter;
+  }
+
+  private String csv(String... lines) {
+    final StringBuilder builder = new StringBuilder();
+    for (String line : lines) {
+      builder.append(line).append(String.format("%n"));
     }
-
-    private static File newFolder(File root, String... subDirs) throws IOException {
-        String subFolder = String.join("/", subDirs);
-        File result = new File(root, subFolder);
-        if (!result.mkdirs()) {
-            throw new IOException("Couldn't create folders " + root);
-        }
-        return result;
+    return builder.toString();
+  }
+
+  @SuppressWarnings("FilesReadStringWithCharset")
+  private String fileContents(String filename) throws IOException {
+    return new String(Files.readAllBytes(new File(dataDirectory, filename).toPath()), UTF_8);
+  }
+
+  private <T> SortedMap<MetricName, T> map() {
+    return new TreeMap<>();
+  }
+
+  private <T> SortedMap<MetricName, T> map(MetricName name, T metric) {
+    final TreeMap<MetricName, T> map = new TreeMap<>();
+    map.put(name, metric);
+    return map;
+  }
+
+  private static File newFolder(File root, String... subDirs) throws IOException {
+    String subFolder = String.join("/", subDirs);
+    File result = new File(root, subFolder);
+    if (!result.mkdirs()) {
+      throw new IOException("Couldn't create folders " + root);
     }
+    return result;
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/DefaultSettableGaugeTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/DefaultSettableGaugeTest.java
@@ -1,26 +1,26 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class DefaultSettableGaugeTest {
-    @Test
-    void newSettableGaugeWithoutDefaultReturnsNull() {
-        DefaultSettableGauge<String> gauge = new DefaultSettableGauge<>();
-        assertThat(gauge.getValue()).isNull();
-    }
+import org.junit.jupiter.api.Test;
+
+final class DefaultSettableGaugeTest {
+  @Test
+  void newSettableGaugeWithoutDefaultReturnsNull() {
+    DefaultSettableGauge<String> gauge = new DefaultSettableGauge<>();
+    assertThat(gauge.getValue()).isNull();
+  }
 
-    @Test
-    void newSettableGaugeWithDefaultReturnsDefault() {
-        DefaultSettableGauge<String> gauge = new DefaultSettableGauge<>("default");
-        assertThat(gauge.getValue()).isEqualTo("default");
-    }
+  @Test
+  void newSettableGaugeWithDefaultReturnsDefault() {
+    DefaultSettableGauge<String> gauge = new DefaultSettableGauge<>("default");
+    assertThat(gauge.getValue()).isEqualTo("default");
+  }
 
-    @Test
-    void setValueOverwritesExistingValue() {
-        DefaultSettableGauge<String> gauge = new DefaultSettableGauge<>("default");
-        gauge.setValue("test");
-        assertThat(gauge.getValue()).isEqualTo("test");
-    }
+  @Test
+  void setValueOverwritesExistingValue() {
+    DefaultSettableGauge<String> gauge = new DefaultSettableGauge<>("default");
+    gauge.setValue("test");
+    assertThat(gauge.getValue()).isEqualTo("test");
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/DerivativeGaugeTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/DerivativeGaugeTest.java
@@ -1,21 +1,21 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class DerivativeGaugeTest {
-    private final Gauge<String> gauge1 = () -> "woo";
-    private final Gauge<Integer> gauge2 = new DerivativeGauge<String, Integer>(gauge1) {
+import org.junit.jupiter.api.Test;
+
+final class DerivativeGaugeTest {
+  private final Gauge<String> gauge1 = () -> "woo";
+  private final Gauge<Integer> gauge2 =
+      new DerivativeGauge<String, Integer>(gauge1) {
         @Override
         protected Integer transform(String value) {
-            return value.length();
+          return value.length();
         }
-    };
+      };
 
-    @Test
-    void returnsATransformedValue() {
-        assertThat(gauge2.getValue())
-                .isEqualTo(3);
-    }
+  @Test
+  void returnsATransformedValue() {
+    assertThat(gauge2.getValue()).isEqualTo(3);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/EWMATest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/EWMATest.java
@@ -1,224 +1,222 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
-import java.util.concurrent.TimeUnit;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.offset;
 
-class EWMATest {
-    @Test
-    void aOneMinuteEWMAWithAValueOfThree() {
-        final EWMA ewma = EWMA.oneMinuteEWMA();
-        ewma.update(3);
-        ewma.tick();
+import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.Test;
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.6, offset(0.000001));
+final class EWMATest {
+  @Test
+  void aOneMinuteEWMAWithAValueOfThree() {
+    final EWMA ewma = EWMA.oneMinuteEWMA();
+    ewma.update(3);
+    ewma.tick();
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.6, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.22072766, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.22072766, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.08120117, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.08120117, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.02987224, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.02987224, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.01098938, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.01098938, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00404277, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00404277, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00148725, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00148725, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00054713, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00054713, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00020128, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00020128, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00007405, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00007405, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00002724, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00002724, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00001002, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00001002, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00000369, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00000369, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00000136, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00000136, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00000050, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00000050, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.00000018, offset(0.000001));
-    }
+    elapseMinute(ewma);
 
-    @Test
-    void aFiveMinuteEWMAWithAValueOfThree() {
-        final EWMA ewma = EWMA.fiveMinuteEWMA();
-        ewma.update(3);
-        ewma.tick();
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.00000018, offset(0.000001));
+  }
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.6, offset(0.000001));
+  @Test
+  void aFiveMinuteEWMAWithAValueOfThree() {
+    final EWMA ewma = EWMA.fiveMinuteEWMA();
+    ewma.update(3);
+    ewma.tick();
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.6, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.49123845, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.49123845, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.40219203, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.40219203, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.32928698, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.32928698, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.26959738, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.26959738, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.22072766, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.22072766, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.18071653, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.18071653, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.14795818, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.14795818, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.12113791, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.12113791, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.09917933, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.09917933, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.08120117, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.08120117, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.06648190, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.06648190, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.05443077, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.05443077, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.04456415, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.04456415, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.03648604, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.03648604, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.02987224, offset(0.000001));
-    }
+    elapseMinute(ewma);
 
-    @Test
-    void aFifteenMinuteEWMAWithAValueOfThree() {
-        final EWMA ewma = EWMA.fifteenMinuteEWMA();
-        ewma.update(3);
-        ewma.tick();
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.02987224, offset(0.000001));
+  }
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.6, offset(0.000001));
+  @Test
+  void aFifteenMinuteEWMAWithAValueOfThree() {
+    final EWMA ewma = EWMA.fifteenMinuteEWMA();
+    ewma.update(3);
+    ewma.tick();
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.6, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.56130419, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.56130419, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.52510399, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.52510399, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.49123845, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.49123845, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.45955700, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.45955700, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.42991879, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.42991879, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.40219203, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.40219203, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.37625345, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.37625345, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.35198773, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.35198773, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.32928698, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.32928698, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.30805027, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.30805027, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.28818318, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.28818318, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.26959738, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.26959738, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.25221023, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.25221023, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.23594443, offset(0.000001));
+    elapseMinute(ewma);
 
-        elapseMinute(ewma);
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.23594443, offset(0.000001));
 
-        assertThat(ewma.getRate(TimeUnit.SECONDS)).isEqualTo(0.22072766, offset(0.000001));
-    }
+    elapseMinute(ewma);
 
+    assertThat(ewma.getRate(TimeUnit.SECONDS)).isCloseTo(0.22072766, offset(0.000001));
+  }
 
-    private void elapseMinute(EWMA ewma) {
-        for (int i = 1; i <= 12; i++) {
-            ewma.tick();
-        }
+  private void elapseMinute(EWMA ewma) {
+    for (int i = 1; i <= 12; i++) {
+      ewma.tick();
     }
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/ExponentialMovingAveragesTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/ExponentialMovingAveragesTest.java
@@ -1,24 +1,23 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
-import java.util.concurrent.TimeUnit;
-
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-public class ExponentialMovingAveragesTest {
-    @Test
-    public void testMaxTicks() {
-        final Clock clock = mock(Clock.class);
-        when(clock.getTick()).thenReturn(0L, Long.MAX_VALUE);
-        final ExponentialMovingAverages ema = new ExponentialMovingAverages(clock);
-        ema.update(Long.MAX_VALUE);
-        ema.tickIfNecessary();
-        final long secondNanos = TimeUnit.SECONDS.toNanos(1);
-        assertEquals(ema.getM1Rate(), Double.MIN_NORMAL * secondNanos, 0.0);
-        assertEquals(ema.getM5Rate(), Double.MIN_NORMAL * secondNanos, 0.0);
-        assertEquals(ema.getM15Rate(), Double.MIN_NORMAL * secondNanos, 0.0);
-    }
+import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.Test;
+
+final class ExponentialMovingAveragesTest {
+  @Test
+  void maxTicks() {
+    final Clock clock = mock();
+    when(clock.getTick()).thenReturn(0L, Long.MAX_VALUE);
+    final ExponentialMovingAverages ema = new ExponentialMovingAverages(clock);
+    ema.update(Long.MAX_VALUE);
+    ema.tickIfNecessary();
+    final long secondNanos = TimeUnit.SECONDS.toNanos(1);
+    assertEquals(ema.getM1Rate(), Double.MIN_NORMAL * secondNanos, 0.0);
+    assertEquals(ema.getM5Rate(), Double.MIN_NORMAL * secondNanos, 0.0);
+    assertEquals(ema.getM15Rate(), Double.MIN_NORMAL * secondNanos, 0.0);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/ExponentiallyDecayingReservoirTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/ExponentiallyDecayingReservoirTest.java
@@ -1,437 +1,405 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.MethodSource;
+import static com.google.common.collect.ImmutableList.toImmutableList;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.stream.Collectors;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
-public class ExponentiallyDecayingReservoirTest {
+final class ExponentiallyDecayingReservoirTest {
 
-    public enum ReservoirFactory {
-        EXPONENTIALLY_DECAYING() {
-        @Override
-        Reservoir create(int size, double alpha, Clock clock) {
-            return new ExponentiallyDecayingReservoir(size, alpha, clock);
-        }
+  public enum ReservoirFactory {
+    EXPONENTIALLY_DECAYING() {
+      @Override
+      Reservoir create(int size, double alpha, Clock clock) {
+        return new ExponentiallyDecayingReservoir(size, alpha, clock);
+      }
     },
 
-        LOCK_FREE_EXPONENTIALLY_DECAYING() {
-            @Override
-            Reservoir create(int size, double alpha, Clock clock) {
-                return LockFreeExponentiallyDecayingReservoir.builder()
-                        .size(size)
-                        .alpha(alpha)
-                        .clock(clock)
-                        .build();
-            }
-        };
-
-        abstract Reservoir create(int size, double alpha, Clock clock);
-
-        Reservoir create(int size, double alpha) {
-            return create(size, alpha, Clock.defaultClock());
-        }
+    LOCK_FREE_EXPONENTIALLY_DECAYING() {
+      @Override
+      Reservoir create(int size, double alpha, Clock clock) {
+        return LockFreeExponentiallyDecayingReservoir.builder()
+            .size(size)
+            .alpha(alpha)
+            .clock(clock)
+            .build();
+      }
+    };
+
+    abstract Reservoir create(int size, double alpha, Clock clock);
+
+    Reservoir create(int size, double alpha) {
+      return create(size, alpha, Clock.defaultClock());
     }
-
-    public static Collection<Object[]> reservoirs() {
-        return Arrays.stream(ReservoirFactory.values())
-                .map(value -> new Object[]{value})
-                .collect(Collectors.toList());
+  }
+
+  public static Collection<Object[]> reservoirs() {
+    return Arrays.stream(ReservoirFactory.values())
+        .map(value -> new Object[] {value})
+        .collect(toImmutableList());
+  }
+
+  private ReservoirFactory reservoirFactory;
+
+  public void initExponentiallyDecayingReservoirTest(ReservoirFactory reservoirFactory) {
+    this.reservoirFactory = reservoirFactory;
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void aReservoirOf100OutOf1000Elements(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final Reservoir reservoir = reservoirFactory.create(100, 0.99);
+    for (int i = 0; i < 1000; i++) {
+      reservoir.update(i);
     }
 
-    private ReservoirFactory reservoirFactory;
-
-    public void initExponentiallyDecayingReservoirTest(ReservoirFactory reservoirFactory) {
-        this.reservoirFactory = reservoirFactory;
-    }
-
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void aReservoirOf100OutOf1000Elements(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final Reservoir reservoir = reservoirFactory.create(100, 0.99);
-        for (int i = 0; i < 1000; i++) {
-            reservoir.update(i);
-        }
+    assertThat(reservoir.size()).isEqualTo(100);
 
-        assertThat(reservoir.size())
-                .isEqualTo(100);
+    final Snapshot snapshot = reservoir.getSnapshot();
 
-        final Snapshot snapshot = reservoir.getSnapshot();
+    assertThat(snapshot.size()).isEqualTo(100);
 
-        assertThat(snapshot.size())
-                .isEqualTo(100);
+    assertAllValuesBetween(reservoir, 0, 1000);
+  }
 
-        assertAllValuesBetween(reservoir, 0, 1000);
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void aReservoirOf100OutOf10Elements(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final Reservoir reservoir = reservoirFactory.create(100, 0.99);
+    for (int i = 0; i < 10; i++) {
+      reservoir.update(i);
     }
 
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void aReservoirOf100OutOf10Elements(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final Reservoir reservoir = reservoirFactory.create(100, 0.99);
-        for (int i = 0; i < 10; i++) {
-            reservoir.update(i);
-        }
+    final Snapshot snapshot = reservoir.getSnapshot();
 
-        final Snapshot snapshot = reservoir.getSnapshot();
+    assertThat(snapshot.size()).isEqualTo(10);
 
-        assertThat(snapshot.size())
-                .isEqualTo(10);
+    assertThat(snapshot.size()).isEqualTo(10);
 
-        assertThat(snapshot.size())
-                .isEqualTo(10);
+    assertAllValuesBetween(reservoir, 0, 10);
+  }
 
-        assertAllValuesBetween(reservoir, 0, 10);
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void aHeavilyBiasedReservoirOf100OutOf1000Elements(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final Reservoir reservoir = reservoirFactory.create(1000, 0.01);
+    for (int i = 0; i < 100; i++) {
+      reservoir.update(i);
     }
 
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void aHeavilyBiasedReservoirOf100OutOf1000Elements(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final Reservoir reservoir = reservoirFactory.create(1000, 0.01);
-        for (int i = 0; i < 100; i++) {
-            reservoir.update(i);
-        }
+    assertThat(reservoir.size()).isEqualTo(100);
 
+    final Snapshot snapshot = reservoir.getSnapshot();
 
-        assertThat(reservoir.size())
-                .isEqualTo(100);
+    assertThat(snapshot.size()).isEqualTo(100);
 
-        final Snapshot snapshot = reservoir.getSnapshot();
+    assertAllValuesBetween(reservoir, 0, 100);
+  }
 
-        assertThat(snapshot.size())
-                .isEqualTo(100);
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void longPeriodsOfInactivityShouldNotCorruptSamplingState(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final ManualClock clock = new ManualClock();
+    final Reservoir reservoir = reservoirFactory.create(10, 0.15, clock);
 
-        assertAllValuesBetween(reservoir, 0, 100);
+    // add 1000 values at a rate of 10 values/second
+    for (int i = 0; i < 1000; i++) {
+      reservoir.update(1000 + i);
+      clock.addMillis(100);
     }
-
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void longPeriodsOfInactivityShouldNotCorruptSamplingState(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final ManualClock clock = new ManualClock();
-        final Reservoir reservoir = reservoirFactory.create(10, 0.15, clock);
-
-        // add 1000 values at a rate of 10 values/second
-        for (int i = 0; i < 1000; i++) {
-            reservoir.update(1000 + i);
-            clock.addMillis(100);
-        }
-        assertThat(reservoir.getSnapshot().size())
-                .isEqualTo(10);
-        assertAllValuesBetween(reservoir, 1000, 2000);
-
-        // wait for 15 hours and add another value.
-        // this should trigger a rescale. Note that the number of samples will be reduced to 1
-        // because scaling factor equal to zero will remove all existing entries after rescale.
-        clock.addHours(15);
-        reservoir.update(2000);
-        assertThat(reservoir.getSnapshot().size())
-                .isEqualTo(1);
-        assertAllValuesBetween(reservoir, 1000, 2001);
-
-
-        // add 1000 values at a rate of 10 values/second
-        for (int i = 0; i < 1000; i++) {
-            reservoir.update(3000 + i);
-            clock.addMillis(100);
-        }
-        assertThat(reservoir.getSnapshot().size())
-                .isEqualTo(10);
-        assertAllValuesBetween(reservoir, 3000, 4000);
-    }
-
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void longPeriodsOfInactivity_fetchShouldResample(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final ManualClock clock = new ManualClock();
-        final Reservoir reservoir = reservoirFactory.create(10,
-                0.015,
-                clock);
-
-        // add 1000 values at a rate of 10 values/second
-        for (int i = 0; i < 1000; i++) {
-            reservoir.update(1000 + i);
-            clock.addMillis(100);
-        }
-        assertThat(reservoir.getSnapshot().size())
-                .isEqualTo(10);
-        assertAllValuesBetween(reservoir, 1000, 2000);
-
-        // wait for 20 hours and take snapshot.
-        // this should trigger a rescale. Note that the number of samples will be reduced to 0
-        // because scaling factor equal to zero will remove all existing entries after rescale.
-        clock.addHours(20);
-        Snapshot snapshot = reservoir.getSnapshot();
-        assertThat(snapshot.getMax()).isEqualTo(0);
-        assertThat(snapshot.getMean()).isEqualTo(0);
-        assertThat(snapshot.getMedian()).isEqualTo(0);
-        assertThat(snapshot.size()).isEqualTo(0);
+    assertThat(reservoir.getSnapshot().size()).isEqualTo(10);
+    assertAllValuesBetween(reservoir, 1000, 2000);
+
+    // wait for 15 hours and add another value.
+    // this should trigger a rescale. Note that the number of samples will be reduced to 1
+    // because scaling factor equal to zero will remove all existing entries after rescale.
+    clock.addHours(15);
+    reservoir.update(2000);
+    assertThat(reservoir.getSnapshot().size()).isEqualTo(1);
+    assertAllValuesBetween(reservoir, 1000, 2001);
+
+    // add 1000 values at a rate of 10 values/second
+    for (int i = 0; i < 1000; i++) {
+      reservoir.update(3000 + i);
+      clock.addMillis(100);
     }
-
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void emptyReservoirSnapshot_shouldReturnZeroForAllValues(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final Reservoir reservoir = reservoirFactory.create(100, 0.015,
-                new ManualClock());
-
-        Snapshot snapshot = reservoir.getSnapshot();
-        assertThat(snapshot.getMax()).isEqualTo(0);
-        assertThat(snapshot.getMean()).isEqualTo(0);
-        assertThat(snapshot.getMedian()).isEqualTo(0);
-        assertThat(snapshot.size()).isEqualTo(0);
+    assertThat(reservoir.getSnapshot().size()).isEqualTo(10);
+    assertAllValuesBetween(reservoir, 3000, 4000);
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void longPeriodsOfInactivity_fetchShouldResample(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final ManualClock clock = new ManualClock();
+    final Reservoir reservoir = reservoirFactory.create(10, 0.015, clock);
+
+    // add 1000 values at a rate of 10 values/second
+    for (int i = 0; i < 1000; i++) {
+      reservoir.update(1000 + i);
+      clock.addMillis(100);
     }
-
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void removeZeroWeightsInSamplesToPreventNaNInMeanValues(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final ManualClock clock = new ManualClock();
-        final Reservoir reservoir = reservoirFactory.create(1028, 0.015, clock);
-        Timer timer = new Timer(reservoir, clock);
-
-        Timer.Context context = timer.time();
-        clock.addMillis(100);
-        context.stop();
-
-        for (int i = 1; i < 48; i++) {
-            clock.addHours(1);
-            assertThat(reservoir.getSnapshot().getMean()).isBetween(0.0, Double.MAX_VALUE);
-        }
+    assertThat(reservoir.getSnapshot().size()).isEqualTo(10);
+    assertAllValuesBetween(reservoir, 1000, 2000);
+
+    // wait for 20 hours and take snapshot.
+    // this should trigger a rescale. Note that the number of samples will be reduced to 0
+    // because scaling factor equal to zero will remove all existing entries after rescale.
+    clock.addHours(20);
+    Snapshot snapshot = reservoir.getSnapshot();
+    assertThat(snapshot.getMax()).isEqualTo(0);
+    assertThat(snapshot.getMean()).isEqualTo(0);
+    assertThat(snapshot.getMedian()).isEqualTo(0);
+    assertThat(snapshot.size()).isEqualTo(0);
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void emptyReservoirSnapshot_shouldReturnZeroForAllValues(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final Reservoir reservoir = reservoirFactory.create(100, 0.015, new ManualClock());
+
+    Snapshot snapshot = reservoir.getSnapshot();
+    assertThat(snapshot.getMax()).isEqualTo(0);
+    assertThat(snapshot.getMean()).isEqualTo(0);
+    assertThat(snapshot.getMedian()).isEqualTo(0);
+    assertThat(snapshot.size()).isEqualTo(0);
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void removeZeroWeightsInSamplesToPreventNaNInMeanValues(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final ManualClock clock = new ManualClock();
+    final Reservoir reservoir = reservoirFactory.create(1028, 0.015, clock);
+    Timer timer = new Timer(reservoir, clock);
+
+    Timer.Context context = timer.time();
+    clock.addMillis(100);
+    context.stop();
+
+    for (int i = 1; i < 48; i++) {
+      clock.addHours(1);
+      assertThat(reservoir.getSnapshot().getMean()).isBetween(0.0, Double.MAX_VALUE);
     }
-
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void multipleUpdatesAfterlongPeriodsOfInactivityShouldNotCorruptSamplingState(ReservoirFactory reservoirFactory) throws Exception {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        // This test illustrates the potential race condition in rescale that
-        // can lead to a corrupt state.  Note that while this test uses updates
-        // exclusively to trigger the race condition, two concurrent updates
-        // may be made much more likely to trigger this behavior if executed
-        // while another thread is constructing a snapshot of the reservoir;
-        // that thread then holds the read lock when the two competing updates
-        // are executed and the race condition's window is substantially
-        // expanded.
-
-        // Run the test several times.
-        for (int attempt = 0; attempt < 10; attempt++) {
-            final ManualClock clock = new ManualClock();
-            final Reservoir reservoir = reservoirFactory.create(10,
-                    0.015,
-                    clock);
-
-            // Various atomics used to communicate between this thread and the
-            // thread created below.
-            final AtomicBoolean running = new AtomicBoolean(true);
-            final AtomicInteger threadUpdates = new AtomicInteger(0);
-            final AtomicInteger testUpdates = new AtomicInteger(0);
-
-            final Thread thread = new Thread(() -> {
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void multipleUpdatesAfterlongPeriodsOfInactivityShouldNotCorruptSamplingState(
+      ReservoirFactory reservoirFactory) throws Exception {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    // This test illustrates the potential race condition in rescale that
+    // can lead to a corrupt state.  Note that while this test uses updates
+    // exclusively to trigger the race condition, two concurrent updates
+    // may be made much more likely to trigger this behavior if executed
+    // while another thread is constructing a snapshot of the reservoir;
+    // that thread then holds the read lock when the two competing updates
+    // are executed and the race condition's window is substantially
+    // expanded.
+
+    // Run the test several times.
+    for (int attempt = 0; attempt < 10; attempt++) {
+      final ManualClock clock = new ManualClock();
+      final Reservoir reservoir = reservoirFactory.create(10, 0.015, clock);
+
+      // Various atomics used to communicate between this thread and the
+      // thread created below.
+      final AtomicBoolean running = new AtomicBoolean(true);
+      final AtomicInteger threadUpdates = new AtomicInteger(0);
+      final AtomicInteger testUpdates = new AtomicInteger(0);
+
+      final Thread thread =
+          new Thread(
+              () -> {
                 int previous = 0;
                 while (running.get()) {
-                    // Wait for the test thread to update it's counter
-                    // before updaing the reservoir.
-                    while (true) {
-                        int next = testUpdates.get();
-                        if (previous < next) {
-                            previous = next;
-                            break;
-                        }
+                  // Wait for the test thread to update it's counter
+                  // before updaing the reservoir.
+                  while (true) {
+                    int next = testUpdates.get();
+                    if (previous < next) {
+                      previous = next;
+                      break;
                     }
+                  }
 
-                    // Update the reservoir.  This needs to occur at the
-                    // same time as the test thread's update.
-                    reservoir.update(1000);
+                  // Update the reservoir.  This needs to occur at the
+                  // same time as the test thread's update.
+                  reservoir.update(1000);
 
-                    // Signal the main thread; allows the next update
-                    // attempt to begin.
-                    threadUpdates.incrementAndGet();
-                }
-            });
-
-            thread.start();
-
-            int sum = 0;
-            int previous = -1;
-            for (int i = 0; i < 100; i++) {
-                // Wait for 15 hours before attempting the next concurrent
-                // update.  The delay here needs to be sufficiently long to
-                // overflow if an update attempt is allowed to add a value to
-                // the reservoir without rescaling.  Note that:
-                // e(alpha*(15*60*60)) =~ 10^351 >> Double.MAX_VALUE =~ 1.8*10^308.
-                clock.addHours(15);
-
-                // Signal the other thread; asynchronously updates the reservoir.
-                testUpdates.incrementAndGet();
-
-                // Delay a variable length of time.  Without a delay here this
-                // thread is heavily favored and the race condition is almost
-                // never observed.
-                for (int j = 0; j < i; j++)
-                    sum += j;
-
-                // Competing reservoir update.
-                reservoir.update(1000);
-
-                // Wait for the other thread to finish it's update.
-                while (true) {
-                    int next = threadUpdates.get();
-                    if (previous < next) {
-                        previous = next;
-                        break;
-                    }
+                  // Signal the main thread; allows the next update
+                  // attempt to begin.
+                  threadUpdates.incrementAndGet();
                 }
-            }
+              });
+
+      thread.start();
+
+      int sum = 0;
+      int previous = -1;
+      for (int i = 0; i < 100; i++) {
+        // Wait for 15 hours before attempting the next concurrent
+        // update.  The delay here needs to be sufficiently long to
+        // overflow if an update attempt is allowed to add a value to
+        // the reservoir without rescaling.  Note that:
+        // e(alpha*(15*60*60)) =~ 10^351 >> Double.MAX_VALUE =~ 1.8*10^308.
+        clock.addHours(15);
 
-            // Terminate the thread.
-            running.set(false);
-            testUpdates.incrementAndGet();
-            thread.join();
+        // Signal the other thread; asynchronously updates the reservoir.
+        testUpdates.incrementAndGet();
 
-            // Test failures will result in normWeights that are not finite;
-            // checking the mean value here is sufficient.
-            assertThat(reservoir.getSnapshot().getMean()).isBetween(0.0, Double.MAX_VALUE);
+        // Delay a variable length of time.  Without a delay here this
+        // thread is heavily favored and the race condition is almost
+        // never observed.
+        for (int j = 0; j < i; j++) sum += j;
 
-            // Check the value of sum; should prevent the JVM from optimizing
-            // out the delay loop entirely.
-            assertThat(sum).isEqualTo(161700);
-        }
-    }
+        // Competing reservoir update.
+        reservoir.update(1000);
 
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void spotLift(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final ManualClock clock = new ManualClock();
-        final Reservoir reservoir = reservoirFactory.create(1000,
-                0.015,
-                clock);
-
-        final int valuesRatePerMinute = 10;
-        final int valuesIntervalMillis = (int) (TimeUnit.MINUTES.toMillis(1) / valuesRatePerMinute);
-        // mode 1: steady regime for 120 minutes
-        for (int i = 0; i < 120 * valuesRatePerMinute; i++) {
-            reservoir.update(177);
-            clock.addMillis(valuesIntervalMillis);
+        // Wait for the other thread to finish it's update.
+        while (true) {
+          int next = threadUpdates.get();
+          if (previous < next) {
+            previous = next;
+            break;
+          }
         }
+      }
 
-        // switching to mode 2: 10 minutes more with the same rate, but larger value
-        for (int i = 0; i < 10 * valuesRatePerMinute; i++) {
-            reservoir.update(9999);
-            clock.addMillis(valuesIntervalMillis);
-        }
+      // Terminate the thread.
+      running.set(false);
+      testUpdates.incrementAndGet();
+      thread.join();
 
-        // expect that quantiles should be more about mode 2 after 10 minutes
-        assertThat(reservoir.getSnapshot().getMedian())
-                .isEqualTo(9999);
-    }
+      // Test failures will result in normWeights that are not finite;
+      // checking the mean value here is sufficient.
+      assertThat(reservoir.getSnapshot().getMean()).isBetween(0.0, Double.MAX_VALUE);
 
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void spotFall(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final ManualClock clock = new ManualClock();
-        final Reservoir reservoir = reservoirFactory.create(1000,
-                0.015,
-                clock);
-
-        final int valuesRatePerMinute = 10;
-        final int valuesIntervalMillis = (int) (TimeUnit.MINUTES.toMillis(1) / valuesRatePerMinute);
-        // mode 1: steady regime for 120 minutes
-        for (int i = 0; i < 120 * valuesRatePerMinute; i++) {
-            reservoir.update(9998);
-            clock.addMillis(valuesIntervalMillis);
-        }
-
-        // switching to mode 2: 10 minutes more with the same rate, but smaller value
-        for (int i = 0; i < 10 * valuesRatePerMinute; i++) {
-            reservoir.update(178);
-            clock.addMillis(valuesIntervalMillis);
-        }
-
-        // expect that quantiles should be more about mode 2 after 10 minutes
-        assertThat(reservoir.getSnapshot().get95thPercentile())
-                .isEqualTo(178);
+      // Check the value of sum; should prevent the JVM from optimizing
+      // out the delay loop entirely.
+      assertThat(sum).isEqualTo(161700);
+    }
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void spotLift(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final ManualClock clock = new ManualClock();
+    final Reservoir reservoir = reservoirFactory.create(1000, 0.015, clock);
+
+    final int valuesRatePerMinute = 10;
+    final int valuesIntervalMillis = (int) (TimeUnit.MINUTES.toMillis(1) / valuesRatePerMinute);
+    // mode 1: steady regime for 120 minutes
+    for (int i = 0; i < 120 * valuesRatePerMinute; i++) {
+      reservoir.update(177);
+      clock.addMillis(valuesIntervalMillis);
     }
 
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void quantiliesShouldBeBasedOnWeights(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        final ManualClock clock = new ManualClock();
-        final Reservoir reservoir = reservoirFactory.create(1000,
-                0.015,
-                clock);
-        for (int i = 0; i < 40; i++) {
-            reservoir.update(177);
-        }
-
-        clock.addSeconds(120);
-
-        for (int i = 0; i < 10; i++) {
-            reservoir.update(9999);
-        }
+    // switching to mode 2: 10 minutes more with the same rate, but larger value
+    for (int i = 0; i < 10 * valuesRatePerMinute; i++) {
+      reservoir.update(9999);
+      clock.addMillis(valuesIntervalMillis);
+    }
 
-        assertThat(reservoir.getSnapshot().size())
-                .isEqualTo(50);
+    // expect that quantiles should be more about mode 2 after 10 minutes
+    assertThat(reservoir.getSnapshot().getMedian()).isEqualTo(9999);
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void spotFall(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final ManualClock clock = new ManualClock();
+    final Reservoir reservoir = reservoirFactory.create(1000, 0.015, clock);
+
+    final int valuesRatePerMinute = 10;
+    final int valuesIntervalMillis = (int) (TimeUnit.MINUTES.toMillis(1) / valuesRatePerMinute);
+    // mode 1: steady regime for 120 minutes
+    for (int i = 0; i < 120 * valuesRatePerMinute; i++) {
+      reservoir.update(9998);
+      clock.addMillis(valuesIntervalMillis);
+    }
 
-        // the first added 40 items (177) have weights 1 
-        // the next added 10 items (9999) have weights ~6 
-        // so, it's 40 vs 60 distribution, not 40 vs 10
-        assertThat(reservoir.getSnapshot().getMedian())
-                .isEqualTo(9999);
-        assertThat(reservoir.getSnapshot().get75thPercentile())
-                .isEqualTo(9999);
+    // switching to mode 2: 10 minutes more with the same rate, but smaller value
+    for (int i = 0; i < 10 * valuesRatePerMinute; i++) {
+      reservoir.update(178);
+      clock.addMillis(valuesIntervalMillis);
     }
 
-    @MethodSource("reservoirs")
-    @ParameterizedTest(name = "{index}: {0}")
-    void clockWrapShouldNotRescale(ReservoirFactory reservoirFactory) {
-        initExponentiallyDecayingReservoirTest(reservoirFactory);
-        // First verify the test works as expected given low values
-        testShortPeriodShouldNotRescale(0);
-        // Now revalidate using an edge case nanoTime value just prior to wrapping
-        testShortPeriodShouldNotRescale(Long.MAX_VALUE - TimeUnit.MINUTES.toNanos(30));
+    // expect that quantiles should be more about mode 2 after 10 minutes
+    assertThat(reservoir.getSnapshot().get95thPercentile()).isEqualTo(178);
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void quantiliesShouldBeBasedOnWeights(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    final ManualClock clock = new ManualClock();
+    final Reservoir reservoir = reservoirFactory.create(1000, 0.015, clock);
+    for (int i = 0; i < 40; i++) {
+      reservoir.update(177);
     }
 
-    private void testShortPeriodShouldNotRescale(long startTimeNanos) {
-        final ManualClock clock = new ManualClock(startTimeNanos);
-        final Reservoir reservoir = reservoirFactory.create(10, 1, clock);
+    clock.addSeconds(120);
 
-        reservoir.update(1000);
-        assertThat(reservoir.getSnapshot().size()).isEqualTo(1);
-
-        assertAllValuesBetween(reservoir, 1000, 1001);
-
-        // wait for 10 millis and take snapshot.
-        // this should not trigger a rescale. Note that the number of samples will be reduced to 0
-        // because scaling factor equal to zero will remove all existing entries after rescale.
-        clock.addSeconds(20 * 60);
-        Snapshot snapshot = reservoir.getSnapshot();
-        assertThat(snapshot.getMax()).isEqualTo(1000);
-        assertThat(snapshot.getMean()).isEqualTo(1000);
-        assertThat(snapshot.getMedian()).isEqualTo(1000);
-        assertThat(snapshot.size()).isEqualTo(1);
+    for (int i = 0; i < 10; i++) {
+      reservoir.update(9999);
     }
 
-    private static void assertAllValuesBetween(Reservoir reservoir,
-                                                double min,
-                                                double max) {
-        for (double i : reservoir.getSnapshot().getValues()) {
-            assertThat(i)
-                    .isLessThan(max)
-                    .isGreaterThanOrEqualTo(min);
-        }
+    assertThat(reservoir.getSnapshot().size()).isEqualTo(50);
+
+    // the first added 40 items (177) have weights 1
+    // the next added 10 items (9999) have weights ~6
+    // so, it's 40 vs 60 distribution, not 40 vs 10
+    assertThat(reservoir.getSnapshot().getMedian()).isEqualTo(9999);
+    assertThat(reservoir.getSnapshot().get75thPercentile()).isEqualTo(9999);
+  }
+
+  @MethodSource("reservoirs")
+  @ParameterizedTest(name = "{index}: {0}")
+  void clockWrapShouldNotRescale(ReservoirFactory reservoirFactory) {
+    initExponentiallyDecayingReservoirTest(reservoirFactory);
+    // First verify the test works as expected given low values
+    testShortPeriodShouldNotRescale(0);
+    // Now revalidate using an edge case nanoTime value just prior to wrapping
+    testShortPeriodShouldNotRescale(Long.MAX_VALUE - TimeUnit.MINUTES.toNanos(30));
+  }
+
+  private void testShortPeriodShouldNotRescale(long startTimeNanos) {
+    final ManualClock clock = new ManualClock(startTimeNanos);
+    final Reservoir reservoir = reservoirFactory.create(10, 1, clock);
+
+    reservoir.update(1000);
+    assertThat(reservoir.getSnapshot().size()).isEqualTo(1);
+
+    assertAllValuesBetween(reservoir, 1000, 1001);
+
+    // wait for 10 millis and take snapshot.
+    // this should not trigger a rescale. Note that the number of samples will be reduced to 0
+    // because scaling factor equal to zero will remove all existing entries after rescale.
+    clock.addSeconds(20 * 60);
+    Snapshot snapshot = reservoir.getSnapshot();
+    assertThat(snapshot.getMax()).isEqualTo(1000);
+    assertThat(snapshot.getMean()).isEqualTo(1000);
+    assertThat(snapshot.getMedian()).isEqualTo(1000);
+    assertThat(snapshot.size()).isEqualTo(1);
+  }
+
+  private static void assertAllValuesBetween(Reservoir reservoir, double min, double max) {
+    for (double i : reservoir.getSnapshot().getValues()) {
+      assertThat(i).isLessThan(max).isGreaterThanOrEqualTo(min);
     }
-
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/FixedNameCsvFileProviderTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/FixedNameCsvFileProviderTest.java
@@ -1,47 +1,45 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.io.TempDir;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.File;
 import java.io.IOException;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class FixedNameCsvFileProviderTest {
-    @TempDir
-    public File folder;
-
-    private File dataDirectory;
-
-    @BeforeEach
-    void setUp() throws Exception {
-        this.dataDirectory = newFolder(folder, "junit");
-    }
-
-    @Test
-    void testGetFile() {
-        FixedNameCsvFileProvider provider = new FixedNameCsvFileProvider();
-        File file = provider.getFile(dataDirectory, "test");
-        assertThat(file.getParentFile()).isEqualTo(dataDirectory);
-        assertThat(file.getName()).isEqualTo("test.csv");
-    }
-
-    @Test
-    void testGetFileSanitize() {
-        FixedNameCsvFileProvider provider = new FixedNameCsvFileProvider();
-        File file = provider.getFile(dataDirectory, "/myfake/uri");
-        assertThat(file.getParentFile()).isEqualTo(dataDirectory);
-        assertThat(file.getName()).isEqualTo("myfake.uri.csv");
-    }
-
-    private static File newFolder(File root, String... subDirs) throws IOException {
-        String subFolder = String.join("/", subDirs);
-        File result = new File(root, subFolder);
-        if (!result.mkdirs()) {
-            throw new IOException("Couldn't create folders " + root);
-        }
-        return result;
+final class FixedNameCsvFileProviderTest {
+  @TempDir public File folder;
+
+  private File dataDirectory;
+
+  @BeforeEach
+  void setUp() throws Exception {
+    this.dataDirectory = newFolder(folder, "junit");
+  }
+
+  @Test
+  void getFile() {
+    FixedNameCsvFileProvider provider = new FixedNameCsvFileProvider();
+    File file = provider.getFile(dataDirectory, "test");
+    assertThat(file.getParentFile()).isEqualTo(dataDirectory);
+    assertThat(file.getName()).isEqualTo("test.csv");
+  }
+
+  @Test
+  void getFileSanitize() {
+    FixedNameCsvFileProvider provider = new FixedNameCsvFileProvider();
+    File file = provider.getFile(dataDirectory, "/myfake/uri");
+    assertThat(file.getParentFile()).isEqualTo(dataDirectory);
+    assertThat(file.getName()).isEqualTo("myfake.uri.csv");
+  }
+
+  private static File newFolder(File root, String... subDirs) throws IOException {
+    String subFolder = String.join("/", subDirs);
+    File result = new File(root, subFolder);
+    if (!result.mkdirs()) {
+      throw new IOException("Couldn't create folders " + root);
     }
-}
\ No newline at end of file
+    return result;
+  }
+}
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/HistogramTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/HistogramTest.java
@@ -1,45 +1,40 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-class HistogramTest {
-    private final Reservoir reservoir = mock(Reservoir.class);
-    private final Histogram histogram = new Histogram(reservoir);
-
-    @Test
-    void updatesTheCountAndSumOnUpdates() {
-        assertThat(histogram.getCount())
-                .isZero();
-        assertThat(histogram.getSum())
-                .isZero();
-
-        histogram.update(1);
-        histogram.update(5);
-
-        assertThat(histogram.getCount())
-                .isEqualTo(2);
-        assertThat(histogram.getSum())
-                .isEqualTo(6);
-    }
-
-    @Test
-    void returnsTheSnapshotFromTheReservoir() {
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(reservoir.getSnapshot()).thenReturn(snapshot);
-
-        assertThat(histogram.getSnapshot())
-                .isEqualTo(snapshot);
-    }
-
-    @Test
-    void updatesTheReservoir() throws Exception {
-        histogram.update(1);
-
-        verify(reservoir).update(1);
-    }
+import org.junit.jupiter.api.Test;
+
+final class HistogramTest {
+  private final Reservoir reservoir = mock();
+  private final Histogram histogram = new Histogram(reservoir);
+
+  @Test
+  void updatesTheCountAndSumOnUpdates() {
+    assertThat(histogram.getCount()).isEqualTo(0);
+    assertThat(histogram.getSum()).isEqualTo(0);
+
+    histogram.update(1);
+    histogram.update(5);
+
+    assertThat(histogram.getCount()).isEqualTo(2);
+    assertThat(histogram.getSum()).isEqualTo(6);
+  }
+
+  @Test
+  void returnsTheSnapshotFromTheReservoir() {
+    final Snapshot snapshot = mock();
+    when(reservoir.getSnapshot()).thenReturn(snapshot);
+
+    assertThat(histogram.getSnapshot()).isEqualTo(snapshot);
+  }
+
+  @Test
+  void updatesTheReservoir() throws Exception {
+    histogram.update(1);
+
+    verify(reservoir).update(1);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/InstrumentedExecutorServiceTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/InstrumentedExecutorServiceTest.java
@@ -1,10 +1,7 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 import java.time.Duration;
 import java.util.concurrent.Callable;
@@ -16,283 +13,301 @@ import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-
-class InstrumentedExecutorServiceTest {
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(InstrumentedExecutorServiceTest.class);
-    private ExecutorService executor;
-    private MetricRegistry registry;
-    private InstrumentedExecutorService instrumentedExecutorService;
-    private Meter submitted;
-    private Counter running;
-    private Meter completed;
-    private Timer duration;
-    private Timer idle;
-
-    @BeforeEach
-    void setup() {
-        executor = Executors.newCachedThreadPool();
-        registry = new MetricRegistry();
-        instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "xs");
-        submitted = registry.meter("xs.submitted");
-        running = registry.counter("xs.running");
-        completed = registry.meter("xs.completed");
-        duration = registry.timer("xs.duration");
-        idle = registry.timer("xs.idle");
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        instrumentedExecutorService.shutdown();
-        if (!instrumentedExecutorService.awaitTermination(2, TimeUnit.SECONDS)) {
-            LOGGER.error("InstrumentedExecutorService did not terminate.");
-        }
+final class InstrumentedExecutorServiceTest {
+
+  private static final Logger LOG = LoggerFactory.getLogger(InstrumentedExecutorServiceTest.class);
+  private ExecutorService executor;
+  private MetricRegistry registry;
+  private InstrumentedExecutorService instrumentedExecutorService;
+  private Meter submitted;
+  private Counter running;
+  private Meter completed;
+  private Timer duration;
+  private Timer idle;
+
+  @BeforeEach
+  void setup() {
+    executor = Executors.newCachedThreadPool();
+    registry = new MetricRegistry();
+    instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "xs");
+    submitted = registry.meter("xs.submitted");
+    running = registry.counter("xs.running");
+    completed = registry.meter("xs.completed");
+    duration = registry.timer("xs.duration");
+    idle = registry.timer("xs.idle");
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    instrumentedExecutorService.shutdown();
+    if (!instrumentedExecutorService.awaitTermination(2, TimeUnit.SECONDS)) {
+      LOG.error("InstrumentedExecutorService did not terminate.");
     }
-
-    @Test
-    void reportsTasksInformationForRunnable() throws Exception {
-
-        assertThat(submitted.getCount()).isEqualTo(0);
-        assertThat(running.getCount()).isEqualTo(0);
-        assertThat(completed.getCount()).isEqualTo(0);
-        assertThat(duration.getCount()).isEqualTo(0);
-        assertThat(idle.getCount()).isEqualTo(0);
-
-        Runnable runnable = () -> {
-            assertThat(submitted.getCount()).isEqualTo(1);
-            assertThat(running.getCount()).isEqualTo(1);
-            assertThat(completed.getCount()).isEqualTo(0);
-            assertThat(duration.getCount()).isEqualTo(0);
-            assertThat(idle.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void reportsTasksInformationForRunnable() throws Exception {
+
+    assertThat(submitted.getCount()).isEqualTo(0);
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
+    assertThat(idle.getCount()).isEqualTo(0);
+
+    Runnable runnable =
+        () -> {
+          assertThat(submitted.getCount()).isEqualTo(1);
+          assertThat(running.getCount()).isEqualTo(1);
+          assertThat(completed.getCount()).isEqualTo(0);
+          assertThat(duration.getCount()).isEqualTo(0);
+          assertThat(idle.getCount()).isEqualTo(1);
         };
 
-        Future<?> theFuture = instrumentedExecutorService.submit(runnable);
-
-        theFuture.get();
-
-        assertThat(submitted.getCount()).isEqualTo(1);
-        assertThat(running.getCount()).isEqualTo(0);
-        assertThat(completed.getCount()).isEqualTo(1);
-        assertThat(duration.getCount()).isEqualTo(1);
-        assertThat(duration.getSnapshot().size()).isEqualTo(1);
-        assertThat(idle.getCount()).isEqualTo(1);
-        assertThat(idle.getSnapshot().size()).isEqualTo(1);
-    }
-
-    @Test
-    void reportsTasksInformationForCallable() throws Exception {
-
-        assertThat(submitted.getCount()).isEqualTo(0);
-        assertThat(running.getCount()).isEqualTo(0);
-        assertThat(completed.getCount()).isEqualTo(0);
-        assertThat(duration.getCount()).isEqualTo(0);
-        assertThat(idle.getCount()).isEqualTo(0);
-
-        Callable<Void> callable = () -> {
-            assertThat(submitted.getCount()).isEqualTo(1);
-            assertThat(running.getCount()).isEqualTo(1);
-            assertThat(completed.getCount()).isEqualTo(0);
-            assertThat(duration.getCount()).isEqualTo(0);
-            assertThat(idle.getCount()).isEqualTo(1);
-            return null;
+    Future<?> theFuture = instrumentedExecutorService.submit(runnable);
+
+    theFuture.get();
+
+    assertThat(submitted.getCount()).isEqualTo(1);
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(1);
+    assertThat(duration.getCount()).isEqualTo(1);
+    assertThat(duration.getSnapshot().size()).isEqualTo(1);
+    assertThat(idle.getCount()).isEqualTo(1);
+    assertThat(idle.getSnapshot().size()).isEqualTo(1);
+  }
+
+  @Test
+  void reportsTasksInformationForCallable() throws Exception {
+
+    assertThat(submitted.getCount()).isEqualTo(0);
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
+    assertThat(idle.getCount()).isEqualTo(0);
+
+    Callable<Void> callable =
+        () -> {
+          assertThat(submitted.getCount()).isEqualTo(1);
+          assertThat(running.getCount()).isEqualTo(1);
+          assertThat(completed.getCount()).isEqualTo(0);
+          assertThat(duration.getCount()).isEqualTo(0);
+          assertThat(idle.getCount()).isEqualTo(1);
+          return null;
         };
 
-        Future<?> theFuture = instrumentedExecutorService.submit(callable);
-
-        theFuture.get();
-
-        assertThat(submitted.getCount()).isEqualTo(1);
-        assertThat(running.getCount()).isEqualTo(0);
-        assertThat(completed.getCount()).isEqualTo(1);
-        assertThat(duration.getCount()).isEqualTo(1);
-        assertThat(duration.getSnapshot().size()).isEqualTo(1);
-        assertThat(idle.getCount()).isEqualTo(1);
-        assertThat(idle.getSnapshot().size()).isEqualTo(1);
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    void reportsTasksInformationForThreadPoolExecutor() throws Exception {
-        executor = new ThreadPoolExecutor(4, 16,
-                0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(32));
-        instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "tp");
-        submitted = registry.meter("tp.submitted");
-        running = registry.counter("tp.running");
-        completed = registry.meter("tp.completed");
-        duration = registry.timer("tp.duration");
-        idle = registry.timer("tp.idle");
-        final Gauge<Integer> poolSize = (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "pool", "size"));
-        final Gauge<Integer> poolCoreSize = (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "pool", "core"));
-        final Gauge<Integer> poolMaxSize = (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "pool", "max"));
-        final Gauge<Integer> tasksActive = (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "tasks", "active"));
-        final Gauge<Long> tasksCompleted = (Gauge<Long>) registry.getGauges().get(MetricName.build("tp", "tasks", "completed"));
-        final Gauge<Integer> tasksQueued = (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "tasks", "queued"));
-        final Gauge<Integer> tasksCapacityRemaining = (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "tasks", "capacity"));
-
-        assertThat(submitted.getCount()).isEqualTo(0);
-        assertThat(running.getCount()).isEqualTo(0);
-        assertThat(completed.getCount()).isEqualTo(0);
-        assertThat(duration.getCount()).isEqualTo(0);
-        assertThat(idle.getCount()).isEqualTo(0);
-        assertThat(poolSize.getValue()).isEqualTo(0);
-        assertThat(poolCoreSize.getValue()).isEqualTo(4);
-        assertThat(poolMaxSize.getValue()).isEqualTo(16);
-        assertThat(tasksActive.getValue()).isEqualTo(0);
-        assertThat(tasksCompleted.getValue()).isEqualTo(0L);
-        assertThat(tasksQueued.getValue()).isEqualTo(0);
-        assertThat(tasksCapacityRemaining.getValue()).isEqualTo(32);
-
-        Runnable runnable = () -> {
-            assertThat(submitted.getCount()).isEqualTo(1);
-            assertThat(running.getCount()).isEqualTo(1);
-            assertThat(completed.getCount()).isEqualTo(0);
-            assertThat(duration.getCount()).isEqualTo(0);
-            assertThat(idle.getCount()).isEqualTo(1);
-            assertThat(tasksActive.getValue()).isEqualTo(1);
-            assertThat(tasksQueued.getValue()).isEqualTo(0);
+    Future<?> theFuture = instrumentedExecutorService.submit(callable);
+
+    theFuture.get();
+
+    assertThat(submitted.getCount()).isEqualTo(1);
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(1);
+    assertThat(duration.getCount()).isEqualTo(1);
+    assertThat(duration.getSnapshot().size()).isEqualTo(1);
+    assertThat(idle.getCount()).isEqualTo(1);
+    assertThat(idle.getSnapshot().size()).isEqualTo(1);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  void reportsTasksInformationForThreadPoolExecutor() throws Exception {
+    executor =
+        new ThreadPoolExecutor(4, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(32));
+    instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "tp");
+    submitted = registry.meter("tp.submitted");
+    running = registry.counter("tp.running");
+    completed = registry.meter("tp.completed");
+    duration = registry.timer("tp.duration");
+    idle = registry.timer("tp.idle");
+    final Gauge<Integer> poolSize =
+        (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "pool", "size"));
+    final Gauge<Integer> poolCoreSize =
+        (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "pool", "core"));
+    final Gauge<Integer> poolMaxSize =
+        (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "pool", "max"));
+    final Gauge<Integer> tasksActive =
+        (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "tasks", "active"));
+    final Gauge<Long> tasksCompleted =
+        (Gauge<Long>) registry.getGauges().get(MetricName.build("tp", "tasks", "completed"));
+    final Gauge<Integer> tasksQueued =
+        (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "tasks", "queued"));
+    final Gauge<Integer> tasksCapacityRemaining =
+        (Gauge<Integer>) registry.getGauges().get(MetricName.build("tp", "tasks", "capacity"));
+
+    assertThat(submitted.getCount()).isEqualTo(0);
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
+    assertThat(idle.getCount()).isEqualTo(0);
+    assertThat(poolSize.getValue()).isEqualTo(0);
+    assertThat(poolCoreSize.getValue()).isEqualTo(4);
+    assertThat(poolMaxSize.getValue()).isEqualTo(16);
+    assertThat(tasksActive.getValue()).isEqualTo(0);
+    assertThat(tasksCompleted.getValue()).isEqualTo(0L);
+    assertThat(tasksQueued.getValue()).isEqualTo(0);
+    assertThat(tasksCapacityRemaining.getValue()).isEqualTo(32);
+
+    Runnable runnable =
+        () -> {
+          assertThat(submitted.getCount()).isEqualTo(1);
+          assertThat(running.getCount()).isEqualTo(1);
+          assertThat(completed.getCount()).isEqualTo(0);
+          assertThat(duration.getCount()).isEqualTo(0);
+          assertThat(idle.getCount()).isEqualTo(1);
+          assertThat(tasksActive.getValue()).isEqualTo(1);
+          assertThat(tasksQueued.getValue()).isEqualTo(0);
         };
 
-        Future<?> theFuture = instrumentedExecutorService.submit(runnable);
-
-        assertThat(theFuture).succeedsWithin(Duration.ofSeconds(5L));
-
-        assertThat(submitted.getCount()).isEqualTo(1);
-        assertThat(running.getCount()).isEqualTo(0);
-        assertThat(completed.getCount()).isEqualTo(1);
-        assertThat(duration.getCount()).isEqualTo(1);
-        assertThat(duration.getSnapshot().size()).isEqualTo(1);
-        assertThat(idle.getCount()).isEqualTo(1);
-        assertThat(idle.getSnapshot().size()).isEqualTo(1);
-        assertThat(poolSize.getValue()).isEqualTo(1);
-    }
-
-    @Test
-    public void reportsRejectedTasksForThreadPoolExecutor() throws Exception {
-        executor = new ThreadPoolExecutor(1, 1,
-                0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1));
-        instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "tp");
-        final Counter rejected = registry.counter("tp.rejected");
-        assertThat(rejected.getCount()).isEqualTo(0);
-
-        final CountDownLatch latch = new CountDownLatch(1);
-
-        Runnable runnable = () -> {
-            try {
-                latch.await();
-            } catch (InterruptedException e) {
-                throw new RuntimeException(e);
-            }
+    Future<?> theFuture = instrumentedExecutorService.submit(runnable);
+
+    assertThat(theFuture).succeedsWithin(Duration.ofSeconds(5L));
+
+    assertThat(submitted.getCount()).isEqualTo(1);
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(1);
+    assertThat(duration.getCount()).isEqualTo(1);
+    assertThat(duration.getSnapshot().size()).isEqualTo(1);
+    assertThat(idle.getCount()).isEqualTo(1);
+    assertThat(idle.getSnapshot().size()).isEqualTo(1);
+    assertThat(poolSize.getValue()).isEqualTo(1);
+  }
+
+  @Test
+  void reportsRejectedTasksForThreadPoolExecutor() throws Exception {
+    executor =
+        new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(1));
+    instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "tp");
+    final Counter rejected = registry.counter("tp.rejected");
+    assertThat(rejected.getCount()).isEqualTo(0);
+
+    final CountDownLatch latch = new CountDownLatch(1);
+
+    Runnable runnable =
+        () -> {
+          try {
+            latch.await();
+          } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+          }
         };
 
-        Future<?> executingFuture = instrumentedExecutorService.submit(runnable);
-        Future<?> queuedFuture = instrumentedExecutorService.submit(runnable);
-        assertThatThrownBy(() -> instrumentedExecutorService.submit(runnable))
-                .isInstanceOf(RejectedExecutionException.class);
-        latch.countDown();
-        assertThat(rejected.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    public void removesMetricsAfterShutdownForThreadPoolExecutor() {
-        executor = new ThreadPoolExecutor(4, 16,
-                0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(32));
-        instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "stp");
-
-        MetricName prefix = MetricName.build("stp");
-        assertThat(registry.getMetrics()).containsKeys(
-                MetricRegistry.name("stp", "pool.size"),
-                MetricRegistry.name("stp", "pool.core"),
-                MetricRegistry.name("stp", "pool.max"),
-                MetricRegistry.name("stp", "tasks.active"),
-                MetricRegistry.name("stp", "tasks.completed"),
-                MetricRegistry.name("stp", "tasks.queued"),
-                MetricRegistry.name("stp", "tasks.capacity")
-        );
-
-        instrumentedExecutorService.shutdown();
-
-        assertThat(registry.getMetrics()).doesNotContainKeys(
-                MetricRegistry.name("stp", "pool.size"),
-                MetricRegistry.name("stp", "pool.core"),
-                MetricRegistry.name("stp", "pool.max"),
-                MetricRegistry.name("stp", "tasks.active"),
-                MetricRegistry.name("stp", "tasks.completed"),
-                MetricRegistry.name("stp", "tasks.queued"),
-                MetricRegistry.name("stp", "tasks.capacity")
-        );
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    void reportsTasksInformationForForkJoinPool() throws Exception {
-        executor = Executors.newWorkStealingPool(4);
-        instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "fjp");
-        submitted = registry.meter("fjp.submitted");
-        running = registry.counter("fjp.running");
-        completed = registry.meter("fjp.completed");
-        duration = registry.timer("fjp.duration");
-        idle = registry.timer("fjp.idle");
-        final Gauge<Long> tasksStolen = (Gauge<Long>) registry.getGauges().get(MetricName.build("fjp", "tasks", "stolen"));
-        final Gauge<Long> tasksQueued = (Gauge<Long>) registry.getGauges().get(MetricName.build("fjp", "tasks", "queued"));
-        final Gauge<Integer> threadsActive = (Gauge<Integer>) registry.getGauges().get(MetricName.build("fjp", "threads", "active"));
-        final Gauge<Integer> threadsRunning = (Gauge<Integer>) registry.getGauges().get(MetricName.build("fjp", "threads", "running"));
-
-        assertThat(submitted.getCount()).isEqualTo(0);
-        assertThat(running.getCount()).isEqualTo(0);
-        assertThat(completed.getCount()).isEqualTo(0);
-        assertThat(duration.getCount()).isEqualTo(0);
-        assertThat(idle.getCount()).isEqualTo(0);
-        assertThat(tasksStolen.getValue()).isEqualTo(0L);
-        assertThat(tasksQueued.getValue()).isEqualTo(0L);
-        assertThat(threadsActive.getValue()).isEqualTo(0);
-        assertThat(threadsRunning.getValue()).isEqualTo(0);
-
-        Runnable runnable = () -> {
-            assertThat(submitted.getCount()).isEqualTo(1);
-            assertThat(running.getCount()).isEqualTo(1);
-            assertThat(completed.getCount()).isEqualTo(0);
-            assertThat(duration.getCount()).isEqualTo(0);
-            assertThat(idle.getCount()).isEqualTo(1);
-            assertThat(tasksQueued.getValue()).isEqualTo(0L);
-            assertThat(threadsActive.getValue()).isEqualTo(1);
-            assertThat(threadsRunning.getValue()).isEqualTo(1);
+    Future<?> executingFuture = instrumentedExecutorService.submit(runnable);
+    Future<?> queuedFuture = instrumentedExecutorService.submit(runnable);
+    assertThatThrownBy(() -> instrumentedExecutorService.submit(runnable))
+        .isInstanceOf(RejectedExecutionException.class);
+    latch.countDown();
+    assertThat(rejected.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void removesMetricsAfterShutdownForThreadPoolExecutor() {
+    executor =
+        new ThreadPoolExecutor(4, 16, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(32));
+    instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "stp");
+
+    MetricName prefix = MetricName.build("stp");
+    assertThat(registry.getMetrics())
+        .containsKeys(
+            MetricRegistry.name("stp", "pool.size"),
+            MetricRegistry.name("stp", "pool.core"),
+            MetricRegistry.name("stp", "pool.max"),
+            MetricRegistry.name("stp", "tasks.active"),
+            MetricRegistry.name("stp", "tasks.completed"),
+            MetricRegistry.name("stp", "tasks.queued"),
+            MetricRegistry.name("stp", "tasks.capacity"));
+
+    instrumentedExecutorService.shutdown();
+
+    assertThat(registry.getMetrics())
+        .doesNotContainKeys(
+            MetricRegistry.name("stp", "pool.size"),
+            MetricRegistry.name("stp", "pool.core"),
+            MetricRegistry.name("stp", "pool.max"),
+            MetricRegistry.name("stp", "tasks.active"),
+            MetricRegistry.name("stp", "tasks.completed"),
+            MetricRegistry.name("stp", "tasks.queued"),
+            MetricRegistry.name("stp", "tasks.capacity"));
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  void reportsTasksInformationForForkJoinPool() throws Exception {
+    executor = Executors.newWorkStealingPool(4);
+    instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "fjp");
+    submitted = registry.meter("fjp.submitted");
+    running = registry.counter("fjp.running");
+    completed = registry.meter("fjp.completed");
+    duration = registry.timer("fjp.duration");
+    idle = registry.timer("fjp.idle");
+    final Gauge<Long> tasksStolen =
+        (Gauge<Long>) registry.getGauges().get(MetricName.build("fjp", "tasks", "stolen"));
+    final Gauge<Long> tasksQueued =
+        (Gauge<Long>) registry.getGauges().get(MetricName.build("fjp", "tasks", "queued"));
+    final Gauge<Integer> threadsActive =
+        (Gauge<Integer>) registry.getGauges().get(MetricName.build("fjp", "threads", "active"));
+    final Gauge<Integer> threadsRunning =
+        (Gauge<Integer>) registry.getGauges().get(MetricName.build("fjp", "threads", "running"));
+
+    assertThat(submitted.getCount()).isEqualTo(0);
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
+    assertThat(idle.getCount()).isEqualTo(0);
+    assertThat(tasksStolen.getValue()).isEqualTo(0L);
+    assertThat(tasksQueued.getValue()).isEqualTo(0L);
+    assertThat(threadsActive.getValue()).isEqualTo(0);
+    assertThat(threadsRunning.getValue()).isEqualTo(0);
+
+    Runnable runnable =
+        () -> {
+          assertThat(submitted.getCount()).isEqualTo(1);
+          assertThat(running.getCount()).isEqualTo(1);
+          assertThat(completed.getCount()).isEqualTo(0);
+          assertThat(duration.getCount()).isEqualTo(0);
+          assertThat(idle.getCount()).isEqualTo(1);
+          assertThat(tasksQueued.getValue()).isEqualTo(0L);
+          assertThat(threadsActive.getValue()).isEqualTo(1);
+          assertThat(threadsRunning.getValue()).isEqualTo(1);
         };
 
-        Future<?> theFuture = instrumentedExecutorService.submit(runnable);
-
-        assertThat(theFuture).succeedsWithin(Duration.ofSeconds(5L));
-
-        assertThat(submitted.getCount()).isEqualTo(1);
-        assertThat(running.getCount()).isEqualTo(0);
-        assertThat(completed.getCount()).isEqualTo(1);
-        assertThat(duration.getCount()).isEqualTo(1);
-        assertThat(duration.getSnapshot().size()).isEqualTo(1);
-        assertThat(idle.getCount()).isEqualTo(1);
-        assertThat(idle.getSnapshot().size()).isEqualTo(1);
-    }
-
-    @Test
-    public void removesMetricsAfterShutdownForForkJoinPool() {
-        executor = Executors.newWorkStealingPool(4);
-        instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "sfjp");
-
-        assertThat(registry.getMetrics()).containsKeys(
-                MetricRegistry.name("sfjp", "tasks.stolen"),
-                MetricRegistry.name("sfjp", "tasks.queued"),
-                MetricRegistry.name("sfjp", "threads.active"),
-                MetricRegistry.name("sfjp", "threads.running")
-        );
-
-        instrumentedExecutorService.shutdown();
-
-        assertThat(registry.getMetrics()).doesNotContainKeys(
-                MetricRegistry.name("sfjp", "tasks.stolen"),
-                MetricRegistry.name("sfjp", "tasks.queued"),
-                MetricRegistry.name("sfjp", "threads.active"),
-                MetricRegistry.name("sfjp", "threads.running")
-        );
-    }
+    Future<?> theFuture = instrumentedExecutorService.submit(runnable);
+
+    assertThat(theFuture).succeedsWithin(Duration.ofSeconds(5L));
+
+    assertThat(submitted.getCount()).isEqualTo(1);
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(1);
+    assertThat(duration.getCount()).isEqualTo(1);
+    assertThat(duration.getSnapshot().size()).isEqualTo(1);
+    assertThat(idle.getCount()).isEqualTo(1);
+    assertThat(idle.getSnapshot().size()).isEqualTo(1);
+  }
+
+  @Test
+  void removesMetricsAfterShutdownForForkJoinPool() {
+    executor = Executors.newWorkStealingPool(4);
+    instrumentedExecutorService = new InstrumentedExecutorService(executor, registry, "sfjp");
+
+    assertThat(registry.getMetrics())
+        .containsKeys(
+            MetricRegistry.name("sfjp", "tasks.stolen"),
+            MetricRegistry.name("sfjp", "tasks.queued"),
+            MetricRegistry.name("sfjp", "threads.active"),
+            MetricRegistry.name("sfjp", "threads.running"));
+
+    instrumentedExecutorService.shutdown();
+
+    assertThat(registry.getMetrics())
+        .doesNotContainKeys(
+            MetricRegistry.name("sfjp", "tasks.stolen"),
+            MetricRegistry.name("sfjp", "tasks.queued"),
+            MetricRegistry.name("sfjp", "threads.active"),
+            MetricRegistry.name("sfjp", "threads.running"));
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/InstrumentedScheduledExecutorServiceTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/InstrumentedScheduledExecutorServiceTest.java
@@ -1,9 +1,6 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.Test;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executors;
@@ -11,295 +8,321 @@ import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class InstrumentedScheduledExecutorServiceTest {
-    private static final Logger LOGGER = LoggerFactory.getLogger(InstrumentedScheduledExecutorServiceTest.class);
-
-    private final ScheduledExecutorService scheduledExecutor = Executors.newSingleThreadScheduledExecutor();
-    private final MetricRegistry registry = new MetricRegistry();
-    private final InstrumentedScheduledExecutorService instrumentedScheduledExecutor = new InstrumentedScheduledExecutorService(scheduledExecutor, registry, "xs");
-
-    private final Meter submitted = registry.meter("xs.submitted");
-
-    private final Counter running = registry.counter("xs.running");
-    private final Meter completed = registry.meter("xs.completed");
-    private final Timer duration = registry.timer("xs.duration");
-
-    private final Meter scheduledOnce = registry.meter("xs.scheduled.once");
-    private final Meter scheduledRepetitively = registry.meter("xs.scheduled.repetitively");
-    private final Counter scheduledOverrun = registry.counter("xs.scheduled.overrun");
-    private final Histogram percentOfPeriod = registry.histogram("xs.scheduled.percent-of-period");
-
-    @Test
-    void testSubmitRunnable() throws Exception {
-        assertThat(submitted.getCount()).isZero();
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isZero();
-        assertThat(duration.getCount()).isZero();
-
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-
-        Future<?> theFuture = instrumentedScheduledExecutor.submit(() -> {
-            assertThat(submitted.getCount()).isEqualTo(1);
-
-            assertThat(running.getCount()).isEqualTo(1);
-            assertThat(completed.getCount()).isZero();
-            assertThat(duration.getCount()).isZero();
-
-            assertThat(scheduledOnce.getCount()).isZero();
-            assertThat(scheduledRepetitively.getCount()).isZero();
-            assertThat(scheduledOverrun.getCount()).isZero();
-            assertThat(percentOfPeriod.getCount()).isZero();
-        });
-
-        theFuture.get();
-
-        assertThat(submitted.getCount()).isEqualTo(1);
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isEqualTo(1);
-        assertThat(duration.getCount()).isEqualTo(1);
-        assertThat(duration.getSnapshot().size()).isEqualTo(1);
-
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-    }
-
-    @Test
-    void testScheduleRunnable() throws Exception {
-        assertThat(submitted.getCount()).isZero();
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isZero();
-        assertThat(duration.getCount()).isZero();
-
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-
-        ScheduledFuture<?> theFuture = instrumentedScheduledExecutor.schedule(() -> {
-            assertThat(submitted.getCount()).isZero();
-
-            assertThat(running.getCount()).isEqualTo(1);
-            assertThat(completed.getCount()).isZero();
-            assertThat(duration.getCount()).isZero();
-
-            assertThat(scheduledOnce.getCount()).isEqualTo(1);
-            assertThat(scheduledRepetitively.getCount()).isZero();
-            assertThat(scheduledOverrun.getCount()).isZero();
-            assertThat(percentOfPeriod.getCount()).isZero();
-        }, 10L, TimeUnit.MILLISECONDS);
-
-        theFuture.get();
-
-        assertThat(submitted.getCount()).isZero();
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isEqualTo(1);
-        assertThat(duration.getCount()).isEqualTo(1);
-        assertThat(duration.getSnapshot().size()).isEqualTo(1);
-
-        assertThat(scheduledOnce.getCount()).isEqualTo(1);
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-    }
-
-    @Test
-    void testSubmitCallable() throws Exception {
-        assertThat(submitted.getCount()).isZero();
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isZero();
-        assertThat(duration.getCount()).isZero();
-
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-
-        final Object obj = new Object();
-
-        Future<Object> theFuture = instrumentedScheduledExecutor.submit(() -> {
-            assertThat(submitted.getCount()).isEqualTo(1);
-
-            assertThat(running.getCount()).isEqualTo(1);
-            assertThat(completed.getCount()).isZero();
-            assertThat(duration.getCount()).isZero();
-
-            assertThat(scheduledOnce.getCount()).isZero();
-            assertThat(scheduledRepetitively.getCount()).isZero();
-            assertThat(scheduledOverrun.getCount()).isZero();
-            assertThat(percentOfPeriod.getCount()).isZero();
-
-            return obj;
-        });
-
-        assertThat(theFuture.get()).isEqualTo(obj);
-
-        assertThat(submitted.getCount()).isEqualTo(1);
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isEqualTo(1);
-        assertThat(duration.getCount()).isEqualTo(1);
-        assertThat(duration.getSnapshot().size()).isEqualTo(1);
-
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-    }
-
-    @Test
-    void testScheduleCallable() throws Exception {
-        assertThat(submitted.getCount()).isZero();
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isZero();
-        assertThat(duration.getCount()).isZero();
-
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-
-        final Object obj = new Object();
+final class InstrumentedScheduledExecutorServiceTest {
+  private static final Logger LOG =
+      LoggerFactory.getLogger(InstrumentedScheduledExecutorServiceTest.class);
+
+  private final ScheduledExecutorService scheduledExecutor =
+      Executors.newSingleThreadScheduledExecutor();
+  private final MetricRegistry registry = new MetricRegistry();
+  private final InstrumentedScheduledExecutorService instrumentedScheduledExecutor =
+      new InstrumentedScheduledExecutorService(scheduledExecutor, registry, "xs");
+
+  private final Meter submitted = registry.meter("xs.submitted");
+
+  private final Counter running = registry.counter("xs.running");
+  private final Meter completed = registry.meter("xs.completed");
+  private final Timer duration = registry.timer("xs.duration");
+
+  private final Meter scheduledOnce = registry.meter("xs.scheduled.once");
+  private final Meter scheduledRepetitively = registry.meter("xs.scheduled.repetitively");
+  private final Counter scheduledOverrun = registry.counter("xs.scheduled.overrun");
+  private final Histogram percentOfPeriod = registry.histogram("xs.scheduled.percent-of-period");
+
+  @Test
+  void submitRunnable() throws Exception {
+    assertThat(submitted.getCount()).isEqualTo(0);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+
+    Future<?> theFuture =
+        instrumentedScheduledExecutor.submit(
+            () -> {
+              assertThat(submitted.getCount()).isEqualTo(1);
+
+              assertThat(running.getCount()).isEqualTo(1);
+              assertThat(completed.getCount()).isEqualTo(0);
+              assertThat(duration.getCount()).isEqualTo(0);
+
+              assertThat(scheduledOnce.getCount()).isEqualTo(0);
+              assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+              assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+              assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+            });
+
+    theFuture.get();
+
+    assertThat(submitted.getCount()).isEqualTo(1);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(1);
+    assertThat(duration.getCount()).isEqualTo(1);
+    assertThat(duration.getSnapshot().size()).isEqualTo(1);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void scheduleRunnable() throws Exception {
+    assertThat(submitted.getCount()).isEqualTo(0);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+
+    ScheduledFuture<?> theFuture =
+        instrumentedScheduledExecutor.schedule(
+            () -> {
+              assertThat(submitted.getCount()).isEqualTo(0);
+
+              assertThat(running.getCount()).isEqualTo(1);
+              assertThat(completed.getCount()).isEqualTo(0);
+              assertThat(duration.getCount()).isEqualTo(0);
+
+              assertThat(scheduledOnce.getCount()).isEqualTo(1);
+              assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+              assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+              assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+            },
+            10L,
+            TimeUnit.MILLISECONDS);
 
-        ScheduledFuture<Object> theFuture = instrumentedScheduledExecutor.schedule(() -> {
-            assertThat(submitted.getCount()).isZero();
+    theFuture.get();
+
+    assertThat(submitted.getCount()).isEqualTo(0);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(1);
+    assertThat(duration.getCount()).isEqualTo(1);
+    assertThat(duration.getSnapshot().size()).isEqualTo(1);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(1);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void submitCallable() throws Exception {
+    assertThat(submitted.getCount()).isEqualTo(0);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+
+    final Object obj = new Object();
+
+    Future<Object> theFuture =
+        instrumentedScheduledExecutor.submit(
+            () -> {
+              assertThat(submitted.getCount()).isEqualTo(1);
+
+              assertThat(running.getCount()).isEqualTo(1);
+              assertThat(completed.getCount()).isEqualTo(0);
+              assertThat(duration.getCount()).isEqualTo(0);
+
+              assertThat(scheduledOnce.getCount()).isEqualTo(0);
+              assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+              assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+              assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+
+              return obj;
+            });
+
+    assertThat(theFuture.get()).isEqualTo(obj);
+
+    assertThat(submitted.getCount()).isEqualTo(1);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(1);
+    assertThat(duration.getCount()).isEqualTo(1);
+    assertThat(duration.getSnapshot().size()).isEqualTo(1);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void scheduleCallable() throws Exception {
+    assertThat(submitted.getCount()).isEqualTo(0);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
 
-            assertThat(running.getCount()).isEqualTo(1);
-            assertThat(completed.getCount()).isZero();
-            assertThat(duration.getCount()).isZero();
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+
+    final Object obj = new Object();
+
+    ScheduledFuture<Object> theFuture =
+        instrumentedScheduledExecutor.schedule(
+            () -> {
+              assertThat(submitted.getCount()).isEqualTo(0);
 
-            assertThat(scheduledOnce.getCount()).isEqualTo(1);
-            assertThat(scheduledRepetitively.getCount()).isZero();
-            assertThat(scheduledOverrun.getCount()).isZero();
-            assertThat(percentOfPeriod.getCount()).isZero();
+              assertThat(running.getCount()).isEqualTo(1);
+              assertThat(completed.getCount()).isEqualTo(0);
+              assertThat(duration.getCount()).isEqualTo(0);
 
-            return obj;
-        }, 10L, TimeUnit.MILLISECONDS);
+              assertThat(scheduledOnce.getCount()).isEqualTo(1);
+              assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+              assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+              assertThat(percentOfPeriod.getCount()).isEqualTo(0);
 
-        assertThat(theFuture.get()).isEqualTo(obj);
+              return obj;
+            },
+            10L,
+            TimeUnit.MILLISECONDS);
 
-        assertThat(submitted.getCount()).isZero();
+    assertThat(theFuture.get()).isEqualTo(obj);
 
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isEqualTo(1);
-        assertThat(duration.getCount()).isEqualTo(1);
-        assertThat(duration.getSnapshot().size()).isEqualTo(1);
+    assertThat(submitted.getCount()).isEqualTo(0);
 
-        assertThat(scheduledOnce.getCount()).isEqualTo(1);
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-    }
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(1);
+    assertThat(duration.getCount()).isEqualTo(1);
+    assertThat(duration.getSnapshot().size()).isEqualTo(1);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(1);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+  }
 
-    @Test
-    void testScheduleFixedRateCallable() throws Exception {
-        assertThat(submitted.getCount()).isZero();
+  @Test
+  void scheduleFixedRateCallable() throws Exception {
+    assertThat(submitted.getCount()).isEqualTo(0);
 
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isZero();
-        assertThat(duration.getCount()).isZero();
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
 
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
 
-        CountDownLatch countDownLatch = new CountDownLatch(1);
-        ScheduledFuture<?> theFuture = instrumentedScheduledExecutor.scheduleAtFixedRate(() -> {
-            assertThat(submitted.getCount()).isZero();
+    CountDownLatch countDownLatch = new CountDownLatch(1);
+    ScheduledFuture<?> theFuture =
+        instrumentedScheduledExecutor.scheduleAtFixedRate(
+            () -> {
+              assertThat(submitted.getCount()).isEqualTo(0);
 
-            assertThat(running.getCount()).isEqualTo(1);
+              assertThat(running.getCount()).isEqualTo(1);
 
-            assertThat(scheduledOnce.getCount()).isEqualTo(0);
-            assertThat(scheduledRepetitively.getCount()).isEqualTo(1);
+              assertThat(scheduledOnce.getCount()).isEqualTo(0);
+              assertThat(scheduledRepetitively.getCount()).isEqualTo(1);
 
-            try {
+              try {
                 TimeUnit.MILLISECONDS.sleep(50);
-            } catch (InterruptedException ex) {
+              } catch (InterruptedException ex) {
                 Thread.currentThread().interrupt();
-            }
-            countDownLatch.countDown();
-        }, 10L, 10L, TimeUnit.MILLISECONDS);
-        TimeUnit.MILLISECONDS.sleep(100); // Give some time for the task to be run
-        countDownLatch.await(5, TimeUnit.SECONDS); // Don't cancel until it didn't complete once
-        theFuture.cancel(true);
-        TimeUnit.MILLISECONDS.sleep(200);         // Wait while the task is cancelled
-
-        assertThat(submitted.getCount()).isZero();
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isNotEqualTo(0);
-        assertThat(duration.getCount()).isNotEqualTo(0);
-        assertThat(duration.getSnapshot().size()).isNotEqualTo(0);
-
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isEqualTo(1);
-        assertThat(scheduledOverrun.getCount()).isNotEqualTo(0);
-        assertThat(percentOfPeriod.getCount()).isNotEqualTo(0);
-    }
-
-    @Test
-    void testScheduleFixedDelayCallable() throws Exception {
-        assertThat(submitted.getCount()).isZero();
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isZero();
-        assertThat(duration.getCount()).isZero();
-
-        assertThat(scheduledOnce.getCount()).isZero();
-        assertThat(scheduledRepetitively.getCount()).isZero();
-        assertThat(scheduledOverrun.getCount()).isZero();
-        assertThat(percentOfPeriod.getCount()).isZero();
-
-        CountDownLatch countDownLatch = new CountDownLatch(1);
-        ScheduledFuture<?> theFuture = instrumentedScheduledExecutor.scheduleWithFixedDelay(() -> {
-            assertThat(submitted.getCount()).isZero();
-
-            assertThat(running.getCount()).isEqualTo(1);
-
-            assertThat(scheduledOnce.getCount()).isEqualTo(0);
-            assertThat(scheduledRepetitively.getCount()).isEqualTo(1);
-
-            try {
+              }
+              countDownLatch.countDown();
+            },
+            10L,
+            10L,
+            TimeUnit.MILLISECONDS);
+    TimeUnit.MILLISECONDS.sleep(100); // Give some time for the task to be run
+    countDownLatch.await(5, TimeUnit.SECONDS); // Don't cancel until it didn't complete once
+    theFuture.cancel(true);
+    TimeUnit.MILLISECONDS.sleep(200); // Wait while the task is cancelled
+
+    assertThat(submitted.getCount()).isEqualTo(0);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isNotEqualTo(0);
+    assertThat(duration.getCount()).isNotEqualTo(0);
+    assertThat(duration.getSnapshot().size()).isNotEqualTo(0);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(1);
+    assertThat(scheduledOverrun.getCount()).isNotEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isNotEqualTo(0);
+  }
+
+  @Test
+  void scheduleFixedDelayCallable() throws Exception {
+    assertThat(submitted.getCount()).isEqualTo(0);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isEqualTo(0);
+    assertThat(duration.getCount()).isEqualTo(0);
+
+    assertThat(scheduledOnce.getCount()).isEqualTo(0);
+    assertThat(scheduledRepetitively.getCount()).isEqualTo(0);
+    assertThat(scheduledOverrun.getCount()).isEqualTo(0);
+    assertThat(percentOfPeriod.getCount()).isEqualTo(0);
+
+    CountDownLatch countDownLatch = new CountDownLatch(1);
+    ScheduledFuture<?> theFuture =
+        instrumentedScheduledExecutor.scheduleWithFixedDelay(
+            () -> {
+              assertThat(submitted.getCount()).isEqualTo(0);
+
+              assertThat(running.getCount()).isEqualTo(1);
+
+              assertThat(scheduledOnce.getCount()).isEqualTo(0);
+              assertThat(scheduledRepetitively.getCount()).isEqualTo(1);
+
+              try {
                 TimeUnit.MILLISECONDS.sleep(50);
-            } catch (InterruptedException ex) {
+              } catch (InterruptedException ex) {
                 Thread.currentThread().interrupt();
-            }
-            countDownLatch.countDown();
-        }, 10L, 10L, TimeUnit.MILLISECONDS);
-
-        TimeUnit.MILLISECONDS.sleep(100);
-        countDownLatch.await(5, TimeUnit.SECONDS);
-        theFuture.cancel(true);
-        TimeUnit.MILLISECONDS.sleep(200);
-
-        assertThat(submitted.getCount()).isZero();
-
-        assertThat(running.getCount()).isZero();
-        assertThat(completed.getCount()).isNotEqualTo(0);
-        assertThat(duration.getCount()).isNotEqualTo(0);
-        assertThat(duration.getSnapshot().size()).isNotEqualTo(0);
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        instrumentedScheduledExecutor.shutdown();
-        if (!instrumentedScheduledExecutor.awaitTermination(2, TimeUnit.SECONDS)) {
-            LOGGER.error("InstrumentedScheduledExecutorService did not terminate.");
-        }
+              }
+              countDownLatch.countDown();
+            },
+            10L,
+            10L,
+            TimeUnit.MILLISECONDS);
+
+    TimeUnit.MILLISECONDS.sleep(100);
+    countDownLatch.await(5, TimeUnit.SECONDS);
+    theFuture.cancel(true);
+    TimeUnit.MILLISECONDS.sleep(200);
+
+    assertThat(submitted.getCount()).isEqualTo(0);
+
+    assertThat(running.getCount()).isEqualTo(0);
+    assertThat(completed.getCount()).isNotEqualTo(0);
+    assertThat(duration.getCount()).isNotEqualTo(0);
+    assertThat(duration.getSnapshot().size()).isNotEqualTo(0);
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    instrumentedScheduledExecutor.shutdown();
+    if (!instrumentedScheduledExecutor.awaitTermination(2, TimeUnit.SECONDS)) {
+      LOG.error("InstrumentedScheduledExecutorService did not terminate.");
     }
-
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/InstrumentedThreadFactoryTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/InstrumentedThreadFactoryTest.java
@@ -9,69 +9,71 @@ import java.util.concurrent.Future;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
-
 import org.junit.jupiter.api.Test;
 
-class InstrumentedThreadFactoryTest {
-    private static final int THREAD_COUNT = 10;
+final class InstrumentedThreadFactoryTest {
+  private static final int THREAD_COUNT = 10;
 
-    private final ThreadFactory factory = Executors.defaultThreadFactory();
-    private final MetricRegistry registry = new MetricRegistry();
-    private final InstrumentedThreadFactory instrumentedFactory = new InstrumentedThreadFactory(factory, registry, "factory");
-    private final ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT, instrumentedFactory);
+  private final ThreadFactory factory = Executors.defaultThreadFactory();
+  private final MetricRegistry registry = new MetricRegistry();
+  private final InstrumentedThreadFactory instrumentedFactory =
+      new InstrumentedThreadFactory(factory, registry, "factory");
+  private final ExecutorService executor =
+      Executors.newFixedThreadPool(THREAD_COUNT, instrumentedFactory);
 
-    /**
-     * Tests all parts of the InstrumentedThreadFactory except for termination since that
-     * is currently difficult to do without race conditions.
-     * TODO: Try not using real threads in a unit test?
-     */
-    @Test
-    void reportsThreadInformation() throws Exception {
-        final CountDownLatch allTasksAreCreated = new CountDownLatch(THREAD_COUNT);
-        final CountDownLatch allTasksAreCounted = new CountDownLatch(1);
-        final AtomicInteger interrupted = new AtomicInteger();
+  /**
+   * Tests all parts of the InstrumentedThreadFactory except for termination since that is currently
+   * difficult to do without race conditions. TODO: Try not using real threads in a unit test?
+   */
+  @Test
+  void reportsThreadInformation() throws Exception {
+    final CountDownLatch allTasksAreCreated = new CountDownLatch(THREAD_COUNT);
+    final CountDownLatch allTasksAreCounted = new CountDownLatch(1);
+    final AtomicInteger interrupted = new AtomicInteger();
 
-        Meter created = registry.meter("factory.created");
-        Meter terminated = registry.meter("factory.terminated");
+    Meter created = registry.meter("factory.created");
+    Meter terminated = registry.meter("factory.terminated");
 
-        assertThat(created.getCount()).isEqualTo(0);
-        assertThat(terminated.getCount()).isEqualTo(0);
+    assertThat(created.getCount()).isEqualTo(0);
+    assertThat(terminated.getCount()).isEqualTo(0);
 
-        // generate demand so the executor service creates the threads through our factory.
-        for (int i = 0; i < THREAD_COUNT + 1; i++) {
-            Future<?> t = executor.submit(() -> {
+    // generate demand so the executor service creates the threads through our factory.
+    for (int i = 0; i < THREAD_COUNT + 1; i++) {
+      Future<?> t =
+          executor.submit(
+              () -> {
                 allTasksAreCreated.countDown();
 
                 // This asserts that all threads have wait wail the testing thread notifies all.
                 // We have to do this to guarantee that the thread pool has 10 LIVE threads
                 // before we check the 'created' Meter.
                 try {
-                    allTasksAreCounted.await();
+                  allTasksAreCounted.await();
                 } catch (InterruptedException e) {
-                    interrupted.incrementAndGet();
-                    Thread.currentThread().interrupt();
+                  interrupted.incrementAndGet();
+                  Thread.currentThread().interrupt();
                 }
-            });
-            assertThat(t).isNotNull();
-        }
+              });
+      assertThat(t).isNotNull();
+    }
 
-        allTasksAreCreated.await(1, TimeUnit.SECONDS);
-        allTasksAreCounted.countDown();
+    allTasksAreCreated.await(1, TimeUnit.SECONDS);
+    allTasksAreCounted.countDown();
 
-        assertThat(created.getCount()).isEqualTo(10);
-        assertThat(terminated.getCount()).isEqualTo(0);
+    assertThat(created.getCount()).isEqualTo(10);
+    assertThat(terminated.getCount()).isEqualTo(0);
 
-        // terminate all threads in the executor service.
-        executor.shutdown();
-        executor.awaitTermination(1, TimeUnit.SECONDS);
+    // terminate all threads in the executor service.
+    executor.shutdown();
+    executor.awaitTermination(1, TimeUnit.SECONDS);
 
-        // assert that all threads from the factory have been terminated.
-        // TODO: Remove this?
-        //       There is no guarantee that all threads have entered the block where they are
-        //       counted as terminated by this time.
-        // assertThat(terminated.getCount()).isEqualTo(10);
+    // assert that all threads from the factory have been terminated.
+    // TODO: Remove this?
+    //       There is no guarantee that all threads have entered the block where they are
+    //       counted as terminated by this time.
+    // assertThat(terminated.getCount()).isEqualTo(10);
 
-        // Check that none of the threads were interrupted.
-        assertThat(interrupted.get()).isEqualTo(0);
-    }
+    // Check that none of the threads were interrupted.
+    assertThat(interrupted.get()).isEqualTo(0);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/ManualClock.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/ManualClock.java
@@ -3,42 +3,41 @@ package io.dropwizard.metrics5;
 import java.util.concurrent.TimeUnit;
 
 public class ManualClock extends Clock {
-    private final long initialTicksInNanos;
-    long ticksInNanos;
-
-    public ManualClock(long initialTicksInNanos) {
-        this.initialTicksInNanos = initialTicksInNanos;
-        this.ticksInNanos = initialTicksInNanos;
-    }
-
-    public ManualClock() {
-        this(0L);
-    }
-
-    public synchronized void addNanos(long nanos) {
-        ticksInNanos += nanos;
-    }
-
-    public synchronized void addSeconds(long seconds) {
-        ticksInNanos += TimeUnit.SECONDS.toNanos(seconds);
-    }
-
-    public synchronized void addMillis(long millis) {
-        ticksInNanos += TimeUnit.MILLISECONDS.toNanos(millis);
-    }
-
-    public synchronized void addHours(long hours) {
-        ticksInNanos += TimeUnit.HOURS.toNanos(hours);
-    }
-
-    @Override
-    public synchronized long getTick() {
-        return ticksInNanos;
-    }
-
-    @Override
-    public synchronized long getTime() {
-        return TimeUnit.NANOSECONDS.toMillis(ticksInNanos - initialTicksInNanos);
-    }
-
+  private final long initialTicksInNanos;
+  long ticksInNanos;
+
+  public ManualClock(long initialTicksInNanos) {
+    this.initialTicksInNanos = initialTicksInNanos;
+    this.ticksInNanos = initialTicksInNanos;
+  }
+
+  public ManualClock() {
+    this(0L);
+  }
+
+  public synchronized void addNanos(long nanos) {
+    ticksInNanos += nanos;
+  }
+
+  public synchronized void addSeconds(long seconds) {
+    ticksInNanos += TimeUnit.SECONDS.toNanos(seconds);
+  }
+
+  public synchronized void addMillis(long millis) {
+    ticksInNanos += TimeUnit.MILLISECONDS.toNanos(millis);
+  }
+
+  public synchronized void addHours(long hours) {
+    ticksInNanos += TimeUnit.HOURS.toNanos(hours);
+  }
+
+  @Override
+  public synchronized long getTick() {
+    return ticksInNanos;
+  }
+
+  @Override
+  public synchronized long getTime() {
+    return TimeUnit.NANOSECONDS.toMillis(ticksInNanos - initialTicksInNanos);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/MeterApproximationTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/MeterApproximationTest.java
@@ -1,84 +1,82 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.MethodSource;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.offset;
 
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.offset;
-
-public class MeterApproximationTest {
-
-    public static Collection<Object[]> ratesPerMinute() {
-        Object[][] data = new Object[][]{
-                {15}, {60}, {600}, {6000}
-        };
-        return Arrays.asList(data);
-    }
-
-    private long ratePerMinute;
-
-    public void initMeterApproximationTest(long ratePerMinute) {
-        this.ratePerMinute = ratePerMinute;
-    }
-
-    @MethodSource("ratesPerMinute")
-    @ParameterizedTest
-    void controlMeter1MinuteMeanApproximation(long ratePerMinute) {
-        initMeterApproximationTest(ratePerMinute);
-        final Meter meter = simulateMetronome(
-                62934, TimeUnit.MILLISECONDS,
-                3, TimeUnit.MINUTES);
-
-        assertThat(meter.getOneMinuteRate() * 60.0)
-                .isEqualTo(ratePerMinute, offset(0.1 * ratePerMinute));
-    }
-
-    @MethodSource("ratesPerMinute")
-    @ParameterizedTest
-    void controlMeter5MinuteMeanApproximation(long ratePerMinute) {
-        initMeterApproximationTest(ratePerMinute);
-        final Meter meter = simulateMetronome(
-                62934, TimeUnit.MILLISECONDS,
-                13, TimeUnit.MINUTES);
-
-        assertThat(meter.getFiveMinuteRate() * 60.0)
-                .isEqualTo(ratePerMinute, offset(0.1 * ratePerMinute));
-    }
-
-    @MethodSource("ratesPerMinute")
-    @ParameterizedTest
-    void controlMeter15MinuteMeanApproximation(long ratePerMinute) {
-        initMeterApproximationTest(ratePerMinute);
-        final Meter meter = simulateMetronome(
-                62934, TimeUnit.MILLISECONDS,
-                38, TimeUnit.MINUTES);
-
-        assertThat(meter.getFifteenMinuteRate() * 60.0)
-                .isEqualTo(ratePerMinute, offset(0.1 * ratePerMinute));
-    }
-
-    private Meter simulateMetronome(
-            long introDelay, TimeUnit introDelayUnit,
-            long duration, TimeUnit durationUnit) {
-
-        final ManualClock clock = new ManualClock();
-        final Meter meter = new Meter(clock);
-
-        clock.addNanos(introDelayUnit.toNanos(introDelay));
-
-        final long endTick = clock.getTick() + durationUnit.toNanos(duration);
-        final long marksIntervalInNanos = TimeUnit.MINUTES.toNanos(1) / ratePerMinute;
-
-        while (clock.getTick() <= endTick) {
-            clock.addNanos(marksIntervalInNanos);
-            meter.mark();
-        }
-
-        return meter;
+final class MeterApproximationTest {
+
+  public static Collection<Object[]> ratesPerMinute() {
+    Object[][] data = new Object[][] {{15}, {60}, {600}, {6000}};
+    return Arrays.asList(data);
+  }
+
+  private long ratePerMinute;
+
+  public void initMeterApproximationTest(long ratePerMinute) {
+    this.ratePerMinute = ratePerMinute;
+  }
+
+  @MethodSource("ratesPerMinute")
+  @ParameterizedTest
+  void controlMeter1MinuteMeanApproximation(long ratePerMinute) {
+    initMeterApproximationTest(ratePerMinute);
+    final Meter meter =
+        simulateMetronome(
+            62934, TimeUnit.MILLISECONDS,
+            3, TimeUnit.MINUTES);
+
+    assertThat(meter.getOneMinuteRate() * 60.0)
+        .isCloseTo(ratePerMinute, offset(0.1 * ratePerMinute));
+  }
+
+  @MethodSource("ratesPerMinute")
+  @ParameterizedTest
+  void controlMeter5MinuteMeanApproximation(long ratePerMinute) {
+    initMeterApproximationTest(ratePerMinute);
+    final Meter meter =
+        simulateMetronome(
+            62934, TimeUnit.MILLISECONDS,
+            13, TimeUnit.MINUTES);
+
+    assertThat(meter.getFiveMinuteRate() * 60.0)
+        .isCloseTo(ratePerMinute, offset(0.1 * ratePerMinute));
+  }
+
+  @MethodSource("ratesPerMinute")
+  @ParameterizedTest
+  void controlMeter15MinuteMeanApproximation(long ratePerMinute) {
+    initMeterApproximationTest(ratePerMinute);
+    final Meter meter =
+        simulateMetronome(
+            62934, TimeUnit.MILLISECONDS,
+            38, TimeUnit.MINUTES);
+
+    assertThat(meter.getFifteenMinuteRate() * 60.0)
+        .isCloseTo(ratePerMinute, offset(0.1 * ratePerMinute));
+  }
+
+  private Meter simulateMetronome(
+      long introDelay, TimeUnit introDelayUnit, long duration, TimeUnit durationUnit) {
+
+    final ManualClock clock = new ManualClock();
+    final Meter meter = new Meter(clock);
+
+    clock.addNanos(introDelayUnit.toNanos(introDelay));
+
+    final long endTick = clock.getTick() + durationUnit.toNanos(duration);
+    final long marksIntervalInNanos = TimeUnit.MINUTES.toNanos(1) / ratePerMinute;
+
+    while (clock.getTick() <= endTick) {
+      clock.addNanos(marksIntervalInNanos);
+      meter.mark();
     }
 
+    return meter;
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/MeterTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/MeterTest.java
@@ -1,67 +1,53 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import java.util.concurrent.TimeUnit;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.offset;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-class MeterTest {
-    private final Clock clock = mock(Clock.class);
-    private final Meter meter = new Meter(clock);
+import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-    @BeforeEach
-    void setUp() throws Exception {
-        when(clock.getTick()).thenReturn(0L, TimeUnit.SECONDS.toNanos(10));
+final class MeterTest {
+  private final Clock clock = mock();
+  private final Meter meter = new Meter(clock);
 
-    }
+  @BeforeEach
+  void setUp() throws Exception {
+    when(clock.getTick()).thenReturn(0L, TimeUnit.SECONDS.toNanos(10));
+  }
 
-    @Test
-    void startsOutWithNoRatesOrCount() {
-        assertThat(meter.getCount())
-                .isZero();
+  @Test
+  void startsOutWithNoRatesOrCount() {
+    assertThat(meter.getCount()).isEqualTo(0);
 
-        assertThat(meter.getSum())
-                .isZero();
+    assertThat(meter.getSum()).isEqualTo(0);
 
-        assertThat(meter.getMeanRate())
-                .isEqualTo(0.0, offset(0.001));
+    assertThat(meter.getMeanRate()).isCloseTo(0.0, offset(0.001));
 
-        assertThat(meter.getOneMinuteRate())
-                .isEqualTo(0.0, offset(0.001));
+    assertThat(meter.getOneMinuteRate()).isCloseTo(0.0, offset(0.001));
 
-        assertThat(meter.getFiveMinuteRate())
-                .isEqualTo(0.0, offset(0.001));
+    assertThat(meter.getFiveMinuteRate()).isCloseTo(0.0, offset(0.001));
 
-        assertThat(meter.getFifteenMinuteRate())
-                .isEqualTo(0.0, offset(0.001));
-    }
+    assertThat(meter.getFifteenMinuteRate()).isCloseTo(0.0, offset(0.001));
+  }
 
-    @Test
-    void marksEventsAndUpdatesRatesAndCount() {
-        meter.mark();
-        meter.mark(2);
+  @Test
+  void marksEventsAndUpdatesRatesAndCount() {
+    meter.mark();
+    meter.mark(2);
 
-        assertThat(meter.getCount())
-                .isEqualTo(3);
+    assertThat(meter.getCount()).isEqualTo(3);
 
-        assertThat(meter.getSum())
-                .isEqualTo(10000000000L);
+    assertThat(meter.getSum()).isEqualTo(10000000000L);
 
-        assertThat(meter.getMeanRate())
-                .isEqualTo(0.3, offset(0.001));
+    assertThat(meter.getMeanRate()).isCloseTo(0.3, offset(0.001));
 
-        assertThat(meter.getOneMinuteRate())
-                .isEqualTo(0.1840, offset(0.001));
+    assertThat(meter.getOneMinuteRate()).isCloseTo(0.1840, offset(0.001));
 
-        assertThat(meter.getFiveMinuteRate())
-                .isEqualTo(0.1966, offset(0.001));
+    assertThat(meter.getFiveMinuteRate()).isCloseTo(0.1966, offset(0.001));
 
-        assertThat(meter.getFifteenMinuteRate())
-                .isEqualTo(0.1988, offset(0.001));
-    }
+    assertThat(meter.getFifteenMinuteRate()).isCloseTo(0.1988, offset(0.001));
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/MetricFilterTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/MetricFilterTest.java
@@ -1,38 +1,44 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 
-class MetricFilterTest {
-    @Test
-    void theAllFilterMatchesAllMetrics() {
-        assertThat(MetricFilter.ALL.matches(MetricName.build(""), mock(Metric.class)))
-                .isTrue();
-    }
+import org.junit.jupiter.api.Test;
+
+final class MetricFilterTest {
+  @Test
+  void theAllFilterMatchesAllMetrics() {
+    assertThat(MetricFilter.ALL.matches(MetricName.build(""), mock(Metric.class))).isTrue();
+  }
 
-    @Test
-    void theStartsWithFilterMatches() {
-        assertThat(MetricFilter.startsWith("foo").matches(MetricName.build("foo.bar"), mock(Metric.class)))
-                .isTrue();
-        assertThat(MetricFilter.startsWith("foo").matches(MetricName.build("bar.foo"), mock(Metric.class)))
-                .isFalse();
-    }
+  @Test
+  void theStartsWithFilterMatches() {
+    assertThat(
+            MetricFilter.startsWith("foo").matches(MetricName.build("foo.bar"), mock(Metric.class)))
+        .isTrue();
+    assertThat(
+            MetricFilter.startsWith("foo").matches(MetricName.build("bar.foo"), mock(Metric.class)))
+        .isFalse();
+  }
 
-    @Test
-    void theEndsWithFilterMatches() {
-        assertThat(MetricFilter.endsWith("foo").matches(MetricName.build("foo.bar"), mock(Metric.class)))
-                .isFalse();
-        assertThat(MetricFilter.endsWith("foo").matches(MetricName.build("bar.foo"), mock(Metric.class)))
-                .isTrue();
-    }
+  @Test
+  void theEndsWithFilterMatches() {
+    assertThat(
+            MetricFilter.endsWith("foo").matches(MetricName.build("foo.bar"), mock(Metric.class)))
+        .isFalse();
+    assertThat(
+            MetricFilter.endsWith("foo").matches(MetricName.build("bar.foo"), mock(Metric.class)))
+        .isTrue();
+  }
 
-    @Test
-    void theContainsFilterMatches() {
-        assertThat(MetricFilter.contains("foo").matches(MetricName.build("bar.foo.bar"), mock(Metric.class)))
-                .isTrue();
-        assertThat(MetricFilter.contains("foo").matches(MetricName.build("bar.bar"), mock(Metric.class)))
-                .isFalse();
-    }
+  @Test
+  void theContainsFilterMatches() {
+    assertThat(
+            MetricFilter.contains("foo")
+                .matches(MetricName.build("bar.foo.bar"), mock(Metric.class)))
+        .isTrue();
+    assertThat(
+            MetricFilter.contains("foo").matches(MetricName.build("bar.bar"), mock(Metric.class)))
+        .isFalse();
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/MetricNameTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/MetricNameTest.java
@@ -1,102 +1,106 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 import java.util.HashMap;
 import java.util.Map;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-
-class MetricNameTest {
-    @Test
-    void testEmpty() {
-        assertThat(MetricName.EMPTY.getTags()).isEmpty();
-        assertThat(MetricName.EMPTY.getKey()).isEqualTo("");
-
-        assertThat(MetricName.build()).isEqualTo(MetricName.EMPTY);
-        assertThat(MetricName.EMPTY.resolve((String) null)).isEqualTo(MetricName.EMPTY);
-    }
-
-    @Test
-    void testEmptyResolve() {
-        final MetricName name = MetricName.build();
-        assertThat(name.resolve("foo")).isEqualTo(MetricName.build("foo"));
-    }
-
-    @Test
-    void testResolveToEmpty() {
-        final MetricName name = MetricName.build("foo");
-        assertThat(name.resolve((String) null)).isEqualTo(MetricName.build("foo"));
-    }
-
-    @Test
-    void testResolve() {
-        final MetricName name = MetricName.build("foo");
-        assertThat(name.resolve("bar")).isEqualTo(MetricName.build("foo.bar"));
-    }
-
-    @Test
-    void testResolveBothEmpty() {
-        final MetricName name = MetricName.build();
-        assertThat(name.resolve((String) null)).isEqualTo(MetricName.EMPTY);
-    }
-
-    @Test
-    void testAddTagsVarious() {
-        final Map<String, String> refTags = new HashMap<String, String>();
-        refTags.put("foo", "bar");
-        final MetricName test = MetricName.EMPTY.tagged("foo", "bar");
-        final MetricName test2 = MetricName.EMPTY.tagged(refTags);
-
-        assertThat(test).isEqualTo(new MetricName("", refTags));
-        assertThat(test.getTags()).isEqualTo(refTags);
-
-        assertThat(test2).isEqualTo(new MetricName("", refTags));
-        assertThat(test2.getTags()).isEqualTo(refTags);
-    }
-
-    @Test
-    void testTaggedMoreArguments() {
-        final Map<String, String> refTags = new HashMap<String, String>();
-        refTags.put("foo", "bar");
-        refTags.put("baz", "biz");
-        assertThat(MetricName.EMPTY.tagged("foo", "bar", "baz", "biz").getTags()).isEqualTo(refTags);
-    }
-
-    @Test
-    void testTaggedNotPairs() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            MetricName.EMPTY.tagged("foo");
-        });
-    }
-
-    @Test
-    void testTaggedNotPairs2() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            MetricName.EMPTY.tagged("foo", "bar", "baz");
-        });
-    }
-
-    @Test
-    void testCompareTo() {
-        final MetricName a = MetricName.EMPTY.tagged("foo", "bar");
-        final MetricName b = MetricName.EMPTY.tagged("foo", "baz");
-
-        assertThat(a.compareTo(b)).isLessThan(0);
-        assertThat(b.compareTo(a)).isGreaterThan(0);
-        assertThat(b.resolve("key").compareTo(b)).isGreaterThan(0);
-        assertThat(b.compareTo(b.resolve("key"))).isLessThan(0);
-    }
-
-    @Test
-    void testCompareTo2() {
-        final MetricName a = MetricName.EMPTY.tagged("a", "x");
-        final MetricName b = MetricName.EMPTY.tagged("b", "x");
-
-        assertThat(MetricName.EMPTY.compareTo(a)).isLessThan(0);
-        assertThat(MetricName.EMPTY.compareTo(b)).isLessThan(0);
-        assertThat(a.compareTo(b)).isLessThan(0);
-        assertThat(b.compareTo(a)).isGreaterThan(0);
-    }
+final class MetricNameTest {
+  @Test
+  void empty() {
+    assertThat(MetricName.EMPTY.getTags()).isEmpty();
+    assertThat(MetricName.EMPTY.getKey()).isEmpty();
+
+    assertThat(MetricName.build()).isEqualTo(MetricName.EMPTY);
+    assertThat(MetricName.EMPTY.resolve((String) null)).isEqualTo(MetricName.EMPTY);
+  }
+
+  @Test
+  void emptyResolve() {
+    final MetricName name = MetricName.build();
+    assertThat(name.resolve("foo")).isEqualTo(MetricName.build("foo"));
+  }
+
+  @Test
+  void resolveToEmpty() {
+    final MetricName name = MetricName.build("foo");
+    assertThat(name.resolve((String) null)).isEqualTo(MetricName.build("foo"));
+  }
+
+  @Test
+  void resolve() {
+    final MetricName name = MetricName.build("foo");
+    assertThat(name.resolve("bar")).isEqualTo(MetricName.build("foo.bar"));
+  }
+
+  @Test
+  void resolveBothEmpty() {
+    final MetricName name = MetricName.build();
+    assertThat(name.resolve((String) null)).isEqualTo(MetricName.EMPTY);
+  }
+
+  @Test
+  void addTagsVarious() {
+    final Map<String, String> refTags = new HashMap<String, String>();
+    refTags.put("foo", "bar");
+    final MetricName test = MetricName.EMPTY.tagged("foo", "bar");
+    final MetricName test2 = MetricName.EMPTY.tagged(refTags);
+
+    assertThat(test).isEqualTo(new MetricName("", refTags));
+    assertThat(test.getTags()).containsExactlyInAnyOrderEntriesOf(refTags);
+
+    assertThat(test2).isEqualTo(new MetricName("", refTags));
+    assertThat(test2.getTags()).containsExactlyInAnyOrderEntriesOf(refTags);
+  }
+
+  @Test
+  void taggedMoreArguments() {
+    final Map<String, String> refTags = new HashMap<String, String>();
+    refTags.put("foo", "bar");
+    refTags.put("baz", "biz");
+    assertThat(MetricName.EMPTY.tagged("foo", "bar", "baz", "biz").getTags())
+        .containsExactlyInAnyOrderEntriesOf(refTags);
+  }
+
+  @Test
+  void taggedNotPairs() {
+    assertThatThrownBy(
+            () -> {
+              MetricName.EMPTY.tagged("foo");
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void taggedNotPairs2() {
+    assertThatThrownBy(
+            () -> {
+              MetricName.EMPTY.tagged("foo", "bar", "baz");
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void compareTo() {
+    final MetricName a = MetricName.EMPTY.tagged("foo", "bar");
+    final MetricName b = MetricName.EMPTY.tagged("foo", "baz");
+
+    assertThat(a).isLessThan(b);
+    assertThat(b).isGreaterThan(a);
+    assertThat(b.resolve("key")).isGreaterThan(b);
+    assertThat(b).isLessThan(b.resolve("key"));
+  }
+
+  @Test
+  void compareTo2() {
+    final MetricName a = MetricName.EMPTY.tagged("a", "x");
+    final MetricName b = MetricName.EMPTY.tagged("b", "x");
+
+    assertThat(MetricName.EMPTY).isLessThan(a);
+    assertThat(MetricName.EMPTY).isLessThan(b);
+    assertThat(a).isLessThan(b);
+    assertThat(b).isGreaterThan(a);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/MetricRegistryListenerTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/MetricRegistryListenerTest.java
@@ -1,62 +1,62 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verifyNoInteractions;
 
-class MetricRegistryListenerTest {
-    private static final MetricName BLAH = MetricName.build("blah");
-
-    private final Counter counter = mock(Counter.class);
-    private final Histogram histogram = mock(Histogram.class);
-    private final Meter meter = mock(Meter.class);
-    private final Timer timer = mock(Timer.class);
-    private final MetricRegistryListener listener = new MetricRegistryListener.Base() {
-
-    };
+import org.junit.jupiter.api.Test;
 
-    @Test
-    void noOpsOnGaugeAdded() {
-        listener.onGaugeAdded(BLAH, () -> {
-            throw new RuntimeException("Should not be called");
+final class MetricRegistryListenerTest {
+  private static final MetricName BLAH = MetricName.build("blah");
+
+  private final Counter counter = mock();
+  private final Histogram histogram = mock();
+  private final Meter meter = mock();
+  private final Timer timer = mock();
+  private final MetricRegistryListener listener = new MetricRegistryListener.Base() {};
+
+  @Test
+  void noOpsOnGaugeAdded() {
+    listener.onGaugeAdded(
+        BLAH,
+        () -> {
+          throw new RuntimeException("Should not be called");
         });
-    }
+  }
 
-    @Test
-    void noOpsOnCounterAdded() {
-        listener.onCounterAdded(BLAH, counter);
+  @Test
+  void noOpsOnCounterAdded() {
+    listener.onCounterAdded(BLAH, counter);
 
-        verifyNoInteractions(counter);
-    }
+    verifyNoInteractions(counter);
+  }
 
-    @Test
-    void noOpsOnHistogramAdded() {
-        listener.onHistogramAdded(BLAH, histogram);
+  @Test
+  void noOpsOnHistogramAdded() {
+    listener.onHistogramAdded(BLAH, histogram);
 
-        verifyNoInteractions(histogram);
-    }
+    verifyNoInteractions(histogram);
+  }
 
-    @Test
-    void noOpsOnMeterAdded() {
-        listener.onMeterAdded(BLAH, meter);
+  @Test
+  void noOpsOnMeterAdded() {
+    listener.onMeterAdded(BLAH, meter);
 
-        verifyNoInteractions(meter);
-    }
+    verifyNoInteractions(meter);
+  }
 
-    @Test
-    void noOpsOnTimerAdded() {
-        listener.onTimerAdded(BLAH, timer);
+  @Test
+  void noOpsOnTimerAdded() {
+    listener.onTimerAdded(BLAH, timer);
 
-        verifyNoInteractions(timer);
-    }
+    verifyNoInteractions(timer);
+  }
 
-    @Test
-    void doesNotExplodeWhenMetricsAreRemoved() {
-        listener.onGaugeRemoved(BLAH);
-        listener.onCounterRemoved(BLAH);
-        listener.onHistogramRemoved(BLAH);
-        listener.onMeterRemoved(BLAH);
-        listener.onTimerRemoved(BLAH);
-    }
+  @Test
+  void doesNotExplodeWhenMetricsAreRemoved() {
+    listener.onGaugeRemoved(BLAH);
+    listener.onCounterRemoved(BLAH);
+    listener.onHistogramRemoved(BLAH);
+    listener.onMeterRemoved(BLAH);
+    listener.onTimerRemoved(BLAH);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/MetricRegistryTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/MetricRegistryTest.java
@@ -1,13 +1,6 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.stream.Collectors;
-
+import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static io.dropwizard.metrics5.MetricRegistry.name;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
@@ -16,665 +9,665 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
-class MetricRegistryTest {
-
-    private static class CustomCounter extends Counter {
-
-        CustomCounter() {
-            super();
-        }
-
-        public void incTheAnswer() {
-            inc(42);
-        }
-    }
-
-    private static final MetricName TIMER2 = MetricName.build("timer");
-    private static final MetricName METER2 = MetricName.build("meter");
-    private static final MetricName HISTOGRAM2 = MetricName.build("histogram");
-    private static final MetricName COUNTER = MetricName.build("counter");
-    private static final MetricName COUNTER2 = MetricName.build("counter2");
-    private static final MetricName GAUGE = MetricName.build("gauge");
-    private static final MetricName GAUGE2 = MetricName.build("gauge2");
-    private static final MetricName SETTABLE_GAUGE = MetricName.build("settable-gauge");
-    private static final MetricName THING = MetricName.build("thing");
-    private final MetricRegistryListener listener = mock(MetricRegistryListener.class);
-    private final MetricRegistry registry = new MetricRegistry();
-    private final Gauge<String> gauge = () -> "";
-    private final SettableGauge<String> settableGauge = new DefaultSettableGauge<>("");
-    private final Counter counter = mock(Counter.class);
-    private final Histogram histogram = mock(Histogram.class);
-    private final Meter meter = mock(Meter.class);
-    private final Timer timer = mock(Timer.class);
-
-    @BeforeEach
-    void setUp() {
-        registry.addListener(listener);
-    }
-
-    @Test
-    void registeringAGaugeTriggersANotification() {
-        assertThat(registry.register(THING, gauge))
-                .isEqualTo(gauge);
-
-        verify(listener).onGaugeAdded(THING, gauge);
-    }
-
-    @Test
-    void removingAGaugeTriggersANotification() {
-        registry.register(THING, gauge);
-
-        assertThat(registry.remove(THING))
-                .isTrue();
-
-        verify(listener).onGaugeRemoved(THING);
-    }
-
-    @Test
-    void registeringACounterTriggersANotification() {
-        assertThat(registry.register(THING, counter))
-                .isEqualTo(counter);
-
-        verify(listener).onCounterAdded(THING, counter);
-    }
-
-    @Test
-    void accessingACounterRegistersAndReusesTheCounter() {
-        final Counter counter1 = registry.counter(THING);
-        final Counter counter2 = registry.counter(THING);
-
-        assertThat(counter1)
-                .isSameAs(counter2);
-
-        verify(listener).onCounterAdded(THING, counter1);
-    }
-
-    @Test
-    void accessingACustomCounterRegistersAndReusesTheCounter() {
-        final MetricRegistry.MetricSupplier<Counter> supplier = () -> counter;
-        final Counter counter1 = registry.counter(THING, supplier);
-        final Counter counter2 = registry.counter(THING, supplier);
-
-        assertThat(counter1)
-                .isSameAs(counter2);
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-        verify(listener).onCounterAdded(THING, counter1);
-    }
+final class MetricRegistryTest {
 
-    @Test
-    void createsTypesafeCustomCounter() {
-        MetricName name = MetricName.build("custom-counter");
-        final CustomCounter customCounter = registry.counter(name, CustomCounter::new);
-        customCounter.incTheAnswer();
+  private static class CustomCounter extends Counter {
 
-        assertThat(registry.counter(name).getCount()).isEqualTo(42);
+    CustomCounter() {
+      super();
     }
 
-    @Test
-    void removingACounterTriggersANotification() {
-        registry.register(THING, counter);
-
-        assertThat(registry.remove(THING))
-                .isTrue();
-
-        verify(listener).onCounterRemoved(THING);
+    public void incTheAnswer() {
+      inc(42);
     }
+  }
 
-    @Test
-    void registeringAHistogramTriggersANotification() {
-        assertThat(registry.register(THING, histogram))
-                .isEqualTo(histogram);
+  private static final MetricName TIMER2 = MetricName.build("timer");
+  private static final MetricName METER2 = MetricName.build("meter");
+  private static final MetricName HISTOGRAM2 = MetricName.build("histogram");
+  private static final MetricName COUNTER = MetricName.build("counter");
+  private static final MetricName COUNTER2 = MetricName.build("counter2");
+  private static final MetricName GAUGE = MetricName.build("gauge");
+  private static final MetricName GAUGE2 = MetricName.build("gauge2");
+  private static final MetricName SETTABLE_GAUGE = MetricName.build("settable-gauge");
+  private static final MetricName THING = MetricName.build("thing");
+  private final MetricRegistryListener listener = mock();
+  private final MetricRegistry registry = new MetricRegistry();
+  private final Gauge<String> gauge = () -> "";
+  private final SettableGauge<String> settableGauge = new DefaultSettableGauge<>("");
+  private final Counter counter = mock();
+  private final Histogram histogram = mock();
+  private final Meter meter = mock();
+  private final Timer timer = mock();
 
-        verify(listener).onHistogramAdded(THING, histogram);
-    }
+  @BeforeEach
+  void setUp() {
+    registry.addListener(listener);
+  }
 
-    @Test
-    void accessingAHistogramRegistersAndReusesIt() {
-        final Histogram histogram1 = registry.histogram(THING);
-        final Histogram histogram2 = registry.histogram(THING);
+  @Test
+  void registeringAGaugeTriggersANotification() {
+    assertThat(registry.register(THING, gauge)).isEqualTo(gauge);
 
-        assertThat(histogram1)
-                .isSameAs(histogram2);
+    verify(listener).onGaugeAdded(THING, gauge);
+  }
 
-        verify(listener).onHistogramAdded(THING, histogram1);
-    }
+  @Test
+  void removingAGaugeTriggersANotification() {
+    registry.register(THING, gauge);
 
-    @Test
-    void accessingACustomHistogramRegistersAndReusesIt() {
-        final MetricRegistry.MetricSupplier<Histogram> supplier = () -> histogram;
-        final Histogram histogram1 = registry.histogram(THING, supplier);
-        final Histogram histogram2 = registry.histogram(THING, supplier);
+    assertThat(registry.remove(THING)).isTrue();
 
-        assertThat(histogram1)
-                .isSameAs(histogram2);
+    verify(listener).onGaugeRemoved(THING);
+  }
 
-        verify(listener).onHistogramAdded(THING, histogram1);
-    }
+  @Test
+  void registeringACounterTriggersANotification() {
+    assertThat(registry.register(THING, counter)).isEqualTo(counter);
 
-    @Test
-    void removingAHistogramTriggersANotification() {
-        registry.register(THING, histogram);
+    verify(listener).onCounterAdded(THING, counter);
+  }
 
-        assertThat(registry.remove(THING))
-                .isTrue();
+  @Test
+  void accessingACounterRegistersAndReusesTheCounter() {
+    final Counter counter1 = registry.counter(THING);
+    final Counter counter2 = registry.counter(THING);
 
-        verify(listener).onHistogramRemoved(THING);
-    }
+    assertThat(counter1).isSameAs(counter2);
 
-    @Test
-    void registeringAMeterTriggersANotification() {
-        assertThat(registry.register(THING, meter))
-                .isEqualTo(meter);
+    verify(listener).onCounterAdded(THING, counter1);
+  }
 
-        verify(listener).onMeterAdded(THING, meter);
-    }
+  @Test
+  void accessingACustomCounterRegistersAndReusesTheCounter() {
+    final MetricRegistry.MetricSupplier<Counter> supplier = () -> counter;
+    final Counter counter1 = registry.counter(THING, supplier);
+    final Counter counter2 = registry.counter(THING, supplier);
 
-    @Test
-    void accessingAMeterRegistersAndReusesIt() {
-        final Meter meter1 = registry.meter(THING);
-        final Meter meter2 = registry.meter(THING);
+    assertThat(counter1).isSameAs(counter2);
 
-        assertThat(meter1)
-                .isSameAs(meter2);
+    verify(listener).onCounterAdded(THING, counter1);
+  }
 
-        verify(listener).onMeterAdded(THING, meter1);
-    }
+  @Test
+  void createsTypesafeCustomCounter() {
+    MetricName name = MetricName.build("custom-counter");
+    final CustomCounter customCounter = registry.counter(name, CustomCounter::new);
+    customCounter.incTheAnswer();
 
-    @Test
-    void accessingACustomMeterRegistersAndReusesIt() {
-        final MetricRegistry.MetricSupplier<Meter> supplier = () -> meter;
-        final Meter meter1 = registry.meter(THING, supplier);
-        final Meter meter2 = registry.meter(THING, supplier);
+    assertThat(registry.counter(name).getCount()).isEqualTo(42);
+  }
 
-        assertThat(meter1)
-                .isSameAs(meter2);
+  @Test
+  void removingACounterTriggersANotification() {
+    registry.register(THING, counter);
 
-        verify(listener).onMeterAdded(THING, meter1);
-    }
+    assertThat(registry.remove(THING)).isTrue();
 
-    @Test
-    void removingAMeterTriggersANotification() {
-        registry.register(THING, meter);
+    verify(listener).onCounterRemoved(THING);
+  }
 
-        assertThat(registry.remove(THING))
-                .isTrue();
+  @Test
+  void registeringAHistogramTriggersANotification() {
+    assertThat(registry.register(THING, histogram)).isEqualTo(histogram);
 
-        verify(listener).onMeterRemoved(THING);
-    }
+    verify(listener).onHistogramAdded(THING, histogram);
+  }
 
-    @Test
-    void registeringATimerTriggersANotification() {
-        assertThat(registry.register(THING, timer))
-                .isEqualTo(timer);
+  @Test
+  void accessingAHistogramRegistersAndReusesIt() {
+    final Histogram histogram1 = registry.histogram(THING);
+    final Histogram histogram2 = registry.histogram(THING);
 
-        verify(listener).onTimerAdded(THING, timer);
-    }
+    assertThat(histogram1).isSameAs(histogram2);
 
-    @Test
-    void accessingATimerRegistersAndReusesIt() {
-        final Timer timer1 = registry.timer(THING);
-        final Timer timer2 = registry.timer(THING);
+    verify(listener).onHistogramAdded(THING, histogram1);
+  }
 
-        assertThat(timer1)
-                .isSameAs(timer2);
+  @Test
+  void accessingACustomHistogramRegistersAndReusesIt() {
+    final MetricRegistry.MetricSupplier<Histogram> supplier = () -> histogram;
+    final Histogram histogram1 = registry.histogram(THING, supplier);
+    final Histogram histogram2 = registry.histogram(THING, supplier);
 
-        verify(listener).onTimerAdded(THING, timer1);
-    }
+    assertThat(histogram1).isSameAs(histogram2);
 
-    @Test
-    void accessingACustomTimerRegistersAndReusesIt() {
-        final MetricRegistry.MetricSupplier<Timer> supplier = () -> timer;
-        final Timer timer1 = registry.timer(THING, supplier);
-        final Timer timer2 = registry.timer(THING, supplier);
+    verify(listener).onHistogramAdded(THING, histogram1);
+  }
 
-        assertThat(timer1)
-                .isSameAs(timer2);
+  @Test
+  void removingAHistogramTriggersANotification() {
+    registry.register(THING, histogram);
 
-        verify(listener).onTimerAdded(THING, timer1);
-    }
+    assertThat(registry.remove(THING)).isTrue();
 
+    verify(listener).onHistogramRemoved(THING);
+  }
 
-    @Test
-    void removingATimerTriggersANotification() {
-        registry.register(THING, timer);
+  @Test
+  void registeringAMeterTriggersANotification() {
+    assertThat(registry.register(THING, meter)).isEqualTo(meter);
 
-        assertThat(registry.remove(THING))
-                .isTrue();
+    verify(listener).onMeterAdded(THING, meter);
+  }
 
-        verify(listener).onTimerRemoved(THING);
-    }
+  @Test
+  void accessingAMeterRegistersAndReusesIt() {
+    final Meter meter1 = registry.meter(THING);
+    final Meter meter2 = registry.meter(THING);
 
-    @Test
-    void accessingACustomGaugeRegistersAndReusesIt() {
-        final MetricRegistry.MetricSupplier<Gauge<String>> supplier = () -> gauge;
-        final Gauge<String> gauge1 = registry.gauge(THING, supplier);
-        final Gauge<String> gauge2 = registry.gauge(THING, supplier);
+    assertThat(meter1).isSameAs(meter2);
 
-        assertThat(gauge1)
-                .isSameAs(gauge2);
+    verify(listener).onMeterAdded(THING, meter1);
+  }
 
-        verify(listener).onGaugeAdded(THING, gauge1);
-    }
+  @Test
+  void accessingACustomMeterRegistersAndReusesIt() {
+    final MetricRegistry.MetricSupplier<Meter> supplier = () -> meter;
+    final Meter meter1 = registry.meter(THING, supplier);
+    final Meter meter2 = registry.meter(THING, supplier);
 
-    @Test
-    void accessingASettableGaugeRegistersAndReusesIt() {
-        final SettableGauge<String> gauge1 = registry.gauge(THING);
-        gauge1.setValue("Test");
-        final Gauge<String> gauge2 = registry.gauge(THING);
+    assertThat(meter1).isSameAs(meter2);
 
-        assertThat(gauge1).isSameAs(gauge2);
-        assertThat(gauge2.getValue()).isEqualTo("Test");
+    verify(listener).onMeterAdded(THING, meter1);
+  }
 
-        verify(listener).onGaugeAdded(THING, gauge1);
-    }
+  @Test
+  void removingAMeterTriggersANotification() {
+    registry.register(THING, meter);
 
-    @Test
-    void accessingAnExistingGaugeReusesIt() {
-        final Gauge<String> gauge1 = registry.gauge(THING, () -> () -> "string-gauge");
-        final Gauge<String> gauge2 = registry.gauge(THING, () -> new DefaultSettableGauge<>("settable-gauge"));
+    assertThat(registry.remove(THING)).isTrue();
 
-        assertThat(gauge1).isSameAs(gauge2);
-        assertThat(gauge2.getValue()).isEqualTo("string-gauge");
+    verify(listener).onMeterRemoved(THING);
+  }
 
-        verify(listener).onGaugeAdded(THING, gauge1);
-    }
+  @Test
+  void registeringATimerTriggersANotification() {
+    assertThat(registry.register(THING, timer)).isEqualTo(timer);
 
-    @Test
-    void accessingAnExistingSettableGaugeReusesIt() {
-        final Gauge<String> gauge1 = registry.gauge(THING, () -> new DefaultSettableGauge<>("settable-gauge"));
-        final Gauge<String> gauge2 = registry.gauge(THING);
+    verify(listener).onTimerAdded(THING, timer);
+  }
 
-        assertThat(gauge1).isSameAs(gauge2);
-        assertThat(gauge2.getValue()).isEqualTo("settable-gauge");
+  @Test
+  void accessingATimerRegistersAndReusesIt() {
+    final Timer timer1 = registry.timer(THING);
+    final Timer timer2 = registry.timer(THING);
 
-        verify(listener).onGaugeAdded(THING, gauge1);
-    }
+    assertThat(timer1).isSameAs(timer2);
 
-    @Test
-    void settableGaugeIsTreatedLikeAGauge() {
-        final MetricRegistry.MetricSupplier<SettableGauge<String>> supplier = () -> settableGauge;
-        final SettableGauge<String> gauge1 = registry.gauge(THING, supplier);
-        final SettableGauge<String> gauge2 = registry.gauge(THING, supplier);
+    verify(listener).onTimerAdded(THING, timer1);
+  }
 
-        assertThat(gauge1)
-                .isSameAs(gauge2);
+  @Test
+  void accessingACustomTimerRegistersAndReusesIt() {
+    final MetricRegistry.MetricSupplier<Timer> supplier = () -> timer;
+    final Timer timer1 = registry.timer(THING, supplier);
+    final Timer timer2 = registry.timer(THING, supplier);
 
-        verify(listener).onGaugeAdded(THING, gauge1);
-    }
+    assertThat(timer1).isSameAs(timer2);
 
-    @Test
-    void addingAListenerWithExistingMetricsCatchesItUp() {
-        registry.register(GAUGE2, gauge);
-        registry.register(SETTABLE_GAUGE, settableGauge);
-        registry.register(COUNTER2, counter);
-        registry.register(HISTOGRAM2, histogram);
-        registry.register(METER2, meter);
-        registry.register(TIMER2, timer);
-
-        final MetricRegistryListener other = mock(MetricRegistryListener.class);
-        registry.addListener(other);
-
-        verify(other).onGaugeAdded(GAUGE2, gauge);
-        verify(other).onGaugeAdded(SETTABLE_GAUGE, settableGauge);
-        verify(other).onCounterAdded(COUNTER2, counter);
-        verify(other).onHistogramAdded(HISTOGRAM2, histogram);
-        verify(other).onMeterAdded(METER2, meter);
-        verify(other).onTimerAdded(TIMER2, timer);
-    }
+    verify(listener).onTimerAdded(THING, timer1);
+  }
 
-    @Test
-    void aRemovedListenerDoesNotReceiveUpdates() {
-        registry.register(GAUGE, gauge);
-        registry.removeListener(listener);
-        registry.register(GAUGE2, gauge);
+  @Test
+  void removingATimerTriggersANotification() {
+    registry.register(THING, timer);
 
-        verify(listener, never()).onGaugeAdded(GAUGE2, gauge);
-    }
+    assertThat(registry.remove(THING)).isTrue();
 
-    @Test
-    void hasAMapOfRegisteredGauges() {
-        registry.register(GAUGE2, gauge);
-        registry.register(SETTABLE_GAUGE, settableGauge);
+    verify(listener).onTimerRemoved(THING);
+  }
 
-        assertThat(registry.getGauges())
-                .containsEntry(GAUGE2, gauge)
-                .containsEntry(SETTABLE_GAUGE, settableGauge);
-    }
+  @Test
+  void accessingACustomGaugeRegistersAndReusesIt() {
+    final MetricRegistry.MetricSupplier<Gauge<String>> supplier = () -> gauge;
+    final Gauge<String> gauge1 = registry.gauge(THING, supplier);
+    final Gauge<String> gauge2 = registry.gauge(THING, supplier);
 
-    @Test
-    void hasAMapOfRegisteredCounters() {
-        registry.register(COUNTER2, counter);
+    assertThat(gauge1).isSameAs(gauge2);
 
-        assertThat(registry.getCounters())
-                .contains(entry(COUNTER2, counter));
-    }
+    verify(listener).onGaugeAdded(THING, gauge1);
+  }
 
-    @Test
-    void hasAMapOfRegisteredHistograms() {
-        registry.register(HISTOGRAM2, histogram);
+  @Test
+  void accessingASettableGaugeRegistersAndReusesIt() {
+    final SettableGauge<String> gauge1 = registry.gauge(THING);
+    gauge1.setValue("Test");
+    final Gauge<String> gauge2 = registry.gauge(THING);
 
-        assertThat(registry.getHistograms())
-                .contains(entry(HISTOGRAM2, histogram));
-    }
+    assertThat(gauge1).isSameAs(gauge2);
+    assertThat(gauge2.getValue()).isEqualTo("Test");
 
-    @Test
-    void hasAMapOfRegisteredMeters() {
-        registry.register(METER2, meter);
+    verify(listener).onGaugeAdded(THING, gauge1);
+  }
 
-        assertThat(registry.getMeters())
-                .contains(entry(METER2, meter));
-    }
+  @Test
+  void accessingAnExistingGaugeReusesIt() {
+    final Gauge<String> gauge1 = registry.gauge(THING, () -> () -> "string-gauge");
+    final Gauge<String> gauge2 =
+        registry.gauge(THING, () -> new DefaultSettableGauge<>("settable-gauge"));
 
-    @Test
-    void hasAMapOfRegisteredTimers() {
-        registry.register(TIMER2, timer);
+    assertThat(gauge1).isSameAs(gauge2);
+    assertThat(gauge2.getValue()).isEqualTo("string-gauge");
 
-        assertThat(registry.getTimers())
-                .contains(entry(TIMER2, timer));
-    }
+    verify(listener).onGaugeAdded(THING, gauge1);
+  }
 
-    @Test
-    void hasASetOfRegisteredMetricNames() {
-        registry.register(GAUGE2, gauge);
-        registry.register(SETTABLE_GAUGE, settableGauge);
-        registry.register(COUNTER2, counter);
-        registry.register(HISTOGRAM2, histogram);
-        registry.register(METER2, meter);
-        registry.register(TIMER2, timer);
-
-        assertThat(registry.getNames())
-                .containsOnly(GAUGE2, SETTABLE_GAUGE, COUNTER2, HISTOGRAM2, METER2, TIMER2);
-    }
+  @Test
+  void accessingAnExistingSettableGaugeReusesIt() {
+    final Gauge<String> gauge1 =
+        registry.gauge(THING, () -> new DefaultSettableGauge<>("settable-gauge"));
+    final Gauge<String> gauge2 = registry.gauge(THING);
 
-    @Test
-    void registersMultipleMetrics() {
-        final MetricSet metrics = () -> {
-            final Map<MetricName, Metric> m = new HashMap<>();
-            m.put(GAUGE2, gauge);
-            m.put(COUNTER2, counter);
-            return m;
+    assertThat(gauge1).isSameAs(gauge2);
+    assertThat(gauge2.getValue()).isEqualTo("settable-gauge");
+
+    verify(listener).onGaugeAdded(THING, gauge1);
+  }
+
+  @Test
+  void settableGaugeIsTreatedLikeAGauge() {
+    final MetricRegistry.MetricSupplier<SettableGauge<String>> supplier = () -> settableGauge;
+    final SettableGauge<String> gauge1 = registry.gauge(THING, supplier);
+    final SettableGauge<String> gauge2 = registry.gauge(THING, supplier);
+
+    assertThat(gauge1).isSameAs(gauge2);
+
+    verify(listener).onGaugeAdded(THING, gauge1);
+  }
+
+  @Test
+  void addingAListenerWithExistingMetricsCatchesItUp() {
+    registry.register(GAUGE2, gauge);
+    registry.register(SETTABLE_GAUGE, settableGauge);
+    registry.register(COUNTER2, counter);
+    registry.register(HISTOGRAM2, histogram);
+    registry.register(METER2, meter);
+    registry.register(TIMER2, timer);
+
+    final MetricRegistryListener other = mock();
+    registry.addListener(other);
+
+    verify(other).onGaugeAdded(GAUGE2, gauge);
+    verify(other).onGaugeAdded(SETTABLE_GAUGE, settableGauge);
+    verify(other).onCounterAdded(COUNTER2, counter);
+    verify(other).onHistogramAdded(HISTOGRAM2, histogram);
+    verify(other).onMeterAdded(METER2, meter);
+    verify(other).onTimerAdded(TIMER2, timer);
+  }
+
+  @Test
+  void aRemovedListenerDoesNotReceiveUpdates() {
+    registry.register(GAUGE, gauge);
+    registry.removeListener(listener);
+    registry.register(GAUGE2, gauge);
+
+    verify(listener, never()).onGaugeAdded(GAUGE2, gauge);
+  }
+
+  @Test
+  void hasAMapOfRegisteredGauges() {
+    registry.register(GAUGE2, gauge);
+    registry.register(SETTABLE_GAUGE, settableGauge);
+
+    assertThat(registry.getGauges())
+        .containsEntry(GAUGE2, gauge)
+        .containsEntry(SETTABLE_GAUGE, settableGauge);
+  }
+
+  @Test
+  void hasAMapOfRegisteredCounters() {
+    registry.register(COUNTER2, counter);
+
+    assertThat(registry.getCounters()).contains(entry(COUNTER2, counter));
+  }
+
+  @Test
+  void hasAMapOfRegisteredHistograms() {
+    registry.register(HISTOGRAM2, histogram);
+
+    assertThat(registry.getHistograms()).contains(entry(HISTOGRAM2, histogram));
+  }
+
+  @Test
+  void hasAMapOfRegisteredMeters() {
+    registry.register(METER2, meter);
+
+    assertThat(registry.getMeters()).contains(entry(METER2, meter));
+  }
+
+  @Test
+  void hasAMapOfRegisteredTimers() {
+    registry.register(TIMER2, timer);
+
+    assertThat(registry.getTimers()).contains(entry(TIMER2, timer));
+  }
+
+  @Test
+  void hasASetOfRegisteredMetricNames() {
+    registry.register(GAUGE2, gauge);
+    registry.register(SETTABLE_GAUGE, settableGauge);
+    registry.register(COUNTER2, counter);
+    registry.register(HISTOGRAM2, histogram);
+    registry.register(METER2, meter);
+    registry.register(TIMER2, timer);
+
+    assertThat(registry.getNames())
+        .containsOnly(GAUGE2, SETTABLE_GAUGE, COUNTER2, HISTOGRAM2, METER2, TIMER2);
+  }
+
+  @Test
+  void registersMultipleMetrics() {
+    final MetricSet metrics =
+        () -> {
+          final Map<MetricName, Metric> m = new HashMap<>();
+          m.put(GAUGE2, gauge);
+          m.put(COUNTER2, counter);
+          return m;
         };
 
-        registry.registerAll(metrics);
+    registry.registerAll(metrics);
 
-        assertThat(registry.getNames())
-                .containsOnly(GAUGE2, COUNTER2);
-    }
+    assertThat(registry.getNames()).containsOnly(GAUGE2, COUNTER2);
+  }
 
-    @Test
-    void registersMultipleMetricsWithAPrefix() {
-        final MetricName myCounter = MetricName.build("my.counter");
-        final MetricName myGauge = MetricName.build("my.gauge");
+  @Test
+  void registersMultipleMetricsWithAPrefix() {
+    final MetricName myCounter = MetricName.build("my.counter");
+    final MetricName myGauge = MetricName.build("my.gauge");
 
-        final MetricSet metrics = () -> {
-            final Map<MetricName, Metric> m = new HashMap<>();
-            m.put(GAUGE, gauge);
-            m.put(COUNTER, counter);
-            return m;
+    final MetricSet metrics =
+        () -> {
+          final Map<MetricName, Metric> m = new HashMap<>();
+          m.put(GAUGE, gauge);
+          m.put(COUNTER, counter);
+          return m;
         };
 
-        registry.register(MetricName.build("my"), metrics);
+    registry.register(MetricName.build("my"), metrics);
 
-        assertThat(registry.getNames())
-                .containsOnly(myGauge, myCounter);
-    }
+    assertThat(registry.getNames()).containsOnly(myGauge, myCounter);
+  }
 
-    @Test
-    void registersRecursiveMetricSets() {
-        final MetricSet inner = () -> {
-            final Map<MetricName, Metric> m = new HashMap<>();
-            m.put(GAUGE, gauge);
-            return m;
+  @Test
+  void registersRecursiveMetricSets() {
+    final MetricSet inner =
+        () -> {
+          final Map<MetricName, Metric> m = new HashMap<>();
+          m.put(GAUGE, gauge);
+          return m;
         };
 
-        final MetricSet outer = () -> {
-            final Map<MetricName, Metric> m = new HashMap<>();
-            m.put(MetricName.build("inner"), inner);
-            m.put(COUNTER, counter);
-            return m;
+    final MetricSet outer =
+        () -> {
+          final Map<MetricName, Metric> m = new HashMap<>();
+          m.put(MetricName.build("inner"), inner);
+          m.put(COUNTER, counter);
+          return m;
         };
 
-        registry.register(MetricName.build("my"), outer);
-
-        final MetricName myCounter = MetricName.build("my.counter");
-        final MetricName myInnerGauge = MetricName.build("my.inner.gauge");
-
-        assertThat(registry.getNames())
-                .containsOnly(myInnerGauge, myCounter);
-    }
-
-    @Test
-    void registersMetricsFromAnotherRegistry() {
-        MetricRegistry other = new MetricRegistry();
-        other.register(GAUGE, gauge);
-        registry.register(MetricName.build("nested"), other);
-        assertThat(registry.getNames()).containsOnly(MetricName.build("nested.gauge"));
-    }
-
-    @Test
-    void concatenatesStringsToFormADottedName() {
-        assertThat(name("one", "two", "three"))
-                .isEqualTo(MetricName.build("one.two.three"));
-    }
-
-    @Test
-    void elidesNullValuesFromNamesWhenOnlyOneNullPassedIn() {
-        assertThat(name("one", (String) null))
-                .isEqualTo(MetricName.build("one"));
-    }
-
-    @Test
-    void elidesNullValuesFromNamesWhenManyNullsPassedIn() {
-        assertThat(name("one", null, null))
-                .isEqualTo(MetricName.build("one"));
-    }
-
-    @Test
-    void elidesNullValuesFromNamesWhenNullAndNotNullPassedIn() {
-        assertThat(name("one", null, "three"))
-                .isEqualTo(MetricName.build("one.three"));
-    }
-
-    @Test
-    void elidesEmptyStringsFromNames() {
-        assertThat(name("one", "", "three"))
-                .isEqualTo(MetricName.build("one.three"));
-    }
-
-    @Test
-    void concatenatesClassNamesWithStringsToFormADottedName() {
-        assertThat(name(MetricRegistryTest.class, "one", "two"))
-                .isEqualTo(MetricName.build("io.dropwizard.metrics5.MetricRegistryTest.one.two"));
-    }
-
-    @Test
-    void concatenatesClassesWithoutCanonicalNamesWithStrings() {
-        final Gauge<String> g = () -> null;
-
-        assertThat(name(g.getClass(), "one", "two"))
-                .isEqualTo(MetricName.build(g.getClass().getName() + ".one.two"));
-    }
-
-    @Test
-    void removesMetricsMatchingAFilter() {
-        final MetricName timer1 = MetricName.build("timer-1");
-        final MetricName timer2 = MetricName.build("timer-2");
-        final MetricName histogram1 = MetricName.build("histogram-1");
-
-        registry.timer(timer1);
-        registry.timer(timer2);
-        registry.histogram(histogram1);
-
-        assertThat(registry.getNames())
-                .contains(timer1, timer2, histogram1);
-
-        registry.removeMatching((name, metric) -> name.getKey().endsWith("1"));
-
-        assertThat(registry.getNames())
-                .doesNotContain(timer1, histogram1);
-        assertThat(registry.getNames())
-                .contains(timer2);
-
-        verify(listener).onTimerRemoved(timer1);
-        verify(listener).onHistogramRemoved(histogram1);
-    }
-
-    @Test
-    void addingChildMetricAfterRegister() {
-        MetricRegistry parent = new MetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-
-        child.counter("test-1");
-        parent.register(MetricName.build("child"), child);
-        child.counter("test-2");
-
-        Set<MetricName> parentMetrics = parent.getMetrics().keySet();
-        Set<MetricName> childMetrics = child.getMetrics().keySet();
-
-        assertThat(parentMetrics)
-                .isEqualTo(childMetrics.stream().map(m -> MetricName.build("child", m.getKey())).collect(Collectors.toSet()));
-    }
-
-    @Test
-    void addingMultipleChildMetricsAfterRegister() {
-        MetricRegistry parent = new MetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-
-        child.counter("test-1");
-        child.counter("test-2");
-        parent.register(MetricName.build("child"), child);
-        child.counter("test-3");
-        child.counter("test-4");
-
-        Set<MetricName> parentMetrics = parent.getMetrics().keySet();
-        Set<MetricName> childMetrics = child.getMetrics().keySet();
-
-        assertThat(parentMetrics)
-                .isEqualTo(childMetrics.stream().map(m -> MetricName.build("child", m.getKey())).collect(Collectors.toSet()));
-    }
-
-    @Test
-    void addingDeepChildMetricsAfterRegister() {
-        MetricRegistry parent = new MetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-        MetricRegistry deepChild = new MetricRegistry();
-
-        deepChild.counter("test-1");
-        child.register(MetricName.build("deep-child"), deepChild);
-        deepChild.counter("test-2");
-
-        child.counter("test-3");
-        parent.register(MetricName.build("child"), child);
-        child.counter("test-4");
-
-        deepChild.counter("test-5");
-        Set<MetricName> parentMetrics = parent.getMetrics().keySet();
-        Set<MetricName> childMetrics = child.getMetrics().keySet();
-        Set<MetricName> deepChildMetrics = deepChild.getMetrics().keySet();
+    registry.register(MetricName.build("my"), outer);
+
+    final MetricName myCounter = MetricName.build("my.counter");
+    final MetricName myInnerGauge = MetricName.build("my.inner.gauge");
+
+    assertThat(registry.getNames()).containsOnly(myInnerGauge, myCounter);
+  }
+
+  @Test
+  void registersMetricsFromAnotherRegistry() {
+    MetricRegistry other = new MetricRegistry();
+    other.register(GAUGE, gauge);
+    registry.register(MetricName.build("nested"), other);
+    assertThat(registry.getNames()).containsExactly(MetricName.build("nested.gauge"));
+  }
+
+  @Test
+  void concatenatesStringsToFormADottedName() {
+    assertThat(name("one", "two", "three")).isEqualTo(MetricName.build("one.two.three"));
+  }
+
+  @Test
+  void elidesNullValuesFromNamesWhenOnlyOneNullPassedIn() {
+    assertThat(name("one", (String) null)).isEqualTo(MetricName.build("one"));
+  }
+
+  @Test
+  void elidesNullValuesFromNamesWhenManyNullsPassedIn() {
+    assertThat(name("one", null, null)).isEqualTo(MetricName.build("one"));
+  }
+
+  @Test
+  void elidesNullValuesFromNamesWhenNullAndNotNullPassedIn() {
+    assertThat(name("one", null, "three")).isEqualTo(MetricName.build("one.three"));
+  }
+
+  @Test
+  void elidesEmptyStringsFromNames() {
+    assertThat(name("one", "", "three")).isEqualTo(MetricName.build("one.three"));
+  }
+
+  @Test
+  void concatenatesClassNamesWithStringsToFormADottedName() {
+    assertThat(name(MetricRegistryTest.class, "one", "two"))
+        .isEqualTo(MetricName.build("io.dropwizard.metrics5.MetricRegistryTest.one.two"));
+  }
+
+  @Test
+  void concatenatesClassesWithoutCanonicalNamesWithStrings() {
+    final Gauge<String> g = () -> null;
+
+    assertThat(name(g.getClass(), "one", "two"))
+        .isEqualTo(MetricName.build(g.getClass().getName() + ".one.two"));
+  }
+
+  @Test
+  void removesMetricsMatchingAFilter() {
+    final MetricName timer1 = MetricName.build("timer-1");
+    final MetricName timer2 = MetricName.build("timer-2");
+    final MetricName histogram1 = MetricName.build("histogram-1");
+
+    registry.timer(timer1);
+    registry.timer(timer2);
+    registry.histogram(histogram1);
+
+    assertThat(registry.getNames()).contains(timer1, timer2, histogram1);
+
+    registry.removeMatching((name, metric) -> name.getKey().endsWith("1"));
+
+    assertThat(registry.getNames()).doesNotContain(timer1, histogram1);
+    assertThat(registry.getNames()).contains(timer2);
+
+    verify(listener).onTimerRemoved(timer1);
+    verify(listener).onHistogramRemoved(histogram1);
+  }
+
+  @Test
+  void addingChildMetricAfterRegister() {
+    MetricRegistry parent = new MetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+
+    child.counter("test-1");
+    parent.register(MetricName.build("child"), child);
+    child.counter("test-2");
+
+    Set<MetricName> parentMetrics = parent.getMetrics().keySet();
+    Set<MetricName> childMetrics = child.getMetrics().keySet();
+
+    assertThat(parentMetrics)
+        .hasSameElementsAs(
+            childMetrics.stream()
+                .map(m -> MetricName.build("child", m.getKey()))
+                .collect(toImmutableSet()));
+  }
+
+  @Test
+  void addingMultipleChildMetricsAfterRegister() {
+    MetricRegistry parent = new MetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+
+    child.counter("test-1");
+    child.counter("test-2");
+    parent.register(MetricName.build("child"), child);
+    child.counter("test-3");
+    child.counter("test-4");
+
+    Set<MetricName> parentMetrics = parent.getMetrics().keySet();
+    Set<MetricName> childMetrics = child.getMetrics().keySet();
+
+    assertThat(parentMetrics)
+        .hasSameElementsAs(
+            childMetrics.stream()
+                .map(m -> MetricName.build("child", m.getKey()))
+                .collect(toImmutableSet()));
+  }
+
+  @Test
+  void addingDeepChildMetricsAfterRegister() {
+    MetricRegistry parent = new MetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+    MetricRegistry deepChild = new MetricRegistry();
+
+    deepChild.counter("test-1");
+    child.register(MetricName.build("deep-child"), deepChild);
+    deepChild.counter("test-2");
+
+    child.counter("test-3");
+    parent.register(MetricName.build("child"), child);
+    child.counter("test-4");
+
+    deepChild.counter("test-5");
+    Set<MetricName> parentMetrics = parent.getMetrics().keySet();
+    Set<MetricName> childMetrics = child.getMetrics().keySet();
+    Set<MetricName> deepChildMetrics = deepChild.getMetrics().keySet();
+
+    assertThat(parentMetrics)
+        .hasSameElementsAs(
+            childMetrics.stream()
+                .map(m -> MetricName.build("child", m.getKey()))
+                .collect(toImmutableSet()));
+
+    assertThat(childMetrics)
+        .containsAll(
+            deepChildMetrics.stream()
+                .map(m -> MetricName.build("deep-child", m.getKey()))
+                .collect(toImmutableSet()));
+
+    assertThat(deepChildMetrics).hasSize(3);
+    assertThat(childMetrics).hasSize(5);
+  }
+
+  @Test
+  void removingChildMetricAfterRegister() {
+    MetricRegistry parent = new MetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+
+    child.counter("test-1");
+    parent.register(MetricName.build("child"), child);
+    child.counter("test-2");
+
+    child.remove(MetricName.build("test-1"));
+
+    Set<MetricName> parentMetrics = parent.getMetrics().keySet();
+    Set<MetricName> childMetrics = child.getMetrics().keySet();
+
+    assertThat(parentMetrics)
+        .hasSameElementsAs(
+            childMetrics.stream()
+                .map(m -> MetricName.build("child", m.getKey()))
+                .collect(toImmutableSet()));
+
+    assertThat(childMetrics).doesNotContain(MetricName.build("test-1"));
+  }
+
+  @Test
+  void removingMultipleChildMetricsAfterRegister() {
+    MetricRegistry parent = new MetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+
+    child.counter("test-1");
+    child.counter("test-2");
+    parent.register(MetricName.build("child"), child);
+    child.counter("test-3");
+    child.counter("test-4");
+
+    child.remove(MetricName.build("test-1"));
+    child.remove(MetricName.build("test-3"));
+
+    Set<MetricName> parentMetrics = parent.getMetrics().keySet();
+    Set<MetricName> childMetrics = child.getMetrics().keySet();
+
+    assertThat(parentMetrics)
+        .hasSameElementsAs(
+            childMetrics.stream()
+                .map(m -> MetricName.build("child", m.getKey()))
+                .collect(toImmutableSet()));
+
+    assertThat(childMetrics).doesNotContain(MetricName.build("test-1"), MetricName.build("test-3"));
+  }
+
+  @Test
+  void removingDeepChildMetricsAfterRegister() {
+    MetricRegistry parent = new MetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+    MetricRegistry deepChild = new MetricRegistry();
+
+    deepChild.counter("test-1");
+    child.register(MetricName.build("deep-child"), deepChild);
+    deepChild.counter("test-2");
+
+    child.counter("test-3");
+    parent.register(MetricName.build("child"), child);
+    child.counter("test-4");
+
+    deepChild.remove(MetricName.build("test-2"));
+
+    Set<MetricName> parentMetrics = parent.getMetrics().keySet();
+    Set<MetricName> childMetrics = child.getMetrics().keySet();
+    Set<MetricName> deepChildMetrics = deepChild.getMetrics().keySet();
+
+    assertThat(parentMetrics)
+        .hasSameElementsAs(
+            childMetrics.stream()
+                .map(m -> MetricName.build("child", m.getKey()))
+                .collect(toImmutableSet()));
+
+    assertThat(childMetrics)
+        .containsAll(
+            deepChildMetrics.stream()
+                .map(m -> MetricName.build("deep-child", m.getKey()))
+                .collect(toImmutableSet()));
+
+    assertThat(deepChildMetrics).doesNotContain(MetricName.build("test-2"));
+
+    assertThat(deepChildMetrics).hasSize(1);
+    assertThat(childMetrics).hasSize(3);
+  }
+
+  @Test
+  void registerNullMetric() {
+    MetricRegistry registry = new MetricRegistry();
+    assertThatThrownBy(() -> registry.register(MetricName.build("any_name"), null))
+        .hasMessage("metric == null");
+  }
+
+  @Test
+  void infersGaugeType() {
+    Gauge<Long> gauge = registry.registerGauge(GAUGE, () -> 10_000_000_000L);
+
+    assertThat(gauge.getValue()).isEqualTo(10_000_000_000L);
+  }
+
+  @Test
+  void registersGaugeAsLambda() {
+    registry.registerGauge(GAUGE, () -> 3.14);
 
-        assertThat(parentMetrics)
-                .isEqualTo(childMetrics.stream().map(m -> MetricName.build("child", m.getKey())).collect(Collectors.toSet()));
-
-        assertThat(childMetrics)
-                .containsAll(deepChildMetrics.stream().map(m -> MetricName.build("deep-child", m.getKey())).collect(Collectors.toSet()));
-
-        assertThat(deepChildMetrics.size()).isEqualTo(3);
-        assertThat(childMetrics.size()).isEqualTo(5);
-    }
-
-    @Test
-    void removingChildMetricAfterRegister() {
-        MetricRegistry parent = new MetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-
-        child.counter("test-1");
-        parent.register(MetricName.build("child"), child);
-        child.counter("test-2");
-
-        child.remove(MetricName.build("test-1"));
-
-        Set<MetricName> parentMetrics = parent.getMetrics().keySet();
-        Set<MetricName> childMetrics = child.getMetrics().keySet();
-
-        assertThat(parentMetrics)
-                .isEqualTo(childMetrics.stream().map(m -> MetricName.build("child", m.getKey())).collect(Collectors.toSet()));
-
-        assertThat(childMetrics).doesNotContain(MetricName.build("test-1"));
-    }
-
-    @Test
-    void removingMultipleChildMetricsAfterRegister() {
-        MetricRegistry parent = new MetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-
-        child.counter("test-1");
-        child.counter("test-2");
-        parent.register(MetricName.build("child"), child);
-        child.counter("test-3");
-        child.counter("test-4");
-
-        child.remove(MetricName.build("test-1"));
-        child.remove(MetricName.build("test-3"));
-
-        Set<MetricName> parentMetrics = parent.getMetrics().keySet();
-        Set<MetricName> childMetrics = child.getMetrics().keySet();
-
-        assertThat(parentMetrics)
-                .isEqualTo(childMetrics.stream().map(m -> MetricName.build("child", m.getKey())).collect(Collectors.toSet()));
-
-        assertThat(childMetrics).doesNotContain(MetricName.build("test-1"), MetricName.build("test-3"));
-    }
-
-    @Test
-    void removingDeepChildMetricsAfterRegister() {
-        MetricRegistry parent = new MetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-        MetricRegistry deepChild = new MetricRegistry();
-
-        deepChild.counter("test-1");
-        child.register(MetricName.build("deep-child"), deepChild);
-        deepChild.counter("test-2");
-
-        child.counter("test-3");
-        parent.register(MetricName.build("child"), child);
-        child.counter("test-4");
-
-        deepChild.remove(MetricName.build("test-2"));
-
-        Set<MetricName> parentMetrics = parent.getMetrics().keySet();
-        Set<MetricName> childMetrics = child.getMetrics().keySet();
-        Set<MetricName> deepChildMetrics = deepChild.getMetrics().keySet();
-
-        assertThat(parentMetrics)
-                .isEqualTo(childMetrics.stream().map(m -> MetricName.build("child", m.getKey())).collect(Collectors.toSet()));
-
-        assertThat(childMetrics)
-                .containsAll(deepChildMetrics.stream().map(m -> MetricName.build("deep-child", m.getKey())).collect(Collectors.toSet()));
-
-        assertThat(deepChildMetrics).doesNotContain(MetricName.build("test-2"));
-
-        assertThat(deepChildMetrics.size()).isEqualTo(1);
-        assertThat(childMetrics.size()).isEqualTo(3);
-    }
-
-    @Test
-    void registerNullMetric() {
-        MetricRegistry registry = new MetricRegistry();
-        assertThatThrownBy(() -> registry.register(MetricName.build("any_name"), null))
-                .hasMessage("metric == null");
-    }
-
-    @Test
-    void infersGaugeType() {
-        Gauge<Long> gauge = registry.registerGauge(GAUGE, () -> 10_000_000_000L);
-
-        assertThat(gauge.getValue()).isEqualTo(10_000_000_000L);
-    }
-
-    @Test
-    void registersGaugeAsLambda() {
-        registry.registerGauge(GAUGE, () -> 3.14);
-
-        assertThat(registry.gauge(GAUGE).getValue()).isEqualTo(3.14);
-    }
+    assertThat(registry.gauge(GAUGE).getValue()).isEqualTo(3.14);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/NoopMetricRegistryTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/NoopMetricRegistryTest.java
@@ -1,497 +1,498 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
-class NoopMetricRegistryTest {
-    private static final MetricName METRIC_THING = MetricName.build("thing");
-
-    private final MetricRegistryListener listener = mock(MetricRegistryListener.class);
-    private final NoopMetricRegistry registry = new NoopMetricRegistry();
-    private final Gauge<String> gauge = () -> "";
-    private final Counter counter = mock(Counter.class);
-    private final Histogram histogram = mock(Histogram.class);
-    private final Meter meter = mock(Meter.class);
-    private final Timer timer = mock(Timer.class);
-
-    @BeforeEach
-    void setUp() {
-        registry.addListener(listener);
-    }
-
-    @Test
-    void registeringAGaugeTriggersNoNotification() {
-        assertThat(registry.register(METRIC_THING, gauge)).isEqualTo(gauge);
-
-        verify(listener, never()).onGaugeAdded(METRIC_THING, gauge);
-    }
-
-    @Test
-    void removingAGaugeTriggersNoNotification() {
-        registry.register(METRIC_THING, gauge);
-
-        assertThat(registry.remove(METRIC_THING)).isFalse();
-
-        verify(listener, never()).onGaugeRemoved(METRIC_THING);
-    }
-
-    @Test
-    void registeringACounterTriggersNoNotification() {
-        assertThat(registry.register(METRIC_THING, counter)).isEqualTo(counter);
-
-        verify(listener, never()).onCounterAdded(METRIC_THING, counter);
-    }
-
-    @Test
-    void accessingACounterRegistersAndReusesTheCounter() {
-        final Counter counter1 = registry.counter(METRIC_THING);
-        final Counter counter2 = registry.counter(METRIC_THING);
-
-        assertThat(counter1).isExactlyInstanceOf(NoopMetricRegistry.NoopCounter.class);
-        assertThat(counter2).isExactlyInstanceOf(NoopMetricRegistry.NoopCounter.class);
-        assertThat(counter1).isSameAs(counter2);
-
-        verify(listener, never()).onCounterAdded(METRIC_THING, counter1);
-    }
-
-    @Test
-    void accessingACustomCounterRegistersAndReusesTheCounter() {
-        final MetricRegistry.MetricSupplier<Counter> supplier = () -> counter;
-        final Counter counter1 = registry.counter(METRIC_THING, supplier);
-        final Counter counter2 = registry.counter(METRIC_THING, supplier);
-
-        assertThat(counter1).isExactlyInstanceOf(NoopMetricRegistry.NoopCounter.class);
-        assertThat(counter2).isExactlyInstanceOf(NoopMetricRegistry.NoopCounter.class);
-        assertThat(counter1).isSameAs(counter2);
-
-        verify(listener, never()).onCounterAdded(METRIC_THING, counter1);
-    }
-
-
-    @Test
-    void removingACounterTriggersNoNotification() {
-        registry.register(METRIC_THING, counter);
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-        assertThat(registry.remove(METRIC_THING)).isFalse();
+final class NoopMetricRegistryTest {
+  private static final MetricName METRIC_THING = MetricName.build("thing");
 
-        verify(listener, never()).onCounterRemoved(METRIC_THING);
-    }
+  private final MetricRegistryListener listener = mock();
+  private final NoopMetricRegistry registry = new NoopMetricRegistry();
+  private final Gauge<String> gauge = () -> "";
+  private final Counter counter = mock();
+  private final Histogram histogram = mock();
+  private final Meter meter = mock();
+  private final Timer timer = mock();
 
-    @Test
-    void registeringAHistogramTriggersNoNotification() {
-        assertThat(registry.register(METRIC_THING, histogram)).isEqualTo(histogram);
+  @BeforeEach
+  void setUp() {
+    registry.addListener(listener);
+  }
 
-        verify(listener, never()).onHistogramAdded(METRIC_THING, histogram);
-    }
+  @Test
+  void registeringAGaugeTriggersNoNotification() {
+    assertThat(registry.register(METRIC_THING, gauge)).isEqualTo(gauge);
 
-    @Test
-    void accessingAHistogramRegistersAndReusesIt() {
-        final Histogram histogram1 = registry.histogram(METRIC_THING);
-        final Histogram histogram2 = registry.histogram(METRIC_THING);
+    verify(listener, never()).onGaugeAdded(METRIC_THING, gauge);
+  }
 
-        assertThat(histogram1).isExactlyInstanceOf(NoopMetricRegistry.NoopHistogram.class);
-        assertThat(histogram2).isExactlyInstanceOf(NoopMetricRegistry.NoopHistogram.class);
-        assertThat(histogram1).isSameAs(histogram2);
+  @Test
+  void removingAGaugeTriggersNoNotification() {
+    registry.register(METRIC_THING, gauge);
 
-        verify(listener, never()).onHistogramAdded(METRIC_THING, histogram1);
-    }
+    assertThat(registry.remove(METRIC_THING)).isFalse();
 
-    @Test
-    void accessingACustomHistogramRegistersAndReusesIt() {
-        final MetricRegistry.MetricSupplier<Histogram> supplier = () -> histogram;
-        final Histogram histogram1 = registry.histogram(METRIC_THING, supplier);
-        final Histogram histogram2 = registry.histogram(METRIC_THING, supplier);
+    verify(listener, never()).onGaugeRemoved(METRIC_THING);
+  }
 
-        assertThat(histogram1).isExactlyInstanceOf(NoopMetricRegistry.NoopHistogram.class);
-        assertThat(histogram2).isExactlyInstanceOf(NoopMetricRegistry.NoopHistogram.class);
-        assertThat(histogram1).isSameAs(histogram2);
+  @Test
+  void registeringACounterTriggersNoNotification() {
+    assertThat(registry.register(METRIC_THING, counter)).isEqualTo(counter);
 
-        verify(listener, never()).onHistogramAdded(METRIC_THING, histogram1);
-    }
+    verify(listener, never()).onCounterAdded(METRIC_THING, counter);
+  }
 
-    @Test
-    void removingAHistogramTriggersNoNotification() {
-        registry.register(METRIC_THING, histogram);
+  @Test
+  void accessingACounterRegistersAndReusesTheCounter() {
+    final Counter counter1 = registry.counter(METRIC_THING);
+    final Counter counter2 = registry.counter(METRIC_THING);
 
-        assertThat(registry.remove(METRIC_THING)).isFalse();
+    assertThat(counter1).isExactlyInstanceOf(NoopMetricRegistry.NoopCounter.class);
+    assertThat(counter2).isExactlyInstanceOf(NoopMetricRegistry.NoopCounter.class);
+    assertThat(counter1).isSameAs(counter2);
 
-        verify(listener, never()).onHistogramRemoved(METRIC_THING);
-    }
+    verify(listener, never()).onCounterAdded(METRIC_THING, counter1);
+  }
 
-    @Test
-    void registeringAMeterTriggersNoNotification() {
-        assertThat(registry.register(METRIC_THING, meter)).isEqualTo(meter);
+  @Test
+  void accessingACustomCounterRegistersAndReusesTheCounter() {
+    final MetricRegistry.MetricSupplier<Counter> supplier = () -> counter;
+    final Counter counter1 = registry.counter(METRIC_THING, supplier);
+    final Counter counter2 = registry.counter(METRIC_THING, supplier);
 
-        verify(listener, never()).onMeterAdded(METRIC_THING, meter);
-    }
+    assertThat(counter1).isExactlyInstanceOf(NoopMetricRegistry.NoopCounter.class);
+    assertThat(counter2).isExactlyInstanceOf(NoopMetricRegistry.NoopCounter.class);
+    assertThat(counter1).isSameAs(counter2);
 
-    @Test
-    void accessingAMeterRegistersAndReusesIt() {
-        final Meter meter1 = registry.meter(METRIC_THING);
-        final Meter meter2 = registry.meter(METRIC_THING);
+    verify(listener, never()).onCounterAdded(METRIC_THING, counter1);
+  }
 
-        assertThat(meter1).isExactlyInstanceOf(NoopMetricRegistry.NoopMeter.class);
-        assertThat(meter2).isExactlyInstanceOf(NoopMetricRegistry.NoopMeter.class);
-        assertThat(meter1).isSameAs(meter2);
+  @Test
+  void removingACounterTriggersNoNotification() {
+    registry.register(METRIC_THING, counter);
 
-        verify(listener, never()).onMeterAdded(METRIC_THING, meter1);
-    }
+    assertThat(registry.remove(METRIC_THING)).isFalse();
 
-    @Test
-    void accessingACustomMeterRegistersAndReusesIt() {
-        final MetricRegistry.MetricSupplier<Meter> supplier = () -> meter;
-        final Meter meter1 = registry.meter(METRIC_THING, supplier);
-        final Meter meter2 = registry.meter(METRIC_THING, supplier);
+    verify(listener, never()).onCounterRemoved(METRIC_THING);
+  }
 
-        assertThat(meter1).isExactlyInstanceOf(NoopMetricRegistry.NoopMeter.class);
-        assertThat(meter2).isExactlyInstanceOf(NoopMetricRegistry.NoopMeter.class);
-        assertThat(meter1).isSameAs(meter2);
+  @Test
+  void registeringAHistogramTriggersNoNotification() {
+    assertThat(registry.register(METRIC_THING, histogram)).isEqualTo(histogram);
 
-        verify(listener, never()).onMeterAdded(METRIC_THING, meter1);
-    }
+    verify(listener, never()).onHistogramAdded(METRIC_THING, histogram);
+  }
 
-    @Test
-    void removingAMeterTriggersNoNotification() {
-        registry.register(METRIC_THING, meter);
+  @Test
+  void accessingAHistogramRegistersAndReusesIt() {
+    final Histogram histogram1 = registry.histogram(METRIC_THING);
+    final Histogram histogram2 = registry.histogram(METRIC_THING);
 
-        assertThat(registry.remove(METRIC_THING)).isFalse();
+    assertThat(histogram1).isExactlyInstanceOf(NoopMetricRegistry.NoopHistogram.class);
+    assertThat(histogram2).isExactlyInstanceOf(NoopMetricRegistry.NoopHistogram.class);
+    assertThat(histogram1).isSameAs(histogram2);
 
-        verify(listener, never()).onMeterRemoved(METRIC_THING);
-    }
+    verify(listener, never()).onHistogramAdded(METRIC_THING, histogram1);
+  }
 
-    @Test
-    void registeringATimerTriggersNoNotification() {
-        assertThat(registry.register(METRIC_THING, timer)).isEqualTo(timer);
+  @Test
+  void accessingACustomHistogramRegistersAndReusesIt() {
+    final MetricRegistry.MetricSupplier<Histogram> supplier = () -> histogram;
+    final Histogram histogram1 = registry.histogram(METRIC_THING, supplier);
+    final Histogram histogram2 = registry.histogram(METRIC_THING, supplier);
 
-        verify(listener, never()).onTimerAdded(METRIC_THING, timer);
-    }
+    assertThat(histogram1).isExactlyInstanceOf(NoopMetricRegistry.NoopHistogram.class);
+    assertThat(histogram2).isExactlyInstanceOf(NoopMetricRegistry.NoopHistogram.class);
+    assertThat(histogram1).isSameAs(histogram2);
 
-    @Test
-    void accessingATimerRegistersAndReusesIt() {
-        final Timer timer1 = registry.timer(METRIC_THING);
-        final Timer timer2 = registry.timer(METRIC_THING);
+    verify(listener, never()).onHistogramAdded(METRIC_THING, histogram1);
+  }
 
-        assertThat(timer1).isExactlyInstanceOf(NoopMetricRegistry.NoopTimer.class);
-        assertThat(timer2).isExactlyInstanceOf(NoopMetricRegistry.NoopTimer.class);
-        assertThat(timer1).isSameAs(timer2);
+  @Test
+  void removingAHistogramTriggersNoNotification() {
+    registry.register(METRIC_THING, histogram);
 
-        verify(listener, never()).onTimerAdded(METRIC_THING, timer1);
-    }
+    assertThat(registry.remove(METRIC_THING)).isFalse();
 
-    @Test
-    void accessingACustomTimerRegistersAndReusesIt() {
-        final MetricRegistry.MetricSupplier<Timer> supplier = () -> timer;
-        final Timer timer1 = registry.timer(METRIC_THING, supplier);
-        final Timer timer2 = registry.timer(METRIC_THING, supplier);
+    verify(listener, never()).onHistogramRemoved(METRIC_THING);
+  }
 
-        assertThat(timer1).isExactlyInstanceOf(NoopMetricRegistry.NoopTimer.class);
-        assertThat(timer2).isExactlyInstanceOf(NoopMetricRegistry.NoopTimer.class);
-        assertThat(timer1).isSameAs(timer2);
+  @Test
+  void registeringAMeterTriggersNoNotification() {
+    assertThat(registry.register(METRIC_THING, meter)).isEqualTo(meter);
 
-        verify(listener, never()).onTimerAdded(METRIC_THING, timer1);
-    }
+    verify(listener, never()).onMeterAdded(METRIC_THING, meter);
+  }
 
+  @Test
+  void accessingAMeterRegistersAndReusesIt() {
+    final Meter meter1 = registry.meter(METRIC_THING);
+    final Meter meter2 = registry.meter(METRIC_THING);
 
-    @Test
-    void removingATimerTriggersNoNotification() {
-        registry.register(METRIC_THING, timer);
+    assertThat(meter1).isExactlyInstanceOf(NoopMetricRegistry.NoopMeter.class);
+    assertThat(meter2).isExactlyInstanceOf(NoopMetricRegistry.NoopMeter.class);
+    assertThat(meter1).isSameAs(meter2);
 
-        assertThat(registry.remove(METRIC_THING)).isFalse();
+    verify(listener, never()).onMeterAdded(METRIC_THING, meter1);
+  }
 
-        verify(listener, never()).onTimerRemoved(METRIC_THING);
-    }
+  @Test
+  void accessingACustomMeterRegistersAndReusesIt() {
+    final MetricRegistry.MetricSupplier<Meter> supplier = () -> meter;
+    final Meter meter1 = registry.meter(METRIC_THING, supplier);
+    final Meter meter2 = registry.meter(METRIC_THING, supplier);
 
-    @Test
-    void accessingAGaugeRegistersAndReusesIt() {
-        final Gauge<Void> gauge1 = registry.gauge(METRIC_THING);
-        final Gauge<Void> gauge2 = registry.gauge(METRIC_THING);
+    assertThat(meter1).isExactlyInstanceOf(NoopMetricRegistry.NoopMeter.class);
+    assertThat(meter2).isExactlyInstanceOf(NoopMetricRegistry.NoopMeter.class);
+    assertThat(meter1).isSameAs(meter2);
 
-        assertThat(gauge1).isExactlyInstanceOf(NoopMetricRegistry.NoopGauge.class);
-        assertThat(gauge2).isExactlyInstanceOf(NoopMetricRegistry.NoopGauge.class);
-        assertThat(gauge1).isSameAs(gauge2);
+    verify(listener, never()).onMeterAdded(METRIC_THING, meter1);
+  }
 
-        verify(listener, never()).onGaugeAdded(METRIC_THING, gauge1);
-    }
+  @Test
+  void removingAMeterTriggersNoNotification() {
+    registry.register(METRIC_THING, meter);
 
-    @Test
-    @SuppressWarnings("rawtypes")
-    void accessingACustomGaugeRegistersAndReusesIt() {
-        final MetricRegistry.MetricSupplier<Gauge<String>> supplier = () -> gauge;
-        final Gauge gauge1 = registry.gauge(METRIC_THING, supplier);
-        final Gauge gauge2 = registry.gauge(METRIC_THING, supplier);
+    assertThat(registry.remove(METRIC_THING)).isFalse();
 
-        assertThat(gauge1).isExactlyInstanceOf(NoopMetricRegistry.NoopGauge.class);
-        assertThat(gauge2).isExactlyInstanceOf(NoopMetricRegistry.NoopGauge.class);
-        assertThat(gauge1).isSameAs(gauge2);
+    verify(listener, never()).onMeterRemoved(METRIC_THING);
+  }
 
-        verify(listener, never()).onGaugeAdded(METRIC_THING, gauge1);
-    }
+  @Test
+  void registeringATimerTriggersNoNotification() {
+    assertThat(registry.register(METRIC_THING, timer)).isEqualTo(timer);
 
+    verify(listener, never()).onTimerAdded(METRIC_THING, timer);
+  }
 
-    @Test
-    void addingAListenerWithExistingMetricsDoesNotNotify() {
-        registry.register(MetricName.build("gauge"), gauge);
-        registry.register(MetricName.build("counter"), counter);
-        registry.register(MetricName.build("histogram"), histogram);
-        registry.register(MetricName.build("meter"), meter);
-        registry.register(MetricName.build("timer"), timer);
+  @Test
+  void accessingATimerRegistersAndReusesIt() {
+    final Timer timer1 = registry.timer(METRIC_THING);
+    final Timer timer2 = registry.timer(METRIC_THING);
 
-        final MetricRegistryListener other = mock(MetricRegistryListener.class);
-        registry.addListener(other);
+    assertThat(timer1).isExactlyInstanceOf(NoopMetricRegistry.NoopTimer.class);
+    assertThat(timer2).isExactlyInstanceOf(NoopMetricRegistry.NoopTimer.class);
+    assertThat(timer1).isSameAs(timer2);
 
-        verify(other, never()).onGaugeAdded(MetricName.build("gauge"), gauge);
-        verify(other, never()).onCounterAdded(MetricName.build("counter"), counter);
-        verify(other, never()).onHistogramAdded(MetricName.build("histogram"), histogram);
-        verify(other, never()).onMeterAdded(MetricName.build("meter"), meter);
-        verify(other, never()).onTimerAdded(MetricName.build("timer"), timer);
-    }
+    verify(listener, never()).onTimerAdded(METRIC_THING, timer1);
+  }
 
-    @Test
-    void aRemovedListenerDoesNotReceiveUpdates() {
-        registry.register(MetricName.build("gauge"), gauge);
-        registry.removeListener(listener);
-        registry.register(MetricName.build("gauge2"), gauge);
+  @Test
+  void accessingACustomTimerRegistersAndReusesIt() {
+    final MetricRegistry.MetricSupplier<Timer> supplier = () -> timer;
+    final Timer timer1 = registry.timer(METRIC_THING, supplier);
+    final Timer timer2 = registry.timer(METRIC_THING, supplier);
 
-        verify(listener, never()).onGaugeAdded(MetricName.build("gauge2"), gauge);
-    }
+    assertThat(timer1).isExactlyInstanceOf(NoopMetricRegistry.NoopTimer.class);
+    assertThat(timer2).isExactlyInstanceOf(NoopMetricRegistry.NoopTimer.class);
+    assertThat(timer1).isSameAs(timer2);
 
-    @Test
-    void hasAMapOfRegisteredGauges() {
-        registry.register(MetricName.build("gauge"), gauge);
+    verify(listener, never()).onTimerAdded(METRIC_THING, timer1);
+  }
 
-        assertThat(registry.getGauges()).isEmpty();
-    }
+  @Test
+  void removingATimerTriggersNoNotification() {
+    registry.register(METRIC_THING, timer);
 
-    @Test
-    void hasAMapOfRegisteredCounters() {
-        registry.register(MetricName.build("counter"), counter);
+    assertThat(registry.remove(METRIC_THING)).isFalse();
 
-        assertThat(registry.getCounters()).isEmpty();
-    }
-
-    @Test
-    void hasAMapOfRegisteredHistograms() {
-        registry.register(MetricName.build("histogram"), histogram);
-
-        assertThat(registry.getHistograms()).isEmpty();
-    }
-
-    @Test
-    void hasAMapOfRegisteredMeters() {
-        registry.register(MetricName.build("meter"), meter);
-
-        assertThat(registry.getMeters()).isEmpty();
-    }
+    verify(listener, never()).onTimerRemoved(METRIC_THING);
+  }
 
-    @Test
-    void hasAMapOfRegisteredTimers() {
-        registry.register(MetricName.build("timer"), timer);
+  @Test
+  void accessingAGaugeRegistersAndReusesIt() {
+    final Gauge<Void> gauge1 = registry.gauge(METRIC_THING);
+    final Gauge<Void> gauge2 = registry.gauge(METRIC_THING);
 
-        assertThat(registry.getTimers()).isEmpty();
-    }
+    assertThat(gauge1).isExactlyInstanceOf(NoopMetricRegistry.NoopGauge.class);
+    assertThat(gauge2).isExactlyInstanceOf(NoopMetricRegistry.NoopGauge.class);
+    assertThat(gauge1).isSameAs(gauge2);
 
-    @Test
-    void hasASetOfRegisteredMetricNames() {
-        registry.register(MetricName.build("gauge"), gauge);
-        registry.register(MetricName.build("counter"), counter);
-        registry.register(MetricName.build("histogram"), histogram);
-        registry.register(MetricName.build("meter"), meter);
-        registry.register(MetricName.build("timer"), timer);
-
-        assertThat(registry.getNames()).isEmpty();
-    }
-
-    @Test
-    void doesNotRegisterMultipleMetrics() {
-        final MetricSet metrics = () -> {
-            final Map<MetricName, Metric> m = new HashMap<>();
-            m.put(MetricName.build("gauge"), gauge);
-            m.put(MetricName.build("counter"), counter);
-            return m;
+    verify(listener, never()).onGaugeAdded(METRIC_THING, gauge1);
+  }
+
+  @SuppressWarnings("rawtypes")
+  @Test
+  void accessingACustomGaugeRegistersAndReusesIt() {
+    final MetricRegistry.MetricSupplier<Gauge<String>> supplier = () -> gauge;
+    final Gauge gauge1 = registry.gauge(METRIC_THING, supplier);
+    final Gauge gauge2 = registry.gauge(METRIC_THING, supplier);
+
+    assertThat(gauge1).isExactlyInstanceOf(NoopMetricRegistry.NoopGauge.class);
+    assertThat(gauge2).isExactlyInstanceOf(NoopMetricRegistry.NoopGauge.class);
+    assertThat(gauge1).isSameAs(gauge2);
+
+    verify(listener, never()).onGaugeAdded(METRIC_THING, gauge1);
+  }
+
+  @Test
+  void addingAListenerWithExistingMetricsDoesNotNotify() {
+    registry.register(MetricName.build("gauge"), gauge);
+    registry.register(MetricName.build("counter"), counter);
+    registry.register(MetricName.build("histogram"), histogram);
+    registry.register(MetricName.build("meter"), meter);
+    registry.register(MetricName.build("timer"), timer);
+
+    final MetricRegistryListener other = mock();
+    registry.addListener(other);
+
+    verify(other, never()).onGaugeAdded(MetricName.build("gauge"), gauge);
+    verify(other, never()).onCounterAdded(MetricName.build("counter"), counter);
+    verify(other, never()).onHistogramAdded(MetricName.build("histogram"), histogram);
+    verify(other, never()).onMeterAdded(MetricName.build("meter"), meter);
+    verify(other, never()).onTimerAdded(MetricName.build("timer"), timer);
+  }
+
+  @Test
+  void aRemovedListenerDoesNotReceiveUpdates() {
+    registry.register(MetricName.build("gauge"), gauge);
+    registry.removeListener(listener);
+    registry.register(MetricName.build("gauge2"), gauge);
+
+    verify(listener, never()).onGaugeAdded(MetricName.build("gauge2"), gauge);
+  }
+
+  @Test
+  void hasAMapOfRegisteredGauges() {
+    registry.register(MetricName.build("gauge"), gauge);
+
+    assertThat(registry.getGauges()).isEmpty();
+  }
+
+  @Test
+  void hasAMapOfRegisteredCounters() {
+    registry.register(MetricName.build("counter"), counter);
+
+    assertThat(registry.getCounters()).isEmpty();
+  }
+
+  @Test
+  void hasAMapOfRegisteredHistograms() {
+    registry.register(MetricName.build("histogram"), histogram);
+
+    assertThat(registry.getHistograms()).isEmpty();
+  }
+
+  @Test
+  void hasAMapOfRegisteredMeters() {
+    registry.register(MetricName.build("meter"), meter);
+
+    assertThat(registry.getMeters()).isEmpty();
+  }
+
+  @Test
+  void hasAMapOfRegisteredTimers() {
+    registry.register(MetricName.build("timer"), timer);
+
+    assertThat(registry.getTimers()).isEmpty();
+  }
+
+  @Test
+  void hasASetOfRegisteredMetricNames() {
+    registry.register(MetricName.build("gauge"), gauge);
+    registry.register(MetricName.build("counter"), counter);
+    registry.register(MetricName.build("histogram"), histogram);
+    registry.register(MetricName.build("meter"), meter);
+    registry.register(MetricName.build("timer"), timer);
+
+    assertThat(registry.getNames()).isEmpty();
+  }
+
+  @Test
+  void doesNotRegisterMultipleMetrics() {
+    final MetricSet metrics =
+        () -> {
+          final Map<MetricName, Metric> m = new HashMap<>();
+          m.put(MetricName.build("gauge"), gauge);
+          m.put(MetricName.build("counter"), counter);
+          return m;
         };
 
-        registry.registerAll(metrics);
+    registry.registerAll(metrics);
 
-        assertThat(registry.getNames()).isEmpty();
-    }
+    assertThat(registry.getNames()).isEmpty();
+  }
 
-    @Test
-    void doesNotRegisterMultipleMetricsWithAPrefix() {
-        final MetricSet metrics = () -> {
-            final Map<MetricName, Metric> m = new HashMap<>();
-            m.put(MetricName.build("gauge"), gauge);
-            m.put(MetricName.build("counter"), counter);
-            return m;
+  @Test
+  void doesNotRegisterMultipleMetricsWithAPrefix() {
+    final MetricSet metrics =
+        () -> {
+          final Map<MetricName, Metric> m = new HashMap<>();
+          m.put(MetricName.build("gauge"), gauge);
+          m.put(MetricName.build("counter"), counter);
+          return m;
         };
 
-        registry.register(MetricName.build("my"), metrics);
+    registry.register(MetricName.build("my"), metrics);
 
-        assertThat(registry.getNames()).isEmpty();
-    }
+    assertThat(registry.getNames()).isEmpty();
+  }
 
-    @Test
-    void doesNotRegisterRecursiveMetricSets() {
-        final MetricSet inner = () -> {
-            final Map<MetricName, Metric> m = new HashMap<>();
-            m.put(MetricName.build("gauge"), gauge);
-            return m;
+  @Test
+  void doesNotRegisterRecursiveMetricSets() {
+    final MetricSet inner =
+        () -> {
+          final Map<MetricName, Metric> m = new HashMap<>();
+          m.put(MetricName.build("gauge"), gauge);
+          return m;
         };
 
-        final MetricSet outer = () -> {
-            final Map<MetricName, Metric> m = new HashMap<>();
-            m.put(MetricName.build("inner"), inner);
-            m.put(MetricName.build("counter"), counter);
-            return m;
+    final MetricSet outer =
+        () -> {
+          final Map<MetricName, Metric> m = new HashMap<>();
+          m.put(MetricName.build("inner"), inner);
+          m.put(MetricName.build("counter"), counter);
+          return m;
         };
 
-        registry.register(MetricName.build("my"), outer);
-
-        assertThat(registry.getNames()).isEmpty();
-    }
-
-    @Test
-    void doesNotRegisterMetricsFromAnotherRegistry() {
-        MetricRegistry other = new MetricRegistry();
-        other.register(MetricName.build("gauge"), gauge);
-        registry.register(MetricName.build("nested"), other);
-        assertThat(registry.getNames()).isEmpty();
-    }
-
-    @Test
-    void removesMetricsMatchingAFilter() {
-        registry.timer("timer-1");
-        registry.timer("timer-2");
-        registry.histogram("histogram-1");
+    registry.register(MetricName.build("my"), outer);
 
-        assertThat(registry.getNames()).isEmpty();
+    assertThat(registry.getNames()).isEmpty();
+  }
 
-        registry.removeMatching((name, metric) -> name.getKey().endsWith("1"));
+  @Test
+  void doesNotRegisterMetricsFromAnotherRegistry() {
+    MetricRegistry other = new MetricRegistry();
+    other.register(MetricName.build("gauge"), gauge);
+    registry.register(MetricName.build("nested"), other);
+    assertThat(registry.getNames()).isEmpty();
+  }
 
-        assertThat(registry.getNames()).isEmpty();
+  @Test
+  void removesMetricsMatchingAFilter() {
+    registry.timer("timer-1");
+    registry.timer("timer-2");
+    registry.histogram("histogram-1");
+
+    assertThat(registry.getNames()).isEmpty();
 
-        verify(listener, never()).onTimerRemoved(MetricName.build("timer-1"));
-        verify(listener, never()).onHistogramRemoved(MetricName.build("histogram-1"));
-    }
+    registry.removeMatching((name, metric) -> name.getKey().endsWith("1"));
+
+    assertThat(registry.getNames()).isEmpty();
 
-    @Test
-    void addingChildMetricAfterRegister() {
-        MetricRegistry parent = new NoopMetricRegistry();
-        MetricRegistry child = new MetricRegistry();
+    verify(listener, never()).onTimerRemoved(MetricName.build("timer-1"));
+    verify(listener, never()).onHistogramRemoved(MetricName.build("histogram-1"));
+  }
 
-        child.counter(MetricName.build("test-1"));
-        parent.register(MetricName.build("child"), child);
-        child.counter(MetricName.build("test-2"));
+  @Test
+  void addingChildMetricAfterRegister() {
+    MetricRegistry parent = new NoopMetricRegistry();
+    MetricRegistry child = new MetricRegistry();
 
-        assertThat(parent.getMetrics()).isEmpty();
-    }
-
-    @Test
-    void addingMultipleChildMetricsAfterRegister() {
-        MetricRegistry parent = new NoopMetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-
-        child.counter(MetricName.build("test-1"));
-        child.counter(MetricName.build("test-2"));
-        parent.register(MetricName.build("child"), child);
-        child.counter(MetricName.build("test-3"));
-        child.counter(MetricName.build("test-4"));
-
-        assertThat(parent.getMetrics()).isEmpty();
-    }
-
-    @Test
-    void addingDeepChildMetricsAfterRegister() {
-        MetricRegistry parent = new NoopMetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-        MetricRegistry deepChild = new MetricRegistry();
-
-        deepChild.counter(MetricName.build("test-1"));
-        child.register(MetricName.build("deep-child"), deepChild);
-        deepChild.counter(MetricName.build("test-2"));
-
-        child.counter(MetricName.build("test-3"));
-        parent.register(MetricName.build("child"), child);
-        child.counter(MetricName.build("test-4"));
-
-        deepChild.counter("test-5");
-
-        assertThat(parent.getMetrics()).isEmpty();
-        assertThat(deepChild.getMetrics()).hasSize(3);
-        assertThat(child.getMetrics()).hasSize(5);
-    }
-
-    @Test
-    void removingChildMetricAfterRegister() {
-        MetricRegistry parent = new NoopMetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-
-        child.counter(MetricName.build("test-1"));
-        parent.register(MetricName.build("child"), child);
-        child.counter(MetricName.build("test-2"));
-
-        child.remove(MetricName.build("test-1"));
-
-        assertThat(parent.getMetrics()).isEmpty();
-        assertThat(child.getMetrics()).doesNotContainKey(MetricName.build("test-1"));
-    }
-
-    @Test
-    void removingMultipleChildMetricsAfterRegister() {
-        MetricRegistry parent = new NoopMetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-
-        child.counter(MetricName.build("test-1"));
-        child.counter(MetricName.build("test-2"));
-        parent.register(MetricName.build("child"), child);
-        child.counter(MetricName.build("test-3"));
-        child.counter(MetricName.build("test-4"));
-
-        child.remove(MetricName.build("test-1"));
-        child.remove(MetricName.build("test-3"));
-
-        assertThat(parent.getMetrics()).isEmpty();
-        assertThat(child.getMetrics()).doesNotContainKeys(MetricName.build("test-1"), MetricName.build("test-3"));
-    }
-
-    @Test
-    void removingDeepChildMetricsAfterRegister() {
-        MetricRegistry parent = new NoopMetricRegistry();
-        MetricRegistry child = new MetricRegistry();
-        MetricRegistry deepChild = new MetricRegistry();
-
-        deepChild.counter(MetricName.build("test-1"));
-        child.register(MetricName.build("deep-child"), deepChild);
-        deepChild.counter(MetricName.build("test-2"));
+    child.counter(MetricName.build("test-1"));
+    parent.register(MetricName.build("child"), child);
+    child.counter(MetricName.build("test-2"));
 
-        child.counter(MetricName.build("test-3"));
-        parent.register(MetricName.build("child"), child);
-        child.counter(MetricName.build("test-4"));
-
-        deepChild.remove(MetricName.build("test-2"));
-
-        Set<MetricName> childMetrics = child.getMetrics().keySet();
-        Set<MetricName> deepChildMetrics = deepChild.getMetrics().keySet();
-
-        assertThat(parent.getMetrics()).isEmpty();
-        assertThat(deepChildMetrics).hasSize(1);
-        assertThat(childMetrics).hasSize(3);
-    }
-
-    @Test
-    void registerNullMetric() {
-        MetricRegistry registry = new NoopMetricRegistry();
-        assertThatNullPointerException()
-                .isThrownBy(() -> registry.register(MetricName.build("any_name"), null))
-                .withMessage("metric == null");
-    }
+    assertThat(parent.getMetrics()).isEmpty();
+  }
+
+  @Test
+  void addingMultipleChildMetricsAfterRegister() {
+    MetricRegistry parent = new NoopMetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+
+    child.counter(MetricName.build("test-1"));
+    child.counter(MetricName.build("test-2"));
+    parent.register(MetricName.build("child"), child);
+    child.counter(MetricName.build("test-3"));
+    child.counter(MetricName.build("test-4"));
+
+    assertThat(parent.getMetrics()).isEmpty();
+  }
+
+  @Test
+  void addingDeepChildMetricsAfterRegister() {
+    MetricRegistry parent = new NoopMetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+    MetricRegistry deepChild = new MetricRegistry();
+
+    deepChild.counter(MetricName.build("test-1"));
+    child.register(MetricName.build("deep-child"), deepChild);
+    deepChild.counter(MetricName.build("test-2"));
+
+    child.counter(MetricName.build("test-3"));
+    parent.register(MetricName.build("child"), child);
+    child.counter(MetricName.build("test-4"));
+
+    deepChild.counter("test-5");
+
+    assertThat(parent.getMetrics()).isEmpty();
+    assertThat(deepChild.getMetrics()).hasSize(3);
+    assertThat(child.getMetrics()).hasSize(5);
+  }
+
+  @Test
+  void removingChildMetricAfterRegister() {
+    MetricRegistry parent = new NoopMetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+
+    child.counter(MetricName.build("test-1"));
+    parent.register(MetricName.build("child"), child);
+    child.counter(MetricName.build("test-2"));
+
+    child.remove(MetricName.build("test-1"));
+
+    assertThat(parent.getMetrics()).isEmpty();
+    assertThat(child.getMetrics()).doesNotContainKey(MetricName.build("test-1"));
+  }
+
+  @Test
+  void removingMultipleChildMetricsAfterRegister() {
+    MetricRegistry parent = new NoopMetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+
+    child.counter(MetricName.build("test-1"));
+    child.counter(MetricName.build("test-2"));
+    parent.register(MetricName.build("child"), child);
+    child.counter(MetricName.build("test-3"));
+    child.counter(MetricName.build("test-4"));
+
+    child.remove(MetricName.build("test-1"));
+    child.remove(MetricName.build("test-3"));
+
+    assertThat(parent.getMetrics()).isEmpty();
+    assertThat(child.getMetrics())
+        .doesNotContainKeys(MetricName.build("test-1"), MetricName.build("test-3"));
+  }
+
+  @Test
+  void removingDeepChildMetricsAfterRegister() {
+    MetricRegistry parent = new NoopMetricRegistry();
+    MetricRegistry child = new MetricRegistry();
+    MetricRegistry deepChild = new MetricRegistry();
+
+    deepChild.counter(MetricName.build("test-1"));
+    child.register(MetricName.build("deep-child"), deepChild);
+    deepChild.counter(MetricName.build("test-2"));
+
+    child.counter(MetricName.build("test-3"));
+    parent.register(MetricName.build("child"), child);
+    child.counter(MetricName.build("test-4"));
+
+    deepChild.remove(MetricName.build("test-2"));
+
+    Set<MetricName> childMetrics = child.getMetrics().keySet();
+    Set<MetricName> deepChildMetrics = deepChild.getMetrics().keySet();
+
+    assertThat(parent.getMetrics()).isEmpty();
+    assertThat(deepChildMetrics).hasSize(1);
+    assertThat(childMetrics).hasSize(3);
+  }
+
+  @Test
+  void registerNullMetric() {
+    MetricRegistry registry = new NoopMetricRegistry();
+    assertThatThrownBy(() -> registry.register(MetricName.build("any_name"), null))
+        .isInstanceOf(NullPointerException.class)
+        .hasMessage("metric == null");
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/RatioGaugeTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/RatioGaugeTest.java
@@ -1,67 +1,66 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class RatioGaugeTest {
-    @Test
-    void ratiosAreHumanReadable() {
-        final RatioGauge.Ratio ratio = RatioGauge.Ratio.of(100, 200);
+import org.junit.jupiter.api.Test;
+
+final class RatioGaugeTest {
+  @Test
+  void ratiosAreHumanReadable() {
+    final RatioGauge.Ratio ratio = RatioGauge.Ratio.of(100, 200);
 
-        assertThat(ratio.toString())
-                .isEqualTo("100.0:200.0");
-    }
+    assertThat(ratio).hasToString("100.0:200.0");
+  }
 
-    @Test
-    void calculatesTheRatioOfTheNumeratorToTheDenominator() {
-        final RatioGauge regular = new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return RatioGauge.Ratio.of(2, 4);
-            }
+  @Test
+  void calculatesTheRatioOfTheNumeratorToTheDenominator() {
+    final RatioGauge regular =
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return RatioGauge.Ratio.of(2, 4);
+          }
         };
 
-        assertThat(regular.getValue())
-                .isEqualTo(0.5);
-    }
+    assertThat(regular.getValue()).isEqualTo(0.5);
+  }
 
-    @Test
-    void handlesDivideByZeroIssues() {
-        final RatioGauge divByZero = new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(100, 0);
-            }
+  @Test
+  void handlesDivideByZeroIssues() {
+    final RatioGauge divByZero =
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(100, 0);
+          }
         };
 
-        assertThat(divByZero.getValue())
-                .isNaN();
-    }
+    assertThat(divByZero.getValue()).isNaN();
+  }
 
-    @Test
-    void handlesInfiniteDenominators() {
-        final RatioGauge infinite = new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(10, Double.POSITIVE_INFINITY);
-            }
+  @Test
+  void handlesInfiniteDenominators() {
+    final RatioGauge infinite =
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(10, Double.POSITIVE_INFINITY);
+          }
         };
 
-        assertThat(infinite.getValue())
-                .isNaN();
-    }
+    assertThat(infinite.getValue()).isNaN();
+  }
 
-    @Test
-    void handlesNaNDenominators() {
-        final RatioGauge nan = new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(10, Double.NaN);
-            }
+  @Test
+  void handlesNaNDenominators() {
+    final RatioGauge nan =
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(10, Double.NaN);
+          }
         };
 
-        assertThat(nan.getValue())
-                .isNaN();
-    }
+    assertThat(nan.getValue()).isNaN();
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/ScheduledReporterTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/ScheduledReporterTest.java
@@ -1,8 +1,15 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.assertj.core.api.Assertions.fail;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
 import java.util.SortedMap;
 import java.util.TreeMap;
@@ -13,279 +20,350 @@ import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-class ScheduledReporterTest {
-    private final Gauge<String> gauge = () -> "";
-    private final Counter counter = mock(Counter.class);
-    private final Histogram histogram = mock(Histogram.class);
-    private final Meter meter = mock(Meter.class);
-    private final Timer timer = mock(Timer.class);
-
-    private final ScheduledExecutorService mockExecutor = mock(ScheduledExecutorService.class);
-    private final ScheduledExecutorService customExecutor = Executors.newSingleThreadScheduledExecutor();
-    private final ScheduledExecutorService externalExecutor = Executors.newSingleThreadScheduledExecutor();
-
-    private final MetricRegistry registry = new MetricRegistry();
-    private final ScheduledReporter reporter = spy(
-            new DummyReporter(registry, "example", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS)
-    );
-    private final ScheduledReporter reporterWithNullExecutor = spy(
-            new DummyReporter(registry, "example", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, null)
-    );
-    private final ScheduledReporter reporterWithCustomMockExecutor = new DummyReporter(registry, "example", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, mockExecutor);
-    private final ScheduledReporter reporterWithCustomExecutor = new DummyReporter(registry, "example", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, customExecutor);
-    private final DummyReporter reporterWithExternallyManagedExecutor = new DummyReporter(registry, "example", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, externalExecutor, false);
-    private final ScheduledReporter[] reporters = new ScheduledReporter[]{reporter, reporterWithCustomExecutor, reporterWithExternallyManagedExecutor};
-
-    @BeforeEach
-    void setUp() throws Exception {
-        registry.register(MetricRegistry.name("gauge"), gauge);
-        registry.register(MetricRegistry.name("counter"), counter);
-        registry.register(MetricRegistry.name("histogram"), histogram);
-        registry.register(MetricRegistry.name("meter"), meter);
-        registry.register(MetricRegistry.name("timer"), timer);
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        customExecutor.shutdown();
-        externalExecutor.shutdown();
-        reporter.stop();
-        reporterWithNullExecutor.stop();
-    }
-
-    @Test
-    void createWithNullMetricRegistry() {
-        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
-        DummyReporter r = null;
-        try {
-            r = new DummyReporter(null, "example", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, executor);
-            fail("NullPointerException must be thrown !!!");
-        } catch (NullPointerException e) {
-            assertEquals("registry == null", e.getMessage());
-        } finally {
-            if (r != null) {
-                r.close();
-            }
-        }
+final class ScheduledReporterTest {
+  private final Gauge<String> gauge = () -> "";
+  private final Counter counter = mock();
+  private final Histogram histogram = mock();
+  private final Meter meter = mock();
+  private final Timer timer = mock();
+
+  private final ScheduledExecutorService mockExecutor = mock();
+  private final ScheduledExecutorService customExecutor =
+      Executors.newSingleThreadScheduledExecutor();
+  private final ScheduledExecutorService externalExecutor =
+      Executors.newSingleThreadScheduledExecutor();
+
+  private final MetricRegistry registry = new MetricRegistry();
+  private final ScheduledReporter reporter =
+      spy(
+          new DummyReporter(
+              registry, "example", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS));
+  private final ScheduledReporter reporterWithNullExecutor =
+      spy(
+          new DummyReporter(
+              registry,
+              "example",
+              MetricFilter.ALL,
+              TimeUnit.SECONDS,
+              TimeUnit.MILLISECONDS,
+              null));
+  private final ScheduledReporter reporterWithCustomMockExecutor =
+      new DummyReporter(
+          registry,
+          "example",
+          MetricFilter.ALL,
+          TimeUnit.SECONDS,
+          TimeUnit.MILLISECONDS,
+          mockExecutor);
+  private final ScheduledReporter reporterWithCustomExecutor =
+      new DummyReporter(
+          registry,
+          "example",
+          MetricFilter.ALL,
+          TimeUnit.SECONDS,
+          TimeUnit.MILLISECONDS,
+          customExecutor);
+  private final DummyReporter reporterWithExternallyManagedExecutor =
+      new DummyReporter(
+          registry,
+          "example",
+          MetricFilter.ALL,
+          TimeUnit.SECONDS,
+          TimeUnit.MILLISECONDS,
+          externalExecutor,
+          false);
+  private final ScheduledReporter[] reporters =
+      new ScheduledReporter[] {
+        reporter, reporterWithCustomExecutor, reporterWithExternallyManagedExecutor
+      };
+
+  @BeforeEach
+  void setUp() throws Exception {
+    registry.register(MetricRegistry.name("gauge"), gauge);
+    registry.register(MetricRegistry.name("counter"), counter);
+    registry.register(MetricRegistry.name("histogram"), histogram);
+    registry.register(MetricRegistry.name("meter"), meter);
+    registry.register(MetricRegistry.name("timer"), timer);
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    customExecutor.shutdown();
+    externalExecutor.shutdown();
+    reporter.stop();
+    reporterWithNullExecutor.stop();
+  }
+
+  @Test
+  void createWithNullMetricRegistry() {
+    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
+    DummyReporter r = null;
+    try {
+      r =
+          new DummyReporter(
+              null, "example", MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, executor);
+      fail("NullPointerException must be thrown !!!");
+    } catch (NullPointerException e) {
+      assertEquals("registry == null", e.getMessage());
+    } finally {
+      if (r != null) {
+        r.close();
+      }
     }
-
-    @Test
-    void pollsPeriodically() throws Exception {
-        CountDownLatch latch = new CountDownLatch(2);
-        reporter.start(100, 100, TimeUnit.MILLISECONDS, () -> {
-            if (latch.getCount() > 0) {
-                reporter.report();
-                latch.countDown();
-            }
+  }
+
+  @Test
+  void pollsPeriodically() throws Exception {
+    CountDownLatch latch = new CountDownLatch(2);
+    reporter.start(
+        100,
+        100,
+        TimeUnit.MILLISECONDS,
+        () -> {
+          if (latch.getCount() > 0) {
+            reporter.report();
+            latch.countDown();
+          }
         });
-        latch.await(5, TimeUnit.SECONDS);
-
-        verify(reporter, times(2)).report(
-                map(MetricName.build("gauge"), gauge),
-                map(MetricName.build("counter"), counter),
-                map(MetricName.build("histogram"), histogram),
-                map(MetricName.build("meter"), meter),
-                map(MetricName.build("timer"), timer)
-        );
-    }
-
-    @Test
-    void shouldUsePeriodAsInitialDelayIfNotSpecifiedOtherwise() throws Exception {
-        reporterWithCustomMockExecutor.start(200, TimeUnit.MILLISECONDS);
-
-        verify(mockExecutor, times(1)).scheduleWithFixedDelay(
-                any(Runnable.class), eq(200L), eq(200L), eq(TimeUnit.MILLISECONDS)
-        );
-    }
-
-    @Test
-    void shouldStartWithSpecifiedInitialDelay() throws Exception {
-        reporterWithCustomMockExecutor.start(350, 100, TimeUnit.MILLISECONDS);
-
-        verify(mockExecutor).scheduleWithFixedDelay(
-                any(Runnable.class), eq(350L), eq(100L), eq(TimeUnit.MILLISECONDS)
-        );
-    }
-
-    @Test
-    void shouldAutoCreateExecutorWhenItNull() throws Exception {
-        CountDownLatch latch = new CountDownLatch(2);
-        reporterWithNullExecutor.start(100, 100, TimeUnit.MILLISECONDS, () -> {
-            if (latch.getCount() > 0) {
-                reporterWithNullExecutor.report();
-                latch.countDown();
-            }
+    latch.await(5, TimeUnit.SECONDS);
+
+    verify(reporter, times(2))
+        .report(
+            map(MetricName.build("gauge"), gauge),
+            map(MetricName.build("counter"), counter),
+            map(MetricName.build("histogram"), histogram),
+            map(MetricName.build("meter"), meter),
+            map(MetricName.build("timer"), timer));
+  }
+
+  @Test
+  void shouldUsePeriodAsInitialDelayIfNotSpecifiedOtherwise() throws Exception {
+    reporterWithCustomMockExecutor.start(200, TimeUnit.MILLISECONDS);
+
+    verify(mockExecutor)
+        .scheduleWithFixedDelay(any(Runnable.class), eq(200L), eq(200L), eq(TimeUnit.MILLISECONDS));
+  }
+
+  @Test
+  void shouldStartWithSpecifiedInitialDelay() throws Exception {
+    reporterWithCustomMockExecutor.start(350, 100, TimeUnit.MILLISECONDS);
+
+    verify(mockExecutor)
+        .scheduleWithFixedDelay(any(Runnable.class), eq(350L), eq(100L), eq(TimeUnit.MILLISECONDS));
+  }
+
+  @Test
+  void shouldAutoCreateExecutorWhenItNull() throws Exception {
+    CountDownLatch latch = new CountDownLatch(2);
+    reporterWithNullExecutor.start(
+        100,
+        100,
+        TimeUnit.MILLISECONDS,
+        () -> {
+          if (latch.getCount() > 0) {
+            reporterWithNullExecutor.report();
+            latch.countDown();
+          }
         });
-        latch.await(5, TimeUnit.SECONDS);
-        verify(reporterWithNullExecutor, times(2)).report(
-                map(MetricName.build("gauge"), gauge),
-                map(MetricName.build("counter"), counter),
-                map(MetricName.build("histogram"), histogram),
-                map(MetricName.build("meter"), meter),
-                map(MetricName.build("timer"), timer)
-        );
+    latch.await(5, TimeUnit.SECONDS);
+    verify(reporterWithNullExecutor, times(2))
+        .report(
+            map(MetricName.build("gauge"), gauge),
+            map(MetricName.build("counter"), counter),
+            map(MetricName.build("histogram"), histogram),
+            map(MetricName.build("meter"), meter),
+            map(MetricName.build("timer"), timer));
+  }
+
+  @Test
+  void shouldDisallowToStartReportingMultiple() throws Exception {
+    assertThatThrownBy(
+            () -> {
+              reporter.start(200, TimeUnit.MILLISECONDS);
+              reporter.start(200, TimeUnit.MILLISECONDS);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void shouldDisallowToStartReportingMultipleTimesOnCustomExecutor() throws Exception {
+    assertThatThrownBy(
+            () -> {
+              reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);
+              reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void shouldDisallowToStartReportingMultipleTimesOnExternallyManagedExecutor() throws Exception {
+    assertThatThrownBy(
+            () -> {
+              reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);
+              reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void shouldNotFailOnStopIfReporterWasNotStared() {
+    for (ScheduledReporter reporter : reporters) {
+      reporter.stop();
     }
-
-    @Test
-    void shouldDisallowToStartReportingMultiple() throws Exception {
-        assertThrows(IllegalArgumentException.class, () -> {
-            reporter.start(200, TimeUnit.MILLISECONDS);
-            reporter.start(200, TimeUnit.MILLISECONDS);
-        });
+  }
+
+  @Test
+  void shouldNotFailWhenStoppingMultipleTimes() {
+    for (ScheduledReporter reporter : reporters) {
+      reporter.start(200, TimeUnit.MILLISECONDS);
+      reporter.stop();
+      reporter.stop();
+      reporter.stop();
     }
-
-    @Test
-    void shouldDisallowToStartReportingMultipleTimesOnCustomExecutor() throws Exception {
-        assertThrows(IllegalArgumentException.class, () -> {
-            reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);
-            reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);
+  }
+
+  @Test
+  void shouldShutdownExecutorOnStopByDefault() {
+    reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);
+    reporterWithCustomExecutor.stop();
+    assertThat(customExecutor.isTerminated()).isTrue();
+  }
+
+  @Test
+  void shouldNotShutdownExternallyManagedExecutorOnStop() {
+    reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);
+    reporterWithExternallyManagedExecutor.stop();
+    assertThat(mockExecutor.isTerminated()).isFalse();
+    assertThat(mockExecutor.isShutdown()).isFalse();
+  }
+
+  @Test
+  void shouldCancelScheduledFutureWhenStoppingWithExternallyManagedExecutor()
+      throws InterruptedException, ExecutionException, TimeoutException {
+    // configure very frequency rate of execution
+    reporterWithExternallyManagedExecutor.start(1, TimeUnit.MILLISECONDS);
+    reporterWithExternallyManagedExecutor.stop();
+    Thread.sleep(100);
+
+    // executionCount should not increase when scheduled future is canceled properly
+    int executionCount = reporterWithExternallyManagedExecutor.executionCount.get();
+    Thread.sleep(500);
+    assertEquals(executionCount, reporterWithExternallyManagedExecutor.executionCount.get());
+  }
+
+  @Test
+  void shouldConvertDurationToMillisecondsPrecisely() {
+    assertEquals(2.0E-5, reporter.convertDuration(20), 0.0);
+  }
+
+  @Test
+  void shouldReportMetricsOnShutdown() throws Exception {
+    CountDownLatch latch = new CountDownLatch(1);
+    reporterWithNullExecutor.start(
+        0,
+        10,
+        TimeUnit.SECONDS,
+        () -> {
+          if (latch.getCount() > 0) {
+            reporterWithNullExecutor.report();
+            latch.countDown();
+          }
         });
-    }
-
-    @Test
-    void shouldDisallowToStartReportingMultipleTimesOnExternallyManagedExecutor() throws Exception {
-        assertThrows(IllegalArgumentException.class, () -> {
-            reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);
-            reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);
+    latch.await(5, TimeUnit.SECONDS);
+    reporterWithNullExecutor.stop();
+
+    verify(reporterWithNullExecutor, times(2))
+        .report(
+            map(MetricName.build("gauge"), gauge),
+            map(MetricName.build("counter"), counter),
+            map(MetricName.build("histogram"), histogram),
+            map(MetricName.build("meter"), meter),
+            map(MetricName.build("timer"), timer));
+  }
+
+  @Test
+  void shouldRescheduleAfterReportFinish() throws Exception {
+    // the first report is triggered at T + 0.1 seconds and takes 0.8 seconds
+    // after the first report finishes at T + 0.9 seconds the next report is scheduled to run at T +
+    // 1.4 seconds
+    reporter.start(
+        100,
+        500,
+        TimeUnit.MILLISECONDS,
+        () -> {
+          reporter.report();
+          try {
+            Thread.sleep(800);
+          } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+          }
         });
-    }
-
-    @Test
-    void shouldNotFailOnStopIfReporterWasNotStared() {
-        for (ScheduledReporter reporter : reporters) {
-            reporter.stop();
-        }
-    }
-
-    @Test
-    void shouldNotFailWhenStoppingMultipleTimes() {
-        for (ScheduledReporter reporter : reporters) {
-            reporter.start(200, TimeUnit.MILLISECONDS);
-            reporter.stop();
-            reporter.stop();
-            reporter.stop();
-        }
-    }
-
-    @Test
-    void shouldShutdownExecutorOnStopByDefault() {
-        reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);
-        reporterWithCustomExecutor.stop();
-        assertTrue(customExecutor.isTerminated());
-    }
-
-    @Test
-    void shouldNotShutdownExternallyManagedExecutorOnStop() {
-        reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);
-        reporterWithExternallyManagedExecutor.stop();
-        assertFalse(mockExecutor.isTerminated());
-        assertFalse(mockExecutor.isShutdown());
-    }
-
-    @Test
-    void shouldCancelScheduledFutureWhenStoppingWithExternallyManagedExecutor() throws InterruptedException, ExecutionException, TimeoutException {
-        // configure very frequency rate of execution
-        reporterWithExternallyManagedExecutor.start(1, TimeUnit.MILLISECONDS);
-        reporterWithExternallyManagedExecutor.stop();
-        Thread.sleep(100);
-
-        // executionCount should not increase when scheduled future is canceled properly
-        int executionCount = reporterWithExternallyManagedExecutor.executionCount.get();
-        Thread.sleep(500);
-        assertEquals(executionCount, reporterWithExternallyManagedExecutor.executionCount.get());
-    }
-
-    @Test
-    void shouldConvertDurationToMillisecondsPrecisely() {
-        assertEquals(2.0E-5, reporter.convertDuration(20), 0.0);
-    }
 
-    @Test
-    void shouldReportMetricsOnShutdown() throws Exception {
-        CountDownLatch latch = new CountDownLatch(1);
-        reporterWithNullExecutor.start(0, 10, TimeUnit.SECONDS, () -> {
-            if (latch.getCount() > 0) {
-                reporterWithNullExecutor.report();
-                latch.countDown();
-            }
-        });
-        latch.await(5, TimeUnit.SECONDS);
-        reporterWithNullExecutor.stop();
-
-        verify(reporterWithNullExecutor, times(2)).report(
-                map(MetricName.build("gauge"), gauge),
-                map(MetricName.build("counter"), counter),
-                map(MetricName.build("histogram"), histogram),
-                map(MetricName.build("meter"), meter),
-                map(MetricName.build("timer"), timer)
-        );
+    Thread.sleep(1_000);
+
+    verify(reporter)
+        .report(
+            map(MetricName.build("gauge"), gauge),
+            map(MetricName.build("counter"), counter),
+            map(MetricName.build("histogram"), histogram),
+            map(MetricName.build("meter"), meter),
+            map(MetricName.build("timer"), timer));
+  }
+
+  private <T> SortedMap<MetricName, T> map(MetricName name, T value) {
+    final SortedMap<MetricName, T> map = new TreeMap<>();
+    map.put(name, value);
+    return map;
+  }
+
+  private static class DummyReporter extends ScheduledReporter {
+
+    private AtomicInteger executionCount = new AtomicInteger();
+
+    DummyReporter(
+        MetricRegistry registry,
+        String name,
+        MetricFilter filter,
+        TimeUnit rateUnit,
+        TimeUnit durationUnit) {
+      super(registry, name, filter, rateUnit, durationUnit);
     }
 
-    @Test
-    void shouldRescheduleAfterReportFinish() throws Exception {
-        // the first report is triggered at T + 0.1 seconds and takes 0.8 seconds
-        // after the first report finishes at T + 0.9 seconds the next report is scheduled to run at T + 1.4 seconds
-        reporter.start(100, 500, TimeUnit.MILLISECONDS, () -> {
-            reporter.report();
-            try {
-                Thread.sleep(800);
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-            }
-        });
-
-        Thread.sleep(1_000);
-
-        verify(reporter, times(1)).report(
-                map(MetricName.build("gauge"), gauge),
-                map(MetricName.build("counter"), counter),
-                map(MetricName.build("histogram"), histogram),
-                map(MetricName.build("meter"), meter),
-                map(MetricName.build("timer"), timer)
-        );
+    DummyReporter(
+        MetricRegistry registry,
+        String name,
+        MetricFilter filter,
+        TimeUnit rateUnit,
+        TimeUnit durationUnit,
+        ScheduledExecutorService executor) {
+      super(registry, name, filter, rateUnit, durationUnit, executor);
     }
 
-    private <T> SortedMap<MetricName, T> map(MetricName name, T value) {
-        final SortedMap<MetricName, T> map = new TreeMap<>();
-        map.put(name, value);
-        return map;
+    DummyReporter(
+        MetricRegistry registry,
+        String name,
+        MetricFilter filter,
+        TimeUnit rateUnit,
+        TimeUnit durationUnit,
+        ScheduledExecutorService executor,
+        boolean shutdownExecutorOnStop) {
+      super(registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop);
     }
 
-    private static class DummyReporter extends ScheduledReporter {
-
-        private AtomicInteger executionCount = new AtomicInteger();
-
-        DummyReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit) {
-            super(registry, name, filter, rateUnit, durationUnit);
-        }
-
-        DummyReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit, ScheduledExecutorService executor) {
-            super(registry, name, filter, rateUnit, durationUnit, executor);
-        }
-
-        DummyReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit, ScheduledExecutorService executor, boolean shutdownExecutorOnStop) {
-            super(registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop);
-        }
-
-        @Override
-        @SuppressWarnings("rawtypes")
-        public void report(SortedMap<MetricName, Gauge<?>> gauges, SortedMap<MetricName, Counter> counters, SortedMap<MetricName, Histogram> histograms, SortedMap<MetricName, Meter> meters, SortedMap<MetricName, Timer> timers) {
-            executionCount.incrementAndGet();
-            // nothing doing!
-        }
+    @Override
+    @SuppressWarnings("rawtypes")
+    public void report(
+        SortedMap<MetricName, Gauge<?>> gauges,
+        SortedMap<MetricName, Counter> counters,
+        SortedMap<MetricName, Histogram> histograms,
+        SortedMap<MetricName, Meter> meters,
+        SortedMap<MetricName, Timer> timers) {
+      executionCount.incrementAndGet();
+      // nothing doing!
     }
-
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/SharedMetricRegistriesTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/SharedMetricRegistriesTest.java
@@ -1,95 +1,95 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.util.concurrent.atomic.AtomicReference;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-class SharedMetricRegistriesTest {
-
-    @BeforeEach
-    void setUp() {
-        SharedMetricRegistries.setDefaultRegistryName(new AtomicReference<>());
-        SharedMetricRegistries.clear();
-    }
-
-    @Test
-    void memorizesRegistriesByName() {
-        final MetricRegistry one = SharedMetricRegistries.getOrCreate("one");
-        final MetricRegistry two = SharedMetricRegistries.getOrCreate("one");
-
-        assertThat(one)
-                .isSameAs(two);
-    }
-
-    @Test
-    void hasASetOfNames() {
-        SharedMetricRegistries.getOrCreate("one");
-
-        assertThat(SharedMetricRegistries.names())
-                .containsOnly("one");
-    }
-
-    @Test
-    void removesRegistries() {
-        final MetricRegistry one = SharedMetricRegistries.getOrCreate("one");
-        SharedMetricRegistries.remove("one");
-
-        assertThat(SharedMetricRegistries.names())
-                .isEmpty();
-
-        final MetricRegistry two = SharedMetricRegistries.getOrCreate("one");
-        assertThat(two)
-                .isNotSameAs(one);
-    }
-
-    @Test
-    void clearsRegistries() {
-        SharedMetricRegistries.getOrCreate("one");
-        SharedMetricRegistries.getOrCreate("two");
-
-        SharedMetricRegistries.clear();
-
-        assertThat(SharedMetricRegistries.names())
-                .isEmpty();
-    }
-
-    @Test
-    void errorsWhenDefaultUnset() {
-        Throwable exception = assertThrows(IllegalStateException.class, () -> {
-            SharedMetricRegistries.getDefault();
-        });
-        assertTrue(exception.getMessage().contains("Default registry name has not been set."));
-    }
-
-    @Test
-    void createsDefaultRegistries() {
-        final String defaultName = "default";
-        final MetricRegistry registry = SharedMetricRegistries.setDefault(defaultName);
-        assertThat(registry).isNotNull();
-        assertThat(SharedMetricRegistries.getDefault()).isEqualTo(registry);
-        assertThat(SharedMetricRegistries.getOrCreate(defaultName)).isEqualTo(registry);
-    }
-
-    @Test
-    void errorsWhenDefaultAlreadySet() {
-        Throwable exception = assertThrows(IllegalStateException.class, () -> {
-            SharedMetricRegistries.setDefault("foobah");
-            SharedMetricRegistries.setDefault("borg");
-        });
-        assertTrue(exception.getMessage().contains("Default metric registry name is already set."));
-    }
-
-    @Test
-    void setsDefaultExistingRegistries() {
-        final String defaultName = "default";
-        final MetricRegistry registry = new MetricRegistry();
-        assertThat(SharedMetricRegistries.setDefault(defaultName, registry)).isEqualTo(registry);
-        assertThat(SharedMetricRegistries.getDefault()).isEqualTo(registry);
-        assertThat(SharedMetricRegistries.getOrCreate(defaultName)).isEqualTo(registry);
-    }
+final class SharedMetricRegistriesTest {
+
+  @BeforeEach
+  void setUp() {
+    SharedMetricRegistries.setDefaultRegistryName(new AtomicReference<>());
+    SharedMetricRegistries.clear();
+  }
+
+  @Test
+  void memorizesRegistriesByName() {
+    final MetricRegistry one = SharedMetricRegistries.getOrCreate("one");
+    final MetricRegistry two = SharedMetricRegistries.getOrCreate("one");
+
+    assertThat(one).isSameAs(two);
+  }
+
+  @Test
+  void hasASetOfNames() {
+    SharedMetricRegistries.getOrCreate("one");
+
+    assertThat(SharedMetricRegistries.names()).containsExactly("one");
+  }
+
+  @Test
+  void removesRegistries() {
+    final MetricRegistry one = SharedMetricRegistries.getOrCreate("one");
+    SharedMetricRegistries.remove("one");
+
+    assertThat(SharedMetricRegistries.names()).isEmpty();
+
+    final MetricRegistry two = SharedMetricRegistries.getOrCreate("one");
+    assertThat(two).isNotSameAs(one);
+  }
+
+  @Test
+  void clearsRegistries() {
+    SharedMetricRegistries.getOrCreate("one");
+    SharedMetricRegistries.getOrCreate("two");
+
+    SharedMetricRegistries.clear();
+
+    assertThat(SharedMetricRegistries.names()).isEmpty();
+  }
+
+  @Test
+  void errorsWhenDefaultUnset() {
+    Throwable exception =
+        assertThrows(
+            IllegalStateException.class,
+            () -> {
+              SharedMetricRegistries.getDefault();
+            });
+    assertThat(exception.getMessage().contains("Default registry name has not been set.")).isTrue();
+  }
+
+  @Test
+  void createsDefaultRegistries() {
+    final String defaultName = "default";
+    final MetricRegistry registry = SharedMetricRegistries.setDefault(defaultName);
+    assertThat(registry).isNotNull();
+    assertThat(SharedMetricRegistries.getDefault()).isEqualTo(registry);
+    assertThat(SharedMetricRegistries.getOrCreate(defaultName)).isEqualTo(registry);
+  }
+
+  @Test
+  void errorsWhenDefaultAlreadySet() {
+    Throwable exception =
+        assertThrows(
+            IllegalStateException.class,
+            () -> {
+              SharedMetricRegistries.setDefault("foobah");
+              SharedMetricRegistries.setDefault("borg");
+            });
+    assertThat(exception.getMessage().contains("Default metric registry name is already set."))
+        .isTrue();
+  }
+
+  @Test
+  void setsDefaultExistingRegistries() {
+    final String defaultName = "default";
+    final MetricRegistry registry = new MetricRegistry();
+    assertThat(SharedMetricRegistries.setDefault(defaultName, registry)).isEqualTo(registry);
+    assertThat(SharedMetricRegistries.getDefault()).isEqualTo(registry);
+    assertThat(SharedMetricRegistries.getOrCreate(defaultName)).isEqualTo(registry);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/SimpleSettableGaugeTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/SimpleSettableGaugeTest.java
@@ -1,29 +1,26 @@
 package io.dropwizard.metrics5;
 
-import io.dropwizard.metrics5.DefaultSettableGauge;
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class SimpleSettableGaugeTest {
+import org.junit.jupiter.api.Test;
+
+final class SimpleSettableGaugeTest {
 
-    @Test
-    void defaultValue() {
-        DefaultSettableGauge<Integer> settable = new DefaultSettableGauge<>(1);
+  @Test
+  void defaultValue() {
+    DefaultSettableGauge<Integer> settable = new DefaultSettableGauge<>(1);
 
-        assertThat(settable.getValue()).isEqualTo(1);
-    }
+    assertThat(settable.getValue()).isEqualTo(1);
+  }
 
-    @Test
-    void setValueAndThenGetValue() {
-        DefaultSettableGauge<String> settable = new DefaultSettableGauge<>("default");
+  @Test
+  void setValueAndThenGetValue() {
+    DefaultSettableGauge<String> settable = new DefaultSettableGauge<>("default");
 
-        settable.setValue("first");
-        assertThat(settable.getValue())
-                .isEqualTo("first");
+    settable.setValue("first");
+    assertThat(settable.getValue()).isEqualTo("first");
 
-        settable.setValue("second");
-        assertThat(settable.getValue())
-                .isEqualTo("second");
-    }
+    settable.setValue("second");
+    assertThat(settable.getValue()).isEqualTo("second");
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/Slf4jReporterTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/Slf4jReporterTest.java
@@ -1,19 +1,8 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-import org.slf4j.Logger;
-import org.slf4j.Marker;
-
-import java.util.EnumSet;
-import java.util.Set;
-import java.util.SortedMap;
-import java.util.TreeMap;
-import java.util.concurrent.TimeUnit;
-
 import static io.dropwizard.metrics5.MetricAttribute.COUNT;
 import static io.dropwizard.metrics5.MetricAttribute.M1_RATE;
 import static io.dropwizard.metrics5.MetricAttribute.MEAN_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.MIN;
 import static io.dropwizard.metrics5.MetricAttribute.P50;
 import static io.dropwizard.metrics5.MetricAttribute.P999;
 import static io.dropwizard.metrics5.MetricAttribute.STDDEV;
@@ -21,342 +10,330 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-class Slf4jReporterTest {
-
-    private final Logger logger = mock(Logger.class);
-    private final Marker marker = mock(Marker.class);
-    private final MetricRegistry registry = mock(MetricRegistry.class);
-
-    /**
-     * The set of disabled metric attributes to pass to the Slf4jReporter builder
-     * in the default factory methods of {@link #infoReporter}
-     * and {@link #errorReporter}.
-     *
-     * This value can be overridden by tests before calling the {@link #infoReporter}
-     * and {@link #errorReporter} factory methods.
-     */
-    private Set<MetricAttribute> disabledMetricAttributes = null;
-
-    private Slf4jReporter infoReporter() {
-        return Slf4jReporter.forRegistry(registry)
-                .outputTo(logger)
-                .markWith(marker)
-                .prefixedWith("prefix")
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .withLoggingLevel(Slf4jReporter.LoggingLevel.INFO)
-                .filter(MetricFilter.ALL)
-                .disabledMetricAttributes(disabledMetricAttributes)
-                .build();
-    }
-
-    private Slf4jReporter errorReporter() {
-        return Slf4jReporter.forRegistry(registry)
-                .outputTo(logger)
-                .markWith(marker)
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .withLoggingLevel(Slf4jReporter.LoggingLevel.ERROR)
-                .filter(MetricFilter.ALL)
-                .disabledMetricAttributes(disabledMetricAttributes)
-                .build();
-    }
-
-    @Test
-    void reportsGaugeValuesAtErrorDefault() {
-        reportsGaugeValuesAtError();
-    }
-
-    @Test
-    void reportsGaugeValuesAtErrorAllDisabled() {
-        disabledMetricAttributes = EnumSet.allOf(MetricAttribute.class); // has no effect
-        reportsGaugeValuesAtError();
-    }
-
-    private void reportsGaugeValuesAtError() {
-        when(logger.isErrorEnabled(marker)).thenReturn(true);
-        errorReporter().report(map("gauge", () -> "value"),
-                map(),
-                map(),
-                map(),
-                map());
-
-        verify(logger).error(marker, "type=GAUGE, name=gauge, value=value");
-    }
-
-
-    private Timer timer() {
-        final Timer timer = mock(Timer.class);
-        when(timer.getCount()).thenReturn(1L);
-
-        when(timer.getMeanRate()).thenReturn(2.0);
-        when(timer.getOneMinuteRate()).thenReturn(3.0);
-        when(timer.getFiveMinuteRate()).thenReturn(4.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(5.0);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
-        when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
-        when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
-        when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
-        when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
-        when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
-        when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
-        when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
-        when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
-        when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS
-                .toNanos(1000));
-
-        when(timer.getSnapshot()).thenReturn(snapshot);
-        return timer;
-    }
-
-    private Histogram histogram() {
-        final Histogram histogram = mock(Histogram.class);
-        when(histogram.getCount()).thenReturn(1L);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(2L);
-        when(snapshot.getMean()).thenReturn(3.0);
-        when(snapshot.getMin()).thenReturn(4L);
-        when(snapshot.getStdDev()).thenReturn(5.0);
-        when(snapshot.getMedian()).thenReturn(6.0);
-        when(snapshot.get75thPercentile()).thenReturn(7.0);
-        when(snapshot.get95thPercentile()).thenReturn(8.0);
-        when(snapshot.get98thPercentile()).thenReturn(9.0);
-        when(snapshot.get99thPercentile()).thenReturn(10.0);
-        when(snapshot.get999thPercentile()).thenReturn(11.0);
-
-        when(histogram.getSnapshot()).thenReturn(snapshot);
-        return histogram;
-    }
-
-    private Meter meter() {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getMeanRate()).thenReturn(2.0);
-        when(meter.getOneMinuteRate()).thenReturn(3.0);
-        when(meter.getFiveMinuteRate()).thenReturn(4.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(5.0);
-        return meter;
-    }
-
-    private Counter counter() {
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(100L);
-        return counter;
-    }
-
-    @Test
-    void reportsCounterValuesAtErrorDefault() {
-        reportsCounterValuesAtError();
-    }
-
-    @Test
-    void reportsCounterValuesAtErrorAllDisabled() {
-        disabledMetricAttributes = EnumSet.allOf(MetricAttribute.class); // has no effect
-        reportsCounterValuesAtError();
-    }
-
-    private void reportsCounterValuesAtError() {
-        final Counter counter = counter();
-        when(logger.isErrorEnabled(marker)).thenReturn(true);
-
-        errorReporter().report(map(),
-                map("test.counter", counter),
-                map(),
-                map(),
-                map());
-
-        verify(logger).error(marker, "type=COUNTER, name=test.counter, count=100");
-    }
-
-    @Test
-    void reportsHistogramValuesAtErrorDefault() {
-        reportsHistogramValuesAtError("type=HISTOGRAM, name=test.histogram, count=1, min=4, " +
-                "max=2, mean=3.0, stddev=5.0, p50=6.0, p75=7.0, p95=8.0, p98=9.0, p99=10.0, p999=11.0");
-    }
-
-    @Test
-    void reportsHistogramValuesAtErrorWithDisabledMetricAttributes() {
-        disabledMetricAttributes = EnumSet.of(COUNT, MIN, P50);
-        reportsHistogramValuesAtError("type=HISTOGRAM, name=test.histogram, max=2, mean=3.0, " +
-                "stddev=5.0, p75=7.0, p95=8.0, p98=9.0, p99=10.0, p999=11.0");
-    }
-
-    private void reportsHistogramValuesAtError(final String expectedLog) {
-        final Histogram histogram = histogram();
-        when(logger.isErrorEnabled(marker)).thenReturn(true);
-
-        errorReporter().report(map(),
-                map(),
-                map("test.histogram", histogram),
-                map(),
-                map());
-
-        verify(logger).error(marker, expectedLog);
-    }
-
-    @Test
-    void reportsMeterValuesAtErrorDefault() {
-        reportsMeterValuesAtError("type=METER, name=test.meter, count=1, m1_rate=3.0, m5_rate=4.0, " +
-                "m15_rate=5.0, mean_rate=2.0, rate_unit=events/second");
-    }
-
-    @Test
-    void reportsMeterValuesAtErrorWithDisabledMetricAttributes() {
-        disabledMetricAttributes = EnumSet.of(MIN, P50, M1_RATE);
-        reportsMeterValuesAtError("type=METER, name=test.meter, count=1, m5_rate=4.0, m15_rate=5.0, " +
-                "mean_rate=2.0, rate_unit=events/second");
-    }
-
-    private void reportsMeterValuesAtError(final String expectedLog) {
-        final Meter meter = meter();
-        when(logger.isErrorEnabled(marker)).thenReturn(true);
-
-        errorReporter().report(map(),
-                map(),
-                map(),
-                map("test.meter", meter),
-                map());
-
-        verify(logger).error(marker, expectedLog);
-    }
-
-
-    @Test
-    void reportsTimerValuesAtErrorDefault() {
-        reportsTimerValuesAtError("type=TIMER, name=test.another.timer, count=1, min=300.0, max=100.0, " +
-                "mean=200.0, stddev=400.0, p50=500.0, p75=600.0, p95=700.0, p98=800.0, p99=900.0, p999=1000.0, " +
-                "m1_rate=3.0, m5_rate=4.0, m15_rate=5.0, mean_rate=2.0, rate_unit=events/second, " +
-                "duration_unit=milliseconds");
-    }
-
-    @Test
-    void reportsTimerValuesAtErrorWithDisabledMetricAttributes() {
-        disabledMetricAttributes = EnumSet.of(MIN, STDDEV, P999, MEAN_RATE);
-        reportsTimerValuesAtError("type=TIMER, name=test.another.timer, count=1, max=100.0, mean=200.0, " +
-                "p50=500.0, p75=600.0, p95=700.0, p98=800.0, p99=900.0, m1_rate=3.0, m5_rate=4.0, m15_rate=5.0, " +
-                "rate_unit=events/second, duration_unit=milliseconds");
-    }
-
-    private void reportsTimerValuesAtError(final String expectedLog) {
-        final Timer timer = timer();
-
-        when(logger.isErrorEnabled(marker)).thenReturn(true);
-
-        errorReporter().report(map(),
-                map(),
-                map(),
-                map(),
-                map("test.another.timer", timer));
-
-        verify(logger).error(marker, expectedLog);
-    }
-
-    @Test
-    void reportsGaugeValuesDefault() {
-        when(logger.isInfoEnabled(marker)).thenReturn(true);
-        infoReporter().report(map("gauge", () -> "value"),
-                map(),
-                map(),
-                map(),
-                map());
-
-        verify(logger).info(marker, "type=GAUGE, name=prefix.gauge, value=value");
-    }
-
-
-    @Test
-    void reportsCounterValuesDefault() {
-        final Counter counter = counter();
-        when(logger.isInfoEnabled(marker)).thenReturn(true);
-
-        infoReporter().report(map(),
-                map("test.counter", counter),
-                map(),
-                map(),
-                map());
-
-        verify(logger).info(marker, "type=COUNTER, name=prefix.test.counter, count=100");
-    }
-
-    @Test
-    void reportsHistogramValuesDefault() {
-        final Histogram histogram = histogram();
-        when(logger.isInfoEnabled(marker)).thenReturn(true);
-
-        infoReporter().report(map(),
-                map(),
-                map("test.histogram", histogram),
-                map(),
-                map());
-
-        verify(logger).info(marker, "type=HISTOGRAM, name=prefix.test.histogram, count=1, min=4, max=2, mean=3.0, " +
-                "stddev=5.0, p50=6.0, p75=7.0, p95=8.0, p98=9.0, p99=10.0, p999=11.0");
-    }
-
-    @Test
-    void reportsMeterValuesDefault() {
-        final Meter meter = meter();
-        when(logger.isInfoEnabled(marker)).thenReturn(true);
-
-        infoReporter().report(map(),
-                map(),
-                map(),
-                map("test.meter", meter),
-                map());
-
-        verify(logger).info(marker, "type=METER, name=prefix.test.meter, count=1, m1_rate=3.0, m5_rate=4.0, " +
-                "m15_rate=5.0, mean_rate=2.0, rate_unit=events/second");
-    }
-
-    @Test
-    void reportsTimerValuesDefault() {
-        final Timer timer = timer();
-        when(logger.isInfoEnabled(marker)).thenReturn(true);
-
-        infoReporter().report(map(),
-                map(),
-                map(),
-                map(),
-                map("test.another.timer", timer));
-
-        verify(logger).info(marker, "type=TIMER, name=prefix.test.another.timer, count=1, min=300.0, max=100.0, " +
-                "mean=200.0, stddev=400.0, p50=500.0, p75=600.0, p95=700.0, p98=800.0, p99=900.0, p999=1000.0," +
-                " m1_rate=3.0, m5_rate=4.0, m15_rate=5.0, mean_rate=2.0, rate_unit=events/second, duration_unit=milliseconds");
-    }
-
-
-    @Test
-    void reportsAllMetricsDefault() {
-        when(logger.isInfoEnabled(marker)).thenReturn(true);
-
-        infoReporter().report(map("test.gauge", () -> "value"),
-                map("test.counter", counter()),
-                map("test.histogram", histogram()),
-                map("test.meter", meter()),
-                map("test.timer", timer()));
-
-        verify(logger).info(marker, "type=GAUGE, name=prefix.test.gauge, value=value");
-        verify(logger).info(marker, "type=COUNTER, name=prefix.test.counter, count=100");
-        verify(logger).info(marker, "type=HISTOGRAM, name=prefix.test.histogram, count=1, min=4, max=2, mean=3.0, " +
-                "stddev=5.0, p50=6.0, p75=7.0, p95=8.0, p98=9.0, p99=10.0, p999=11.0");
-        verify(logger).info(marker, "type=METER, name=prefix.test.meter, count=1, m1_rate=3.0, m5_rate=4.0, " +
-                "m15_rate=5.0, mean_rate=2.0, rate_unit=events/second");
-        verify(logger).info(marker, "type=TIMER, name=prefix.test.timer, count=1, min=300.0, max=100.0, " +
-                "mean=200.0, stddev=400.0, p50=500.0, p75=600.0, p95=700.0, p98=800.0, p99=900.0, p999=1000.0," +
-                " m1_rate=3.0, m5_rate=4.0, m15_rate=5.0, mean_rate=2.0, rate_unit=events/second, duration_unit=milliseconds");
-    }
-
-    private <T> SortedMap<MetricName, T> map() {
-        return new TreeMap<>();
-    }
-
-    private <T> SortedMap<MetricName, T> map(String name, T metric) {
-        final SortedMap<MetricName, T> map = new TreeMap<>();
-        map.put(MetricName.build(name), metric);
-        return map;
-    }
+import java.util.EnumSet;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.Marker;
 
+final class Slf4jReporterTest {
+
+  private final Logger logger = mock();
+  private final Marker marker = mock();
+  private final MetricRegistry registry = mock();
+
+  /**
+   * The set of disabled metric attributes to pass to the Slf4jReporter builder in the default
+   * factory methods of {@link #infoReporter} and {@link #errorReporter}.
+   *
+   * <p>This value can be overridden by tests before calling the {@link #infoReporter} and {@link
+   * #errorReporter} factory methods.
+   */
+  private Set<MetricAttribute> disabledMetricAttributes = null;
+
+  private Slf4jReporter infoReporter() {
+    return Slf4jReporter.forRegistry(registry)
+        .outputTo(logger)
+        .markWith(marker)
+        .prefixedWith("prefix")
+        .convertRatesTo(TimeUnit.SECONDS)
+        .convertDurationsTo(TimeUnit.MILLISECONDS)
+        .withLoggingLevel(Slf4jReporter.LoggingLevel.INFO)
+        .filter(MetricFilter.ALL)
+        .disabledMetricAttributes(disabledMetricAttributes)
+        .build();
+  }
+
+  private Slf4jReporter errorReporter() {
+    return Slf4jReporter.forRegistry(registry)
+        .outputTo(logger)
+        .markWith(marker)
+        .convertRatesTo(TimeUnit.SECONDS)
+        .convertDurationsTo(TimeUnit.MILLISECONDS)
+        .withLoggingLevel(Slf4jReporter.LoggingLevel.ERROR)
+        .filter(MetricFilter.ALL)
+        .disabledMetricAttributes(disabledMetricAttributes)
+        .build();
+  }
+
+  @Test
+  void reportsGaugeValuesAtErrorDefault() {
+    reportsGaugeValuesAtError();
+  }
+
+  @Test
+  void reportsGaugeValuesAtErrorAllDisabled() {
+    disabledMetricAttributes = EnumSet.allOf(MetricAttribute.class); // has no effect
+    reportsGaugeValuesAtError();
+  }
+
+  private void reportsGaugeValuesAtError() {
+    when(logger.isErrorEnabled(marker)).thenReturn(true);
+    errorReporter().report(map("gauge", () -> "value"), map(), map(), map(), map());
+
+    verify(logger).error(marker, "type=GAUGE, name=gauge, value=value");
+  }
+
+  private Timer timer() {
+    final Timer timer = mock();
+    when(timer.getCount()).thenReturn(1L);
+
+    when(timer.getMeanRate()).thenReturn(2.0);
+    when(timer.getOneMinuteRate()).thenReturn(3.0);
+    when(timer.getFiveMinuteRate()).thenReturn(4.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(5.0);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
+    when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
+    when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
+    when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
+    when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
+    when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
+    when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
+    when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
+    when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
+    when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
+
+    when(timer.getSnapshot()).thenReturn(snapshot);
+    return timer;
+  }
+
+  private Histogram histogram() {
+    final Histogram histogram = mock();
+    when(histogram.getCount()).thenReturn(1L);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(2L);
+    when(snapshot.getMean()).thenReturn(3.0);
+    when(snapshot.getMin()).thenReturn(4L);
+    when(snapshot.getStdDev()).thenReturn(5.0);
+    when(snapshot.getMedian()).thenReturn(6.0);
+    when(snapshot.get75thPercentile()).thenReturn(7.0);
+    when(snapshot.get95thPercentile()).thenReturn(8.0);
+    when(snapshot.get98thPercentile()).thenReturn(9.0);
+    when(snapshot.get99thPercentile()).thenReturn(10.0);
+    when(snapshot.get999thPercentile()).thenReturn(11.0);
+
+    when(histogram.getSnapshot()).thenReturn(snapshot);
+    return histogram;
+  }
+
+  private Meter meter() {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getMeanRate()).thenReturn(2.0);
+    when(meter.getOneMinuteRate()).thenReturn(3.0);
+    when(meter.getFiveMinuteRate()).thenReturn(4.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(5.0);
+    return meter;
+  }
+
+  private Counter counter() {
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(100L);
+    return counter;
+  }
+
+  @Test
+  void reportsCounterValuesAtErrorDefault() {
+    reportsCounterValuesAtError();
+  }
+
+  @Test
+  void reportsCounterValuesAtErrorAllDisabled() {
+    disabledMetricAttributes = EnumSet.allOf(MetricAttribute.class); // has no effect
+    reportsCounterValuesAtError();
+  }
+
+  private void reportsCounterValuesAtError() {
+    final Counter counter = counter();
+    when(logger.isErrorEnabled(marker)).thenReturn(true);
+
+    errorReporter().report(map(), map("test.counter", counter), map(), map(), map());
+
+    verify(logger).error(marker, "type=COUNTER, name=test.counter, count=100");
+  }
+
+  @Test
+  void reportsHistogramValuesAtErrorDefault() {
+    reportsHistogramValuesAtError(
+        "type=HISTOGRAM, name=test.histogram, count=1, min=4, "
+            + "max=2, mean=3.0, stddev=5.0, p50=6.0, p75=7.0, p95=8.0, p98=9.0, p99=10.0, p999=11.0");
+  }
+
+  @Test
+  void reportsHistogramValuesAtErrorWithDisabledMetricAttributes() {
+    disabledMetricAttributes = EnumSet.of(COUNT, MetricAttribute.MIN, P50);
+    reportsHistogramValuesAtError(
+        "type=HISTOGRAM, name=test.histogram, max=2, mean=3.0, "
+            + "stddev=5.0, p75=7.0, p95=8.0, p98=9.0, p99=10.0, p999=11.0");
+  }
+
+  private void reportsHistogramValuesAtError(final String expectedLog) {
+    final Histogram histogram = histogram();
+    when(logger.isErrorEnabled(marker)).thenReturn(true);
+
+    errorReporter().report(map(), map(), map("test.histogram", histogram), map(), map());
+
+    verify(logger).error(marker, expectedLog);
+  }
+
+  @Test
+  void reportsMeterValuesAtErrorDefault() {
+    reportsMeterValuesAtError(
+        "type=METER, name=test.meter, count=1, m1_rate=3.0, m5_rate=4.0, "
+            + "m15_rate=5.0, mean_rate=2.0, rate_unit=events/second");
+  }
+
+  @Test
+  void reportsMeterValuesAtErrorWithDisabledMetricAttributes() {
+    disabledMetricAttributes = EnumSet.of(MetricAttribute.MIN, P50, M1_RATE);
+    reportsMeterValuesAtError(
+        "type=METER, name=test.meter, count=1, m5_rate=4.0, m15_rate=5.0, "
+            + "mean_rate=2.0, rate_unit=events/second");
+  }
+
+  private void reportsMeterValuesAtError(final String expectedLog) {
+    final Meter meter = meter();
+    when(logger.isErrorEnabled(marker)).thenReturn(true);
+
+    errorReporter().report(map(), map(), map(), map("test.meter", meter), map());
+
+    verify(logger).error(marker, expectedLog);
+  }
+
+  @Test
+  void reportsTimerValuesAtErrorDefault() {
+    reportsTimerValuesAtError(
+        "type=TIMER, name=test.another.timer, count=1, min=300.0, max=100.0, "
+            + "mean=200.0, stddev=400.0, p50=500.0, p75=600.0, p95=700.0, p98=800.0, p99=900.0, p999=1000.0, "
+            + "m1_rate=3.0, m5_rate=4.0, m15_rate=5.0, mean_rate=2.0, rate_unit=events/second, "
+            + "duration_unit=milliseconds");
+  }
+
+  @Test
+  void reportsTimerValuesAtErrorWithDisabledMetricAttributes() {
+    disabledMetricAttributes = EnumSet.of(MetricAttribute.MIN, STDDEV, P999, MEAN_RATE);
+    reportsTimerValuesAtError(
+        "type=TIMER, name=test.another.timer, count=1, max=100.0, mean=200.0, "
+            + "p50=500.0, p75=600.0, p95=700.0, p98=800.0, p99=900.0, m1_rate=3.0, m5_rate=4.0, m15_rate=5.0, "
+            + "rate_unit=events/second, duration_unit=milliseconds");
+  }
+
+  private void reportsTimerValuesAtError(final String expectedLog) {
+    final Timer timer = timer();
+
+    when(logger.isErrorEnabled(marker)).thenReturn(true);
+
+    errorReporter().report(map(), map(), map(), map(), map("test.another.timer", timer));
+
+    verify(logger).error(marker, expectedLog);
+  }
+
+  @Test
+  void reportsGaugeValuesDefault() {
+    when(logger.isInfoEnabled(marker)).thenReturn(true);
+    infoReporter().report(map("gauge", () -> "value"), map(), map(), map(), map());
+
+    verify(logger).info(marker, "type=GAUGE, name=prefix.gauge, value=value");
+  }
+
+  @Test
+  void reportsCounterValuesDefault() {
+    final Counter counter = counter();
+    when(logger.isInfoEnabled(marker)).thenReturn(true);
+
+    infoReporter().report(map(), map("test.counter", counter), map(), map(), map());
+
+    verify(logger).info(marker, "type=COUNTER, name=prefix.test.counter, count=100");
+  }
+
+  @Test
+  void reportsHistogramValuesDefault() {
+    final Histogram histogram = histogram();
+    when(logger.isInfoEnabled(marker)).thenReturn(true);
+
+    infoReporter().report(map(), map(), map("test.histogram", histogram), map(), map());
+
+    verify(logger)
+        .info(
+            marker,
+            "type=HISTOGRAM, name=prefix.test.histogram, count=1, min=4, max=2, mean=3.0, "
+                + "stddev=5.0, p50=6.0, p75=7.0, p95=8.0, p98=9.0, p99=10.0, p999=11.0");
+  }
+
+  @Test
+  void reportsMeterValuesDefault() {
+    final Meter meter = meter();
+    when(logger.isInfoEnabled(marker)).thenReturn(true);
+
+    infoReporter().report(map(), map(), map(), map("test.meter", meter), map());
+
+    verify(logger)
+        .info(
+            marker,
+            "type=METER, name=prefix.test.meter, count=1, m1_rate=3.0, m5_rate=4.0, "
+                + "m15_rate=5.0, mean_rate=2.0, rate_unit=events/second");
+  }
+
+  @Test
+  void reportsTimerValuesDefault() {
+    final Timer timer = timer();
+    when(logger.isInfoEnabled(marker)).thenReturn(true);
+
+    infoReporter().report(map(), map(), map(), map(), map("test.another.timer", timer));
+
+    verify(logger)
+        .info(
+            marker,
+            "type=TIMER, name=prefix.test.another.timer, count=1, min=300.0, max=100.0, "
+                + "mean=200.0, stddev=400.0, p50=500.0, p75=600.0, p95=700.0, p98=800.0, p99=900.0, p999=1000.0,"
+                + " m1_rate=3.0, m5_rate=4.0, m15_rate=5.0, mean_rate=2.0, rate_unit=events/second, duration_unit=milliseconds");
+  }
+
+  @Test
+  void reportsAllMetricsDefault() {
+    when(logger.isInfoEnabled(marker)).thenReturn(true);
+
+    infoReporter()
+        .report(
+            map("test.gauge", () -> "value"),
+            map("test.counter", counter()),
+            map("test.histogram", histogram()),
+            map("test.meter", meter()),
+            map("test.timer", timer()));
+
+    verify(logger).info(marker, "type=GAUGE, name=prefix.test.gauge, value=value");
+    verify(logger).info(marker, "type=COUNTER, name=prefix.test.counter, count=100");
+    verify(logger)
+        .info(
+            marker,
+            "type=HISTOGRAM, name=prefix.test.histogram, count=1, min=4, max=2, mean=3.0, "
+                + "stddev=5.0, p50=6.0, p75=7.0, p95=8.0, p98=9.0, p99=10.0, p999=11.0");
+    verify(logger)
+        .info(
+            marker,
+            "type=METER, name=prefix.test.meter, count=1, m1_rate=3.0, m5_rate=4.0, "
+                + "m15_rate=5.0, mean_rate=2.0, rate_unit=events/second");
+    verify(logger)
+        .info(
+            marker,
+            "type=TIMER, name=prefix.test.timer, count=1, min=300.0, max=100.0, "
+                + "mean=200.0, stddev=400.0, p50=500.0, p75=600.0, p95=700.0, p98=800.0, p99=900.0, p999=1000.0,"
+                + " m1_rate=3.0, m5_rate=4.0, m15_rate=5.0, mean_rate=2.0, rate_unit=events/second, duration_unit=milliseconds");
+  }
+
+  private <T> SortedMap<MetricName, T> map() {
+    return new TreeMap<>();
+  }
+
+  private <T> SortedMap<MetricName, T> map(String name, T metric) {
+    final SortedMap<MetricName, T> map = new TreeMap<>();
+    map.put(MetricName.build(name), metric);
+    return map;
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoirTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoirTest.java
@@ -1,150 +1,166 @@
 package io.dropwizard.metrics5;
 
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-import org.junit.jupiter.api.Test;
 
 import java.util.Arrays;
 import java.util.Random;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.atomic.AtomicLong;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("Duplicates")
-class SlidingTimeWindowArrayReservoirTest {
-
-    @Test
-    void storesMeasurementsWithDuplicateTicks() {
-        final Clock clock = mock(Clock.class);
-        final SlidingTimeWindowArrayReservoir reservoir = new SlidingTimeWindowArrayReservoir(10, NANOSECONDS, clock);
-
-        when(clock.getTick()).thenReturn(20L);
-
-        reservoir.update(1);
-        reservoir.update(2);
-
-        assertThat(reservoir.getSnapshot().getValues())
-                .containsOnly(1, 2);
-    }
-
-    @Test
-    void boundsMeasurementsToATimeWindow() {
-        final Clock clock = mock(Clock.class);
-        final SlidingTimeWindowArrayReservoir reservoir = new SlidingTimeWindowArrayReservoir(10, NANOSECONDS, clock);
-
-        when(clock.getTick()).thenReturn(0L);
-        reservoir.update(1);
-
-        when(clock.getTick()).thenReturn(5L);
-        reservoir.update(2);
-
-        when(clock.getTick()).thenReturn(10L);
-        reservoir.update(3);
-
-        when(clock.getTick()).thenReturn(15L);
-        reservoir.update(4);
-
-        when(clock.getTick()).thenReturn(20L);
-        reservoir.update(5);
-
-        assertThat(reservoir.getSnapshot().getValues())
-                .containsOnly(4, 5);
+final class SlidingTimeWindowArrayReservoirTest {
+
+  @Test
+  void storesMeasurementsWithDuplicateTicks() {
+    final Clock clock = mock();
+    final SlidingTimeWindowArrayReservoir reservoir =
+        new SlidingTimeWindowArrayReservoir(10, NANOSECONDS, clock);
+
+    when(clock.getTick()).thenReturn(20L);
+
+    reservoir.update(1);
+    reservoir.update(2);
+
+    assertThat(reservoir.getSnapshot().getValues()).containsOnly(1, 2);
+  }
+
+  @Test
+  void boundsMeasurementsToATimeWindow() {
+    final Clock clock = mock();
+    final SlidingTimeWindowArrayReservoir reservoir =
+        new SlidingTimeWindowArrayReservoir(10, NANOSECONDS, clock);
+
+    when(clock.getTick()).thenReturn(0L);
+    reservoir.update(1);
+
+    when(clock.getTick()).thenReturn(5L);
+    reservoir.update(2);
+
+    when(clock.getTick()).thenReturn(10L);
+    reservoir.update(3);
+
+    when(clock.getTick()).thenReturn(15L);
+    reservoir.update(4);
+
+    when(clock.getTick()).thenReturn(20L);
+    reservoir.update(5);
+
+    assertThat(reservoir.getSnapshot().getValues()).containsOnly(4, 5);
+  }
+
+  @Test
+  void comparisonResultsTest() {
+    int cycles = 1000000;
+    long time = (Long.MAX_VALUE / 256) - (long) (cycles * 0.5);
+    ManualClock manualClock = new ManualClock();
+    manualClock.addNanos(time);
+    int window = 300;
+    Random random = new Random(ThreadLocalRandom.current().nextInt());
+
+    SlidingTimeWindowReservoir treeReservoir =
+        new SlidingTimeWindowReservoir(window, NANOSECONDS, manualClock);
+    SlidingTimeWindowArrayReservoir arrayReservoir =
+        new SlidingTimeWindowArrayReservoir(window, NANOSECONDS, manualClock);
+
+    for (int i = 0; i < cycles; i++) {
+      manualClock.addNanos(1);
+      treeReservoir.update(i);
+      arrayReservoir.update(i);
+      if (random.nextDouble() < 0.01) {
+        long[] treeValues = treeReservoir.getSnapshot().getValues();
+        long[] arrValues = arrayReservoir.getSnapshot().getValues();
+        assertThat(arrValues).isEqualTo(treeValues);
+      }
+      if (random.nextDouble() < 0.05) {
+        assertThat(arrayReservoir.size()).isEqualTo(treeReservoir.size());
+      }
     }
-
-    @Test
-    void comparisonResultsTest() {
-        int cycles = 1000000;
-        long time = (Long.MAX_VALUE / 256) - (long) (cycles * 0.5);
-        ManualClock manualClock = new ManualClock();
-        manualClock.addNanos(time);
-        int window = 300;
-        Random random = new Random(ThreadLocalRandom.current().nextInt());
-
-        SlidingTimeWindowReservoir treeReservoir = new SlidingTimeWindowReservoir(window, NANOSECONDS, manualClock);
-        SlidingTimeWindowArrayReservoir arrayReservoir = new SlidingTimeWindowArrayReservoir(window, NANOSECONDS, manualClock);
-
-        for (int i = 0; i < cycles; i++) {
-            manualClock.addNanos(1);
-            treeReservoir.update(i);
-            arrayReservoir.update(i);
-            if (random.nextDouble() < 0.01) {
-                long[] treeValues = treeReservoir.getSnapshot().getValues();
-                long[] arrValues = arrayReservoir.getSnapshot().getValues();
-                assertThat(arrValues).isEqualTo(treeValues);
-            }
-            if (random.nextDouble() < 0.05) {
-                assertThat(arrayReservoir.size()).isEqualTo(treeReservoir.size());
+  }
+
+  @Test
+  void getTickOverflow() {
+    final Random random = new Random(0);
+    final int window = 128;
+    AtomicLong counter = new AtomicLong(0L);
+
+    // Note: 'threshold' defines the number of updates submitted to the reservoir after overflowing
+    for (int threshold : Arrays.asList(0, 1, 2, 127, 128, 129, 255, 256, 257)) {
+
+      // Note: 'updatePerTick' defines the number of updates submitted to the reservoir between each
+      // tick
+      for (int updatesPerTick : Arrays.asList(1, 2, 127, 128, 129, 255, 256, 257)) {
+        // logger.info("Executing test: threshold={}, updatesPerTick={}", threshold,
+        // updatesPerTick);
+
+        // Set the clock to overflow in (2*window+1)ns
+        final ManualClock clock = new ManualClock();
+        clock.addNanos(Long.MAX_VALUE / 256 - 2 * window - clock.getTick());
+        assertThat(clock.getTick() * 256).isPositive();
+
+        // Create the reservoir
+        final SlidingTimeWindowArrayReservoir reservoir =
+            new SlidingTimeWindowArrayReservoir(window, NANOSECONDS, clock);
+        int updatesAfterThreshold = 0;
+        while (true) {
+          // Update the reservoir
+          for (int i = 0; i < updatesPerTick; i++) {
+            long l = counter.incrementAndGet();
+            reservoir.update(l);
+          }
+
+          // Randomly check the reservoir size
+          if (random.nextDouble() < 0.1) {
+            assertThat(reservoir.size())
+                .as(
+                    "Bad reservoir size with: threshold=%d, updatesPerTick=%d",
+                    threshold, updatesPerTick)
+                .isLessThanOrEqualTo(window * 256);
+          }
+
+          // Update the clock
+          clock.addNanos(1);
+
+          // If the clock has overflowed start counting updates
+          if ((clock.getTick() * 256) < 0) {
+            if (updatesAfterThreshold++ >= threshold) {
+              break;
             }
+          }
         }
-    }
 
-    @Test
-    void testGetTickOverflow() {
-        final Random random = new Random(0);
-        final int window = 128;
-        AtomicLong counter = new AtomicLong(0L);
-
-        // Note: 'threshold' defines the number of updates submitted to the reservoir after overflowing
-        for (int threshold : Arrays.asList(0, 1, 2, 127, 128, 129, 255, 256, 257)) {
-
-            // Note: 'updatePerTick' defines the number of updates submitted to the reservoir between each tick
-            for (int updatesPerTick : Arrays.asList(1, 2, 127, 128, 129, 255, 256, 257)) {
-                //logger.info("Executing test: threshold={}, updatesPerTick={}", threshold, updatesPerTick);
-
-                // Set the clock to overflow in (2*window+1)ns
-                final ManualClock clock = new ManualClock();
-                clock.addNanos(Long.MAX_VALUE / 256 - 2 * window - clock.getTick());
-                assertThat(clock.getTick() * 256).isGreaterThan(0);
-
-                // Create the reservoir
-                final SlidingTimeWindowArrayReservoir reservoir = new SlidingTimeWindowArrayReservoir(window, NANOSECONDS, clock);
-                int updatesAfterThreshold = 0;
-                while (true) {
-                    // Update the reservoir
-                    for (int i = 0; i < updatesPerTick; i++) {
-                        long l = counter.incrementAndGet();
-                        reservoir.update(l);
-                    }
-
-                    // Randomly check the reservoir size
-                    if (random.nextDouble() < 0.1) {
-                        assertThat(reservoir.size())
-                                .as("Bad reservoir size with: threshold=%d, updatesPerTick=%d", threshold, updatesPerTick)
-                                .isLessThanOrEqualTo(window * 256);
-                    }
-
-                    // Update the clock
-                    clock.addNanos(1);
-
-                    // If the clock has overflowed start counting updates
-                    if ((clock.getTick() * 256) < 0) {
-                        if (updatesAfterThreshold++ >= threshold) {
-                            break;
-                        }
-                    }
-                }
-
-                // Check the final reservoir size
-                assertThat(reservoir.size())
-                        .as("Bad final reservoir size with: threshold=%d, updatesPerTick=%d", threshold, updatesPerTick)
-                        .isLessThanOrEqualTo(window * 256);
-
-                // Advance the clock far enough to clear the reservoir.  Note that here the window only loosely defines
-                // the reservoir window; when updatesPerTick is greater than 128 the sliding window will always be well
-                // ahead of the current clock time, and advances in getTick while in trim (called randomly above from
-                // size and every 256 updates).  Until the clock "catches up" advancing the clock will have no effect on
-                // the reservoir, and reservoir.size() will merely move the window forward 1/256th of a ns - as such, an
-                // arbitrary increment of 1s here was used instead to advance the clock well beyond any updates recorded
-                // above.
-                clock.addSeconds(1);
-
-                // The reservoir should now be empty
-                assertThat(reservoir.size())
-                        .as("Bad reservoir size after delay with: threshold=%d, updatesPerTick=%d", threshold, updatesPerTick)
-                        .isEqualTo(0);
-            }
-        }
+        // Check the final reservoir size
+        assertThat(reservoir.size())
+            .as(
+                "Bad final reservoir size with: threshold=%d, updatesPerTick=%d",
+                threshold, updatesPerTick)
+            .isLessThanOrEqualTo(window * 256);
+
+        // Advance the clock far enough to clear the reservoir.  Note that here the window only
+        // loosely defines
+        // the reservoir window; when updatesPerTick is greater than 128 the sliding window will
+        // always be well
+        // ahead of the current clock time, and advances in getTick while in trim (called randomly
+        // above from
+        // size and every 256 updates).  Until the clock "catches up" advancing the clock will have
+        // no effect on
+        // the reservoir, and reservoir.size() will merely move the window forward 1/256th of a ns -
+        // as such, an
+        // arbitrary increment of 1s here was used instead to advance the clock well beyond any
+        // updates recorded
+        // above.
+        clock.addSeconds(1);
+
+        // The reservoir should now be empty
+        assertThat(reservoir.size())
+            .as(
+                "Bad reservoir size after delay with: threshold=%d, updatesPerTick=%d",
+                threshold, updatesPerTick)
+            .isEqualTo(0);
+      }
     }
-}
\ No newline at end of file
+  }
+}
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/SlidingTimeWindowMovingAveragesTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/SlidingTimeWindowMovingAveragesTest.java
@@ -1,166 +1,165 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import java.time.Instant;
-
 import static io.dropwizard.metrics5.SlidingTimeWindowMovingAverages.NUMBER_OF_BUCKETS;
 import static org.assertj.core.api.Assertions.assertThat;
 
-class SlidingTimeWindowMovingAveragesTest {
-
-    private ManualClock clock;
-    private SlidingTimeWindowMovingAverages movingAverages;
-    private Meter meter;
+import java.time.Instant;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-    @BeforeEach
-    void init() {
-        clock = new ManualClock();
-        movingAverages = new SlidingTimeWindowMovingAverages(clock);
-        meter = new Meter(movingAverages, clock);
-    }
+final class SlidingTimeWindowMovingAveragesTest {
 
-    @Test
-    void normalizeIndex() {
+  private ManualClock clock;
+  private SlidingTimeWindowMovingAverages movingAverages;
+  private Meter meter;
 
-        SlidingTimeWindowMovingAverages stwm = new SlidingTimeWindowMovingAverages();
+  @BeforeEach
+  void init() {
+    clock = new ManualClock();
+    movingAverages = new SlidingTimeWindowMovingAverages(clock);
+    meter = new Meter(movingAverages, clock);
+  }
 
-        assertThat(stwm.normalizeIndex(0)).isEqualTo(0);
-        assertThat(stwm.normalizeIndex(900)).isEqualTo(0);
-        assertThat(stwm.normalizeIndex(9000)).isEqualTo(0);
-        assertThat(stwm.normalizeIndex(-900)).isEqualTo(0);
+  @Test
+  void normalizeIndex() {
 
-        assertThat(stwm.normalizeIndex(1)).isEqualTo(1);
+    SlidingTimeWindowMovingAverages stwm = new SlidingTimeWindowMovingAverages();
 
-        assertThat(stwm.normalizeIndex(899)).isEqualTo(899);
-        assertThat(stwm.normalizeIndex(-1)).isEqualTo(899);
-        assertThat(stwm.normalizeIndex(-901)).isEqualTo(899);
-    }
+    assertThat(stwm.normalizeIndex(0)).isEqualTo(0);
+    assertThat(stwm.normalizeIndex(900)).isEqualTo(0);
+    assertThat(stwm.normalizeIndex(9000)).isEqualTo(0);
+    assertThat(stwm.normalizeIndex(-900)).isEqualTo(0);
 
-    @Test
-    void calculateIndexOfTick() {
+    assertThat(stwm.normalizeIndex(1)).isEqualTo(1);
 
-        SlidingTimeWindowMovingAverages stwm = new SlidingTimeWindowMovingAverages(clock);
+    assertThat(stwm.normalizeIndex(899)).isEqualTo(899);
+    assertThat(stwm.normalizeIndex(-1)).isEqualTo(899);
+    assertThat(stwm.normalizeIndex(-901)).isEqualTo(899);
+  }
 
-        assertThat(stwm.calculateIndexOfTick(Instant.ofEpochSecond(0L))).isEqualTo(0);
-        assertThat(stwm.calculateIndexOfTick(Instant.ofEpochSecond(1L))).isEqualTo(1);
-    }
+  @Test
+  void calculateIndexOfTick() {
 
-    @Test
-    void mark_max_without_cleanup() {
+    SlidingTimeWindowMovingAverages stwm = new SlidingTimeWindowMovingAverages(clock);
 
-        int markCount = NUMBER_OF_BUCKETS;
+    assertThat(stwm.calculateIndexOfTick(Instant.EPOCH)).isEqualTo(0);
+    assertThat(stwm.calculateIndexOfTick(Instant.ofEpochSecond(1L))).isEqualTo(1);
+  }
 
-        // compensate the first addSeconds in the loop; first tick should be at zero
-        clock.addSeconds(-1);
+  @Test
+  void mark_max_without_cleanup() {
 
-        for (int i = 0; i < markCount; i++) {
-            clock.addSeconds(1);
-            meter.mark();
-        }
+    int markCount = NUMBER_OF_BUCKETS;
 
-        // verify that no cleanup happened yet
-        assertThat(movingAverages.oldestBucketTime).isEqualTo(Instant.ofEpochSecond(0L));
+    // compensate the first addSeconds in the loop; first tick should be at zero
+    clock.addSeconds(-1);
 
-        assertThat(meter.getOneMinuteRate()).isEqualTo(60.0);
-        assertThat(meter.getFiveMinuteRate()).isEqualTo(300.0);
-        assertThat(meter.getFifteenMinuteRate()).isEqualTo(900.0);
+    for (int i = 0; i < markCount; i++) {
+      clock.addSeconds(1);
+      meter.mark();
     }
 
-    @Test
-    void mark_first_cleanup() {
+    // verify that no cleanup happened yet
+    assertThat(movingAverages.oldestBucketTime).isEqualTo(Instant.EPOCH);
 
-        int markCount = NUMBER_OF_BUCKETS + 1;
+    assertThat(meter.getOneMinuteRate()).isEqualTo(60.0);
+    assertThat(meter.getFiveMinuteRate()).isEqualTo(300.0);
+    assertThat(meter.getFifteenMinuteRate()).isEqualTo(900.0);
+  }
 
-        // compensate the first addSeconds in the loop; first tick should be at zero
-        clock.addSeconds(-1);
+  @Test
+  void mark_first_cleanup() {
 
-        for (int i = 0; i < markCount; i++) {
-            clock.addSeconds(1);
-            meter.mark();
-        }
+    int markCount = NUMBER_OF_BUCKETS + 1;
 
-        // verify that at least one cleanup happened
-        assertThat(movingAverages.oldestBucketTime).isNotEqualTo(Instant.EPOCH);
+    // compensate the first addSeconds in the loop; first tick should be at zero
+    clock.addSeconds(-1);
 
-        assertThat(meter.getOneMinuteRate()).isEqualTo(60.0);
-        assertThat(meter.getFiveMinuteRate()).isEqualTo(300.0);
-        assertThat(meter.getFifteenMinuteRate()).isEqualTo(900.0);
+    for (int i = 0; i < markCount; i++) {
+      clock.addSeconds(1);
+      meter.mark();
     }
 
-    @Test
-    void mark_10_values() {
+    // verify that at least one cleanup happened
+    assertThat(movingAverages.oldestBucketTime).isNotEqualTo(Instant.EPOCH);
 
-        // compensate the first addSeconds in the loop; first tick should be at zero
-        clock.addSeconds(-1);
+    assertThat(meter.getOneMinuteRate()).isEqualTo(60.0);
+    assertThat(meter.getFiveMinuteRate()).isEqualTo(300.0);
+    assertThat(meter.getFifteenMinuteRate()).isEqualTo(900.0);
+  }
 
-        for (int i = 0; i < 10; i++) {
-            clock.addSeconds(1);
-            meter.mark();
-        }
+  @Test
+  void mark_10_values() {
 
-        assertThat(meter.getCount()).isEqualTo(10L);
-        assertThat(meter.getOneMinuteRate()).isEqualTo(10.0);
-        assertThat(meter.getFiveMinuteRate()).isEqualTo(10.0);
-        assertThat(meter.getFifteenMinuteRate()).isEqualTo(10.0);
-    }
-
-    @Test
-    void mark_1000_values() {
-
-        for (int i = 0; i < 1000; i++) {
-            clock.addSeconds(1);
-            meter.mark();
-        }
+    // compensate the first addSeconds in the loop; first tick should be at zero
+    clock.addSeconds(-1);
 
-        // only 60/300/900 of the 1000 events took place in the last 1/5/15 minute(s)
-        assertThat(meter.getOneMinuteRate()).isEqualTo(60.0);
-        assertThat(meter.getFiveMinuteRate()).isEqualTo(300.0);
-        assertThat(meter.getFifteenMinuteRate()).isEqualTo(900.0);
+    for (int i = 0; i < 10; i++) {
+      clock.addSeconds(1);
+      meter.mark();
     }
 
-    @Test
-    void cleanup_pause_shorter_than_window() {
+    assertThat(meter.getCount()).isEqualTo(10L);
+    assertThat(meter.getOneMinuteRate()).isEqualTo(10.0);
+    assertThat(meter.getFiveMinuteRate()).isEqualTo(10.0);
+    assertThat(meter.getFifteenMinuteRate()).isEqualTo(10.0);
+  }
 
-        meter.mark(10);
+  @Test
+  void mark_1000_values() {
 
-        // no mark for three minutes
-        clock.addSeconds(180);
-        assertThat(meter.getOneMinuteRate()).isEqualTo(0.0);
-        assertThat(meter.getFiveMinuteRate()).isEqualTo(10.0);
-        assertThat(meter.getFifteenMinuteRate()).isEqualTo(10.0);
+    for (int i = 0; i < 1000; i++) {
+      clock.addSeconds(1);
+      meter.mark();
     }
 
-    @Test
-    void cleanup_window_wrap_around() {
-
-        // mark at 14:40 minutes of the 15 minute window...
-        clock.addSeconds(880);
-        meter.mark(10);
-
-        // and query at 15:30 minutes (the bucket index must have wrapped around)
-        clock.addSeconds(50);
-        assertThat(meter.getOneMinuteRate()).isEqualTo(10.0);
-        assertThat(meter.getFiveMinuteRate()).isEqualTo(10.0);
-        assertThat(meter.getFifteenMinuteRate()).isEqualTo(10.0);
-
-        // and query at 30:10 minutes (the bucket index must have wrapped around for the second time)
-        clock.addSeconds(880);
-        assertThat(meter.getOneMinuteRate()).isEqualTo(0.0);
-        assertThat(meter.getFiveMinuteRate()).isEqualTo(0.0);
-        assertThat(meter.getFifteenMinuteRate()).isEqualTo(0.0);
-    }
-
-    @Test
-    void cleanup_pause_longer_than_two_windows() {
-
-        meter.mark(10);
-
-        // after forty minutes all rates should be zero
-        clock.addSeconds(2400);
-        assertThat(meter.getOneMinuteRate()).isEqualTo(0.0);
-        assertThat(meter.getFiveMinuteRate()).isEqualTo(0.0);
-        assertThat(meter.getFifteenMinuteRate()).isEqualTo(0.0);
-    }
-}
\ No newline at end of file
+    // only 60/300/900 of the 1000 events took place in the last 1/5/15 minute(s)
+    assertThat(meter.getOneMinuteRate()).isEqualTo(60.0);
+    assertThat(meter.getFiveMinuteRate()).isEqualTo(300.0);
+    assertThat(meter.getFifteenMinuteRate()).isEqualTo(900.0);
+  }
+
+  @Test
+  void cleanup_pause_shorter_than_window() {
+
+    meter.mark(10);
+
+    // no mark for three minutes
+    clock.addSeconds(180);
+    assertThat(meter.getOneMinuteRate()).isEqualTo(0.0);
+    assertThat(meter.getFiveMinuteRate()).isEqualTo(10.0);
+    assertThat(meter.getFifteenMinuteRate()).isEqualTo(10.0);
+  }
+
+  @Test
+  void cleanup_window_wrap_around() {
+
+    // mark at 14:40 minutes of the 15 minute window...
+    clock.addSeconds(880);
+    meter.mark(10);
+
+    // and query at 15:30 minutes (the bucket index must have wrapped around)
+    clock.addSeconds(50);
+    assertThat(meter.getOneMinuteRate()).isEqualTo(10.0);
+    assertThat(meter.getFiveMinuteRate()).isEqualTo(10.0);
+    assertThat(meter.getFifteenMinuteRate()).isEqualTo(10.0);
+
+    // and query at 30:10 minutes (the bucket index must have wrapped around for the second time)
+    clock.addSeconds(880);
+    assertThat(meter.getOneMinuteRate()).isEqualTo(0.0);
+    assertThat(meter.getFiveMinuteRate()).isEqualTo(0.0);
+    assertThat(meter.getFifteenMinuteRate()).isEqualTo(0.0);
+  }
+
+  @Test
+  void cleanup_pause_longer_than_two_windows() {
+
+    meter.mark(10);
+
+    // after forty minutes all rates should be zero
+    clock.addSeconds(2400);
+    assertThat(meter.getOneMinuteRate()).isEqualTo(0.0);
+    assertThat(meter.getFiveMinuteRate()).isEqualTo(0.0);
+    assertThat(meter.getFifteenMinuteRate()).isEqualTo(0.0);
+  }
+}
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/SlidingTimeWindowReservoirTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/SlidingTimeWindowReservoirTest.java
@@ -1,119 +1,131 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
-import java.util.Arrays;
-import java.util.Random;
-
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-class SlidingTimeWindowReservoirTest {
-    @Test
-    void storesMeasurementsWithDuplicateTicks() {
-        final Clock clock = mock(Clock.class);
-        final SlidingTimeWindowReservoir reservoir = new SlidingTimeWindowReservoir(10, NANOSECONDS, clock);
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.jupiter.api.Test;
 
-        when(clock.getTick()).thenReturn(20L);
+final class SlidingTimeWindowReservoirTest {
+  @Test
+  void storesMeasurementsWithDuplicateTicks() {
+    final Clock clock = mock();
+    final SlidingTimeWindowReservoir reservoir =
+        new SlidingTimeWindowReservoir(10, NANOSECONDS, clock);
 
-        reservoir.update(1);
-        reservoir.update(2);
+    when(clock.getTick()).thenReturn(20L);
 
-        assertThat(reservoir.getSnapshot().getValues())
-                .containsOnly(1, 2);
-    }
+    reservoir.update(1);
+    reservoir.update(2);
 
-    @Test
-    void boundsMeasurementsToATimeWindow() {
-        final Clock clock = mock(Clock.class);
-        when(clock.getTick()).thenReturn(0L);
+    assertThat(reservoir.getSnapshot().getValues()).containsOnly(1, 2);
+  }
 
-        final SlidingTimeWindowReservoir reservoir = new SlidingTimeWindowReservoir(10, NANOSECONDS, clock);
+  @Test
+  void boundsMeasurementsToATimeWindow() {
+    final Clock clock = mock();
+    when(clock.getTick()).thenReturn(0L);
 
-        when(clock.getTick()).thenReturn(0L);
-        reservoir.update(1);
+    final SlidingTimeWindowReservoir reservoir =
+        new SlidingTimeWindowReservoir(10, NANOSECONDS, clock);
 
-        when(clock.getTick()).thenReturn(5L);
-        reservoir.update(2);
+    when(clock.getTick()).thenReturn(0L);
+    reservoir.update(1);
 
-        when(clock.getTick()).thenReturn(10L);
-        reservoir.update(3);
+    when(clock.getTick()).thenReturn(5L);
+    reservoir.update(2);
 
-        when(clock.getTick()).thenReturn(15L);
-        reservoir.update(4);
+    when(clock.getTick()).thenReturn(10L);
+    reservoir.update(3);
 
-        when(clock.getTick()).thenReturn(20L);
-        reservoir.update(5);
+    when(clock.getTick()).thenReturn(15L);
+    reservoir.update(4);
 
-        assertThat(reservoir.getSnapshot().getValues())
-                .containsOnly(4, 5);
-    }
+    when(clock.getTick()).thenReturn(20L);
+    reservoir.update(5);
+
+    assertThat(reservoir.getSnapshot().getValues()).containsOnly(4, 5);
+  }
 
-    @Test
-    void testGetTickOverflow() {
-        final Random random = new Random(0);
-        final int window = 128;
-
-        // Note: 'threshold' defines the number of updates submitted to the reservoir after overflowing
-        for (int threshold : Arrays.asList(0, 1, 2, 127, 128, 129, 255, 256, 257)) {
-
-            // Note: 'updatePerTick' defines the number of updates submitted to the reservoir between each tick
-            for (int updatesPerTick : Arrays.asList(1, 2, 127, 128, 129, 255, 256, 257)) {
-                //logger.info("Executing test: threshold={}, updatesPerTick={}", threshold, updatesPerTick);
-
-                final ManualClock clock = new ManualClock();
-
-                // Create the reservoir
-                final SlidingTimeWindowReservoir reservoir = new SlidingTimeWindowReservoir(window, NANOSECONDS, clock);
-
-                // Set the clock to overflow in (2*window+1)ns
-                clock.addNanos(Long.MAX_VALUE / 256 - 2 * window - clock.getTick());
-                assertThat(clock.getTick() * 256).isGreaterThan(0);
-
-                int updatesAfterThreshold = 0;
-                while (true) {
-                    // Update the reservoir
-                    for (int i = 0; i < updatesPerTick; i++)
-                        reservoir.update(0);
-
-                    // Randomly check the reservoir size
-                    if (random.nextDouble() < 0.1) {
-                        assertThat(reservoir.size())
-                                .as("Bad reservoir size with: threshold=%d, updatesPerTick=%d", threshold, updatesPerTick)
-                                .isLessThanOrEqualTo(window * 256);
-                    }
-
-                    // Update the clock
-                    clock.addNanos(1);
-
-                    // If the clock has overflowed start counting updates
-                    if ((clock.getTick() * 256) < 0) {
-                        if (updatesAfterThreshold++ >= threshold)
-                            break;
-                    }
-                }
-
-                // Check the final reservoir size
-                assertThat(reservoir.size())
-                        .as("Bad final reservoir size with: threshold=%d, updatesPerTick=%d", threshold, updatesPerTick)
-                        .isLessThanOrEqualTo(window * 256);
-
-                // Advance the clock far enough to clear the reservoir.  Note that here the window only loosely defines
-                // the reservoir window; when updatesPerTick is greater than 128 the sliding window will always be well
-                // ahead of the current clock time, and advances in getTick while in trim (called randomly above from
-                // size and every 256 updates).  Until the clock "catches up" advancing the clock will have no effect on
-                // the reservoir, and reservoir.size() will merely move the window forward 1/256th of a ns - as such, an
-                // arbitrary increment of 1s here was used instead to advance the clock well beyond any updates recorded
-                // above.
-                clock.addSeconds(1);
-
-                // The reservoir should now be empty
-                assertThat(reservoir.size())
-                        .as("Bad reservoir size after delay with: threshold=%d, updatesPerTick=%d", threshold, updatesPerTick)
-                        .isEqualTo(0);
-            }
+  @Test
+  void getTickOverflow() {
+    final Random random = new Random(0);
+    final int window = 128;
+
+    // Note: 'threshold' defines the number of updates submitted to the reservoir after overflowing
+    for (int threshold : Arrays.asList(0, 1, 2, 127, 128, 129, 255, 256, 257)) {
+
+      // Note: 'updatePerTick' defines the number of updates submitted to the reservoir between each
+      // tick
+      for (int updatesPerTick : Arrays.asList(1, 2, 127, 128, 129, 255, 256, 257)) {
+        // logger.info("Executing test: threshold={}, updatesPerTick={}", threshold,
+        // updatesPerTick);
+
+        final ManualClock clock = new ManualClock();
+
+        // Create the reservoir
+        final SlidingTimeWindowReservoir reservoir =
+            new SlidingTimeWindowReservoir(window, NANOSECONDS, clock);
+
+        // Set the clock to overflow in (2*window+1)ns
+        clock.addNanos(Long.MAX_VALUE / 256 - 2 * window - clock.getTick());
+        assertThat(clock.getTick() * 256).isPositive();
+
+        int updatesAfterThreshold = 0;
+        while (true) {
+          // Update the reservoir
+          for (int i = 0; i < updatesPerTick; i++) reservoir.update(0);
+
+          // Randomly check the reservoir size
+          if (random.nextDouble() < 0.1) {
+            assertThat(reservoir.size())
+                .as(
+                    "Bad reservoir size with: threshold=%d, updatesPerTick=%d",
+                    threshold, updatesPerTick)
+                .isLessThanOrEqualTo(window * 256);
+          }
+
+          // Update the clock
+          clock.addNanos(1);
+
+          // If the clock has overflowed start counting updates
+          if ((clock.getTick() * 256) < 0) {
+            if (updatesAfterThreshold++ >= threshold) break;
+          }
         }
+
+        // Check the final reservoir size
+        assertThat(reservoir.size())
+            .as(
+                "Bad final reservoir size with: threshold=%d, updatesPerTick=%d",
+                threshold, updatesPerTick)
+            .isLessThanOrEqualTo(window * 256);
+
+        // Advance the clock far enough to clear the reservoir.  Note that here the window only
+        // loosely defines
+        // the reservoir window; when updatesPerTick is greater than 128 the sliding window will
+        // always be well
+        // ahead of the current clock time, and advances in getTick while in trim (called randomly
+        // above from
+        // size and every 256 updates).  Until the clock "catches up" advancing the clock will have
+        // no effect on
+        // the reservoir, and reservoir.size() will merely move the window forward 1/256th of a ns -
+        // as such, an
+        // arbitrary increment of 1s here was used instead to advance the clock well beyond any
+        // updates recorded
+        // above.
+        clock.addSeconds(1);
+
+        // The reservoir should now be empty
+        assertThat(reservoir.size())
+            .as(
+                "Bad reservoir size after delay with: threshold=%d, updatesPerTick=%d",
+                threshold, updatesPerTick)
+            .isEqualTo(0);
+      }
     }
-}
\ No newline at end of file
+  }
+}
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/SlidingWindowReservoirTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/SlidingWindowReservoirTest.java
@@ -1,29 +1,27 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class SlidingWindowReservoirTest {
-    private final SlidingWindowReservoir reservoir = new SlidingWindowReservoir(3);
+import org.junit.jupiter.api.Test;
+
+final class SlidingWindowReservoirTest {
+  private final SlidingWindowReservoir reservoir = new SlidingWindowReservoir(3);
 
-    @Test
-    void handlesSmallDataStreams() {
-        reservoir.update(1);
-        reservoir.update(2);
+  @Test
+  void handlesSmallDataStreams() {
+    reservoir.update(1);
+    reservoir.update(2);
 
-        assertThat(reservoir.getSnapshot().getValues())
-                .containsOnly(1, 2);
-    }
+    assertThat(reservoir.getSnapshot().getValues()).containsOnly(1, 2);
+  }
 
-    @Test
-    void onlyKeepsTheMostRecentFromBigDataStreams() {
-        reservoir.update(1);
-        reservoir.update(2);
-        reservoir.update(3);
-        reservoir.update(4);
+  @Test
+  void onlyKeepsTheMostRecentFromBigDataStreams() {
+    reservoir.update(1);
+    reservoir.update(2);
+    reservoir.update(3);
+    reservoir.update(4);
 
-        assertThat(reservoir.getSnapshot().getValues())
-                .containsOnly(2, 3, 4);
-    }
+    assertThat(reservoir.getSnapshot().getValues()).containsOnly(2, 3, 4);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/TimerTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/TimerTest.java
@@ -1,11 +1,5 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
-import java.time.Duration;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.offset;
 import static org.mockito.Mockito.mock;
@@ -13,168 +7,148 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoInteractions;
 import static org.mockito.Mockito.when;
 
-class TimerTest {
-    private final Reservoir reservoir = mock(Reservoir.class);
-    private final Clock clock = new Clock() {
+import java.time.Duration;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.junit.jupiter.api.Test;
+
+final class TimerTest {
+  private final Reservoir reservoir = mock();
+  private final Clock clock =
+      new Clock() {
         // a mock clock that increments its ticker by 50msec per call
         private long val = 0;
 
         @Override
         public long getTick() {
-            return val += 50000000;
+          return val += 50000000;
         }
-    };
-    private final Timer timer = new Timer(reservoir, clock);
+      };
+  private final Timer timer = new Timer(reservoir, clock);
 
-    @Test
-    void hasRates() {
-        assertThat(timer.getCount())
-                .isZero();
+  @Test
+  void hasRates() {
+    assertThat(timer.getCount()).isEqualTo(0);
 
-        assertThat(timer.getSum())
-                .isZero();
+    assertThat(timer.getSum()).isEqualTo(0);
 
-        assertThat(timer.getMeanRate())
-                .isEqualTo(0.0, offset(0.001));
+    assertThat(timer.getMeanRate()).isCloseTo(0.0, offset(0.001));
 
-        assertThat(timer.getOneMinuteRate())
-                .isEqualTo(0.0, offset(0.001));
+    assertThat(timer.getOneMinuteRate()).isCloseTo(0.0, offset(0.001));
 
-        assertThat(timer.getFiveMinuteRate())
-                .isEqualTo(0.0, offset(0.001));
+    assertThat(timer.getFiveMinuteRate()).isCloseTo(0.0, offset(0.001));
 
-        assertThat(timer.getFifteenMinuteRate())
-                .isEqualTo(0.0, offset(0.001));
-    }
+    assertThat(timer.getFifteenMinuteRate()).isCloseTo(0.0, offset(0.001));
+  }
 
-    @Test
-    void updatesTheCountAndSumOnUpdates() {
-        assertThat(timer.getCount())
-                .isZero();
-        assertThat(timer.getSum())
-                .isZero();
+  @Test
+  void updatesTheCountAndSumOnUpdates() {
+    assertThat(timer.getCount()).isEqualTo(0);
+    assertThat(timer.getSum()).isEqualTo(0);
 
-        timer.update(1, TimeUnit.SECONDS);
-        timer.update(5, TimeUnit.SECONDS);
+    timer.update(1, TimeUnit.SECONDS);
+    timer.update(5, TimeUnit.SECONDS);
 
-        assertThat(timer.getCount())
-                .isEqualTo(2);
-        assertThat(timer.getSum())
-                .isEqualTo(6000000000L);
-    }
+    assertThat(timer.getCount()).isEqualTo(2);
+    assertThat(timer.getSum()).isEqualTo(6000000000L);
+  }
 
-    @Test
-    void timesCallableInstances() throws Exception {
-        final String value = timer.time(() -> "one");
+  @Test
+  void timesCallableInstances() throws Exception {
+    final String value = timer.time(() -> "one");
 
-        assertThat(timer.getCount())
-                .isEqualTo(1);
-        assertThat(timer.getSum())
-                .isEqualTo(50000000);
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSum()).isEqualTo(50000000);
 
-        assertThat(value)
-                .isEqualTo("one");
+    assertThat(value).isEqualTo("one");
 
-        verify(reservoir).update(50000000);
-    }
+    verify(reservoir).update(50000000);
+  }
 
-    @Test
-    void timesSuppliedInstances() {
-        final String value = timer.timeSupplier(() -> "one");
+  @Test
+  void timesSuppliedInstances() {
+    final String value = timer.timeSupplier(() -> "one");
 
-        assertThat(timer.getCount())
-                .isEqualTo(1);
+    assertThat(timer.getCount()).isEqualTo(1);
 
-        assertThat(value)
-                .isEqualTo("one");
+    assertThat(value).isEqualTo("one");
 
-        verify(reservoir).update(50000000);
-    }
+    verify(reservoir).update(50000000);
+  }
 
-    @Test
-    void timesRunnableInstances() {
-        final AtomicBoolean called = new AtomicBoolean();
-        timer.time(() -> called.set(true));
+  @Test
+  void timesRunnableInstances() {
+    final AtomicBoolean called = new AtomicBoolean();
+    timer.time(() -> called.set(true));
 
-        assertThat(timer.getCount())
-                .isEqualTo(1);
-        assertThat(timer.getSum())
-                .isEqualTo(50000000);
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSum()).isEqualTo(50000000);
 
-        assertThat(called.get())
-                .isTrue();
+    assertThat(called.get()).isTrue();
 
-        verify(reservoir).update(50000000);
-    }
+    verify(reservoir).update(50000000);
+  }
 
-    @Test
-    void timesContexts() {
-        timer.time().stop();
+  @Test
+  void timesContexts() {
+    timer.time().stop();
 
-        assertThat(timer.getCount())
-                .isEqualTo(1);
-        assertThat(timer.getSum())
-                .isEqualTo(50000000);
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSum()).isEqualTo(50000000);
 
-        verify(reservoir).update(50000000);
-    }
+    verify(reservoir).update(50000000);
+  }
 
-    @Test
-    void returnsTheSnapshotFromTheReservoir() {
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(reservoir.getSnapshot()).thenReturn(snapshot);
+  @Test
+  void returnsTheSnapshotFromTheReservoir() {
+    final Snapshot snapshot = mock();
+    when(reservoir.getSnapshot()).thenReturn(snapshot);
 
-        assertThat(timer.getSnapshot())
-                .isEqualTo(snapshot);
-    }
+    assertThat(timer.getSnapshot()).isEqualTo(snapshot);
+  }
 
-    @Test
-    void ignoresNegativeValues() {
-        timer.update(-1, TimeUnit.SECONDS);
+  @Test
+  void ignoresNegativeValues() {
+    timer.update(-1, TimeUnit.SECONDS);
 
-        assertThat(timer.getCount())
-                .isZero();
-        assertThat(timer.getSum())
-                .isZero();
+    assertThat(timer.getCount()).isEqualTo(0);
+    assertThat(timer.getSum()).isEqualTo(0);
 
-        verifyNoInteractions(reservoir);
-    }
+    verifyNoInteractions(reservoir);
+  }
 
-    @Test
-    void java8Duration() {
-        timer.update(Duration.ofSeconds(1234));
+  @Test
+  void java8Duration() {
+    timer.update(Duration.ofSeconds(1234));
 
-        assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getCount()).isEqualTo(1);
 
-        verify(reservoir).update((long) 1234e9);
-    }
+    verify(reservoir).update((long) 1234e9);
+  }
 
-    @Test
-    void java8NegativeDuration() {
-        timer.update(Duration.ofMillis(-5678));
+  @Test
+  void java8NegativeDuration() {
+    timer.update(Duration.ofMillis(-5678));
 
-        assertThat(timer.getCount()).isZero();
+    assertThat(timer.getCount()).isEqualTo(0);
 
-        verifyNoInteractions(reservoir);
-    }
+    verifyNoInteractions(reservoir);
+  }
 
-    @Test
-    void tryWithResourcesWork() {
-        assertThat(timer.getCount()).isZero();
-        assertThat(timer.getSum()).isZero();
-
-        int dummy = 0;
-        try (Timer.Context context = timer.time()) {
-            assertThat(context).isNotNull();
-            dummy += 1;
-        }
-        assertThat(dummy).isEqualTo(1);
-        assertThat(timer.getCount())
-                .isEqualTo(1);
-        assertThat(timer.getSum())
-                .isEqualTo(50000000);
+  @Test
+  void tryWithResourcesWork() {
+    assertThat(timer.getCount()).isEqualTo(0);
+    assertThat(timer.getSum()).isEqualTo(0);
 
-        verify(reservoir).update(50000000);
+    int dummy = 0;
+    try (Timer.Context context = timer.time()) {
+      assertThat(context).isNotNull();
+      dummy += 1;
     }
+    assertThat(dummy).isEqualTo(1);
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSum()).isEqualTo(50000000);
 
+    verify(reservoir).update(50000000);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/UniformReservoirTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/UniformReservoirTest.java
@@ -1,31 +1,26 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class UniformReservoirTest {
-    @Test
-    @SuppressWarnings("unchecked")
-    void aReservoirOf100OutOf1000Elements() {
-        final UniformReservoir reservoir = new UniformReservoir(100);
-        for (int i = 0; i < 1000; i++) {
-            reservoir.update(i);
-        }
+import org.junit.jupiter.api.Test;
+
+final class UniformReservoirTest {
+  @SuppressWarnings("unchecked")
+  @Test
+  void aReservoirOf100OutOf1000Elements() {
+    final UniformReservoir reservoir = new UniformReservoir(100);
+    for (int i = 0; i < 1000; i++) {
+      reservoir.update(i);
+    }
 
-        final Snapshot snapshot = reservoir.getSnapshot();
+    final Snapshot snapshot = reservoir.getSnapshot();
 
-        assertThat(reservoir.size())
-                .isEqualTo(100);
+    assertThat(reservoir.size()).isEqualTo(100);
 
-        assertThat(snapshot.size())
-                .isEqualTo(100);
+    assertThat(snapshot.size()).isEqualTo(100);
 
-        for (double i : snapshot.getValues()) {
-            assertThat(i)
-                    .isLessThan(1000)
-                    .isGreaterThanOrEqualTo(0);
-        }
+    for (double i : snapshot.getValues()) {
+      assertThat(i).isLessThan(1000).isNotNegative();
     }
-
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/UniformSnapshotTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/UniformSnapshotTest.java
@@ -1,205 +1,198 @@
 package io.dropwizard.metrics5;
 
-import org.junit.jupiter.api.Test;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.assertj.core.api.Assertions.offset;
 
 import java.io.ByteArrayOutputStream;
 import java.util.Random;
 import java.util.concurrent.ConcurrentSkipListSet;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.Test;
 
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.offset;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-
-class UniformSnapshotTest {
-    private final Snapshot snapshot = new UniformSnapshot(new long[]{5, 1, 2, 3, 4});
-
-    @Test
-    void smallQuantilesAreTheFirstValue() {
-        assertThat(snapshot.getValue(0.0))
-                .isEqualTo(1, offset(0.1));
-    }
-
-    @Test
-    void bigQuantilesAreTheLastValue() {
-        assertThat(snapshot.getValue(1.0))
-                .isEqualTo(5, offset(0.1));
-    }
-
-    @Test
-    void disallowsNotANumberQuantile() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            snapshot.getValue(Double.NaN);
-        });
-    }
-
-    @Test
-    void disallowsNegativeQuantile() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            snapshot.getValue(-0.5);
-        });
-    }
-
-    @Test
-    void disallowsQuantileOverOne() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            snapshot.getValue(1.5);
-        });
-    }
-
-    @Test
-    void hasAMedian() {
-        assertThat(snapshot.getMedian()).isEqualTo(3, offset(0.1));
-    }
-
-    @Test
-    void hasAp75() {
-        assertThat(snapshot.get75thPercentile()).isEqualTo(4.5, offset(0.1));
-    }
-
-    @Test
-    void hasAp95() {
-        assertThat(snapshot.get95thPercentile()).isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void hasAp98() {
-        assertThat(snapshot.get98thPercentile()).isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void hasAp99() {
-        assertThat(snapshot.get99thPercentile()).isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void hasAp999() {
-        assertThat(snapshot.get999thPercentile()).isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void hasValues() {
-        assertThat(snapshot.getValues())
-                .containsOnly(1, 2, 3, 4, 5);
-    }
-
-    @Test
-    void hasASize() {
-        assertThat(snapshot.size())
-                .isEqualTo(5);
-    }
-
-    @Test
-    void canAlsoBeCreatedFromACollectionOfLongs() {
-        final Snapshot other = new UniformSnapshot(asList(5L, 1L, 2L, 3L, 4L));
-
-        assertThat(other.getValues())
-                .containsOnly(1, 2, 3, 4, 5);
-    }
-
-    @Test
-    void correctlyCreatedFromCollectionWithWeakIterator() throws Exception {
-        final ConcurrentSkipListSet<Long> values = new ConcurrentSkipListSet<>();
-
-        // Create a latch to make sure that the background thread has started and
-        // pushed some data to the collection.
-        final CountDownLatch latch = new CountDownLatch(10);
-        final Thread backgroundThread = new Thread(() -> {
-            final Random random = new Random();
-            // Update the collection in the loop to trigger a potential `ArrayOutOfBoundException`
-            // and verify that the snapshot doesn't make assumptions about the size of the iterator.
-            while (!Thread.currentThread().isInterrupted()) {
+final class UniformSnapshotTest {
+  private final Snapshot snapshot = new UniformSnapshot(new long[] {5, 1, 2, 3, 4});
+
+  @Test
+  void smallQuantilesAreTheFirstValue() {
+    assertThat(snapshot.getValue(0.0)).isCloseTo(1, offset(0.1));
+  }
+
+  @Test
+  void bigQuantilesAreTheLastValue() {
+    assertThat(snapshot.getValue(1.0)).isCloseTo(5, offset(0.1));
+  }
+
+  @Test
+  void disallowsNotANumberQuantile() {
+    assertThatThrownBy(
+            () -> {
+              snapshot.getValue(Double.NaN);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void disallowsNegativeQuantile() {
+    assertThatThrownBy(
+            () -> {
+              snapshot.getValue(-0.5);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void disallowsQuantileOverOne() {
+    assertThatThrownBy(
+            () -> {
+              snapshot.getValue(1.5);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void hasAMedian() {
+    assertThat(snapshot.getMedian()).isCloseTo(3, offset(0.1));
+  }
+
+  @Test
+  void hasAp75() {
+    assertThat(snapshot.get75thPercentile()).isCloseTo(4.5, offset(0.1));
+  }
+
+  @Test
+  void hasAp95() {
+    assertThat(snapshot.get95thPercentile()).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void hasAp98() {
+    assertThat(snapshot.get98thPercentile()).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void hasAp99() {
+    assertThat(snapshot.get99thPercentile()).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void hasAp999() {
+    assertThat(snapshot.get999thPercentile()).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void hasValues() {
+    assertThat(snapshot.getValues()).containsOnly(1, 2, 3, 4, 5);
+  }
+
+  @Test
+  void hasASize() {
+    assertThat(snapshot.size()).isEqualTo(5);
+  }
+
+  @Test
+  void canAlsoBeCreatedFromACollectionOfLongs() {
+    final Snapshot other = new UniformSnapshot(asList(5L, 1L, 2L, 3L, 4L));
+
+    assertThat(other.getValues()).containsOnly(1, 2, 3, 4, 5);
+  }
+
+  @Test
+  void correctlyCreatedFromCollectionWithWeakIterator() throws Exception {
+    final ConcurrentSkipListSet<Long> values = new ConcurrentSkipListSet<>();
+
+    // Create a latch to make sure that the background thread has started and
+    // pushed some data to the collection.
+    final CountDownLatch latch = new CountDownLatch(10);
+    final Thread backgroundThread =
+        new Thread(
+            () -> {
+              final Random random = new Random();
+              // Update the collection in the loop to trigger a potential `ArrayOutOfBoundException`
+              // and verify that the snapshot doesn't make assumptions about the size of the
+              // iterator.
+              while (!Thread.currentThread().isInterrupted()) {
                 values.add(random.nextLong());
                 latch.countDown();
-            }
-        });
-        backgroundThread.start();
-
-        try {
-            latch.await(5, TimeUnit.SECONDS);
-            assertThat(latch.getCount()).isEqualTo(0);
-
-            // Create a snapshot while the  collection is being updated.
-            final Snapshot snapshot = new UniformSnapshot(values);
-            assertThat(snapshot.getValues().length).isGreaterThanOrEqualTo(10);
-        } finally {
-            backgroundThread.interrupt();
-        }
+              }
+            });
+    backgroundThread.start();
+
+    try {
+      latch.await(5, TimeUnit.SECONDS);
+      assertThat(latch.getCount()).isEqualTo(0);
+
+      // Create a snapshot while the  collection is being updated.
+      final Snapshot snapshot = new UniformSnapshot(values);
+      assertThat(snapshot.getValues().length).isGreaterThanOrEqualTo(10);
+    } finally {
+      backgroundThread.interrupt();
     }
+  }
 
-    @Test
-    void dumpsToAStream() {
-        final ByteArrayOutputStream output = new ByteArrayOutputStream();
+  @Test
+  void dumpsToAStream() {
+    final ByteArrayOutputStream output = new ByteArrayOutputStream();
 
-        snapshot.dump(output);
+    snapshot.dump(output);
 
-        assertThat(output.toString())
-                .isEqualTo(String.format("1%n2%n3%n4%n5%n"));
-    }
+    assertThat(output).hasToString(String.format("1%n2%n3%n4%n5%n"));
+  }
 
-    @Test
-    void calculatesTheMinimumValue() {
-        assertThat(snapshot.getMin())
-                .isEqualTo(1);
-    }
+  @Test
+  void calculatesTheMinimumValue() {
+    assertThat(snapshot.getMin()).isEqualTo(1);
+  }
 
-    @Test
-    void calculatesTheMaximumValue() {
-        assertThat(snapshot.getMax())
-                .isEqualTo(5);
-    }
+  @Test
+  void calculatesTheMaximumValue() {
+    assertThat(snapshot.getMax()).isEqualTo(5);
+  }
 
-    @Test
-    void calculatesTheMeanValue() {
-        assertThat(snapshot.getMean())
-                .isEqualTo(3.0);
-    }
+  @Test
+  void calculatesTheMeanValue() {
+    assertThat(snapshot.getMean()).isEqualTo(3.0);
+  }
 
-    @Test
-    void calculatesTheStdDev() {
-        assertThat(snapshot.getStdDev())
-                .isEqualTo(1.5811, offset(0.0001));
-    }
+  @Test
+  void calculatesTheStdDev() {
+    assertThat(snapshot.getStdDev()).isCloseTo(1.5811, offset(0.0001));
+  }
 
-    @Test
-    void calculatesAMinOfZeroForAnEmptySnapshot() {
-        final Snapshot emptySnapshot = new UniformSnapshot(new long[]{});
+  @Test
+  void calculatesAMinOfZeroForAnEmptySnapshot() {
+    final Snapshot emptySnapshot = new UniformSnapshot(new long[] {});
 
-        assertThat(emptySnapshot.getMin())
-                .isZero();
-    }
+    assertThat(emptySnapshot.getMin()).isEqualTo(0);
+  }
 
-    @Test
-    void calculatesAMaxOfZeroForAnEmptySnapshot() {
-        final Snapshot emptySnapshot = new UniformSnapshot(new long[]{});
+  @Test
+  void calculatesAMaxOfZeroForAnEmptySnapshot() {
+    final Snapshot emptySnapshot = new UniformSnapshot(new long[] {});
 
-        assertThat(emptySnapshot.getMax())
-                .isZero();
-    }
+    assertThat(emptySnapshot.getMax()).isEqualTo(0);
+  }
 
-    @Test
-    void calculatesAMeanOfZeroForAnEmptySnapshot() {
-        final Snapshot emptySnapshot = new UniformSnapshot(new long[]{});
+  @Test
+  void calculatesAMeanOfZeroForAnEmptySnapshot() {
+    final Snapshot emptySnapshot = new UniformSnapshot(new long[] {});
 
-        assertThat(emptySnapshot.getMean())
-                .isZero();
-    }
+    assertThat(emptySnapshot.getMean()).isEqualTo(0);
+  }
 
-    @Test
-    void calculatesAStdDevOfZeroForAnEmptySnapshot() {
-        final Snapshot emptySnapshot = new UniformSnapshot(new long[]{});
+  @Test
+  void calculatesAStdDevOfZeroForAnEmptySnapshot() {
+    final Snapshot emptySnapshot = new UniformSnapshot(new long[] {});
 
-        assertThat(emptySnapshot.getStdDev())
-                .isZero();
-    }
+    assertThat(emptySnapshot.getStdDev()).isEqualTo(0);
+  }
 
-    @Test
-    void calculatesAStdDevOfZeroForASingletonSnapshot() {
-        final Snapshot singleItemSnapshot = new UniformSnapshot(new long[]{1});
+  @Test
+  void calculatesAStdDevOfZeroForASingletonSnapshot() {
+    final Snapshot singleItemSnapshot = new UniformSnapshot(new long[] {1});
 
-        assertThat(singleItemSnapshot.getStdDev())
-                .isZero();
-    }
+    assertThat(singleItemSnapshot.getStdDev()).isEqualTo(0);
+  }
 }
--- a/metrics-core/src/test/java/io/dropwizard/metrics5/WeightedSnapshotTest.java
+++ b/metrics-core/src/test/java/io/dropwizard/metrics5/WeightedSnapshotTest.java
@@ -1,235 +1,232 @@
 package io.dropwizard.metrics5;
 
-import io.dropwizard.metrics5.WeightedSnapshot.WeightedSample;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentMatchers;
-
-import java.io.ByteArrayOutputStream;
-import java.util.ArrayList;
-import java.util.List;
-
+import static com.google.common.base.Preconditions.checkArgument;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.Assertions.offset;
-import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 
-class WeightedSnapshotTest {
-
-    private static List<WeightedSnapshot.WeightedSample> weightedArray(long[] values, double[] weights) {
-        if (values.length != weights.length) {
-            throw new IllegalArgumentException("Mismatched lengths: " + values.length + " vs " + weights.length);
-        }
-
-        final List<WeightedSnapshot.WeightedSample> samples = new ArrayList<>();
-        for (int i = 0; i < values.length; i++) {
-            samples.add(new WeightedSnapshot.WeightedSample(values[i], weights[i]));
-        }
-
-        return samples;
-    }
-
-    private final Snapshot snapshot = new WeightedSnapshot(
-            weightedArray(new long[]{5, 1, 2, 3, 4}, new double[]{1, 2, 3, 2, 2}));
-
-    @Test
-    void smallQuantilesAreTheFirstValue() {
-        assertThat(snapshot.getValue(0.0))
-                .isEqualTo(1.0, offset(0.1));
-    }
-
-    @Test
-    void bigQuantilesAreTheLastValue() {
-        assertThat(snapshot.getValue(1.0))
-                .isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void disallowsNotANumberQuantile() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            snapshot.getValue(Double.NaN);
-        });
-    }
-
-    @Test
-    void disallowsNegativeQuantile() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            snapshot.getValue(-0.5);
-        });
-    }
-
-    @Test
-    void disallowsQuantileOverOne() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            snapshot.getValue(1.5);
-        });
-    }
-
-    @Test
-    void hasAMedian() {
-        assertThat(snapshot.getMedian()).isEqualTo(3.0, offset(0.1));
-    }
-
-    @Test
-    void hasAp75() {
-        assertThat(snapshot.get75thPercentile()).isEqualTo(4.0, offset(0.1));
-    }
-
-    @Test
-    void hasAp95() {
-        assertThat(snapshot.get95thPercentile()).isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void hasAp98() {
-        assertThat(snapshot.get98thPercentile()).isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void hasAp99() {
-        assertThat(snapshot.get99thPercentile()).isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void hasAp999() {
-        assertThat(snapshot.get999thPercentile()).isEqualTo(5.0, offset(0.1));
-    }
-
-    @Test
-    void hasValues() {
-        assertThat(snapshot.getValues())
-                .containsOnly(1, 2, 3, 4, 5);
-    }
-
-    @Test
-    void hasASize() {
-        assertThat(snapshot.size())
-                .isEqualTo(5);
-    }
-
-    @Test
-    void worksWithUnderestimatedCollections() {
-        final List<WeightedSample> originalItems = weightedArray(new long[]{5, 1, 2, 3, 4}, new double[]{1, 2, 3, 2, 2});
-        final List<WeightedSample> spyItems = spy(originalItems);
-        doReturn(originalItems.toArray(new WeightedSample[]{})).when(spyItems).toArray(ArgumentMatchers.any(WeightedSample[].class));
-        when(spyItems.size()).thenReturn(4, 5);
-
-        final Snapshot other = new WeightedSnapshot(spyItems);
-
-        assertThat(other.getValues())
-                .containsOnly(1, 2, 3, 4, 5);
-    }
-
-    @Test
-    void worksWithOverestimatedCollections() {
-        final List<WeightedSample> originalItems = weightedArray(new long[]{5, 1, 2, 3, 4}, new double[]{1, 2, 3, 2, 2});
-        final List<WeightedSample> spyItems = spy(originalItems);
-        doReturn(originalItems.toArray(new WeightedSample[]{})).when(spyItems).toArray(ArgumentMatchers.any(WeightedSample[].class));
-        when(spyItems.size()).thenReturn(6, 5);
-
-        final Snapshot other = new WeightedSnapshot(spyItems);
-
-        assertThat(other.getValues())
-                .containsOnly(1, 2, 3, 4, 5);
-    }
-
-    @Test
-    void dumpsToAStream() {
-        final ByteArrayOutputStream output = new ByteArrayOutputStream();
-
-        snapshot.dump(output);
-
-        assertThat(output.toString())
-                .isEqualTo(String.format("1%n2%n3%n4%n5%n"));
-    }
-
-    @Test
-    void calculatesTheMinimumValue() {
-        assertThat(snapshot.getMin())
-                .isEqualTo(1);
-    }
-
-    @Test
-    void calculatesTheMaximumValue() {
-        assertThat(snapshot.getMax())
-                .isEqualTo(5);
-    }
-
-    @Test
-    void calculatesTheMeanValue() {
-        assertThat(snapshot.getMean())
-                .isEqualTo(2.7);
-    }
-
-    @Test
-    void calculatesTheStdDev() {
-        assertThat(snapshot.getStdDev())
-                .isEqualTo(1.2688, offset(0.0001));
-    }
-
-    @Test
-    void calculatesAMinOfZeroForAnEmptySnapshot() {
-        final Snapshot emptySnapshot = new WeightedSnapshot(
-                weightedArray(new long[]{}, new double[]{}));
-
-        assertThat(emptySnapshot.getMin())
-                .isZero();
-    }
-
-    @Test
-    void calculatesAMaxOfZeroForAnEmptySnapshot() {
-        final Snapshot emptySnapshot = new WeightedSnapshot(
-                weightedArray(new long[]{}, new double[]{}));
-
-        assertThat(emptySnapshot.getMax())
-                .isZero();
-    }
-
-    @Test
-    void calculatesAMeanOfZeroForAnEmptySnapshot() {
-        final Snapshot emptySnapshot = new WeightedSnapshot(
-                weightedArray(new long[]{}, new double[]{}));
-
-        assertThat(emptySnapshot.getMean())
-                .isZero();
-    }
-
-    @Test
-    void calculatesAStdDevOfZeroForAnEmptySnapshot() {
-        final Snapshot emptySnapshot = new WeightedSnapshot(
-                weightedArray(new long[]{}, new double[]{}));
-
-        assertThat(emptySnapshot.getStdDev())
-                .isZero();
-    }
-
-    @Test
-    void calculatesAStdDevOfZeroForASingletonSnapshot() {
-        final Snapshot singleItemSnapshot = new WeightedSnapshot(
-                weightedArray(new long[]{1}, new double[]{1.0}));
-
-        assertThat(singleItemSnapshot.getStdDev())
-                .isZero();
-    }
-
-    @Test
-    void expectNoOverflowForLowWeights() {
-        final Snapshot scatteredSnapshot = new WeightedSnapshot(
-                weightedArray(
-                        new long[]{1, 2, 3},
-                        new double[]{Double.MIN_VALUE, Double.MIN_VALUE, Double.MIN_VALUE}
-                )
-        );
-
-        assertThat(scatteredSnapshot.getMean())
-                .isEqualTo(2);
-    }
+import io.dropwizard.metrics5.WeightedSnapshot.WeightedSample;
+import java.io.ByteArrayOutputStream;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.jupiter.api.Test;
 
-    @Test
-    void doesNotProduceNaNValues() {
-        WeightedSnapshot weightedSnapshot = new WeightedSnapshot(
-                weightedArray(new long[]{1, 2, 3}, new double[]{0, 0, 0}));
-        assertThat(weightedSnapshot.getMean()).isEqualTo(0);
-    }
+final class WeightedSnapshotTest {
+
+  private static List<WeightedSnapshot.WeightedSample> weightedArray(
+      long[] values, double[] weights) {
+    checkArgument(
+        values.length == weights.length,
+        "Mismatched lengths: %s vs %s",
+        values.length,
+        weights.length);
+
+    final List<WeightedSnapshot.WeightedSample> samples = new ArrayList<>();
+    for (int i = 0; i < values.length; i++) {
+      samples.add(new WeightedSnapshot.WeightedSample(values[i], weights[i]));
+    }
+
+    return samples;
+  }
+
+  private final Snapshot snapshot =
+      new WeightedSnapshot(weightedArray(new long[] {5, 1, 2, 3, 4}, new double[] {1, 2, 3, 2, 2}));
+
+  @Test
+  void smallQuantilesAreTheFirstValue() {
+    assertThat(snapshot.getValue(0.0)).isCloseTo(1.0, offset(0.1));
+  }
+
+  @Test
+  void bigQuantilesAreTheLastValue() {
+    assertThat(snapshot.getValue(1.0)).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void disallowsNotANumberQuantile() {
+    assertThatThrownBy(
+            () -> {
+              snapshot.getValue(Double.NaN);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void disallowsNegativeQuantile() {
+    assertThatThrownBy(
+            () -> {
+              snapshot.getValue(-0.5);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void disallowsQuantileOverOne() {
+    assertThatThrownBy(
+            () -> {
+              snapshot.getValue(1.5);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void hasAMedian() {
+    assertThat(snapshot.getMedian()).isCloseTo(3.0, offset(0.1));
+  }
+
+  @Test
+  void hasAp75() {
+    assertThat(snapshot.get75thPercentile()).isCloseTo(4.0, offset(0.1));
+  }
+
+  @Test
+  void hasAp95() {
+    assertThat(snapshot.get95thPercentile()).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void hasAp98() {
+    assertThat(snapshot.get98thPercentile()).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void hasAp99() {
+    assertThat(snapshot.get99thPercentile()).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void hasAp999() {
+    assertThat(snapshot.get999thPercentile()).isCloseTo(5.0, offset(0.1));
+  }
+
+  @Test
+  void hasValues() {
+    assertThat(snapshot.getValues()).containsOnly(1, 2, 3, 4, 5);
+  }
+
+  @Test
+  void hasASize() {
+    assertThat(snapshot.size()).isEqualTo(5);
+  }
+
+  @Test
+  void worksWithUnderestimatedCollections() {
+    final List<WeightedSample> originalItems =
+        weightedArray(new long[] {5, 1, 2, 3, 4}, new double[] {1, 2, 3, 2, 2});
+    final List<WeightedSample> spyItems = spy(originalItems);
+    doReturn(originalItems.toArray(new WeightedSample[] {}))
+        .when(spyItems)
+        .toArray(any(WeightedSample[].class));
+    when(spyItems.size()).thenReturn(4, 5);
+
+    final Snapshot other = new WeightedSnapshot(spyItems);
+
+    assertThat(other.getValues()).containsOnly(1, 2, 3, 4, 5);
+  }
+
+  @Test
+  void worksWithOverestimatedCollections() {
+    final List<WeightedSample> originalItems =
+        weightedArray(new long[] {5, 1, 2, 3, 4}, new double[] {1, 2, 3, 2, 2});
+    final List<WeightedSample> spyItems = spy(originalItems);
+    doReturn(originalItems.toArray(new WeightedSample[] {}))
+        .when(spyItems)
+        .toArray(any(WeightedSample[].class));
+    when(spyItems.size()).thenReturn(6, 5);
+
+    final Snapshot other = new WeightedSnapshot(spyItems);
+
+    assertThat(other.getValues()).containsOnly(1, 2, 3, 4, 5);
+  }
+
+  @Test
+  void dumpsToAStream() {
+    final ByteArrayOutputStream output = new ByteArrayOutputStream();
+
+    snapshot.dump(output);
+
+    assertThat(output).hasToString(String.format("1%n2%n3%n4%n5%n"));
+  }
+
+  @Test
+  void calculatesTheMinimumValue() {
+    assertThat(snapshot.getMin()).isEqualTo(1);
+  }
+
+  @Test
+  void calculatesTheMaximumValue() {
+    assertThat(snapshot.getMax()).isEqualTo(5);
+  }
+
+  @Test
+  void calculatesTheMeanValue() {
+    assertThat(snapshot.getMean()).isEqualTo(2.7);
+  }
+
+  @Test
+  void calculatesTheStdDev() {
+    assertThat(snapshot.getStdDev()).isCloseTo(1.2688, offset(0.0001));
+  }
+
+  @Test
+  void calculatesAMinOfZeroForAnEmptySnapshot() {
+    final Snapshot emptySnapshot =
+        new WeightedSnapshot(weightedArray(new long[] {}, new double[] {}));
+
+    assertThat(emptySnapshot.getMin()).isEqualTo(0);
+  }
+
+  @Test
+  void calculatesAMaxOfZeroForAnEmptySnapshot() {
+    final Snapshot emptySnapshot =
+        new WeightedSnapshot(weightedArray(new long[] {}, new double[] {}));
+
+    assertThat(emptySnapshot.getMax()).isEqualTo(0);
+  }
+
+  @Test
+  void calculatesAMeanOfZeroForAnEmptySnapshot() {
+    final Snapshot emptySnapshot =
+        new WeightedSnapshot(weightedArray(new long[] {}, new double[] {}));
+
+    assertThat(emptySnapshot.getMean()).isEqualTo(0);
+  }
+
+  @Test
+  void calculatesAStdDevOfZeroForAnEmptySnapshot() {
+    final Snapshot emptySnapshot =
+        new WeightedSnapshot(weightedArray(new long[] {}, new double[] {}));
+
+    assertThat(emptySnapshot.getStdDev()).isEqualTo(0);
+  }
+
+  @Test
+  void calculatesAStdDevOfZeroForASingletonSnapshot() {
+    final Snapshot singleItemSnapshot =
+        new WeightedSnapshot(weightedArray(new long[] {1}, new double[] {1.0}));
+
+    assertThat(singleItemSnapshot.getStdDev()).isEqualTo(0);
+  }
+
+  @Test
+  void expectNoOverflowForLowWeights() {
+    final Snapshot scatteredSnapshot =
+        new WeightedSnapshot(
+            weightedArray(
+                new long[] {1, 2, 3},
+                new double[] {Double.MIN_VALUE, Double.MIN_VALUE, Double.MIN_VALUE}));
+
+    assertThat(scatteredSnapshot.getMean()).isEqualTo(2);
+  }
+
+  @Test
+  void doesNotProduceNaNValues() {
+    WeightedSnapshot weightedSnapshot =
+        new WeightedSnapshot(weightedArray(new long[] {1, 2, 3}, new double[] {0, 0, 0}));
+    assertThat(weightedSnapshot.getMean()).isEqualTo(0);
+  }
 }
--- a/metrics-ehcache/src/main/java/io/dropwizard/metrics5/ehcache/InstrumentedCacheDecoratorFactory.java
+++ b/metrics-ehcache/src/main/java/io/dropwizard/metrics5/ehcache/InstrumentedCacheDecoratorFactory.java
@@ -2,23 +2,22 @@ package io.dropwizard.metrics5.ehcache;
 
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.SharedMetricRegistries;
+import java.util.Properties;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.constructs.CacheDecoratorFactory;
 
-import java.util.Properties;
-
 public class InstrumentedCacheDecoratorFactory extends CacheDecoratorFactory {
-    @Override
-    public Ehcache createDecoratedEhcache(Ehcache cache, Properties properties) {
-        final String name = properties.getProperty("metric-registry-name");
-        final MetricRegistry registry = SharedMetricRegistries.getOrCreate(name);
-        return InstrumentedEhcache.instrument(registry, cache);
-    }
+  @Override
+  public Ehcache createDecoratedEhcache(Ehcache cache, Properties properties) {
+    final String name = properties.getProperty("metric-registry-name");
+    final MetricRegistry registry = SharedMetricRegistries.getOrCreate(name);
+    return InstrumentedEhcache.instrument(registry, cache);
+  }
 
-    @Override
-    public Ehcache createDefaultDecoratedEhcache(Ehcache cache, Properties properties) {
-        final String name = properties.getProperty("metric-registry-name");
-        final MetricRegistry registry = SharedMetricRegistries.getOrCreate(name);
-        return InstrumentedEhcache.instrument(registry, cache);
-    }
+  @Override
+  public Ehcache createDefaultDecoratedEhcache(Ehcache cache, Properties properties) {
+    final String name = properties.getProperty("metric-registry-name");
+    final MetricRegistry registry = SharedMetricRegistries.getOrCreate(name);
+    return InstrumentedEhcache.instrument(registry, cache);
+  }
 }
--- a/metrics-ehcache/src/main/java/io/dropwizard/metrics5/ehcache/InstrumentedEhcache.java
+++ b/metrics-ehcache/src/main/java/io/dropwizard/metrics5/ehcache/InstrumentedEhcache.java
@@ -1,232 +1,233 @@
 package io.dropwizard.metrics5.ehcache;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.io.Serializable;
 import net.sf.ehcache.CacheException;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.Element;
 import net.sf.ehcache.constructs.EhcacheDecoratorAdapter;
 import net.sf.ehcache.statistics.StatisticsGateway;
 
-import java.io.Serializable;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
-/**
- * An instrumented {@link Ehcache} instance.
- */
+/** An instrumented {@link Ehcache} instance. */
 public class InstrumentedEhcache extends EhcacheDecoratorAdapter {
-    /**
-     * Instruments the given {@link Ehcache} instance with get and put timers
-     * and a set of gauges for Ehcache's built-in statistics:
-     * <p>
-     * <table>
-     * <caption>Ehcache timered metrics</caption>
-     * <tr>
-     * <td>{@code hits}</td>
-     * <td>The number of times a requested item was found in the
-     * cache.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code in-memory-hits}</td>
-     * <td>Number of times a requested item was found in the memory
-     * store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code off-heap-hits}</td>
-     * <td>Number of times a requested item was found in the off-heap
-     * store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code on-disk-hits}</td>
-     * <td>Number of times a requested item was found in the disk
-     * store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code misses}</td>
-     * <td>Number of times a requested item was not found in the
-     * cache.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code in-memory-misses}</td>
-     * <td>Number of times a requested item was not found in the memory
-     * store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code off-heap-misses}</td>
-     * <td>Number of times a requested item was not found in the
-     * off-heap store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code on-disk-misses}</td>
-     * <td>Number of times a requested item was not found in the disk
-     * store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code objects}</td>
-     * <td>Number of elements stored in the cache.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code in-memory-objects}</td>
-     * <td>Number of objects in the memory store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code off-heap-objects}</td>
-     * <td>Number of objects in the off-heap store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code on-disk-objects}</td>
-     * <td>Number of objects in the disk store.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code mean-get-time}</td>
-     * <td>The average get time. Because ehcache support JDK1.4.2, each
-     * get time uses {@link System#currentTimeMillis()}, rather than
-     * nanoseconds. The accuracy is thus limited.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code mean-search-time}</td>
-     * <td>The average execution time (in milliseconds) within the last
-     * sample period.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code eviction-count}</td>
-     * <td>The number of cache evictions, since the cache was created,
-     * or statistics were cleared.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code searches-per-second}</td>
-     * <td>The number of search executions that have completed in the
-     * last second.</td>
-     * </tr>
-     * <tr>
-     * <td>{@code accuracy}</td>
-     * <td>A human readable description of the accuracy setting. One of
-     * "None", "Best Effort" or "Guaranteed".</td>
-     * </tr>
-     * </table>
-     * <p>
-     * <b>N.B.: This enables Ehcache's sampling statistics with an accuracy
-     * level of "none."</b>
-     *
-     * @param cache    an {@link Ehcache} instance
-     * @param registry a {@link MetricRegistry}
-     * @return an instrumented decorator for {@code cache}
-     * @see StatisticsGateway
-     */
-    public static Ehcache instrument(MetricRegistry registry, final Ehcache cache) {
-
-        final MetricName prefix = name(cache.getClass(), cache.getName());
-        registry.registerGauge(prefix.resolve("hits"),
-                () -> cache.getStatistics().cacheHitCount());
-
-        registry.registerGauge(prefix.resolve("in-memory-hits"),
-                () -> cache.getStatistics().localHeapHitCount());
-
-        registry.registerGauge(prefix.resolve("off-heap-hits"),
-                () -> cache.getStatistics().localOffHeapHitCount());
-
-        registry.registerGauge(prefix.resolve("on-disk-hits"),
-                () -> cache.getStatistics().localDiskHitCount());
-
-        registry.registerGauge(prefix.resolve("misses"),
-                () -> cache.getStatistics().cacheMissCount());
-
-        registry.registerGauge(prefix.resolve("in-memory-misses"),
-                () -> cache.getStatistics().localHeapMissCount());
-
-        registry.registerGauge(prefix.resolve("off-heap-misses"),
-                () -> cache.getStatistics().localOffHeapMissCount());
-
-        registry.registerGauge(prefix.resolve("on-disk-misses"),
-                () -> cache.getStatistics().localDiskMissCount());
-
-        registry.registerGauge(prefix.resolve("objects"),
-                () -> cache.getStatistics().getSize());
-
-        registry.registerGauge(prefix.resolve("in-memory-objects"),
-                () -> cache.getStatistics().getLocalHeapSize());
-
-        registry.registerGauge(prefix.resolve("off-heap-objects"),
-                () -> cache.getStatistics().getLocalOffHeapSize());
-
-        registry.registerGauge(prefix.resolve("on-disk-objects"),
-                () -> cache.getStatistics().getLocalDiskSize());
-
-        registry.registerGauge(prefix.resolve("mean-get-time"),
-                () -> cache.getStatistics().cacheGetOperation().latency().average().value());
-
-        registry.registerGauge(prefix.resolve("mean-search-time"),
-                () -> cache.getStatistics().cacheSearchOperation().latency().average().value());
-
-        registry.registerGauge(prefix.resolve("eviction-count"),
-                () -> cache.getStatistics().cacheEvictionOperation().count().value());
-
-        registry.registerGauge(prefix.resolve("searches-per-second"),
-                () -> cache.getStatistics().cacheSearchOperation().rate().value());
-
-        registry.registerGauge(prefix.resolve("writer-queue-size"),
-                () -> cache.getStatistics().getWriterQueueLength());
-
-        return new InstrumentedEhcache(registry, cache);
-    }
-
-    private final Timer getTimer, putTimer;
-
-    private InstrumentedEhcache(MetricRegistry registry, Ehcache cache) {
-        super(cache);
-        this.getTimer = registry.timer(MetricRegistry.name(cache.getClass(), cache.getName(), "gets"));
-        this.putTimer = registry.timer(MetricRegistry.name(cache.getClass(), cache.getName(), "puts"));
-    }
-
-    @Override
-    public Element get(Object key) throws IllegalStateException, CacheException {
-        final Timer.Context ctx = getTimer.time();
-        try {
-            return underlyingCache.get(key);
-        } finally {
-            ctx.stop();
-        }
+  /**
+   * Instruments the given {@link Ehcache} instance with get and put timers and a set of gauges for
+   * Ehcache's built-in statistics:
+   *
+   * <p>
+   *
+   * <table>
+   * <caption>Ehcache timered metrics</caption>
+   * <tr>
+   * <td>{@code hits}</td>
+   * <td>The number of times a requested item was found in the
+   * cache.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code in-memory-hits}</td>
+   * <td>Number of times a requested item was found in the memory
+   * store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code off-heap-hits}</td>
+   * <td>Number of times a requested item was found in the off-heap
+   * store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code on-disk-hits}</td>
+   * <td>Number of times a requested item was found in the disk
+   * store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code misses}</td>
+   * <td>Number of times a requested item was not found in the
+   * cache.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code in-memory-misses}</td>
+   * <td>Number of times a requested item was not found in the memory
+   * store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code off-heap-misses}</td>
+   * <td>Number of times a requested item was not found in the
+   * off-heap store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code on-disk-misses}</td>
+   * <td>Number of times a requested item was not found in the disk
+   * store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code objects}</td>
+   * <td>Number of elements stored in the cache.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code in-memory-objects}</td>
+   * <td>Number of objects in the memory store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code off-heap-objects}</td>
+   * <td>Number of objects in the off-heap store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code on-disk-objects}</td>
+   * <td>Number of objects in the disk store.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code mean-get-time}</td>
+   * <td>The average get time. Because ehcache support JDK1.4.2, each
+   * get time uses {@link System#currentTimeMillis()}, rather than
+   * nanoseconds. The accuracy is thus limited.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code mean-search-time}</td>
+   * <td>The average execution time (in milliseconds) within the last
+   * sample period.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code eviction-count}</td>
+   * <td>The number of cache evictions, since the cache was created,
+   * or statistics were cleared.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code searches-per-second}</td>
+   * <td>The number of search executions that have completed in the
+   * last second.</td>
+   * </tr>
+   * <tr>
+   * <td>{@code accuracy}</td>
+   * <td>A human readable description of the accuracy setting. One of
+   * "None", "Best Effort" or "Guaranteed".</td>
+   * </tr>
+   * </table>
+   *
+   * <p><b>N.B.: This enables Ehcache's sampling statistics with an accuracy level of "none."</b>
+   *
+   * @param cache an {@link Ehcache} instance
+   * @param registry a {@link MetricRegistry}
+   * @return an instrumented decorator for {@code cache}
+   * @see StatisticsGateway
+   */
+  public static Ehcache instrument(MetricRegistry registry, final Ehcache cache) {
+
+    final MetricName prefix = name(cache.getClass(), cache.getName());
+    registry.registerGauge(prefix.resolve("hits"), () -> cache.getStatistics().cacheHitCount());
+
+    registry.registerGauge(
+        prefix.resolve("in-memory-hits"), () -> cache.getStatistics().localHeapHitCount());
+
+    registry.registerGauge(
+        prefix.resolve("off-heap-hits"), () -> cache.getStatistics().localOffHeapHitCount());
+
+    registry.registerGauge(
+        prefix.resolve("on-disk-hits"), () -> cache.getStatistics().localDiskHitCount());
+
+    registry.registerGauge(prefix.resolve("misses"), () -> cache.getStatistics().cacheMissCount());
+
+    registry.registerGauge(
+        prefix.resolve("in-memory-misses"), () -> cache.getStatistics().localHeapMissCount());
+
+    registry.registerGauge(
+        prefix.resolve("off-heap-misses"), () -> cache.getStatistics().localOffHeapMissCount());
+
+    registry.registerGauge(
+        prefix.resolve("on-disk-misses"), () -> cache.getStatistics().localDiskMissCount());
+
+    registry.registerGauge(prefix.resolve("objects"), () -> cache.getStatistics().getSize());
+
+    registry.registerGauge(
+        prefix.resolve("in-memory-objects"), () -> cache.getStatistics().getLocalHeapSize());
+
+    registry.registerGauge(
+        prefix.resolve("off-heap-objects"), () -> cache.getStatistics().getLocalOffHeapSize());
+
+    registry.registerGauge(
+        prefix.resolve("on-disk-objects"), () -> cache.getStatistics().getLocalDiskSize());
+
+    registry.registerGauge(
+        prefix.resolve("mean-get-time"),
+        () -> cache.getStatistics().cacheGetOperation().latency().average().value());
+
+    registry.registerGauge(
+        prefix.resolve("mean-search-time"),
+        () -> cache.getStatistics().cacheSearchOperation().latency().average().value());
+
+    registry.registerGauge(
+        prefix.resolve("eviction-count"),
+        () -> cache.getStatistics().cacheEvictionOperation().count().value());
+
+    registry.registerGauge(
+        prefix.resolve("searches-per-second"),
+        () -> cache.getStatistics().cacheSearchOperation().rate().value());
+
+    registry.registerGauge(
+        prefix.resolve("writer-queue-size"), () -> cache.getStatistics().getWriterQueueLength());
+
+    return new InstrumentedEhcache(registry, cache);
+  }
+
+  private final Timer getTimer, putTimer;
+
+  private InstrumentedEhcache(MetricRegistry registry, Ehcache cache) {
+    super(cache);
+    this.getTimer = registry.timer(MetricRegistry.name(cache.getClass(), cache.getName(), "gets"));
+    this.putTimer = registry.timer(MetricRegistry.name(cache.getClass(), cache.getName(), "puts"));
+  }
+
+  @Override
+  public Element get(Object key) throws IllegalStateException, CacheException {
+    final Timer.Context ctx = getTimer.time();
+    try {
+      return underlyingCache.get(key);
+    } finally {
+      ctx.stop();
     }
-
-    @Override
-    public Element get(Serializable key) throws IllegalStateException, CacheException {
-        final Timer.Context ctx = getTimer.time();
-        try {
-            return underlyingCache.get(key);
-        } finally {
-            ctx.stop();
-        }
+  }
+
+  @Override
+  public Element get(Serializable key) throws IllegalStateException, CacheException {
+    final Timer.Context ctx = getTimer.time();
+    try {
+      return underlyingCache.get(key);
+    } finally {
+      ctx.stop();
     }
-
-    @Override
-    public void put(Element element) throws IllegalArgumentException, IllegalStateException, CacheException {
-        final Timer.Context ctx = putTimer.time();
-        try {
-            underlyingCache.put(element);
-        } finally {
-            ctx.stop();
-        }
+  }
+
+  @Override
+  public void put(Element element)
+      throws IllegalArgumentException, IllegalStateException, CacheException {
+    final Timer.Context ctx = putTimer.time();
+    try {
+      underlyingCache.put(element);
+    } finally {
+      ctx.stop();
     }
-
-    @Override
-    public void put(Element element, boolean doNotNotifyCacheReplicators) throws IllegalArgumentException, IllegalStateException, CacheException {
-        final Timer.Context ctx = putTimer.time();
-        try {
-            underlyingCache.put(element, doNotNotifyCacheReplicators);
-        } finally {
-            ctx.stop();
-        }
+  }
+
+  @Override
+  public void put(Element element, boolean doNotNotifyCacheReplicators)
+      throws IllegalArgumentException, IllegalStateException, CacheException {
+    final Timer.Context ctx = putTimer.time();
+    try {
+      underlyingCache.put(element, doNotNotifyCacheReplicators);
+    } finally {
+      ctx.stop();
     }
-
-    @Override
-    public Element putIfAbsent(Element element) throws NullPointerException {
-        final Timer.Context ctx = putTimer.time();
-        try {
-            return underlyingCache.putIfAbsent(element);
-        } finally {
-            ctx.stop();
-        }
+  }
+
+  @Override
+  public Element putIfAbsent(Element element) throws NullPointerException {
+    final Timer.Context ctx = putTimer.time();
+    try {
+      return underlyingCache.putIfAbsent(element);
+    } finally {
+      ctx.stop();
     }
+  }
 }
--- a/metrics-ehcache/src/test/java/io/dropwizard/metrics5/ehcache/InstrumentedCacheDecoratorFactoryTest.java
+++ b/metrics-ehcache/src/test/java/io/dropwizard/metrics5/ehcache/InstrumentedCacheDecoratorFactoryTest.java
@@ -1,5 +1,8 @@
 package io.dropwizard.metrics5.ehcache;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assumptions.assumeThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.SharedMetricRegistries;
 import net.sf.ehcache.Cache;
@@ -9,37 +12,33 @@ import net.sf.ehcache.Element;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assumptions.assumeThat;
-
-class InstrumentedCacheDecoratorFactoryTest {
-    private static final CacheManager MANAGER = CacheManager.create();
-
-    private MetricRegistry registry;
-    private Ehcache cache;
+final class InstrumentedCacheDecoratorFactoryTest {
+  private static final CacheManager MANAGER = CacheManager.create();
 
-    @BeforeEach
-    void setUp() {
-        this.cache = MANAGER.getEhcache("test-config");
-        assumeThat(cache).isNotNull();
+  private MetricRegistry registry;
+  private Ehcache cache;
 
-        this.registry = SharedMetricRegistries.getOrCreate("cache-metrics");
-    }
+  @BeforeEach
+  void setUp() {
+    this.cache = MANAGER.getEhcache("test-config");
+    assumeThat(cache).isNotNull();
 
-    @Test
-    void measuresGets() {
-        cache.get("woo");
+    this.registry = SharedMetricRegistries.getOrCreate("cache-metrics");
+  }
 
-        assertThat(registry.timer(MetricRegistry.name(Cache.class, "test-config", "gets")).getCount())
-                .isEqualTo(1);
+  @Test
+  void measuresGets() {
+    cache.get("woo");
 
-    }
+    assertThat(registry.timer(MetricRegistry.name(Cache.class, "test-config", "gets")).getCount())
+        .isEqualTo(1);
+  }
 
-    @Test
-    void measuresPuts() {
-        cache.put(new Element("woo", "whee"));
+  @Test
+  void measuresPuts() {
+    cache.put(new Element("woo", "whee"));
 
-        assertThat(registry.timer(MetricRegistry.name(Cache.class, "test-config", "puts")).getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.timer(MetricRegistry.name(Cache.class, "test-config", "puts")).getCount())
+        .isEqualTo(1);
+  }
 }
--- a/metrics-ehcache/src/test/java/io/dropwizard/metrics5/ehcache/InstrumentedEhcacheTest.java
+++ b/metrics-ehcache/src/test/java/io/dropwizard/metrics5/ehcache/InstrumentedEhcacheTest.java
@@ -1,5 +1,8 @@
 package io.dropwizard.metrics5.ehcache;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.entry;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import net.sf.ehcache.Cache;
@@ -10,57 +13,52 @@ import net.sf.ehcache.config.CacheConfiguration;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.entry;
-
-class InstrumentedEhcacheTest {
-    private static final CacheManager MANAGER = CacheManager.create();
+final class InstrumentedEhcacheTest {
+  private static final CacheManager MANAGER = CacheManager.create();
 
-    private final MetricRegistry registry = new MetricRegistry();
-    private Ehcache cache;
+  private final MetricRegistry registry = new MetricRegistry();
+  private Ehcache cache;
 
-    @BeforeEach
-    void setUp() {
-        final Cache c = new Cache(new CacheConfiguration("test", 100));
-        MANAGER.addCache(c);
-        this.cache = InstrumentedEhcache.instrument(registry, c);
-        assertThat(registry.getGauges().entrySet().stream()
+  @BeforeEach
+  void setUp() {
+    final Cache c = new Cache(new CacheConfiguration("test", 100));
+    MANAGER.addCache(c);
+    this.cache = InstrumentedEhcache.instrument(registry, c);
+    assertThat(
+            registry.getGauges().entrySet().stream()
                 .map(e -> entry(e.getKey().getKey(), (Number) e.getValue().getValue())))
-                .containsOnly(
-                        entry("net.sf.ehcache.Cache.test.eviction-count", 0L),
-                        entry("net.sf.ehcache.Cache.test.hits", 0L),
-                        entry("net.sf.ehcache.Cache.test.in-memory-hits", 0L),
-                        entry("net.sf.ehcache.Cache.test.in-memory-misses", 0L),
-                        entry("net.sf.ehcache.Cache.test.in-memory-objects", 0L),
-                        entry("net.sf.ehcache.Cache.test.mean-get-time", Double.NaN),
-                        entry("net.sf.ehcache.Cache.test.mean-search-time", Double.NaN),
-                        entry("net.sf.ehcache.Cache.test.misses", 0L),
-                        entry("net.sf.ehcache.Cache.test.objects", 0L),
-                        entry("net.sf.ehcache.Cache.test.off-heap-hits", 0L),
-                        entry("net.sf.ehcache.Cache.test.off-heap-misses", 0L),
-                        entry("net.sf.ehcache.Cache.test.off-heap-objects", 0L),
-                        entry("net.sf.ehcache.Cache.test.on-disk-hits", 0L),
-                        entry("net.sf.ehcache.Cache.test.on-disk-misses", 0L),
-                        entry("net.sf.ehcache.Cache.test.on-disk-objects", 0L),
-                        entry("net.sf.ehcache.Cache.test.searches-per-second", 0.0),
-                        entry("net.sf.ehcache.Cache.test.writer-queue-size", 0L)
-                );
-    }
+        .containsOnly(
+            entry("net.sf.ehcache.Cache.test.eviction-count", 0L),
+            entry("net.sf.ehcache.Cache.test.hits", 0L),
+            entry("net.sf.ehcache.Cache.test.in-memory-hits", 0L),
+            entry("net.sf.ehcache.Cache.test.in-memory-misses", 0L),
+            entry("net.sf.ehcache.Cache.test.in-memory-objects", 0L),
+            entry("net.sf.ehcache.Cache.test.mean-get-time", Double.NaN),
+            entry("net.sf.ehcache.Cache.test.mean-search-time", Double.NaN),
+            entry("net.sf.ehcache.Cache.test.misses", 0L),
+            entry("net.sf.ehcache.Cache.test.objects", 0L),
+            entry("net.sf.ehcache.Cache.test.off-heap-hits", 0L),
+            entry("net.sf.ehcache.Cache.test.off-heap-misses", 0L),
+            entry("net.sf.ehcache.Cache.test.off-heap-objects", 0L),
+            entry("net.sf.ehcache.Cache.test.on-disk-hits", 0L),
+            entry("net.sf.ehcache.Cache.test.on-disk-misses", 0L),
+            entry("net.sf.ehcache.Cache.test.on-disk-objects", 0L),
+            entry("net.sf.ehcache.Cache.test.searches-per-second", 0.0),
+            entry("net.sf.ehcache.Cache.test.writer-queue-size", 0L));
+  }
 
-    @Test
-    void measuresGetsAndPuts() {
-        cache.get("woo");
+  @Test
+  void measuresGetsAndPuts() {
+    cache.get("woo");
 
-        cache.put(new Element("woo", "whee"));
+    cache.put(new Element("woo", "whee"));
 
-        final Timer gets = registry.timer(MetricRegistry.name(Cache.class, "test", "gets"));
+    final Timer gets = registry.timer(MetricRegistry.name(Cache.class, "test", "gets"));
 
-        assertThat(gets.getCount())
-                .isEqualTo(1);
+    assertThat(gets.getCount()).isEqualTo(1);
 
-        final Timer puts = registry.timer(MetricRegistry.name(Cache.class, "test", "puts"));
+    final Timer puts = registry.timer(MetricRegistry.name(Cache.class, "test", "puts"));
 
-        assertThat(puts.getCount())
-                .isEqualTo(1);
-    }
+    assertThat(puts.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/Graphite.java
+++ b/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/Graphite.java
@@ -1,9 +1,11 @@
 package io.dropwizard.metrics5.graphite;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Objects.requireNonNull;
 
-import javax.net.SocketFactory;
+import com.google.common.base.Strings;
 import java.io.BufferedWriter;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
@@ -12,190 +14,184 @@ import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.net.UnknownHostException;
 import java.nio.charset.Charset;
+import javax.net.SocketFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Objects.requireNonNull;
-
-/**
- * A client to a Carbon server via TCP.
- */
+/** A client to a Carbon server via TCP. */
 public class Graphite implements GraphiteSender {
-    // this may be optimistic about Carbon/Graphite
-
-    private final String hostname;
-    private final int port;
-    private final InetSocketAddress address;
-    private final SocketFactory socketFactory;
-    private final Charset charset;
-
-    private Socket socket;
-    private Writer writer;
-    private int failures;
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(Graphite.class);
-
-    /**
-     * Creates a new client which connects to the given address using the default
-     * {@link SocketFactory}.
-     *
-     * @param hostname The hostname of the Carbon server
-     * @param port     The port of the Carbon server
-     */
-    public Graphite(String hostname, int port) {
-        this(hostname, port, SocketFactory.getDefault());
-    }
-
-    /**
-     * Creates a new client which connects to the given address and socket factory.
-     *
-     * @param hostname      The hostname of the Carbon server
-     * @param port          The port of the Carbon server
-     * @param socketFactory the socket factory
-     */
-    public Graphite(String hostname, int port, SocketFactory socketFactory) {
-        this(hostname, port, socketFactory, UTF_8);
-    }
-
-    /**
-     * Creates a new client which connects to the given address and socket factory using the given
-     * character set.
-     *
-     * @param hostname      The hostname of the Carbon server
-     * @param port          The port of the Carbon server
-     * @param socketFactory the socket factory
-     * @param charset       the character set used by the server
-     */
-    public Graphite(String hostname, int port, SocketFactory socketFactory, Charset charset) {
-        if (hostname == null || hostname.isEmpty()) {
-            throw new IllegalArgumentException("hostname must not be null or empty");
-        }
-
-        if (port < 0 || port > 65535) {
-            throw new IllegalArgumentException("port must be a valid IP port (0-65535)");
-        }
-
-        this.hostname = hostname;
-        this.port = port;
-        this.address = null;
-        this.socketFactory = requireNonNull(socketFactory, "socketFactory must not be null");
-        this.charset = requireNonNull(charset, "charset must not be null");
-    }
-
-    /**
-     * Creates a new client which connects to the given address using the default
-     * {@link SocketFactory}.
-     *
-     * @param address the address of the Carbon server
-     */
-    public Graphite(InetSocketAddress address) {
-        this(address, SocketFactory.getDefault());
-    }
-
-    /**
-     * Creates a new client which connects to the given address and socket factory.
-     *
-     * @param address       the address of the Carbon server
-     * @param socketFactory the socket factory
-     */
-    public Graphite(InetSocketAddress address, SocketFactory socketFactory) {
-        this(address, socketFactory, UTF_8);
-    }
-
-    /**
-     * Creates a new client which connects to the given address and socket factory using the given
-     * character set.
-     *
-     * @param address       the address of the Carbon server
-     * @param socketFactory the socket factory
-     * @param charset       the character set used by the server
-     */
-    public Graphite(InetSocketAddress address, SocketFactory socketFactory, Charset charset) {
-        this.hostname = null;
-        this.port = -1;
-        this.address = requireNonNull(address, "address must not be null");
-        this.socketFactory = requireNonNull(socketFactory, "socketFactory must not be null");
-        this.charset = requireNonNull(charset, "charset must not be null");
+  // this may be optimistic about Carbon/Graphite
+
+  private final String hostname;
+  private final int port;
+  private final InetSocketAddress address;
+  private final SocketFactory socketFactory;
+  private final Charset charset;
+
+  private Socket socket;
+  private Writer writer;
+  private int failures;
+
+  private static final Logger LOG = LoggerFactory.getLogger(Graphite.class);
+
+  /**
+   * Creates a new client which connects to the given address using the default {@link
+   * SocketFactory}.
+   *
+   * @param hostname The hostname of the Carbon server
+   * @param port The port of the Carbon server
+   */
+  public Graphite(String hostname, int port) {
+    this(hostname, port, SocketFactory.getDefault());
+  }
+
+  /**
+   * Creates a new client which connects to the given address and socket factory.
+   *
+   * @param hostname The hostname of the Carbon server
+   * @param port The port of the Carbon server
+   * @param socketFactory the socket factory
+   */
+  public Graphite(String hostname, int port, SocketFactory socketFactory) {
+    this(hostname, port, socketFactory, UTF_8);
+  }
+
+  /**
+   * Creates a new client which connects to the given address and socket factory using the given
+   * character set.
+   *
+   * @param hostname The hostname of the Carbon server
+   * @param port The port of the Carbon server
+   * @param socketFactory the socket factory
+   * @param charset the character set used by the server
+   */
+  public Graphite(String hostname, int port, SocketFactory socketFactory, Charset charset) {
+    checkArgument(!Strings.isNullOrEmpty(hostname), "hostname must not be null or empty");
+
+    checkArgument(port >= 0 && port <= 65535, "port must be a valid IP port (0-65535)");
+
+    this.hostname = hostname;
+    this.port = port;
+    this.address = null;
+    this.socketFactory = requireNonNull(socketFactory, "socketFactory must not be null");
+    this.charset = requireNonNull(charset, "charset must not be null");
+  }
+
+  /**
+   * Creates a new client which connects to the given address using the default {@link
+   * SocketFactory}.
+   *
+   * @param address the address of the Carbon server
+   */
+  public Graphite(InetSocketAddress address) {
+    this(address, SocketFactory.getDefault());
+  }
+
+  /**
+   * Creates a new client which connects to the given address and socket factory.
+   *
+   * @param address the address of the Carbon server
+   * @param socketFactory the socket factory
+   */
+  public Graphite(InetSocketAddress address, SocketFactory socketFactory) {
+    this(address, socketFactory, UTF_8);
+  }
+
+  /**
+   * Creates a new client which connects to the given address and socket factory using the given
+   * character set.
+   *
+   * @param address the address of the Carbon server
+   * @param socketFactory the socket factory
+   * @param charset the character set used by the server
+   */
+  public Graphite(InetSocketAddress address, SocketFactory socketFactory, Charset charset) {
+    this.hostname = null;
+    this.port = -1;
+    this.address = requireNonNull(address, "address must not be null");
+    this.socketFactory = requireNonNull(socketFactory, "socketFactory must not be null");
+    this.charset = requireNonNull(charset, "charset must not be null");
+  }
+
+  @Override
+  public void connect() throws IllegalStateException, IOException {
+    checkState(!isConnected(), "Already connected");
+    InetSocketAddress address = this.address;
+    // the previous dns retry logic did not work, as address.getAddress would always return the
+    // cached value
+    // this version of the simplified logic will always cause a dns request if hostname has been
+    // supplied.
+    // InetAddress.getByName forces the dns lookup
+    // if an InetSocketAddress was supplied at create time that will take precedence.
+    if (address == null || address.getHostName() == null && hostname != null) {
+      address = new InetSocketAddress(hostname, port);
     }
 
-    @Override
-    public void connect() throws IllegalStateException, IOException {
-        if (isConnected()) {
-            throw new IllegalStateException("Already connected");
-        }
-        InetSocketAddress address = this.address;
-        // the previous dns retry logic did not work, as address.getAddress would always return the cached value
-        // this version of the simplified logic will always cause a dns request if hostname has been supplied.
-        // InetAddress.getByName forces the dns lookup
-        // if an InetSocketAddress was supplied at create time that will take precedence.
-        if (address == null || address.getHostName() == null && hostname != null) {
-            address = new InetSocketAddress(hostname, port);
-        }
-
-        if (address.getAddress() == null) {
-            throw new UnknownHostException(address.getHostName());
-        }
-
-        this.socket = socketFactory.createSocket(address.getAddress(), address.getPort());
-        this.writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));
+    if (address.getAddress() == null) {
+      throw new UnknownHostException(address.getHostName());
     }
 
-    @Override
-    public boolean isConnected() {
-        return socket != null && socket.isConnected() && !socket.isClosed();
+    this.socket = socketFactory.createSocket(address.getAddress(), address.getPort());
+    this.writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));
+  }
+
+  @Override
+  public boolean isConnected() {
+    return socket != null && socket.isConnected() && !socket.isClosed();
+  }
+
+  @Override
+  public void send(String name, String value, long timestamp) throws IOException {
+    try {
+      writer.write(sanitize(name));
+      writer.write(' ');
+      writer.write(sanitize(value));
+      writer.write(' ');
+      writer.write(Long.toString(timestamp));
+      writer.write('\n');
+      this.failures = 0;
+    } catch (IOException e) {
+      failures++;
+      throw e;
     }
+  }
 
-    @Override
-    public void send(String name, String value, long timestamp) throws IOException {
-        try {
-            writer.write(sanitize(name));
-            writer.write(' ');
-            writer.write(sanitize(value));
-            writer.write(' ');
-            writer.write(Long.toString(timestamp));
-            writer.write('\n');
-            this.failures = 0;
-        } catch (IOException e) {
-            failures++;
-            throw e;
-        }
-    }
+  @Override
+  public int getFailures() {
+    return failures;
+  }
 
-    @Override
-    public int getFailures() {
-        return failures;
+  @Override
+  public void flush() throws IOException {
+    if (writer != null) {
+      writer.flush();
     }
-
-    @Override
-    public void flush() throws IOException {
-        if (writer != null) {
-            writer.flush();
-        }
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      if (writer != null) {
+        writer.close();
+      }
+    } catch (IOException ex) {
+      LOG.debug("Error closing writer", ex);
+    } finally {
+      this.writer = null;
     }
 
-    @Override
-    public void close() throws IOException {
-        try {
-            if (writer != null) {
-                writer.close();
-            }
-        } catch (IOException ex) {
-            LOGGER.debug("Error closing writer", ex);
-        } finally {
-            this.writer = null;
-        }
-
-        try {
-            if (socket != null) {
-                socket.close();
-            }
-        } catch (IOException ex) {
-            LOGGER.debug("Error closing socket", ex);
-        } finally {
-            this.socket = null;
-        }
+    try {
+      if (socket != null) {
+        socket.close();
+      }
+    } catch (IOException ex) {
+      LOG.debug("Error closing socket", ex);
+    } finally {
+      this.socket = null;
     }
+  }
 
-    protected String sanitize(String s) {
-        return GraphiteSanitize.sanitize(s);
-    }
+  protected String sanitize(String s) {
+    return GraphiteSanitize.sanitize(s);
+  }
 }
--- a/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteRabbitMQ.java
+++ b/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteRabbitMQ.java
@@ -1,163 +1,162 @@
 package io.dropwizard.metrics5.graphite;
 
+import static com.google.common.base.Preconditions.checkState;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import com.rabbitmq.client.Channel;
 import com.rabbitmq.client.Connection;
 import com.rabbitmq.client.ConnectionFactory;
 import com.rabbitmq.client.DefaultSocketConfigurator;
-
 import java.io.IOException;
 import java.net.Socket;
 import java.util.concurrent.TimeoutException;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/**
- * A rabbit-mq client to a Carbon server.
- */
+/** A rabbit-mq client to a Carbon server. */
 public class GraphiteRabbitMQ implements GraphiteSender {
 
-    private static final Integer DEFAULT_RABBIT_CONNECTION_TIMEOUT_MS = 500;
-    private static final Integer DEFAULT_RABBIT_SOCKET_TIMEOUT_MS = 5000;
-    private static final Integer DEFAULT_RABBIT_REQUESTED_HEARTBEAT_SEC = 10;
-
-    private ConnectionFactory connectionFactory;
-    private Connection connection;
-    private Channel channel;
-    private String exchange;
-
-    private int failures;
-
-    /**
-     * Creates a new client with a given a {@link com.rabbitmq.client.ConnectionFactory} and an amqp exchange
-     *
-     * @param connectionFactory the {@link com.rabbitmq.client.ConnectionFactory} used to establish connection and publish to graphite server
-     * @param exchange          the amqp exchange
-     */
-    public GraphiteRabbitMQ(final ConnectionFactory connectionFactory, final String exchange) {
-        this.connectionFactory = connectionFactory;
-        this.exchange = exchange;
-    }
-
-    /**
-     * Creates a new client given connection details
-     *
-     * @param rabbitHost     the rabbitmq server host
-     * @param rabbitPort     the rabbitmq server port
-     * @param rabbitUsername the rabbitmq server username
-     * @param rabbitPassword the rabbitmq server password
-     * @param exchange       the amqp exchange
-     */
-    public GraphiteRabbitMQ(
-            final String rabbitHost,
-            final Integer rabbitPort,
-            final String rabbitUsername,
-            final String rabbitPassword,
-            final String exchange) {
-
-        this(rabbitHost,
-                rabbitPort,
-                rabbitUsername,
-                rabbitPassword,
-                exchange,
-                DEFAULT_RABBIT_CONNECTION_TIMEOUT_MS,
-                DEFAULT_RABBIT_SOCKET_TIMEOUT_MS,
-                DEFAULT_RABBIT_REQUESTED_HEARTBEAT_SEC);
-    }
-
-    /**
-     * Creates a new client given connection details
-     *
-     * @param rabbitHost                        the rabbitmq server host
-     * @param rabbitPort                        the rabbitmq server port
-     * @param rabbitUsername                    the rabbitmq server username
-     * @param rabbitPassword                    the rabbitmq server password
-     * @param exchange                          the amqp exchange
-     * @param rabbitConnectionTimeoutMS         the connection timeout in milliseconds
-     * @param rabbitSocketTimeoutMS             the socket timeout in milliseconds
-     * @param rabbitRequestedHeartbeatInSeconds the hearthbeat in seconds
-     */
-    public GraphiteRabbitMQ(
-            final String rabbitHost,
-            final Integer rabbitPort,
-            final String rabbitUsername,
-            final String rabbitPassword,
-            final String exchange,
-            final Integer rabbitConnectionTimeoutMS,
-            final Integer rabbitSocketTimeoutMS,
-            final Integer rabbitRequestedHeartbeatInSeconds) {
-
-        this.exchange = exchange;
-
-        this.connectionFactory = new ConnectionFactory();
-
-        connectionFactory.setSocketConfigurator(new DefaultSocketConfigurator() {
-            @Override
-            public void configure(Socket socket) throws IOException {
-                super.configure(socket);
-                socket.setSoTimeout(rabbitSocketTimeoutMS);
-            }
+  private static final Integer DEFAULT_RABBIT_CONNECTION_TIMEOUT_MS = 500;
+  private static final Integer DEFAULT_RABBIT_SOCKET_TIMEOUT_MS = 5000;
+  private static final Integer DEFAULT_RABBIT_REQUESTED_HEARTBEAT_SEC = 10;
+
+  private ConnectionFactory connectionFactory;
+  private Connection connection;
+  private Channel channel;
+  private String exchange;
+
+  private int failures;
+
+  /**
+   * Creates a new client with a given a {@link com.rabbitmq.client.ConnectionFactory} and an amqp
+   * exchange
+   *
+   * @param connectionFactory the {@link com.rabbitmq.client.ConnectionFactory} used to establish
+   *     connection and publish to graphite server
+   * @param exchange the amqp exchange
+   */
+  public GraphiteRabbitMQ(final ConnectionFactory connectionFactory, final String exchange) {
+    this.connectionFactory = connectionFactory;
+    this.exchange = exchange;
+  }
+
+  /**
+   * Creates a new client given connection details
+   *
+   * @param rabbitHost the rabbitmq server host
+   * @param rabbitPort the rabbitmq server port
+   * @param rabbitUsername the rabbitmq server username
+   * @param rabbitPassword the rabbitmq server password
+   * @param exchange the amqp exchange
+   */
+  public GraphiteRabbitMQ(
+      final String rabbitHost,
+      final Integer rabbitPort,
+      final String rabbitUsername,
+      final String rabbitPassword,
+      final String exchange) {
+
+    this(
+        rabbitHost,
+        rabbitPort,
+        rabbitUsername,
+        rabbitPassword,
+        exchange,
+        DEFAULT_RABBIT_CONNECTION_TIMEOUT_MS,
+        DEFAULT_RABBIT_SOCKET_TIMEOUT_MS,
+        DEFAULT_RABBIT_REQUESTED_HEARTBEAT_SEC);
+  }
+
+  /**
+   * Creates a new client given connection details
+   *
+   * @param rabbitHost the rabbitmq server host
+   * @param rabbitPort the rabbitmq server port
+   * @param rabbitUsername the rabbitmq server username
+   * @param rabbitPassword the rabbitmq server password
+   * @param exchange the amqp exchange
+   * @param rabbitConnectionTimeoutMS the connection timeout in milliseconds
+   * @param rabbitSocketTimeoutMS the socket timeout in milliseconds
+   * @param rabbitRequestedHeartbeatInSeconds the hearthbeat in seconds
+   */
+  public GraphiteRabbitMQ(
+      final String rabbitHost,
+      final Integer rabbitPort,
+      final String rabbitUsername,
+      final String rabbitPassword,
+      final String exchange,
+      final Integer rabbitConnectionTimeoutMS,
+      final Integer rabbitSocketTimeoutMS,
+      final Integer rabbitRequestedHeartbeatInSeconds) {
+
+    this.exchange = exchange;
+
+    this.connectionFactory = new ConnectionFactory();
+
+    connectionFactory.setSocketConfigurator(
+        new DefaultSocketConfigurator() {
+          @Override
+          public void configure(Socket socket) throws IOException {
+            super.configure(socket);
+            socket.setSoTimeout(rabbitSocketTimeoutMS);
+          }
         });
 
-        connectionFactory.setConnectionTimeout(rabbitConnectionTimeoutMS);
-        connectionFactory.setRequestedHeartbeat(rabbitRequestedHeartbeatInSeconds);
-        connectionFactory.setHost(rabbitHost);
-        connectionFactory.setPort(rabbitPort);
-        connectionFactory.setUsername(rabbitUsername);
-        connectionFactory.setPassword(rabbitPassword);
+    connectionFactory.setConnectionTimeout(rabbitConnectionTimeoutMS);
+    connectionFactory.setRequestedHeartbeat(rabbitRequestedHeartbeatInSeconds);
+    connectionFactory.setHost(rabbitHost);
+    connectionFactory.setPort(rabbitPort);
+    connectionFactory.setUsername(rabbitUsername);
+    connectionFactory.setPassword(rabbitPassword);
+  }
+
+  @Override
+  public void connect() throws IllegalStateException, IOException {
+    checkState(!isConnected(), "Already connected");
+
+    try {
+      connection = connectionFactory.newConnection();
+    } catch (TimeoutException e) {
+      throw new IllegalStateException(e);
     }
-
-    @Override
-    public void connect() throws IllegalStateException, IOException {
-        if (isConnected()) {
-            throw new IllegalStateException("Already connected");
-        }
-
-        try {
-            connection = connectionFactory.newConnection();
-        } catch (TimeoutException e) {
-            throw new IllegalStateException(e);
-        }
-        channel = connection.createChannel();
+    channel = connection.createChannel();
+  }
+
+  @Override
+  public boolean isConnected() {
+    return connection != null && connection.isOpen();
+  }
+
+  @Override
+  public void send(String name, String value, long timestamp) throws IOException {
+    try {
+      final String sanitizedName = sanitize(name);
+      final String sanitizedValue = sanitize(value);
+
+      final String message = sanitizedName + ' ' + sanitizedValue + ' ' + timestamp + '\n';
+      channel.basicPublish(exchange, sanitizedName, null, message.getBytes(UTF_8));
+    } catch (IOException e) {
+      failures++;
+      throw e;
     }
+  }
 
-    @Override
-    public boolean isConnected() {
-        return connection != null && connection.isOpen();
-    }
+  @Override
+  public void flush() throws IOException {
+    // Nothing to do
+  }
 
-    @Override
-    public void send(String name, String value, long timestamp) throws IOException {
-        try {
-            final String sanitizedName = sanitize(name);
-            final String sanitizedValue = sanitize(value);
-
-            final String message = sanitizedName + ' ' + sanitizedValue + ' ' + Long.toString(timestamp) + '\n';
-            channel.basicPublish(exchange, sanitizedName, null, message.getBytes(UTF_8));
-        } catch (IOException e) {
-            failures++;
-            throw e;
-        }
+  @Override
+  public void close() throws IOException {
+    if (connection != null) {
+      connection.close();
     }
+  }
 
-    @Override
-    public void flush() throws IOException {
-        // Nothing to do
-    }
-
-    @Override
-    public void close() throws IOException {
-        if (connection != null) {
-            connection.close();
-        }
-    }
-
-    @Override
-    public int getFailures() {
-        return failures;
-    }
-
-    public String sanitize(String s) {
-        return GraphiteSanitize.sanitize(s);
-    }
+  @Override
+  public int getFailures() {
+    return failures;
+  }
 
+  public String sanitize(String s) {
+    return GraphiteSanitize.sanitize(s);
+  }
 }
--- a/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteReporter.java
+++ b/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteReporter.java
@@ -1,5 +1,21 @@
 package io.dropwizard.metrics5.graphite;
 
+import static io.dropwizard.metrics5.MetricAttribute.COUNT;
+import static io.dropwizard.metrics5.MetricAttribute.M15_RATE;
+import static io.dropwizard.metrics5.MetricAttribute.M1_RATE;
+import static io.dropwizard.metrics5.MetricAttribute.M5_RATE;
+import static io.dropwizard.metrics5.MetricAttribute.MEAN;
+import static io.dropwizard.metrics5.MetricAttribute.MEAN_RATE;
+import static io.dropwizard.metrics5.MetricAttribute.P50;
+import static io.dropwizard.metrics5.MetricAttribute.P75;
+import static io.dropwizard.metrics5.MetricAttribute.P95;
+import static io.dropwizard.metrics5.MetricAttribute.P98;
+import static io.dropwizard.metrics5.MetricAttribute.P99;
+import static io.dropwizard.metrics5.MetricAttribute.P999;
+import static io.dropwizard.metrics5.MetricAttribute.STDDEV;
+import static io.dropwizard.metrics5.MetricAttribute.SUM;
+
+import com.google.common.collect.ImmutableSet;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
@@ -13,11 +29,7 @@ import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.ScheduledReporter;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.IOException;
-import java.util.Collections;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
@@ -25,23 +37,8 @@ import java.util.SortedMap;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.function.DoubleFunction;
-
-import static io.dropwizard.metrics5.MetricAttribute.COUNT;
-import static io.dropwizard.metrics5.MetricAttribute.M15_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.M1_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.M5_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.MAX;
-import static io.dropwizard.metrics5.MetricAttribute.MEAN;
-import static io.dropwizard.metrics5.MetricAttribute.MEAN_RATE;
-import static io.dropwizard.metrics5.MetricAttribute.MIN;
-import static io.dropwizard.metrics5.MetricAttribute.P50;
-import static io.dropwizard.metrics5.MetricAttribute.P75;
-import static io.dropwizard.metrics5.MetricAttribute.P95;
-import static io.dropwizard.metrics5.MetricAttribute.P98;
-import static io.dropwizard.metrics5.MetricAttribute.P99;
-import static io.dropwizard.metrics5.MetricAttribute.P999;
-import static io.dropwizard.metrics5.MetricAttribute.STDDEV;
-import static io.dropwizard.metrics5.MetricAttribute.SUM;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A reporter which publishes metric values to a Graphite server.
@@ -49,477 +46,521 @@ import static io.dropwizard.metrics5.MetricAttribute.SUM;
  * @see <a href="http://graphite.wikidot.com/">Graphite - Scalable Realtime Graphing</a>
  */
 public class GraphiteReporter extends ScheduledReporter {
+  /**
+   * Returns a new {@link Builder} for {@link GraphiteReporter}.
+   *
+   * @param registry the registry to report
+   * @return a {@link Builder} instance for a {@link GraphiteReporter}
+   */
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
+
+  /**
+   * A builder for {@link GraphiteReporter} instances. Defaults to not using a prefix, using the
+   * default clock, converting rates to events/second, converting durations to milliseconds, and not
+   * filtering metrics.
+   */
+  public static class Builder {
+    private final MetricRegistry registry;
+    private Clock clock;
+    private String prefix;
+    private TimeUnit rateUnit;
+    private TimeUnit durationUnit;
+    private MetricFilter filter;
+    private ScheduledExecutorService executor;
+    private boolean shutdownExecutorOnStop;
+    private Set<MetricAttribute> disabledMetricAttributes;
+    private boolean addMetricAttributesAsTags;
+    private DoubleFunction<String> floatingPointFormatter;
+
+    private Builder(MetricRegistry registry) {
+      this.registry = registry;
+      this.clock = Clock.defaultClock();
+      this.prefix = null;
+      this.rateUnit = TimeUnit.SECONDS;
+      this.durationUnit = TimeUnit.MILLISECONDS;
+      this.filter = MetricFilter.ALL;
+      this.executor = null;
+      this.shutdownExecutorOnStop = true;
+      this.disabledMetricAttributes = ImmutableSet.of();
+      this.addMetricAttributesAsTags = false;
+      this.floatingPointFormatter = DEFAULT_FP_FORMATTER;
+    }
+
     /**
-     * Returns a new {@link Builder} for {@link GraphiteReporter}.
+     * Specifies whether or not, the executor (used for reporting) will be stopped with same time
+     * with reporter. Default value is true. Setting this parameter to false, has the sense in
+     * combining with providing external managed executor via {@link
+     * #scheduleOn(ScheduledExecutorService)}.
      *
-     * @param registry the registry to report
-     * @return a {@link Builder} instance for a {@link GraphiteReporter}
+     * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+     *     reporter
+     * @return {@code this}
      */
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
+    public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      this.shutdownExecutorOnStop = shutdownExecutorOnStop;
+      return this;
     }
 
     /**
-     * A builder for {@link GraphiteReporter} instances. Defaults to not using a prefix, using the
-     * default clock, converting rates to events/second, converting durations to milliseconds, and
-     * not filtering metrics.
+     * Specifies the executor to use while scheduling reporting of metrics. Default value is null.
+     * Null value leads to executor will be auto created on start.
+     *
+     * @param executor the executor to use while scheduling reporting of metrics.
+     * @return {@code this}
      */
-    public static class Builder {
-        private final MetricRegistry registry;
-        private Clock clock;
-        private String prefix;
-        private TimeUnit rateUnit;
-        private TimeUnit durationUnit;
-        private MetricFilter filter;
-        private ScheduledExecutorService executor;
-        private boolean shutdownExecutorOnStop;
-        private Set<MetricAttribute> disabledMetricAttributes;
-        private boolean addMetricAttributesAsTags;
-        private DoubleFunction<String> floatingPointFormatter;
-
-        private Builder(MetricRegistry registry) {
-            this.registry = registry;
-            this.clock = Clock.defaultClock();
-            this.prefix = null;
-            this.rateUnit = TimeUnit.SECONDS;
-            this.durationUnit = TimeUnit.MILLISECONDS;
-            this.filter = MetricFilter.ALL;
-            this.executor = null;
-            this.shutdownExecutorOnStop = true;
-            this.disabledMetricAttributes = Collections.emptySet();
-            this.addMetricAttributesAsTags = false;
-            this.floatingPointFormatter = DEFAULT_FP_FORMATTER;
-        }
-
-        /**
-         * Specifies whether or not, the executor (used for reporting) will be stopped with same time with reporter.
-         * Default value is true.
-         * Setting this parameter to false, has the sense in combining with providing external managed executor via {@link #scheduleOn(ScheduledExecutorService)}.
-         *
-         * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this reporter
-         * @return {@code this}
-         */
-        public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            this.shutdownExecutorOnStop = shutdownExecutorOnStop;
-            return this;
-        }
-
-        /**
-         * Specifies the executor to use while scheduling reporting of metrics.
-         * Default value is null.
-         * Null value leads to executor will be auto created on start.
-         *
-         * @param executor the executor to use while scheduling reporting of metrics.
-         * @return {@code this}
-         */
-        public Builder scheduleOn(ScheduledExecutorService executor) {
-            this.executor = executor;
-            return this;
-        }
-
-        /**
-         * Use the given {@link Clock} instance for the time.
-         *
-         * @param clock a {@link Clock} instance
-         * @return {@code this}
-         */
-        public Builder withClock(Clock clock) {
-            this.clock = clock;
-            return this;
-        }
-
-        /**
-         * Prefix all metric names with the given string.
-         *
-         * @param prefix the prefix for all metric names
-         * @return {@code this}
-         */
-        public Builder prefixedWith(String prefix) {
-            this.prefix = prefix;
-            return this;
-        }
-
-        /**
-         * Convert rates to the given time unit.
-         *
-         * @param rateUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertRatesTo(TimeUnit rateUnit) {
-            this.rateUnit = rateUnit;
-            return this;
-        }
-
-        /**
-         * Convert durations to the given time unit.
-         *
-         * @param durationUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertDurationsTo(TimeUnit durationUnit) {
-            this.durationUnit = durationUnit;
-            return this;
-        }
-
-        /**
-         * Only report metrics which match the given filter.
-         *
-         * @param filter a {@link MetricFilter}
-         * @return {@code this}
-         */
-        public Builder filter(MetricFilter filter) {
-            this.filter = filter;
-            return this;
-        }
-
-        /**
-         * Don't report the passed metric attributes for all metrics (e.g. "p999", "stddev" or "m15").
-         * See {@link MetricAttribute}.
-         *
-         * @param disabledMetricAttributes a set of {@link MetricAttribute}
-         * @return {@code this}
-         */
-        public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
-            this.disabledMetricAttributes = disabledMetricAttributes;
-            return this;
-        }
-
-
-        /**
-         * Specifies whether or not metric attributes (e.g. "p999", "stddev" or "m15") should be reported in the traditional dot delimited format or in the tag based format.
-         * Without tags (default): `my.metric.p99`
-         * With tags: `my.metric;metricattribute=p99`
-         * <p>
-         * Note that this setting only modifies the metric attribute, and will not convert any other portion of the metric name to use tags.
-         * For mor information on Graphite tag support see https://graphite.readthedocs.io/en/latest/tags.html
-         * See {@link MetricAttribute}.
-         *
-         * @param addMetricAttributesAsTags if true, then metric attributes will be added as tags
-         * @return {@code this}
-         */
-        public Builder addMetricAttributesAsTags(boolean addMetricAttributesAsTags) {
-            this.addMetricAttributesAsTags = addMetricAttributesAsTags;
-            return this;
-        }
-
-        /**
-         * Use custom floating point formatter.
-         *
-         * @param floatingPointFormatter a custom formatter for floating point values
-         * @return {@code this}
-         */
-        public Builder withFloatingPointFormatter(DoubleFunction<String> floatingPointFormatter) {
-            this.floatingPointFormatter = floatingPointFormatter;
-            return this;
-        }
-
-        /**
-         * Builds a {@link GraphiteReporter} with the given properties, sending metrics using the
-         * given {@link GraphiteSender}.
-         * <p>
-         * Present for binary compatibility
-         *
-         * @param graphite a {@link Graphite}
-         * @return a {@link GraphiteReporter}
-         */
-        public GraphiteReporter build(Graphite graphite) {
-            return build((GraphiteSender) graphite);
-        }
-
-        /**
-         * Builds a {@link GraphiteReporter} with the given properties, sending metrics using the
-         * given {@link GraphiteSender}.
-         *
-         * @param graphite a {@link GraphiteSender}
-         * @return a {@link GraphiteReporter}
-         */
-        public GraphiteReporter build(GraphiteSender graphite) {
-            return new GraphiteReporter(registry,
-                    graphite,
-                    clock,
-                    prefix,
-                    rateUnit,
-                    durationUnit,
-                    filter,
-                    executor,
-                    shutdownExecutorOnStop,
-                    disabledMetricAttributes,
-                    addMetricAttributesAsTags,
-                    floatingPointFormatter);
-        }
+    public Builder scheduleOn(ScheduledExecutorService executor) {
+      this.executor = executor;
+      return this;
     }
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(GraphiteReporter.class);
-    // the Carbon plaintext format is pretty underspecified, but it seems like it just wants US-formatted digits
-    private static final DoubleFunction<String> DEFAULT_FP_FORMATTER = fp -> String.format(Locale.US, "%2.2f", fp);
-
-    private final GraphiteSender graphite;
-    private final Clock clock;
-    private final String prefix;
-    private final boolean addMetricAttributesAsTags;
-    private final DoubleFunction<String> floatingPointFormatter;
-
     /**
-     * Creates a new {@link GraphiteReporter} instance.
+     * Use the given {@link Clock} instance for the time.
      *
-     * @param registry                 the {@link MetricRegistry} containing the metrics this
-     *                                 reporter will report
-     * @param graphite                 the {@link GraphiteSender} which is responsible for sending metrics to a Carbon server
-     *                                 via a transport protocol
-     * @param clock                    the instance of the time. Use {@link Clock#defaultClock()} for the default
-     * @param prefix                   the prefix of all metric names (may be null)
-     * @param rateUnit                 the time unit of in which rates will be converted
-     * @param durationUnit             the time unit of in which durations will be converted
-     * @param filter                   the filter for which metrics to report
-     * @param executor                 the executor to use while scheduling reporting of metrics (may be null).
-     * @param shutdownExecutorOnStop   if true, then executor will be stopped in same time with this reporter
-     * @param disabledMetricAttributes do not report specific metric attributes
+     * @param clock a {@link Clock} instance
+     * @return {@code this}
      */
-    protected GraphiteReporter(MetricRegistry registry,
-                               GraphiteSender graphite,
-                               Clock clock,
-                               String prefix,
-                               TimeUnit rateUnit,
-                               TimeUnit durationUnit,
-                               MetricFilter filter,
-                               ScheduledExecutorService executor,
-                               boolean shutdownExecutorOnStop,
-                               Set<MetricAttribute> disabledMetricAttributes) {
-        this(registry, graphite, clock, prefix, rateUnit, durationUnit, filter, executor, shutdownExecutorOnStop,
-                disabledMetricAttributes, false);
+    public Builder withClock(Clock clock) {
+      this.clock = clock;
+      return this;
     }
 
-
     /**
-     * Creates a new {@link GraphiteReporter} instance.
+     * Prefix all metric names with the given string.
      *
-     * @param registry                  the {@link MetricRegistry} containing the metrics this
-     *                                  reporter will report
-     * @param graphite                  the {@link GraphiteSender} which is responsible for sending metrics to a Carbon server
-     *                                  via a transport protocol
-     * @param clock                     the instance of the time. Use {@link Clock#defaultClock()} for the default
-     * @param prefix                    the prefix of all metric names (may be null)
-     * @param rateUnit                  the time unit of in which rates will be converted
-     * @param durationUnit              the time unit of in which durations will be converted
-     * @param filter                    the filter for which metrics to report
-     * @param executor                  the executor to use while scheduling reporting of metrics (may be null).
-     * @param shutdownExecutorOnStop    if true, then executor will be stopped in same time with this reporter
-     * @param disabledMetricAttributes  do not report specific metric attributes
-     * @param addMetricAttributesAsTags if true, then add metric attributes as tags instead of suffixes
+     * @param prefix the prefix for all metric names
+     * @return {@code this}
      */
-    protected GraphiteReporter(MetricRegistry registry,
-                               GraphiteSender graphite,
-                               Clock clock,
-                               String prefix,
-                               TimeUnit rateUnit,
-                               TimeUnit durationUnit,
-                               MetricFilter filter,
-                               ScheduledExecutorService executor,
-                               boolean shutdownExecutorOnStop,
-                               Set<MetricAttribute> disabledMetricAttributes,
-                               boolean addMetricAttributesAsTags) {
-        this(registry, graphite, clock, prefix, rateUnit, durationUnit, filter, executor, shutdownExecutorOnStop,
-                disabledMetricAttributes, addMetricAttributesAsTags, DEFAULT_FP_FORMATTER);
+    public Builder prefixedWith(String prefix) {
+      this.prefix = prefix;
+      return this;
     }
 
     /**
-     * Creates a new {@link GraphiteReporter} instance.
+     * Convert rates to the given time unit.
      *
-     * @param registry                  the {@link MetricRegistry} containing the metrics this
-     *                                  reporter will report
-     * @param graphite                  the {@link GraphiteSender} which is responsible for sending metrics to a Carbon server
-     *                                  via a transport protocol
-     * @param clock                     the instance of the time. Use {@link Clock#defaultClock()} for the default
-     * @param prefix                    the prefix of all metric names (may be null)
-     * @param rateUnit                  the time unit of in which rates will be converted
-     * @param durationUnit              the time unit of in which durations will be converted
-     * @param filter                    the filter for which metrics to report
-     * @param executor                  the executor to use while scheduling reporting of metrics (may be null).
-     * @param shutdownExecutorOnStop    if true, then executor will be stopped in same time with this reporter
-     * @param disabledMetricAttributes  do not report specific metric attributes
-     * @param addMetricAttributesAsTags if true, then add metric attributes as tags instead of suffixes
-     * @param floatingPointFormatter    custom floating point formatter
+     * @param rateUnit a unit of time
+     * @return {@code this}
      */
-    protected GraphiteReporter(MetricRegistry registry,
-                               GraphiteSender graphite,
-                               Clock clock,
-                               String prefix,
-                               TimeUnit rateUnit,
-                               TimeUnit durationUnit,
-                               MetricFilter filter,
-                               ScheduledExecutorService executor,
-                               boolean shutdownExecutorOnStop,
-                               Set<MetricAttribute> disabledMetricAttributes,
-                               boolean addMetricAttributesAsTags,
-                               DoubleFunction<String> floatingPointFormatter) {
-        super(registry, "graphite-reporter", filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop,
-                disabledMetricAttributes);
-        this.graphite = graphite;
-        this.clock = clock;
-        this.prefix = prefix;
-        this.addMetricAttributesAsTags = addMetricAttributesAsTags;
-        this.floatingPointFormatter = floatingPointFormatter;
+    public Builder convertRatesTo(TimeUnit rateUnit) {
+      this.rateUnit = rateUnit;
+      return this;
     }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void report(SortedMap<MetricName, Gauge<?>> gauges,
-                       SortedMap<MetricName, Counter> counters,
-                       SortedMap<MetricName, Histogram> histograms,
-                       SortedMap<MetricName, Meter> meters,
-                       SortedMap<MetricName, Timer> timers) {
-        final long timestamp = clock.getTime() / 1000;
-
-        // oh it'd be lovely to use Java 7 here
-        try {
-            graphite.connect();
-
-            for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
-                reportGauge(entry.getKey(), entry.getValue(), timestamp);
-            }
-
-            for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
-                reportCounter(entry.getKey(), entry.getValue(), timestamp);
-            }
-
-            for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
-                reportHistogram(entry.getKey(), entry.getValue(), timestamp);
-            }
-
-            for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
-                reportMetered(entry.getKey(), entry.getValue(), timestamp, false);
-            }
-
-            for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
-                reportTimer(entry.getKey(), entry.getValue(), timestamp);
-            }
-            graphite.flush();
-        } catch (IOException e) {
-            LOGGER.warn("Unable to report to Graphite", graphite, e);
-        } finally {
-            try {
-                graphite.close();
-            } catch (IOException e1) {
-                LOGGER.warn("Error closing Graphite", graphite, e1);
-            }
-        }
+    /**
+     * Convert durations to the given time unit.
+     *
+     * @param durationUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertDurationsTo(TimeUnit durationUnit) {
+      this.durationUnit = durationUnit;
+      return this;
     }
 
-    @Override
-    public void stop() {
-        try {
-            super.stop();
-        } finally {
-            try {
-                graphite.close();
-            } catch (IOException e) {
-                LOGGER.debug("Error disconnecting from Graphite", graphite, e);
-            }
-        }
+    /**
+     * Only report metrics which match the given filter.
+     *
+     * @param filter a {@link MetricFilter}
+     * @return {@code this}
+     */
+    public Builder filter(MetricFilter filter) {
+      this.filter = filter;
+      return this;
     }
 
-    private void reportTimer(MetricName name, Timer timer, long timestamp) throws IOException {
-        final Snapshot snapshot = timer.getSnapshot();
-        sendIfEnabled(MAX, name, convertDuration(snapshot.getMax()), timestamp);
-        sendIfEnabled(MEAN, name, convertDuration(snapshot.getMean()), timestamp);
-        sendIfEnabled(MIN, name, convertDuration(snapshot.getMin()), timestamp);
-        sendIfEnabled(STDDEV, name, convertDuration(snapshot.getStdDev()), timestamp);
-        sendIfEnabled(P50, name, convertDuration(snapshot.getMedian()), timestamp);
-        sendIfEnabled(P75, name, convertDuration(snapshot.get75thPercentile()), timestamp);
-        sendIfEnabled(P95, name, convertDuration(snapshot.get95thPercentile()), timestamp);
-        sendIfEnabled(P98, name, convertDuration(snapshot.get98thPercentile()), timestamp);
-        sendIfEnabled(P99, name, convertDuration(snapshot.get99thPercentile()), timestamp);
-        sendIfEnabled(P999, name, convertDuration(snapshot.get999thPercentile()), timestamp);
-        reportMetered(name, timer, timestamp, true);
+    /**
+     * Don't report the passed metric attributes for all metrics (e.g. "p999", "stddev" or "m15").
+     * See {@link MetricAttribute}.
+     *
+     * @param disabledMetricAttributes a set of {@link MetricAttribute}
+     * @return {@code this}
+     */
+    public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
+      this.disabledMetricAttributes = disabledMetricAttributes;
+      return this;
     }
 
-    private void reportMetered(MetricName name, Metered meter, long timestamp, boolean sumIsDuration) throws IOException {
-        sendIfEnabled(COUNT, name, meter.getCount(), timestamp);
-        sendIfEnabled(SUM, name, sumIsDuration ? convertDuration(meter.getSum()) : meter.getSum(), timestamp);
-        sendIfEnabled(M1_RATE, name, convertRate(meter.getOneMinuteRate()), timestamp);
-        sendIfEnabled(M5_RATE, name, convertRate(meter.getFiveMinuteRate()), timestamp);
-        sendIfEnabled(M15_RATE, name, convertRate(meter.getFifteenMinuteRate()), timestamp);
-        sendIfEnabled(MEAN_RATE, name, convertRate(meter.getMeanRate()), timestamp);
+    /**
+     * Specifies whether or not metric attributes (e.g. "p999", "stddev" or "m15") should be
+     * reported in the traditional dot delimited format or in the tag based format. Without tags
+     * (default): `my.metric.p99` With tags: `my.metric;metricattribute=p99`
+     *
+     * <p>Note that this setting only modifies the metric attribute, and will not convert any other
+     * portion of the metric name to use tags. For mor information on Graphite tag support see
+     * https://graphite.readthedocs.io/en/latest/tags.html See {@link MetricAttribute}.
+     *
+     * @param addMetricAttributesAsTags if true, then metric attributes will be added as tags
+     * @return {@code this}
+     */
+    public Builder addMetricAttributesAsTags(boolean addMetricAttributesAsTags) {
+      this.addMetricAttributesAsTags = addMetricAttributesAsTags;
+      return this;
     }
 
-    private void reportHistogram(MetricName name, Histogram histogram, long timestamp) throws IOException {
-        final Snapshot snapshot = histogram.getSnapshot();
-        sendIfEnabled(COUNT, name, histogram.getCount(), timestamp);
-        sendIfEnabled(SUM, name, histogram.getSum(), timestamp);
-        sendIfEnabled(MAX, name, snapshot.getMax(), timestamp);
-        sendIfEnabled(MEAN, name, snapshot.getMean(), timestamp);
-        sendIfEnabled(MIN, name, snapshot.getMin(), timestamp);
-        sendIfEnabled(STDDEV, name, snapshot.getStdDev(), timestamp);
-        sendIfEnabled(P50, name, snapshot.getMedian(), timestamp);
-        sendIfEnabled(P75, name, snapshot.get75thPercentile(), timestamp);
-        sendIfEnabled(P95, name, snapshot.get95thPercentile(), timestamp);
-        sendIfEnabled(P98, name, snapshot.get98thPercentile(), timestamp);
-        sendIfEnabled(P99, name, snapshot.get99thPercentile(), timestamp);
-        sendIfEnabled(P999, name, snapshot.get999thPercentile(), timestamp);
+    /**
+     * Use custom floating point formatter.
+     *
+     * @param floatingPointFormatter a custom formatter for floating point values
+     * @return {@code this}
+     */
+    public Builder withFloatingPointFormatter(DoubleFunction<String> floatingPointFormatter) {
+      this.floatingPointFormatter = floatingPointFormatter;
+      return this;
     }
 
-    private void sendIfEnabled(MetricAttribute type, MetricName name, double value, long timestamp) throws IOException {
-        if (getDisabledMetricAttributes().contains(type)) {
-            return;
-        }
-        graphite.send(prefix(appendMetricAttribute(name, type.getCode())), format(value), timestamp);
+    /**
+     * Builds a {@link GraphiteReporter} with the given properties, sending metrics using the given
+     * {@link GraphiteSender}.
+     *
+     * <p>Present for binary compatibility
+     *
+     * @param graphite a {@link Graphite}
+     * @return a {@link GraphiteReporter}
+     */
+    public GraphiteReporter build(Graphite graphite) {
+      return build((GraphiteSender) graphite);
     }
 
-    private void sendIfEnabled(MetricAttribute type, MetricName name, long value, long timestamp) throws IOException {
-        if (getDisabledMetricAttributes().contains(type)) {
-            return;
-        }
-        graphite.send(prefix(appendMetricAttribute(name, type.getCode())), format(value), timestamp);
+    /**
+     * Builds a {@link GraphiteReporter} with the given properties, sending metrics using the given
+     * {@link GraphiteSender}.
+     *
+     * @param graphite a {@link GraphiteSender}
+     * @return a {@link GraphiteReporter}
+     */
+    public GraphiteReporter build(GraphiteSender graphite) {
+      return new GraphiteReporter(
+          registry,
+          graphite,
+          clock,
+          prefix,
+          rateUnit,
+          durationUnit,
+          filter,
+          executor,
+          shutdownExecutorOnStop,
+          disabledMetricAttributes,
+          addMetricAttributesAsTags,
+          floatingPointFormatter);
     }
-
-    private void reportCounter(MetricName name, Counter counter, long timestamp) throws IOException {
-        graphite.send(prefix(appendMetricAttribute(name, COUNT.getCode())), format(counter.getCount()), timestamp);
+  }
+
+  private static final Logger LOG = LoggerFactory.getLogger(GraphiteReporter.class);
+  // the Carbon plaintext format is pretty underspecified, but it seems like it just wants
+  // US-formatted digits
+  private static final DoubleFunction<String> DEFAULT_FP_FORMATTER =
+      fp -> String.format(Locale.US, "%2.2f", fp);
+
+  private final GraphiteSender graphite;
+  private final Clock clock;
+  private final String prefix;
+  private final boolean addMetricAttributesAsTags;
+  private final DoubleFunction<String> floatingPointFormatter;
+
+  /**
+   * Creates a new {@link GraphiteReporter} instance.
+   *
+   * @param registry the {@link MetricRegistry} containing the metrics this reporter will report
+   * @param graphite the {@link GraphiteSender} which is responsible for sending metrics to a Carbon
+   *     server via a transport protocol
+   * @param clock the instance of the time. Use {@link Clock#defaultClock()} for the default
+   * @param prefix the prefix of all metric names (may be null)
+   * @param rateUnit the time unit of in which rates will be converted
+   * @param durationUnit the time unit of in which durations will be converted
+   * @param filter the filter for which metrics to report
+   * @param executor the executor to use while scheduling reporting of metrics (may be null).
+   * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+   *     reporter
+   * @param disabledMetricAttributes do not report specific metric attributes
+   */
+  protected GraphiteReporter(
+      MetricRegistry registry,
+      GraphiteSender graphite,
+      Clock clock,
+      String prefix,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      MetricFilter filter,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes) {
+    this(
+        registry,
+        graphite,
+        clock,
+        prefix,
+        rateUnit,
+        durationUnit,
+        filter,
+        executor,
+        shutdownExecutorOnStop,
+        disabledMetricAttributes,
+        false);
+  }
+
+  /**
+   * Creates a new {@link GraphiteReporter} instance.
+   *
+   * @param registry the {@link MetricRegistry} containing the metrics this reporter will report
+   * @param graphite the {@link GraphiteSender} which is responsible for sending metrics to a Carbon
+   *     server via a transport protocol
+   * @param clock the instance of the time. Use {@link Clock#defaultClock()} for the default
+   * @param prefix the prefix of all metric names (may be null)
+   * @param rateUnit the time unit of in which rates will be converted
+   * @param durationUnit the time unit of in which durations will be converted
+   * @param filter the filter for which metrics to report
+   * @param executor the executor to use while scheduling reporting of metrics (may be null).
+   * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+   *     reporter
+   * @param disabledMetricAttributes do not report specific metric attributes
+   * @param addMetricAttributesAsTags if true, then add metric attributes as tags instead of
+   *     suffixes
+   */
+  protected GraphiteReporter(
+      MetricRegistry registry,
+      GraphiteSender graphite,
+      Clock clock,
+      String prefix,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      MetricFilter filter,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes,
+      boolean addMetricAttributesAsTags) {
+    this(
+        registry,
+        graphite,
+        clock,
+        prefix,
+        rateUnit,
+        durationUnit,
+        filter,
+        executor,
+        shutdownExecutorOnStop,
+        disabledMetricAttributes,
+        addMetricAttributesAsTags,
+        DEFAULT_FP_FORMATTER);
+  }
+
+  /**
+   * Creates a new {@link GraphiteReporter} instance.
+   *
+   * @param registry the {@link MetricRegistry} containing the metrics this reporter will report
+   * @param graphite the {@link GraphiteSender} which is responsible for sending metrics to a Carbon
+   *     server via a transport protocol
+   * @param clock the instance of the time. Use {@link Clock#defaultClock()} for the default
+   * @param prefix the prefix of all metric names (may be null)
+   * @param rateUnit the time unit of in which rates will be converted
+   * @param durationUnit the time unit of in which durations will be converted
+   * @param filter the filter for which metrics to report
+   * @param executor the executor to use while scheduling reporting of metrics (may be null).
+   * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+   *     reporter
+   * @param disabledMetricAttributes do not report specific metric attributes
+   * @param addMetricAttributesAsTags if true, then add metric attributes as tags instead of
+   *     suffixes
+   * @param floatingPointFormatter custom floating point formatter
+   */
+  protected GraphiteReporter(
+      MetricRegistry registry,
+      GraphiteSender graphite,
+      Clock clock,
+      String prefix,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      MetricFilter filter,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes,
+      boolean addMetricAttributesAsTags,
+      DoubleFunction<String> floatingPointFormatter) {
+    super(
+        registry,
+        "graphite-reporter",
+        filter,
+        rateUnit,
+        durationUnit,
+        executor,
+        shutdownExecutorOnStop,
+        disabledMetricAttributes);
+    this.graphite = graphite;
+    this.clock = clock;
+    this.prefix = prefix;
+    this.addMetricAttributesAsTags = addMetricAttributesAsTags;
+    this.floatingPointFormatter = floatingPointFormatter;
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report(
+      SortedMap<MetricName, Gauge<?>> gauges,
+      SortedMap<MetricName, Counter> counters,
+      SortedMap<MetricName, Histogram> histograms,
+      SortedMap<MetricName, Meter> meters,
+      SortedMap<MetricName, Timer> timers) {
+    final long timestamp = clock.getTime() / 1000;
+
+    // oh it'd be lovely to use Java 7 here
+    try {
+      graphite.connect();
+
+      for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
+        reportGauge(entry.getKey(), entry.getValue(), timestamp);
+      }
+
+      for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
+        reportCounter(entry.getKey(), entry.getValue(), timestamp);
+      }
+
+      for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
+        reportHistogram(entry.getKey(), entry.getValue(), timestamp);
+      }
+
+      for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
+        reportMetered(entry.getKey(), entry.getValue(), timestamp, false);
+      }
+
+      for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
+        reportTimer(entry.getKey(), entry.getValue(), timestamp);
+      }
+      graphite.flush();
+    } catch (IOException e) {
+      LOG.warn("Unable to report to Graphite", graphite, e);
+    } finally {
+      try {
+        graphite.close();
+      } catch (IOException e1) {
+        LOG.warn("Error closing Graphite", graphite, e1);
+      }
     }
-
-    private void reportGauge(MetricName name, Gauge<?> gauge, long timestamp) throws IOException {
-        final String value = format(gauge.getValue());
-        if (value != null) {
-            graphite.send(prefix(name.getKey()), value, timestamp);
-        }
+  }
+
+  @Override
+  public void stop() {
+    try {
+      super.stop();
+    } finally {
+      try {
+        graphite.close();
+      } catch (IOException e) {
+        LOG.debug("Error disconnecting from Graphite", graphite, e);
+      }
     }
-
-    private String format(Object o) {
-        if (o instanceof Float) {
-            return format(((Float) o).doubleValue());
-        } else if (o instanceof Double) {
-            return format(((Double) o).doubleValue());
-        } else if (o instanceof Byte) {
-            return format(((Byte) o).longValue());
-        } else if (o instanceof Short) {
-            return format(((Short) o).longValue());
-        } else if (o instanceof Integer) {
-            return format(((Integer) o).longValue());
-        } else if (o instanceof Long) {
-            return format(((Long) o).longValue());
-        } else if (o instanceof Number) {
-            return format(((Number) o).doubleValue());
-        } else if (o instanceof Boolean) {
-            return format(((Boolean) o) ? 1 : 0);
-        }
-        return null;
+  }
+
+  private void reportTimer(MetricName name, Timer timer, long timestamp) throws IOException {
+    final Snapshot snapshot = timer.getSnapshot();
+    sendIfEnabled(MetricAttribute.MAX, name, convertDuration(snapshot.getMax()), timestamp);
+    sendIfEnabled(MEAN, name, convertDuration(snapshot.getMean()), timestamp);
+    sendIfEnabled(MetricAttribute.MIN, name, convertDuration(snapshot.getMin()), timestamp);
+    sendIfEnabled(STDDEV, name, convertDuration(snapshot.getStdDev()), timestamp);
+    sendIfEnabled(P50, name, convertDuration(snapshot.getMedian()), timestamp);
+    sendIfEnabled(P75, name, convertDuration(snapshot.get75thPercentile()), timestamp);
+    sendIfEnabled(P95, name, convertDuration(snapshot.get95thPercentile()), timestamp);
+    sendIfEnabled(P98, name, convertDuration(snapshot.get98thPercentile()), timestamp);
+    sendIfEnabled(P99, name, convertDuration(snapshot.get99thPercentile()), timestamp);
+    sendIfEnabled(P999, name, convertDuration(snapshot.get999thPercentile()), timestamp);
+    reportMetered(name, timer, timestamp, true);
+  }
+
+  private void reportMetered(MetricName name, Metered meter, long timestamp, boolean sumIsDuration)
+      throws IOException {
+    sendIfEnabled(COUNT, name, meter.getCount(), timestamp);
+    sendIfEnabled(
+        SUM, name, sumIsDuration ? convertDuration(meter.getSum()) : meter.getSum(), timestamp);
+    sendIfEnabled(M1_RATE, name, convertRate(meter.getOneMinuteRate()), timestamp);
+    sendIfEnabled(M5_RATE, name, convertRate(meter.getFiveMinuteRate()), timestamp);
+    sendIfEnabled(M15_RATE, name, convertRate(meter.getFifteenMinuteRate()), timestamp);
+    sendIfEnabled(MEAN_RATE, name, convertRate(meter.getMeanRate()), timestamp);
+  }
+
+  private void reportHistogram(MetricName name, Histogram histogram, long timestamp)
+      throws IOException {
+    final Snapshot snapshot = histogram.getSnapshot();
+    sendIfEnabled(COUNT, name, histogram.getCount(), timestamp);
+    sendIfEnabled(SUM, name, histogram.getSum(), timestamp);
+    sendIfEnabled(MetricAttribute.MAX, name, snapshot.getMax(), timestamp);
+    sendIfEnabled(MEAN, name, snapshot.getMean(), timestamp);
+    sendIfEnabled(MetricAttribute.MIN, name, snapshot.getMin(), timestamp);
+    sendIfEnabled(STDDEV, name, snapshot.getStdDev(), timestamp);
+    sendIfEnabled(P50, name, snapshot.getMedian(), timestamp);
+    sendIfEnabled(P75, name, snapshot.get75thPercentile(), timestamp);
+    sendIfEnabled(P95, name, snapshot.get95thPercentile(), timestamp);
+    sendIfEnabled(P98, name, snapshot.get98thPercentile(), timestamp);
+    sendIfEnabled(P99, name, snapshot.get99thPercentile(), timestamp);
+    sendIfEnabled(P999, name, snapshot.get999thPercentile(), timestamp);
+  }
+
+  private void sendIfEnabled(MetricAttribute type, MetricName name, double value, long timestamp)
+      throws IOException {
+    if (getDisabledMetricAttributes().contains(type)) {
+      return;
     }
+    graphite.send(prefix(appendMetricAttribute(name, type.getCode())), format(value), timestamp);
+  }
 
-    private String prefix(String name) {
-        return prefix + "." + name;
+  private void sendIfEnabled(MetricAttribute type, MetricName name, long value, long timestamp)
+      throws IOException {
+    if (getDisabledMetricAttributes().contains(type)) {
+      return;
     }
-
-    private String appendMetricAttribute(MetricName name, String metricAttribute) {
-        if (addMetricAttributesAsTags) {
-            return name.getKey() + ";metricattribute=" + metricAttribute;
-        }
-        return name.getKey() + "." + metricAttribute;
+    graphite.send(prefix(appendMetricAttribute(name, type.getCode())), format(value), timestamp);
+  }
+
+  private void reportCounter(MetricName name, Counter counter, long timestamp) throws IOException {
+    graphite.send(
+        prefix(appendMetricAttribute(name, COUNT.getCode())),
+        format(counter.getCount()),
+        timestamp);
+  }
+
+  private void reportGauge(MetricName name, Gauge<?> gauge, long timestamp) throws IOException {
+    final String value = format(gauge.getValue());
+    if (value != null) {
+      graphite.send(prefix(name.getKey()), value, timestamp);
     }
-
-    private String format(long n) {
-        return Long.toString(n);
+  }
+
+  private String format(Object o) {
+    if (o instanceof Float) {
+      return format(((Float) o).doubleValue());
+    } else if (o instanceof Double) {
+      return format(((Double) o).doubleValue());
+    } else if (o instanceof Byte) {
+      return format(((Byte) o).longValue());
+    } else if (o instanceof Short) {
+      return format(((Short) o).longValue());
+    } else if (o instanceof Integer) {
+      return format(((Integer) o).longValue());
+    } else if (o instanceof Long) {
+      return format(((Long) o).longValue());
+    } else if (o instanceof Number) {
+      return format(((Number) o).doubleValue());
+    } else if (o instanceof Boolean) {
+      return format(((Boolean) o) ? 1 : 0);
     }
+    return null;
+  }
+
+  private String prefix(String name) {
+    return prefix + "." + name;
+  }
 
-    protected String format(double v) {
-        return floatingPointFormatter.apply(v);
+  private String appendMetricAttribute(MetricName name, String metricAttribute) {
+    if (addMetricAttributesAsTags) {
+      return name.getKey() + ";metricattribute=" + metricAttribute;
     }
+    return name.getKey() + "." + metricAttribute;
+  }
+
+  private String format(long n) {
+    return Long.toString(n);
+  }
+
+  protected String format(double v) {
+    return floatingPointFormatter.apply(v);
+  }
 }
--- a/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteSanitize.java
+++ b/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteSanitize.java
@@ -4,13 +4,11 @@ import java.util.regex.Pattern;
 
 class GraphiteSanitize {
 
-    private static final Pattern WHITESPACE = Pattern.compile("[\\s]+");
-    private static final String DASH = "-";
+  private static final Pattern WHITESPACE = Pattern.compile("[\\s]+");
+  private static final String DASH = "-";
 
-    /**
-     * Trims the string and replaces all whitespace characters with the provided symbol
-     */
-    static String sanitize(String string) {
-        return WHITESPACE.matcher(string.trim()).replaceAll(DASH);
-    }
+  /** Trims the string and replaces all whitespace characters with the provided symbol */
+  static String sanitize(String string) {
+    return WHITESPACE.matcher(string.trim()).replaceAll(DASH);
+  }
 }
--- a/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteSender.java
+++ b/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteSender.java
@@ -5,41 +5,38 @@ import java.io.IOException;
 
 public interface GraphiteSender extends Closeable {
 
-    /**
-     * Connects to the server.
-     *
-     * @throws IllegalStateException if the client is already connected
-     * @throws IOException           if there is an error connecting
-     */
-    void connect() throws IllegalStateException, IOException;
-
-    /**
-     * Sends the given measurement to the server.
-     *
-     * @param name      the name of the metric
-     * @param value     the value of the metric
-     * @param timestamp the timestamp of the metric
-     * @throws IOException if there was an error sending the metric
-     */
-    void send(String name, String value, long timestamp) throws IOException;
-
-    /**
-     * Flushes buffer, if applicable
-     *
-     * @throws IOException if there was an error during flushing metrics to the socket
-     */
-    void flush() throws IOException;
-
-    /**
-     * Returns true if ready to send data
-     */
-    boolean isConnected();
-
-    /**
-     * Returns the number of failed writes to the server.
-     *
-     * @return the number of failed writes to the server
-     */
-    int getFailures();
-
-}
\ No newline at end of file
+  /**
+   * Connects to the server.
+   *
+   * @throws IllegalStateException if the client is already connected
+   * @throws IOException if there is an error connecting
+   */
+  void connect() throws IllegalStateException, IOException;
+
+  /**
+   * Sends the given measurement to the server.
+   *
+   * @param name the name of the metric
+   * @param value the value of the metric
+   * @param timestamp the timestamp of the metric
+   * @throws IOException if there was an error sending the metric
+   */
+  void send(String name, String value, long timestamp) throws IOException;
+
+  /**
+   * Flushes buffer, if applicable
+   *
+   * @throws IOException if there was an error during flushing metrics to the socket
+   */
+  void flush() throws IOException;
+
+  /** Returns true if ready to send data */
+  boolean isConnected();
+
+  /**
+   * Returns the number of failed writes to the server.
+   *
+   * @return the number of failed writes to the server
+   */
+  int getFailures();
+}
--- a/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteUDP.java
+++ b/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/GraphiteUDP.java
@@ -1,118 +1,115 @@
 package io.dropwizard.metrics5.graphite;
 
+import static com.google.common.base.Preconditions.checkState;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import java.io.IOException;
-import java.net.InetSocketAddress;
 import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.DatagramChannel;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/**
- * A client to a Carbon server using unconnected UDP
- */
+/** A client to a Carbon server using unconnected UDP */
 public class GraphiteUDP implements GraphiteSender {
 
-    private final String hostname;
-    private final int port;
-    private InetSocketAddress address;
-
-    private DatagramChannel datagramChannel = null;
-    private int failures;
-
-    /**
-     * Creates a new client which sends data to given address using UDP
-     *
-     * @param hostname The hostname of the Carbon server
-     * @param port     The port of the Carbon server
-     */
-    public GraphiteUDP(String hostname, int port) {
-        this.hostname = hostname;
-        this.port = port;
-        this.address = null;
-    }
-
-    /**
-     * Creates a new client which sends data to given address using UDP
-     *
-     * @param address the address of the Carbon server
-     */
-    public GraphiteUDP(InetSocketAddress address) {
-        this.hostname = null;
-        this.port = -1;
-        this.address = address;
-    }
-
-    @Override
-    public void connect() throws IllegalStateException, IOException {
-        if (isConnected()) {
-            throw new IllegalStateException("Already connected");
-        }
-
-        // Resolve hostname
-        if (hostname != null) {
-            address = new InetSocketAddress(InetAddress.getByName(hostname), port);
-        }
-
-        datagramChannel = DatagramChannel.open();
+  private final String hostname;
+  private final int port;
+  private InetSocketAddress address;
+
+  private DatagramChannel datagramChannel = null;
+  private int failures;
+
+  /**
+   * Creates a new client which sends data to given address using UDP
+   *
+   * @param hostname The hostname of the Carbon server
+   * @param port The port of the Carbon server
+   */
+  public GraphiteUDP(String hostname, int port) {
+    this.hostname = hostname;
+    this.port = port;
+    this.address = null;
+  }
+
+  /**
+   * Creates a new client which sends data to given address using UDP
+   *
+   * @param address the address of the Carbon server
+   */
+  public GraphiteUDP(InetSocketAddress address) {
+    this.hostname = null;
+    this.port = -1;
+    this.address = address;
+  }
+
+  @Override
+  public void connect() throws IllegalStateException, IOException {
+    checkState(!isConnected(), "Already connected");
+
+    // Resolve hostname
+    if (hostname != null) {
+      address = new InetSocketAddress(InetAddress.getByName(hostname), port);
     }
 
-    @Override
-    public boolean isConnected() {
-        return datagramChannel != null && !datagramChannel.socket().isClosed();
+    datagramChannel = DatagramChannel.open();
+  }
+
+  @Override
+  public boolean isConnected() {
+    return datagramChannel != null && !datagramChannel.socket().isClosed();
+  }
+
+  @Override
+  public void send(String name, String value, long timestamp) throws IOException {
+    try {
+      String str = sanitize(name) + ' ' + sanitize(value) + ' ' + timestamp + '\n';
+      ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes(UTF_8));
+      datagramChannel.send(byteBuffer, address);
+      this.failures = 0;
+    } catch (IOException e) {
+      failures++;
+      throw e;
     }
-
-    @Override
-    public void send(String name, String value, long timestamp) throws IOException {
-        try {
-            String str = sanitize(name) + ' ' + sanitize(value) + ' ' + Long.toString(timestamp) + '\n';
-            ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes(UTF_8));
-            datagramChannel.send(byteBuffer, address);
-            this.failures = 0;
-        } catch (IOException e) {
-            failures++;
-            throw e;
-        }
-    }
-
-    @Override
-    public int getFailures() {
-        return failures;
-    }
-
-    @Override
-    public void flush() throws IOException {
-        // Nothing to do
-    }
-
-    @Override
-    public void close() throws IOException {
-        if (datagramChannel != null) {
-            try {
-                datagramChannel.close();
-            } finally {
-                datagramChannel = null;
-            }
-        }
+  }
+
+  @Override
+  public int getFailures() {
+    return failures;
+  }
+
+  @Override
+  public void flush() throws IOException {
+    // Nothing to do
+  }
+
+  @Override
+  public void close() throws IOException {
+    if (datagramChannel != null) {
+      try {
+        datagramChannel.close();
+      } finally {
+        datagramChannel = null;
+      }
     }
+  }
 
-    protected String sanitize(String s) {
-        return GraphiteSanitize.sanitize(s);
-    }
+  protected String sanitize(String s) {
+    return GraphiteSanitize.sanitize(s);
+  }
 
-    DatagramChannel getDatagramChannel() {
-        return datagramChannel;
-    }
+  DatagramChannel getDatagramChannel() {
+    return datagramChannel;
+  }
 
-    void setDatagramChannel(DatagramChannel datagramChannel) {
-        this.datagramChannel = datagramChannel;
-    }
+  void setDatagramChannel(DatagramChannel datagramChannel) {
+    this.datagramChannel = datagramChannel;
+  }
 
-    InetSocketAddress getAddress() {
-        return address;
-    }
+  InetSocketAddress getAddress() {
+    return address;
+  }
 
-    void setAddress(InetSocketAddress address) {
-        this.address = address;
-    }
+  void setAddress(InetSocketAddress address) {
+    this.address = address;
+  }
 }
--- a/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/PickledGraphite.java
+++ b/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/PickledGraphite.java
@@ -1,9 +1,7 @@
 package io.dropwizard.metrics5.graphite;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.SocketFactory;
+import static com.google.common.base.Preconditions.checkState;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 import java.io.BufferedWriter;
 import java.io.ByteArrayOutputStream;
@@ -18,320 +16,320 @@ import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
+import javax.net.SocketFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
- * A client to a Carbon server that sends all metrics after they have been pickled in configurable sized batches
+ * A client to a Carbon server that sends all metrics after they have been pickled in configurable
+ * sized batches
  */
 public class PickledGraphite implements GraphiteSender {
 
-    static class MetricTuple {
-        String name;
-        long timestamp;
-        String value;
+  static class MetricTuple {
+    String name;
+    long timestamp;
+    String value;
 
-        MetricTuple(String name, long timestamp, String value) {
-            this.name = name;
-            this.timestamp = timestamp;
-            this.value = value;
-        }
+    MetricTuple(String name, long timestamp, String value) {
+      this.name = name;
+      this.timestamp = timestamp;
+      this.value = value;
     }
-
-    /**
-     * Minimally necessary pickle opcodes.
-     */
-    private static final char
-            MARK = '(',
-            STOP = '.',
-            LONG = 'L',
-            STRING = 'S',
-            APPEND = 'a',
-            LIST = 'l',
-            TUPLE = 't',
-            QUOTE = '\'',
-            LF = '\n';
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(PickledGraphite.class);
-    private final static int DEFAULT_BATCH_SIZE = 100;
-
-    private int batchSize;
-    // graphite expects a python-pickled list of nested tuples.
-    private List<MetricTuple> metrics = new ArrayList<>();
-
-    private final String hostname;
-    private final int port;
-    private final InetSocketAddress address;
-    private final SocketFactory socketFactory;
-    private final Charset charset;
-
-    private Socket socket;
-    private Writer writer;
-    private int failures;
-
-    /**
-     * Creates a new client which connects to the given address using the default {@link SocketFactory}. This defaults
-     * to a batchSize of 100
-     *
-     * @param address the address of the Carbon server
-     */
-    public PickledGraphite(InetSocketAddress address) {
-        this(address, DEFAULT_BATCH_SIZE);
+  }
+
+  /** Minimally necessary pickle opcodes. */
+  private static final char MARK = '(',
+      STOP = '.',
+      LONG = 'L',
+      STRING = 'S',
+      APPEND = 'a',
+      LIST = 'l',
+      TUPLE = 't',
+      QUOTE = '\'',
+      LF = '\n';
+
+  private static final Logger LOG = LoggerFactory.getLogger(PickledGraphite.class);
+  private static final int DEFAULT_BATCH_SIZE = 100;
+
+  private int batchSize;
+  // graphite expects a python-pickled list of nested tuples.
+  private List<MetricTuple> metrics = new ArrayList<>();
+
+  private final String hostname;
+  private final int port;
+  private final InetSocketAddress address;
+  private final SocketFactory socketFactory;
+  private final Charset charset;
+
+  private Socket socket;
+  private Writer writer;
+  private int failures;
+
+  /**
+   * Creates a new client which connects to the given address using the default {@link
+   * SocketFactory}. This defaults to a batchSize of 100
+   *
+   * @param address the address of the Carbon server
+   */
+  public PickledGraphite(InetSocketAddress address) {
+    this(address, DEFAULT_BATCH_SIZE);
+  }
+
+  /**
+   * Creates a new client which connects to the given address using the default {@link
+   * SocketFactory}.
+   *
+   * @param address the address of the Carbon server
+   * @param batchSize how many metrics are bundled into a single pickle request to graphite
+   */
+  public PickledGraphite(InetSocketAddress address, int batchSize) {
+    this(address, SocketFactory.getDefault(), batchSize);
+  }
+
+  /**
+   * Creates a new client which connects to the given address and socket factory.
+   *
+   * @param address the address of the Carbon server
+   * @param socketFactory the socket factory
+   * @param batchSize how many metrics are bundled into a single pickle request to graphite
+   */
+  public PickledGraphite(InetSocketAddress address, SocketFactory socketFactory, int batchSize) {
+    this(address, socketFactory, UTF_8, batchSize);
+  }
+
+  /**
+   * Creates a new client which connects to the given address and socket factory using the given
+   * character set.
+   *
+   * @param address the address of the Carbon server
+   * @param socketFactory the socket factory
+   * @param charset the character set used by the server
+   * @param batchSize how many metrics are bundled into a single pickle request to graphite
+   */
+  public PickledGraphite(
+      InetSocketAddress address, SocketFactory socketFactory, Charset charset, int batchSize) {
+    this.address = address;
+    this.hostname = null;
+    this.port = -1;
+    this.socketFactory = socketFactory;
+    this.charset = charset;
+    this.batchSize = batchSize;
+  }
+
+  /**
+   * Creates a new client which connects to the given address using the default {@link
+   * SocketFactory}. This defaults to a batchSize of 100
+   *
+   * @param hostname the hostname of the Carbon server
+   * @param port the port of the Carbon server
+   */
+  public PickledGraphite(String hostname, int port) {
+    this(hostname, port, DEFAULT_BATCH_SIZE);
+  }
+
+  /**
+   * Creates a new client which connects to the given address using the default {@link
+   * SocketFactory}.
+   *
+   * @param hostname the hostname of the Carbon server
+   * @param port the port of the Carbon server
+   * @param batchSize how many metrics are bundled into a single pickle request to graphite
+   */
+  public PickledGraphite(String hostname, int port, int batchSize) {
+    this(hostname, port, SocketFactory.getDefault(), batchSize);
+  }
+
+  /**
+   * Creates a new client which connects to the given address and socket factory.
+   *
+   * @param hostname the hostname of the Carbon server
+   * @param port the port of the Carbon server
+   * @param socketFactory the socket factory
+   * @param batchSize how many metrics are bundled into a single pickle request to graphite
+   */
+  public PickledGraphite(String hostname, int port, SocketFactory socketFactory, int batchSize) {
+    this(hostname, port, socketFactory, UTF_8, batchSize);
+  }
+
+  /**
+   * Creates a new client which connects to the given address and socket factory using the given
+   * character set.
+   *
+   * @param hostname the hostname of the Carbon server
+   * @param port the port of the Carbon server
+   * @param socketFactory the socket factory
+   * @param charset the character set used by the server
+   * @param batchSize how many metrics are bundled into a single pickle request to graphite
+   */
+  public PickledGraphite(
+      String hostname, int port, SocketFactory socketFactory, Charset charset, int batchSize) {
+    this.address = null;
+    this.hostname = hostname;
+    this.port = port;
+    this.socketFactory = socketFactory;
+    this.charset = charset;
+    this.batchSize = batchSize;
+  }
+
+  @Override
+  public void connect() throws IllegalStateException, IOException {
+    checkState(!isConnected(), "Already connected");
+    InetSocketAddress address = this.address;
+    if (address == null) {
+      address = new InetSocketAddress(hostname, port);
     }
-
-    /**
-     * Creates a new client which connects to the given address using the default {@link SocketFactory}.
-     *
-     * @param address   the address of the Carbon server
-     * @param batchSize how many metrics are bundled into a single pickle request to graphite
-     */
-    public PickledGraphite(InetSocketAddress address, int batchSize) {
-        this(address, SocketFactory.getDefault(), batchSize);
-    }
-
-    /**
-     * Creates a new client which connects to the given address and socket factory.
-     *
-     * @param address       the address of the Carbon server
-     * @param socketFactory the socket factory
-     * @param batchSize     how many metrics are bundled into a single pickle request to graphite
-     */
-    public PickledGraphite(InetSocketAddress address, SocketFactory socketFactory, int batchSize) {
-        this(address, socketFactory, UTF_8, batchSize);
+    if (address.getAddress() == null) {
+      throw new UnknownHostException(address.getHostName());
     }
 
-    /**
-     * Creates a new client which connects to the given address and socket factory using the given character set.
-     *
-     * @param address       the address of the Carbon server
-     * @param socketFactory the socket factory
-     * @param charset       the character set used by the server
-     * @param batchSize     how many metrics are bundled into a single pickle request to graphite
-     */
-    public PickledGraphite(InetSocketAddress address, SocketFactory socketFactory, Charset charset, int batchSize) {
-        this.address = address;
-        this.hostname = null;
-        this.port = -1;
-        this.socketFactory = socketFactory;
-        this.charset = charset;
-        this.batchSize = batchSize;
+    this.socket = socketFactory.createSocket(address.getAddress(), address.getPort());
+    this.writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));
+  }
+
+  @Override
+  public boolean isConnected() {
+    return socket != null && socket.isConnected() && !socket.isClosed();
+  }
+
+  /**
+   * Convert the metric to a python tuple of the form:
+   *
+   * <p>(timestamp, (name, value))
+   *
+   * <p>And add it to the list of metrics. If we reach the batch size, write them out.
+   *
+   * @param name the name of the metric
+   * @param value the value of the metric
+   * @param timestamp the timestamp of the metric
+   * @throws IOException if there was an error sending the metric
+   */
+  @Override
+  public void send(String name, String value, long timestamp) throws IOException {
+    metrics.add(new MetricTuple(sanitize(name), timestamp, sanitize(value)));
+
+    if (metrics.size() >= batchSize) {
+      writeMetrics();
     }
+  }
 
-    /**
-     * Creates a new client which connects to the given address using the default {@link SocketFactory}. This defaults
-     * to a batchSize of 100
-     *
-     * @param hostname the hostname of the Carbon server
-     * @param port     the port of the Carbon server
-     */
-    public PickledGraphite(String hostname, int port) {
-        this(hostname, port, DEFAULT_BATCH_SIZE);
+  @Override
+  public void flush() throws IOException {
+    writeMetrics();
+    if (writer != null) {
+      writer.flush();
     }
-
-    /**
-     * Creates a new client which connects to the given address using the default {@link SocketFactory}.
-     *
-     * @param hostname  the hostname of the Carbon server
-     * @param port      the port of the Carbon server
-     * @param batchSize how many metrics are bundled into a single pickle request to graphite
-     */
-    public PickledGraphite(String hostname, int port, int batchSize) {
-        this(hostname, port, SocketFactory.getDefault(), batchSize);
-    }
-
-    /**
-     * Creates a new client which connects to the given address and socket factory.
-     *
-     * @param hostname      the hostname of the Carbon server
-     * @param port          the port of the Carbon server
-     * @param socketFactory the socket factory
-     * @param batchSize     how many metrics are bundled into a single pickle request to graphite
-     */
-    public PickledGraphite(String hostname, int port, SocketFactory socketFactory, int batchSize) {
-        this(hostname, port, socketFactory, UTF_8, batchSize);
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      flush();
+      if (writer != null) {
+        writer.close();
+      }
+    } catch (IOException ex) {
+      if (socket != null) {
+        socket.close();
+      }
+    } finally {
+      this.socket = null;
+      this.writer = null;
     }
-
-    /**
-     * Creates a new client which connects to the given address and socket factory using the given character set.
-     *
-     * @param hostname      the hostname of the Carbon server
-     * @param port          the port of the Carbon server
-     * @param socketFactory the socket factory
-     * @param charset       the character set used by the server
-     * @param batchSize     how many metrics are bundled into a single pickle request to graphite
-     */
-    public PickledGraphite(String hostname, int port, SocketFactory socketFactory, Charset charset, int batchSize) {
-        this.address = null;
-        this.hostname = hostname;
-        this.port = port;
-        this.socketFactory = socketFactory;
-        this.charset = charset;
-        this.batchSize = batchSize;
-    }
-
-    @Override
-    public void connect() throws IllegalStateException, IOException {
-        if (isConnected()) {
-            throw new IllegalStateException("Already connected");
-        }
-        InetSocketAddress address = this.address;
-        if (address == null) {
-            address = new InetSocketAddress(hostname, port);
-        }
-        if (address.getAddress() == null) {
-            throw new UnknownHostException(address.getHostName());
-        }
-
-        this.socket = socketFactory.createSocket(address.getAddress(), address.getPort());
-        this.writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));
-    }
-
-    @Override
-    public boolean isConnected() {
-        return socket != null && socket.isConnected() && !socket.isClosed();
-    }
-
-    /**
-     * Convert the metric to a python tuple of the form:
-     * <p>
-     * (timestamp, (name, value))
-     * <p>
-     * And add it to the list of metrics. If we reach the batch size, write them out.
-     *
-     * @param name      the name of the metric
-     * @param value     the value of the metric
-     * @param timestamp the timestamp of the metric
-     * @throws IOException if there was an error sending the metric
-     */
-    @Override
-    public void send(String name, String value, long timestamp) throws IOException {
-        metrics.add(new MetricTuple(sanitize(name), timestamp, sanitize(value)));
-
-        if (metrics.size() >= batchSize) {
-            writeMetrics();
-        }
-    }
-
-    @Override
-    public void flush() throws IOException {
-        writeMetrics();
-        if (writer != null) {
-            writer.flush();
-        }
-    }
-
-    @Override
-    public void close() throws IOException {
-        try {
-            flush();
-            if (writer != null) {
-                writer.close();
-            }
-        } catch (IOException ex) {
-            if (socket != null) {
-                socket.close();
-            }
-        } finally {
-            this.socket = null;
-            this.writer = null;
+  }
+
+  @Override
+  public int getFailures() {
+    return failures;
+  }
+
+  /**
+   * 1. Run the pickler script to package all the pending metrics into a single message 2. Send the
+   * message to graphite 3. Clear out the list of metrics
+   */
+  private void writeMetrics() throws IOException {
+    if (!metrics.isEmpty()) {
+      try {
+        byte[] payload = pickleMetrics(metrics);
+        byte[] header = ByteBuffer.allocate(4).putInt(payload.length).array();
+
+        @SuppressWarnings("resource")
+        OutputStream outputStream = socket.getOutputStream();
+        outputStream.write(header);
+        outputStream.write(payload);
+        outputStream.flush();
+
+        if (LOG.isDebugEnabled()) {
+          LOG.debug("Wrote {} metrics", metrics.size());
         }
+      } catch (IOException e) {
+        this.failures++;
+        throw e;
+      } finally {
+        // if there was an error, we might miss some data. for now, drop those on the floor and
+        // try to keep going.
+        metrics.clear();
+      }
     }
-
-    @Override
-    public int getFailures() {
-        return failures;
+  }
+
+  /**
+   * See: http://readthedocs.org/docs/graphite/en/1.0/feeding-carbon.html
+   *
+   * @throws IOException shouldn't happen because we write to memory.
+   */
+  byte[] pickleMetrics(List<MetricTuple> metrics) throws IOException {
+    // Extremely rough estimate of 75 bytes per message
+    ByteArrayOutputStream out = new ByteArrayOutputStream(metrics.size() * 75);
+    Writer pickled = new OutputStreamWriter(out, charset);
+
+    pickled.append(MARK);
+    pickled.append(LIST);
+
+    for (MetricTuple tuple : metrics) {
+      // start the outer tuple
+      pickled.append(MARK);
+
+      // the metric name is a string.
+      pickled.append(STRING);
+      // the single quotes are to match python's repr("abcd")
+      pickled.append(QUOTE);
+      pickled.append(tuple.name);
+      pickled.append(QUOTE);
+      pickled.append(LF);
+
+      // start the inner tuple
+      pickled.append(MARK);
+
+      // timestamp is a long
+      pickled.append(LONG);
+      pickled.append(Long.toString(tuple.timestamp));
+      // the trailing L is to match python's repr(long(1234))
+      pickled.append(LONG);
+      pickled.append(LF);
+
+      // and the value is a string.
+      pickled.append(STRING);
+      pickled.append(QUOTE);
+      pickled.append(tuple.value);
+      pickled.append(QUOTE);
+      pickled.append(LF);
+
+      pickled.append(TUPLE); // inner close
+      pickled.append(TUPLE); // outer close
+
+      pickled.append(APPEND);
     }
 
-    /**
-     * 1. Run the pickler script to package all the pending metrics into a single message
-     * 2. Send the message to graphite
-     * 3. Clear out the list of metrics
-     */
-    private void writeMetrics() throws IOException {
-        if (metrics.size() > 0) {
-            try {
-                byte[] payload = pickleMetrics(metrics);
-                byte[] header = ByteBuffer.allocate(4).putInt(payload.length).array();
-
-                @SuppressWarnings("resource")
-                OutputStream outputStream = socket.getOutputStream();
-                outputStream.write(header);
-                outputStream.write(payload);
-                outputStream.flush();
-
-                if (LOGGER.isDebugEnabled()) {
-                    LOGGER.debug("Wrote {} metrics", metrics.size());
-                }
-            } catch (IOException e) {
-                this.failures++;
-                throw e;
-            } finally {
-                // if there was an error, we might miss some data. for now, drop those on the floor and
-                // try to keep going.
-                metrics.clear();
-            }
-
-        }
-    }
+    // every pickle ends with STOP
+    pickled.append(STOP);
 
-    /**
-     * See: http://readthedocs.org/docs/graphite/en/1.0/feeding-carbon.html
-     *
-     * @throws IOException shouldn't happen because we write to memory.
-     */
-    byte[] pickleMetrics(List<MetricTuple> metrics) throws IOException {
-        // Extremely rough estimate of 75 bytes per message
-        ByteArrayOutputStream out = new ByteArrayOutputStream(metrics.size() * 75);
-        Writer pickled = new OutputStreamWriter(out, charset);
-
-        pickled.append(MARK);
-        pickled.append(LIST);
-
-        for (MetricTuple tuple : metrics) {
-            // start the outer tuple
-            pickled.append(MARK);
-
-            // the metric name is a string.
-            pickled.append(STRING);
-            // the single quotes are to match python's repr("abcd")
-            pickled.append(QUOTE);
-            pickled.append(tuple.name);
-            pickled.append(QUOTE);
-            pickled.append(LF);
-
-            // start the inner tuple
-            pickled.append(MARK);
-
-            // timestamp is a long
-            pickled.append(LONG);
-            pickled.append(Long.toString(tuple.timestamp));
-            // the trailing L is to match python's repr(long(1234))
-            pickled.append(LONG);
-            pickled.append(LF);
-
-            // and the value is a string.
-            pickled.append(STRING);
-            pickled.append(QUOTE);
-            pickled.append(tuple.value);
-            pickled.append(QUOTE);
-            pickled.append(LF);
-
-            pickled.append(TUPLE); // inner close
-            pickled.append(TUPLE); // outer close
-
-            pickled.append(APPEND);
-        }
+    pickled.flush();
 
-        // every pickle ends with STOP
-        pickled.append(STOP);
-
-        pickled.flush();
-
-        return out.toByteArray();
-    }
-
-    protected String sanitize(String s) {
-        return GraphiteSanitize.sanitize(s);
-    }
+    return out.toByteArray();
+  }
 
+  protected String sanitize(String s) {
+    return GraphiteSanitize.sanitize(s);
+  }
 }
--- a/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteRabbitMQTest.java
+++ b/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteRabbitMQTest.java
@@ -1,14 +1,5 @@
 package io.dropwizard.metrics5.graphite;
 
-import com.rabbitmq.client.Channel;
-import com.rabbitmq.client.Connection;
-import com.rabbitmq.client.ConnectionFactory;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import java.io.IOException;
-import java.net.UnknownHostException;
-
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Fail.failBecauseExceptionWasNotThrown;
@@ -17,111 +8,118 @@ import static org.mockito.Mockito.anyString;
 import static org.mockito.Mockito.atMost;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-class GraphiteRabbitMQTest {
-    private final ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
-    private final Connection connection = mock(Connection.class);
-    private final Channel channel = mock(Channel.class);
-
-    private final ConnectionFactory bogusConnectionFactory = mock(ConnectionFactory.class);
-    private final Connection bogusConnection = mock(Connection.class);
-    private final Channel bogusChannel = mock(Channel.class);
-
-    private final GraphiteRabbitMQ graphite = new GraphiteRabbitMQ(connectionFactory, "graphite");
-
-    @BeforeEach
-    void setUp() throws Exception {
-        when(connectionFactory.newConnection()).thenReturn(connection);
-        when(connection.createChannel()).thenReturn(channel);
-        when(connection.isOpen()).thenReturn(true);
-
-        when(bogusConnectionFactory.newConnection()).thenReturn(bogusConnection);
-        when(bogusConnection.createChannel()).thenReturn(bogusChannel);
-        doThrow(new IOException())
-            .when(bogusChannel)
-            .basicPublish(anyString(), anyString(), any(), any(byte[].class));
-    }
-
-    @Test
-    void shouldConnectToGraphiteServer() throws Exception {
-        graphite.connect();
-
-        verify(connectionFactory, atMost(1)).newConnection();
-        verify(connection, atMost(1)).createChannel();
-
-    }
+import com.rabbitmq.client.Channel;
+import com.rabbitmq.client.Connection;
+import com.rabbitmq.client.ConnectionFactory;
+import java.io.IOException;
+import java.net.UnknownHostException;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-    @Test
-    void measuresFailures() throws Exception {
-        try (final GraphiteRabbitMQ graphite = new GraphiteRabbitMQ(bogusConnectionFactory, "graphite")) {
-            graphite.connect();
-            try {
-                graphite.send("name", "value", 0);
-                failBecauseExceptionWasNotThrown(IOException.class);
-            } catch (IOException e) {
-                assertThat(graphite.getFailures()).isEqualTo(1);
-            }
-        }
+final class GraphiteRabbitMQTest {
+  private final ConnectionFactory connectionFactory = mock();
+  private final Connection connection = mock();
+  private final Channel channel = mock();
+
+  private final ConnectionFactory bogusConnectionFactory = mock();
+  private final Connection bogusConnection = mock();
+  private final Channel bogusChannel = mock();
+
+  private final GraphiteRabbitMQ graphite = new GraphiteRabbitMQ(connectionFactory, "graphite");
+
+  @BeforeEach
+  void setUp() throws Exception {
+    when(connectionFactory.newConnection()).thenReturn(connection);
+    when(connection.createChannel()).thenReturn(channel);
+    when(connection.isOpen()).thenReturn(true);
+
+    when(bogusConnectionFactory.newConnection()).thenReturn(bogusConnection);
+    when(bogusConnection.createChannel()).thenReturn(bogusChannel);
+    doThrow(new IOException())
+        .when(bogusChannel)
+        .basicPublish(anyString(), anyString(), any(), any(byte[].class));
+  }
+
+  @Test
+  void shouldConnectToGraphiteServer() throws Exception {
+    graphite.connect();
+
+    verify(connectionFactory, atMost(1)).newConnection();
+    verify(connection, atMost(1)).createChannel();
+  }
+
+  @Test
+  void measuresFailures() throws Exception {
+    try (final GraphiteRabbitMQ graphite =
+        new GraphiteRabbitMQ(bogusConnectionFactory, "graphite")) {
+      graphite.connect();
+      try {
+        graphite.send("name", "value", 0);
+        failBecauseExceptionWasNotThrown(IOException.class);
+      } catch (IOException e) {
+        assertThat(graphite.getFailures()).isEqualTo(1);
+      }
     }
-
-    @Test
-    void shouldDisconnectsFromGraphiteServer() throws Exception {
-        graphite.connect();
-        graphite.close();
-
-        verify(connection).close();
+  }
+
+  @Test
+  void shouldDisconnectsFromGraphiteServer() throws Exception {
+    graphite.connect();
+    graphite.close();
+
+    verify(connection).close();
+  }
+
+  @Test
+  void shouldNotConnectToGraphiteServerMoreThenOnce() throws Exception {
+    graphite.connect();
+    try {
+      graphite.connect();
+      failBecauseExceptionWasNotThrown(IllegalStateException.class);
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).isEqualTo("Already connected");
     }
+  }
 
-    @Test
-    void shouldNotConnectToGraphiteServerMoreThenOnce() throws Exception {
-        graphite.connect();
-        try {
-            graphite.connect();
-            failBecauseExceptionWasNotThrown(IllegalStateException.class);
-        } catch (IllegalStateException e) {
-            assertThat(e.getMessage()).isEqualTo("Already connected");
-        }
-    }
+  @Test
+  void shouldSendMetricsToGraphiteServer() throws Exception {
+    graphite.connect();
+    graphite.send("name", "value", 100);
 
-    @Test
-    void shouldSendMetricsToGraphiteServer() throws Exception {
-        graphite.connect();
-        graphite.send("name", "value", 100);
+    String expectedMessage = "name value 100\n";
 
-        String expectedMessage = "name value 100\n";
+    verify(channel).basicPublish("graphite", "name", null, expectedMessage.getBytes(UTF_8));
 
-        verify(channel, times(1)).basicPublish("graphite", "name", null,
-            expectedMessage.getBytes(UTF_8));
+    assertThat(graphite.getFailures()).isEqualTo(0);
+  }
 
-        assertThat(graphite.getFailures()).isZero();
-    }
+  @Test
+  void shouldSanitizeAndSendMetricsToGraphiteServer() throws Exception {
+    graphite.connect();
+    graphite.send("name to sanitize", "value to sanitize", 100);
 
-    @Test
-    void shouldSanitizeAndSendMetricsToGraphiteServer() throws Exception {
-        graphite.connect();
-        graphite.send("name to sanitize", "value to sanitize", 100);
+    String expectedMessage = "name-to-sanitize value-to-sanitize 100\n";
 
-        String expectedMessage = "name-to-sanitize value-to-sanitize 100\n";
+    verify(channel)
+        .basicPublish("graphite", "name-to-sanitize", null, expectedMessage.getBytes(UTF_8));
 
-        verify(channel, times(1)).basicPublish("graphite", "name-to-sanitize", null,
-            expectedMessage.getBytes(UTF_8));
+    assertThat(graphite.getFailures()).isEqualTo(0);
+  }
 
-        assertThat(graphite.getFailures()).isZero();
-    }
+  @Test
+  void shouldFailWhenGraphiteHostUnavailable() {
+    ConnectionFactory connectionFactory = new ConnectionFactory();
+    connectionFactory.setHost("some-unknown-host");
 
-    @Test
-    void shouldFailWhenGraphiteHostUnavailable() {
-        ConnectionFactory connectionFactory = new ConnectionFactory();
-        connectionFactory.setHost("some-unknown-host");
-
-        try (GraphiteRabbitMQ unavailableGraphite = new GraphiteRabbitMQ(connectionFactory, "graphite")) {
-            unavailableGraphite.connect();
-            failBecauseExceptionWasNotThrown(UnknownHostException.class);
-        } catch (Exception e) {
-            assertThat(e.getMessage()).contains("some-unknown-host");
-        }
+    try (GraphiteRabbitMQ unavailableGraphite =
+        new GraphiteRabbitMQ(connectionFactory, "graphite")) {
+      unavailableGraphite.connect();
+      failBecauseExceptionWasNotThrown(UnknownHostException.class);
+    } catch (Exception e) {
+      assertThat(e.getMessage()).contains("some-unknown-host");
     }
+  }
 }
--- a/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteReporterTest.java
+++ b/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteReporterTest.java
@@ -1,5 +1,14 @@
 package io.dropwizard.metrics5.graphite;
 
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.ImmutableSet;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
@@ -11,479 +20,411 @@ import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.mockito.InOrder;
-
 import java.net.UnknownHostException;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Locale;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
 import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.InOrder;
 
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
-class GraphiteReporterTest {
-    private static final MetricName GAUGE = MetricName.build("gauge");
-    private static final MetricName METER = MetricName.build("meter");
-    private static final MetricName COUNTER = MetricName.build("counter");
-
-    private final long timestamp = 1000198;
-    private final Clock clock = mock(Clock.class);
-    private final Graphite graphite = mock(Graphite.class);
-    private final MetricRegistry registry = mock(MetricRegistry.class);
-    private final GraphiteReporter reporter = GraphiteReporter.forRegistry(registry)
-        .withClock(clock)
-        .prefixedWith("prefix")
-        .convertRatesTo(TimeUnit.SECONDS)
-        .convertDurationsTo(TimeUnit.MILLISECONDS)
-        .filter(MetricFilter.ALL)
-        .disabledMetricAttributes(Collections.emptySet())
-        .build(graphite);
-
-    private final GraphiteReporter minuteRateReporter = GraphiteReporter
-        .forRegistry(registry)
-        .withClock(clock)
-        .prefixedWith("prefix")
-        .convertRatesTo(TimeUnit.MINUTES)
-        .convertDurationsTo(TimeUnit.MILLISECONDS)
-        .filter(MetricFilter.ALL)
-        .disabledMetricAttributes(Collections.emptySet())
-        .build(graphite);
-
-    @BeforeEach
-    void setUp() {
-        when(clock.getTime()).thenReturn(timestamp * 1000);
-    }
-
-    @Test
-    void doesNotReportStringGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge("value")),
-            map(),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite, never()).send("prefix.gauge", "value", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsByteGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge((byte) 1)),
-            map(),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsShortGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge((short) 1)),
-            map(),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsIntegerGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(1)),
-            map(),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsLongGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(1L)),
-            map(),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsFloatGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(1.1f)),
-            map(),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.gauge", "1.10", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsDoubleGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(1.1)),
-            map(),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.gauge", "1.10", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsDoubleGaugeValuesWithCustomFormat() throws Exception {
-        try (final GraphiteReporter graphiteReporter = getReporterWithCustomFormat()) {
-            reportGaugeValue(graphiteReporter, 1.13574);
-            verifyGraphiteSentCorrectMetricValue("prefix.gauge", "1.1357", timestamp);
-            verifyNoMoreInteractions(graphite);
-        }
+final class GraphiteReporterTest {
+  private static final MetricName GAUGE = MetricName.build("gauge");
+  private static final MetricName METER = MetricName.build("meter");
+  private static final MetricName COUNTER = MetricName.build("counter");
+
+  private final long timestamp = 1000198;
+  private final Clock clock = mock();
+  private final Graphite graphite = mock();
+  private final MetricRegistry registry = mock();
+  private final GraphiteReporter reporter =
+      GraphiteReporter.forRegistry(registry)
+          .withClock(clock)
+          .prefixedWith("prefix")
+          .convertRatesTo(TimeUnit.SECONDS)
+          .convertDurationsTo(TimeUnit.MILLISECONDS)
+          .filter(MetricFilter.ALL)
+          .disabledMetricAttributes(ImmutableSet.of())
+          .build(graphite);
+
+  private final GraphiteReporter minuteRateReporter =
+      GraphiteReporter.forRegistry(registry)
+          .withClock(clock)
+          .prefixedWith("prefix")
+          .convertRatesTo(TimeUnit.MINUTES)
+          .convertDurationsTo(TimeUnit.MILLISECONDS)
+          .filter(MetricFilter.ALL)
+          .disabledMetricAttributes(ImmutableSet.of())
+          .build(graphite);
+
+  @BeforeEach
+  void setUp() {
+    when(clock.getTime()).thenReturn(timestamp * 1000);
+  }
+
+  @Test
+  void doesNotReportStringGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge("value")), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite, never()).send("prefix.gauge", "value", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsByteGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge((byte) 1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsShortGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge((short) 1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsIntegerGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsLongGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(1L)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsFloatGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(1.1f)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.gauge", "1.10", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsDoubleGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(1.1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.gauge", "1.10", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsDoubleGaugeValuesWithCustomFormat() throws Exception {
+    try (final GraphiteReporter graphiteReporter = getReporterWithCustomFormat()) {
+      reportGaugeValue(graphiteReporter, 1.13574);
+      verifyGraphiteSentCorrectMetricValue("prefix.gauge", "1.1357", timestamp);
+      verifyNoMoreInteractions(graphite);
     }
+  }
 
-    @Test
-    void reportDoubleGaugeValuesUsingCustomFormatter() throws Exception {
-        DecimalFormat formatter = new DecimalFormat("##.##########", DecimalFormatSymbols.getInstance(Locale.US));
+  @Test
+  void reportDoubleGaugeValuesUsingCustomFormatter() throws Exception {
+    DecimalFormat formatter =
+        new DecimalFormat("##.##########", DecimalFormatSymbols.getInstance(Locale.US));
 
-        try (GraphiteReporter graphiteReporter = GraphiteReporter.forRegistry(registry)
+    try (GraphiteReporter graphiteReporter =
+        GraphiteReporter.forRegistry(registry)
             .withClock(clock)
             .prefixedWith("prefix")
             .convertRatesTo(TimeUnit.SECONDS)
             .convertDurationsTo(TimeUnit.MILLISECONDS)
             .filter(MetricFilter.ALL)
-            .disabledMetricAttributes(Collections.emptySet())
+            .disabledMetricAttributes(ImmutableSet.of())
             .withFloatingPointFormatter(formatter::format)
             .build(graphite)) {
-            reportGaugeValue(graphiteReporter, 0.000045322);
-            verifyGraphiteSentCorrectMetricValue("prefix.gauge", "0.000045322", timestamp);
-            verifyNoMoreInteractions(graphite);
-        }
+      reportGaugeValue(graphiteReporter, 0.000045322);
+      verifyGraphiteSentCorrectMetricValue("prefix.gauge", "0.000045322", timestamp);
+      verifyNoMoreInteractions(graphite);
     }
-
-    private void reportGaugeValue(GraphiteReporter graphiteReporter, double value) {
-        graphiteReporter.report(map(MetricName.build("gauge"), gauge(value)),
-            map(),
-            map(),
-            map(),
-            map());
-    }
-
-    private void verifyGraphiteSentCorrectMetricValue(String metricName, String value, long timestamp) throws Exception {
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send(metricName, value, timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-    }
-
-    @Test
-    void reportsBooleanGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(true)),
-            map(),
-            map(),
-            map(),
-            map());
-
-        reporter.report(map(GAUGE, gauge(false)),
-            map(),
-            map(),
-            map(),
-            map());
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.gauge", "0", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsCounters() throws Exception {
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(100L);
-
-        reporter.report(map(),
-            map(COUNTER, counter),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.counter.count", "100", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsHistograms() throws Exception {
-        final Histogram histogram = mock(Histogram.class);
-        when(histogram.getCount()).thenReturn(1L);
-        when(histogram.getSum()).thenReturn(12L);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(2L);
-        when(snapshot.getMean()).thenReturn(3.0);
-        when(snapshot.getMin()).thenReturn(4L);
-        when(snapshot.getStdDev()).thenReturn(5.0);
-        when(snapshot.getMedian()).thenReturn(6.0);
-        when(snapshot.get75thPercentile()).thenReturn(7.0);
-        when(snapshot.get95thPercentile()).thenReturn(8.0);
-        when(snapshot.get98thPercentile()).thenReturn(9.0);
-        when(snapshot.get99thPercentile()).thenReturn(10.0);
-        when(snapshot.get999thPercentile()).thenReturn(11.0);
-
-        when(histogram.getSnapshot()).thenReturn(snapshot);
-
-        reporter.report(map(),
-            map(),
-            map(MetricName.build("histogram"), histogram),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.histogram.count", "1", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.sum", "12", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.max", "2", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.mean", "3.00", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.min", "4", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.stddev", "5.00", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.p50", "6.00", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.p75", "7.00", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.p95", "8.00", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.p98", "9.00", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.p99", "10.00", timestamp);
-        inOrder.verify(graphite).send("prefix.histogram.p999", "11.00", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsMeters() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(6L);
-        when(meter.getOneMinuteRate()).thenReturn(2.0);
-        when(meter.getFiveMinuteRate()).thenReturn(3.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(4.0);
-        when(meter.getMeanRate()).thenReturn(5.0);
-
-        reporter.report(map(),
-            map(),
-            map(),
-            map(METER, meter),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.meter.count", "1", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.sum", "6.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.m1_rate", "2.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.m5_rate", "3.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.m15_rate", "4.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.mean_rate", "5.00", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsMetersInMinutes() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(6L);
-        when(meter.getOneMinuteRate()).thenReturn(2.0);
-        when(meter.getFiveMinuteRate()).thenReturn(3.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(4.0);
-        when(meter.getMeanRate()).thenReturn(5.0);
-
-        minuteRateReporter.report(this.map(),
-            this.map(),
-            this.map(),
-            this.map(METER, meter),
-            this.map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.meter.count", "1", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.sum", "6.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.m1_rate", "120.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.m5_rate", "180.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.m15_rate", "240.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.mean_rate", "300.00", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void reportsTimers() throws Exception {
-        final Timer timer = mock(Timer.class);
-        when(timer.getCount()).thenReturn(1L);
-        when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(6));
-        when(timer.getMeanRate()).thenReturn(2.0);
-        when(timer.getOneMinuteRate()).thenReturn(3.0);
-        when(timer.getFiveMinuteRate()).thenReturn(4.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(5.0);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
-        when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
-        when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
-        when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
-        when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
-        when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
-        when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
-        when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
-        when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
-        when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS
-            .toNanos(1000));
-
-        when(timer.getSnapshot()).thenReturn(snapshot);
-
-        reporter.report(map(),
-            map(),
-            map(),
-            map(),
-            map(MetricName.build("timer"), timer));
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.timer.max", "100.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.mean", "200.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.min", "300.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.stddev", "400.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.p50", "500.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.p75", "600.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.p95", "700.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.p98", "800.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.p99", "900.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.p999", "1000.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.count", "1", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.sum", "6.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.m1_rate", "3.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.m5_rate", "4.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.m15_rate", "5.00", timestamp);
-        inOrder.verify(graphite).send("prefix.timer.mean_rate", "2.00", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-
-        reporter.close();
-    }
-
-    @Test
-    void closesConnectionIfGraphiteIsUnavailable() throws Exception {
-        doThrow(new UnknownHostException("UNKNOWN-HOST")).when(graphite).connect();
-        reporter.report(map(GAUGE, gauge(1)),
-            map(),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).close();
-
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void closesConnectionOnReporterStop() throws Exception {
-        reporter.start(1, TimeUnit.SECONDS);
-        reporter.stop();
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite, times(2)).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void disabledMetricsAttribute() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(6L);
-        when(meter.getOneMinuteRate()).thenReturn(2.0);
-        when(meter.getFiveMinuteRate()).thenReturn(3.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(4.0);
-        when(meter.getMeanRate()).thenReturn(5.0);
-
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(11L);
-
-        Set<MetricAttribute> disabledMetricAttributes = EnumSet.of(MetricAttribute.M15_RATE, MetricAttribute.M5_RATE);
-        GraphiteReporter reporterWithdisabledMetricAttributes = GraphiteReporter.forRegistry(registry)
+  }
+
+  private void reportGaugeValue(GraphiteReporter graphiteReporter, double value) {
+    graphiteReporter.report(
+        map(MetricName.build("gauge"), gauge(value)), map(), map(), map(), map());
+  }
+
+  private void verifyGraphiteSentCorrectMetricValue(String metricName, String value, long timestamp)
+      throws Exception {
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send(metricName, value, timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+  }
+
+  @Test
+  void reportsBooleanGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(true)), map(), map(), map(), map());
+
+    reporter.report(map(GAUGE, gauge(false)), map(), map(), map(), map());
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.gauge", "1", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.gauge", "0", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsCounters() throws Exception {
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(100L);
+
+    reporter.report(map(), map(COUNTER, counter), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.counter.count", "100", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsHistograms() throws Exception {
+    final Histogram histogram = mock();
+    when(histogram.getCount()).thenReturn(1L);
+    when(histogram.getSum()).thenReturn(12L);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(2L);
+    when(snapshot.getMean()).thenReturn(3.0);
+    when(snapshot.getMin()).thenReturn(4L);
+    when(snapshot.getStdDev()).thenReturn(5.0);
+    when(snapshot.getMedian()).thenReturn(6.0);
+    when(snapshot.get75thPercentile()).thenReturn(7.0);
+    when(snapshot.get95thPercentile()).thenReturn(8.0);
+    when(snapshot.get98thPercentile()).thenReturn(9.0);
+    when(snapshot.get99thPercentile()).thenReturn(10.0);
+    when(snapshot.get999thPercentile()).thenReturn(11.0);
+
+    when(histogram.getSnapshot()).thenReturn(snapshot);
+
+    reporter.report(map(), map(), map(MetricName.build("histogram"), histogram), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.histogram.count", "1", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.sum", "12", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.max", "2", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.mean", "3.00", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.min", "4", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.stddev", "5.00", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.p50", "6.00", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.p75", "7.00", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.p95", "8.00", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.p98", "9.00", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.p99", "10.00", timestamp);
+    inOrder.verify(graphite).send("prefix.histogram.p999", "11.00", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsMeters() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(6L);
+    when(meter.getOneMinuteRate()).thenReturn(2.0);
+    when(meter.getFiveMinuteRate()).thenReturn(3.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(4.0);
+    when(meter.getMeanRate()).thenReturn(5.0);
+
+    reporter.report(map(), map(), map(), map(METER, meter), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.meter.count", "1", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.sum", "6.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.m1_rate", "2.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.m5_rate", "3.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.m15_rate", "4.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.mean_rate", "5.00", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsMetersInMinutes() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(6L);
+    when(meter.getOneMinuteRate()).thenReturn(2.0);
+    when(meter.getFiveMinuteRate()).thenReturn(3.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(4.0);
+    when(meter.getMeanRate()).thenReturn(5.0);
+
+    minuteRateReporter.report(
+        this.map(), this.map(), this.map(), this.map(METER, meter), this.map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.meter.count", "1", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.sum", "6.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.m1_rate", "120.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.m5_rate", "180.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.m15_rate", "240.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.mean_rate", "300.00", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void reportsTimers() throws Exception {
+    final Timer timer = mock();
+    when(timer.getCount()).thenReturn(1L);
+    when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(6));
+    when(timer.getMeanRate()).thenReturn(2.0);
+    when(timer.getOneMinuteRate()).thenReturn(3.0);
+    when(timer.getFiveMinuteRate()).thenReturn(4.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(5.0);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
+    when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
+    when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
+    when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
+    when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
+    when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
+    when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
+    when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
+    when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
+    when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
+
+    when(timer.getSnapshot()).thenReturn(snapshot);
+
+    reporter.report(map(), map(), map(), map(), map(MetricName.build("timer"), timer));
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.timer.max", "100.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.mean", "200.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.min", "300.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.stddev", "400.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.p50", "500.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.p75", "600.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.p95", "700.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.p98", "800.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.p99", "900.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.p999", "1000.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.count", "1", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.sum", "6.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.m1_rate", "3.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.m5_rate", "4.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.m15_rate", "5.00", timestamp);
+    inOrder.verify(graphite).send("prefix.timer.mean_rate", "2.00", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+
+    reporter.close();
+  }
+
+  @Test
+  void closesConnectionIfGraphiteIsUnavailable() throws Exception {
+    doThrow(new UnknownHostException("UNKNOWN-HOST")).when(graphite).connect();
+    reporter.report(map(GAUGE, gauge(1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void closesConnectionOnReporterStop() throws Exception {
+    reporter.start(1, TimeUnit.SECONDS);
+    reporter.stop();
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite, times(2)).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void disabledMetricsAttribute() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(6L);
+    when(meter.getOneMinuteRate()).thenReturn(2.0);
+    when(meter.getFiveMinuteRate()).thenReturn(3.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(4.0);
+    when(meter.getMeanRate()).thenReturn(5.0);
+
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(11L);
+
+    Set<MetricAttribute> disabledMetricAttributes =
+        EnumSet.of(MetricAttribute.M15_RATE, MetricAttribute.M5_RATE);
+    GraphiteReporter reporterWithdisabledMetricAttributes =
+        GraphiteReporter.forRegistry(registry)
             .withClock(clock)
             .prefixedWith("prefix")
             .convertRatesTo(TimeUnit.SECONDS)
@@ -491,79 +432,82 @@ class GraphiteReporterTest {
             .filter(MetricFilter.ALL)
             .disabledMetricAttributes(disabledMetricAttributes)
             .build(graphite);
-        reporterWithdisabledMetricAttributes.report(map(),
-            map(COUNTER, counter),
-            map(),
-            map(METER, meter),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.counter.count", "11", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.count", "1", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.sum", "6.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.m1_rate", "2.00", timestamp);
-        inOrder.verify(graphite).send("prefix.meter.mean_rate", "5.00", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    @Test
-    void sendsMetricAttributesAsTagsIfEnabled() throws Exception {
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(100L);
-
-        getReporterThatSendsMetricAttributesAsTags().report(map(),
-            map(COUNTER, counter),
-            map(),
-            map(),
-            map());
-
-        final InOrder inOrder = inOrder(graphite);
-        inOrder.verify(graphite).connect();
-        inOrder.verify(graphite).send("prefix.counter;metricattribute=count", "100", timestamp);
-        inOrder.verify(graphite).flush();
-        inOrder.verify(graphite).close();
-
-        verifyNoMoreInteractions(graphite);
-    }
-
-    private GraphiteReporter getReporterWithCustomFormat() {
-        return new GraphiteReporter(registry, graphite, clock, "prefix",
-            TimeUnit.SECONDS, TimeUnit.MICROSECONDS, MetricFilter.ALL, null, false,
-            Collections.emptySet(), false) {
-            @Override
-            protected String format(double v) {
-                return String.format(Locale.US, "%4.4f", v);
-            }
-        };
-    }
-
-    private GraphiteReporter getReporterThatSendsMetricAttributesAsTags() {
-        return GraphiteReporter.forRegistry(registry)
-            .withClock(clock)
-            .prefixedWith("prefix")
-            .convertRatesTo(TimeUnit.SECONDS)
-            .convertDurationsTo(TimeUnit.MILLISECONDS)
-            .filter(MetricFilter.ALL)
-            .disabledMetricAttributes(Collections.emptySet())
-            .addMetricAttributesAsTags(true)
-            .build(graphite);
-    }
+    reporterWithdisabledMetricAttributes.report(
+        map(), map(COUNTER, counter), map(), map(METER, meter), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.counter.count", "11", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.count", "1", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.sum", "6.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.m1_rate", "2.00", timestamp);
+    inOrder.verify(graphite).send("prefix.meter.mean_rate", "5.00", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  @Test
+  void sendsMetricAttributesAsTagsIfEnabled() throws Exception {
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(100L);
+
+    getReporterThatSendsMetricAttributesAsTags()
+        .report(map(), map(COUNTER, counter), map(), map(), map());
+
+    final InOrder inOrder = inOrder(graphite);
+    inOrder.verify(graphite).connect();
+    inOrder.verify(graphite).send("prefix.counter;metricattribute=count", "100", timestamp);
+    inOrder.verify(graphite).flush();
+    inOrder.verify(graphite).close();
+
+    verifyNoMoreInteractions(graphite);
+  }
+
+  private GraphiteReporter getReporterWithCustomFormat() {
+    return new GraphiteReporter(
+        registry,
+        graphite,
+        clock,
+        "prefix",
+        TimeUnit.SECONDS,
+        TimeUnit.MICROSECONDS,
+        MetricFilter.ALL,
+        null,
+        false,
+        ImmutableSet.of(),
+        false) {
+      @Override
+      protected String format(double v) {
+        return String.format(Locale.US, "%4.4f", v);
+      }
+    };
+  }
+
+  private GraphiteReporter getReporterThatSendsMetricAttributesAsTags() {
+    return GraphiteReporter.forRegistry(registry)
+        .withClock(clock)
+        .prefixedWith("prefix")
+        .convertRatesTo(TimeUnit.SECONDS)
+        .convertDurationsTo(TimeUnit.MILLISECONDS)
+        .filter(MetricFilter.ALL)
+        .disabledMetricAttributes(ImmutableSet.of())
+        .addMetricAttributesAsTags(true)
+        .build(graphite);
+  }
 
-    private <T> SortedMap<MetricName, T> map() {
-        return new TreeMap<>();
-    }
+  private <T> SortedMap<MetricName, T> map() {
+    return new TreeMap<>();
+  }
 
-    private <T> SortedMap<MetricName, T> map(MetricName name, T metric) {
-        final TreeMap<MetricName, T> map = new TreeMap<>();
-        map.put(name, metric);
-        return map;
-    }
+  private <T> SortedMap<MetricName, T> map(MetricName name, T metric) {
+    final TreeMap<MetricName, T> map = new TreeMap<>();
+    map.put(name, metric);
+    return map;
+  }
 
-    private <T> Gauge<T> gauge(T value) {
-        return () -> value;
-    }
+  private <T> Gauge<T> gauge(T value) {
+    return () -> value;
+  }
 }
--- a/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteSanitizeTest.java
+++ b/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteSanitizeTest.java
@@ -3,25 +3,27 @@ package io.dropwizard.metrics5.graphite;
 import org.assertj.core.api.SoftAssertions;
 import org.junit.jupiter.api.Test;
 
-class GraphiteSanitizeTest {
-    @Test
-    void sanitizeGraphiteValues() {
-        SoftAssertions softly = new SoftAssertions();
+final class GraphiteSanitizeTest {
+  @Test
+  void sanitizeGraphiteValues() {
+    SoftAssertions softly = new SoftAssertions();
 
-        softly.assertThat(GraphiteSanitize.sanitize("Foo Bar")).isEqualTo("Foo-Bar");
-        softly.assertThat(GraphiteSanitize.sanitize(" Foo Bar ")).isEqualTo("Foo-Bar");
-        softly.assertThat(GraphiteSanitize.sanitize(" Foo Bar")).isEqualTo("Foo-Bar");
-        softly.assertThat(GraphiteSanitize.sanitize("Foo Bar ")).isEqualTo("Foo-Bar");
-        softly.assertThat(GraphiteSanitize.sanitize("  Foo Bar  ")).isEqualTo("Foo-Bar");
-        softly.assertThat(GraphiteSanitize.sanitize("Foo@Bar")).isEqualTo("Foo@Bar");
-        softly.assertThat(GraphiteSanitize.sanitize("Foó Bar")).isEqualTo("Foó-Bar");
-        softly.assertThat(GraphiteSanitize.sanitize("||ó/.")).isEqualTo("||ó/.");
-        softly.assertThat(GraphiteSanitize.sanitize("${Foo:Bar:baz}")).isEqualTo("${Foo:Bar:baz}");
-        softly.assertThat(GraphiteSanitize.sanitize("St. Foo's of Bar")).isEqualTo("St.-Foo's-of-Bar");
-        softly.assertThat(GraphiteSanitize.sanitize("(Foo and (Bar and (Baz)))")).isEqualTo("(Foo-and-(Bar-and-(Baz)))");
-        softly.assertThat(GraphiteSanitize.sanitize("Foo.bar.baz")).isEqualTo("Foo.bar.baz");
-        softly.assertThat(GraphiteSanitize.sanitize("FooBar")).isEqualTo("FooBar");
+    softly.assertThat(GraphiteSanitize.sanitize("Foo Bar")).isEqualTo("Foo-Bar");
+    softly.assertThat(GraphiteSanitize.sanitize(" Foo Bar ")).isEqualTo("Foo-Bar");
+    softly.assertThat(GraphiteSanitize.sanitize(" Foo Bar")).isEqualTo("Foo-Bar");
+    softly.assertThat(GraphiteSanitize.sanitize("Foo Bar ")).isEqualTo("Foo-Bar");
+    softly.assertThat(GraphiteSanitize.sanitize("  Foo Bar  ")).isEqualTo("Foo-Bar");
+    softly.assertThat(GraphiteSanitize.sanitize("Foo@Bar")).isEqualTo("Foo@Bar");
+    softly.assertThat(GraphiteSanitize.sanitize("Foó Bar")).isEqualTo("Foó-Bar");
+    softly.assertThat(GraphiteSanitize.sanitize("||ó/.")).isEqualTo("||ó/.");
+    softly.assertThat(GraphiteSanitize.sanitize("${Foo:Bar:baz}")).isEqualTo("${Foo:Bar:baz}");
+    softly.assertThat(GraphiteSanitize.sanitize("St. Foo's of Bar")).isEqualTo("St.-Foo's-of-Bar");
+    softly
+        .assertThat(GraphiteSanitize.sanitize("(Foo and (Bar and (Baz)))"))
+        .isEqualTo("(Foo-and-(Bar-and-(Baz)))");
+    softly.assertThat(GraphiteSanitize.sanitize("Foo.bar.baz")).isEqualTo("Foo.bar.baz");
+    softly.assertThat(GraphiteSanitize.sanitize("FooBar")).isEqualTo("FooBar");
 
-        softly.assertAll();
-    }
+    softly.assertAll();
+  }
 }
--- a/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteTest.java
+++ b/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteTest.java
@@ -1,17 +1,5 @@
 package io.dropwizard.metrics5.graphite;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import javax.net.SocketFactory;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.UnknownHostException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatNoException;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
@@ -24,120 +12,137 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-class GraphiteTest {
-    private final String host = "example.com";
-    private final int port = 1234;
-    private final SocketFactory socketFactory = mock(SocketFactory.class);
-    private final InetSocketAddress address = new InetSocketAddress(host, port);
-
-    private final Socket socket = mock(Socket.class);
-    private final ByteArrayOutputStream output = spy(ByteArrayOutputStream.class);
-
-    @BeforeEach
-    void setUp() throws Exception {
-        final AtomicBoolean connected = new AtomicBoolean(true);
-        final AtomicBoolean closed = new AtomicBoolean(false);
-
-        when(socket.isConnected()).thenAnswer(invocation -> connected.get());
-
-        when(socket.isClosed()).thenAnswer(invocation -> closed.get());
-
-        doAnswer(invocation -> {
-            connected.set(false);
-            closed.set(true);
-            return null;
-        }).when(socket).close();
-
-        when(socket.getOutputStream()).thenReturn(output);
-
-        // Mock behavior of socket.getOutputStream().close() calling socket.close();
-        doAnswer(invocation -> {
-            invocation.callRealMethod();
-            socket.close();
-            return null;
-        }).when(output).close();
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import javax.net.SocketFactory;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-        when(socketFactory.createSocket(any(InetAddress.class), anyInt())).thenReturn(socket);
+final class GraphiteTest {
+  private final String host = "example.com";
+  private final int port = 1234;
+  private final SocketFactory socketFactory = mock();
+  private final InetSocketAddress address = new InetSocketAddress(host, port);
+
+  private final Socket socket = mock();
+  private final ByteArrayOutputStream output = spy();
+
+  @BeforeEach
+  void setUp() throws Exception {
+    final AtomicBoolean connected = new AtomicBoolean(true);
+    final AtomicBoolean closed = new AtomicBoolean(false);
+
+    when(socket.isConnected()).thenAnswer(invocation -> connected.get());
+
+    when(socket.isClosed()).thenAnswer(invocation -> closed.get());
+
+    doAnswer(
+            invocation -> {
+              connected.set(false);
+              closed.set(true);
+              return null;
+            })
+        .when(socket)
+        .close();
+
+    when(socket.getOutputStream()).thenReturn(output);
+
+    // Mock behavior of socket.getOutputStream().close() calling socket.close();
+    doAnswer(
+            invocation -> {
+              invocation.callRealMethod();
+              socket.close();
+              return null;
+            })
+        .when(output)
+        .close();
+
+    when(socketFactory.createSocket(any(InetAddress.class), anyInt())).thenReturn(socket);
+  }
+
+  @Test
+  void connectsToGraphiteWithInetSocketAddress() throws Exception {
+    try (Graphite graphite = new Graphite(address, socketFactory)) {
+      graphite.connect();
     }
+    verify(socketFactory).createSocket(address.getAddress(), address.getPort());
+  }
 
-    @Test
-    void connectsToGraphiteWithInetSocketAddress() throws Exception {
-        try (Graphite graphite = new Graphite(address, socketFactory)) {
-            graphite.connect();
-        }
-        verify(socketFactory).createSocket(address.getAddress(), address.getPort());
+  @Test
+  void connectsToGraphiteWithHostAndPort() throws Exception {
+    try (Graphite graphite = new Graphite(host, port, socketFactory)) {
+      graphite.connect();
     }
+    verify(socketFactory).createSocket(address.getAddress(), port);
+  }
 
-    @Test
-    void connectsToGraphiteWithHostAndPort() throws Exception {
-        try (Graphite graphite = new Graphite(host, port, socketFactory)) {
-            graphite.connect();
-        }
-        verify(socketFactory).createSocket(address.getAddress(), port);
+  @Test
+  void measuresFailures() throws IOException {
+    try (Graphite graphite = new Graphite(address, socketFactory)) {
+      assertThat(graphite.getFailures()).isEqualTo(0);
     }
+  }
 
-    @Test
-    void measuresFailures() throws IOException {
-        try (Graphite graphite = new Graphite(address, socketFactory)) {
-            assertThat(graphite.getFailures()).isZero();
-        }
+  @Test
+  void disconnectsFromGraphite() throws Exception {
+    try (Graphite graphite = new Graphite(address, socketFactory)) {
+      graphite.connect();
     }
 
-    @Test
-    void disconnectsFromGraphite() throws Exception {
-        try (Graphite graphite = new Graphite(address, socketFactory)) {
-            graphite.connect();
-        }
-
-        verify(socket, times(2)).close();
-    }
+    verify(socket, times(2)).close();
+  }
 
-    @Test
-    void doesNotAllowDoubleConnections() throws Exception {
-        try (Graphite graphite = new Graphite(address, socketFactory)) {
-            assertThatNoException().isThrownBy(graphite::connect);
-            assertThatThrownBy(graphite::connect)
-                .isInstanceOf(IllegalStateException.class)
-                .hasMessage("Already connected");
-        }
+  @Test
+  void doesNotAllowDoubleConnections() throws Exception {
+    try (Graphite graphite = new Graphite(address, socketFactory)) {
+      assertThatNoException().isThrownBy(graphite::connect);
+      assertThatThrownBy(graphite::connect)
+          .isInstanceOf(IllegalStateException.class)
+          .hasMessage("Already connected");
     }
+  }
 
-    @Test
-    void writesValuesToGraphite() throws Exception {
-        try (Graphite graphite = new Graphite(address, socketFactory)) {
-            graphite.connect();
-            graphite.send("name", "value", 100);
-        }
-        assertThat(output).hasToString("name value 100\n");
+  @Test
+  void writesValuesToGraphite() throws Exception {
+    try (Graphite graphite = new Graphite(address, socketFactory)) {
+      graphite.connect();
+      graphite.send("name", "value", 100);
     }
-
-    @Test
-    void sanitizesNames() throws Exception {
-        try (Graphite graphite = new Graphite(address, socketFactory)) {
-            graphite.connect();
-            graphite.send("name woo", "value", 100);
-        }
-        assertThat(output).hasToString("name-woo value 100\n");
+    assertThat(output).hasToString("name value 100\n");
+  }
+
+  @Test
+  void sanitizesNames() throws Exception {
+    try (Graphite graphite = new Graphite(address, socketFactory)) {
+      graphite.connect();
+      graphite.send("name woo", "value", 100);
     }
-
-    @Test
-    void sanitizesValues() throws Exception {
-        try (Graphite graphite = new Graphite(address, socketFactory)) {
-            graphite.connect();
-            graphite.send("name", "value woo", 100);
-        }
-        assertThat(output).hasToString("name value-woo 100\n");
+    assertThat(output).hasToString("name-woo value 100\n");
+  }
+
+  @Test
+  void sanitizesValues() throws Exception {
+    try (Graphite graphite = new Graphite(address, socketFactory)) {
+      graphite.connect();
+      graphite.send("name", "value woo", 100);
     }
-
-    @Test
-    void notifiesIfGraphiteIsUnavailable() throws IOException {
-        final String unavailableHost = "unknown-host-10el6m7yg56ge7dmcom";
-        InetSocketAddress unavailableAddress = new InetSocketAddress(unavailableHost, 1234);
-
-        try (Graphite unavailableGraphite = new Graphite(unavailableAddress, socketFactory)) {
-            assertThatThrownBy(unavailableGraphite::connect)
-                .isInstanceOf(UnknownHostException.class)
-                .hasMessage(unavailableHost);
-        }
+    assertThat(output).hasToString("name value-woo 100\n");
+  }
+
+  @Test
+  void notifiesIfGraphiteIsUnavailable() throws IOException {
+    final String unavailableHost = "unknown-host-10el6m7yg56ge7dmcom";
+    InetSocketAddress unavailableAddress = new InetSocketAddress(unavailableHost, 1234);
+
+    try (Graphite unavailableGraphite = new Graphite(unavailableAddress, socketFactory)) {
+      assertThatThrownBy(unavailableGraphite::connect)
+          .isInstanceOf(UnknownHostException.class)
+          .hasMessage(unavailableHost);
     }
+  }
 }
--- a/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteUDPTest.java
+++ b/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/GraphiteUDPTest.java
@@ -1,43 +1,43 @@
 package io.dropwizard.metrics5.graphite;
 
-import org.junit.jupiter.api.Test;
-import org.mockito.Mockito;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.DatagramChannel;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.verify;
-
-class GraphiteUDPTest {
+final class GraphiteUDPTest {
 
-    private final String host = "example.com";
-    private final int port = 1234;
+  private final String host = "example.com";
+  private final int port = 1234;
 
-    private GraphiteUDP graphiteUDP;
+  private GraphiteUDP graphiteUDP;
 
-    @Test
-    void connects() throws Exception {
-        graphiteUDP = new GraphiteUDP(host, port);
-        graphiteUDP.connect();
+  @Test
+  void connects() throws Exception {
+    graphiteUDP = new GraphiteUDP(host, port);
+    graphiteUDP.connect();
 
-        assertThat(graphiteUDP.getDatagramChannel()).isNotNull();
-        assertThat(graphiteUDP.getAddress()).isEqualTo(new InetSocketAddress(host, port));
+    assertThat(graphiteUDP.getDatagramChannel()).isNotNull();
+    assertThat(graphiteUDP.getAddress()).isEqualTo(new InetSocketAddress(host, port));
 
-        graphiteUDP.close();
-    }
+    graphiteUDP.close();
+  }
 
-    @Test
-    void writesValue() throws Exception {
-        graphiteUDP = new GraphiteUDP(host, port);
-        DatagramChannel mockDatagramChannel = Mockito.mock(DatagramChannel.class);
-        graphiteUDP.setDatagramChannel(mockDatagramChannel);
-        graphiteUDP.setAddress(new InetSocketAddress(host, port));
+  @Test
+  void writesValue() throws Exception {
+    graphiteUDP = new GraphiteUDP(host, port);
+    DatagramChannel mockDatagramChannel = mock();
+    graphiteUDP.setDatagramChannel(mockDatagramChannel);
+    graphiteUDP.setAddress(new InetSocketAddress(host, port));
 
-        graphiteUDP.send("name woo", "value", 100);
-        verify(mockDatagramChannel).send(ByteBuffer.wrap("name-woo value 100\n".getBytes("UTF-8")),
+    graphiteUDP.send("name woo", "value", 100);
+    verify(mockDatagramChannel)
+        .send(
+            ByteBuffer.wrap("name-woo value 100\n".getBytes("UTF-8")),
             new InetSocketAddress(host, port));
-    }
-
-}
\ No newline at end of file
+  }
+}
--- a/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/PickledGraphiteTest.java
+++ b/metrics-graphite/src/test/java/io/dropwizard/metrics5/graphite/PickledGraphiteTest.java
@@ -1,26 +1,5 @@
 package io.dropwizard.metrics5.graphite;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.python.core.PyList;
-import org.python.core.PyTuple;
-
-import javax.net.SocketFactory;
-import javax.script.Bindings;
-import javax.script.Compilable;
-import javax.script.CompiledScript;
-import javax.script.ScriptEngine;
-import javax.script.ScriptEngineManager;
-import javax.script.SimpleBindings;
-import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.math.BigInteger;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Fail.failBecauseExceptionWasNotThrown;
@@ -32,150 +11,169 @@ import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-class PickledGraphiteTest {
-    private final SocketFactory socketFactory = mock(SocketFactory.class);
-    private final InetSocketAddress address = new InetSocketAddress("example.com", 1234);
-    private final PickledGraphite graphite = new PickledGraphite(address, socketFactory, UTF_8, 2);
-
-    private final Socket socket = mock(Socket.class);
-    private final ByteArrayOutputStream output = spy(ByteArrayOutputStream.class);
-
-    private CompiledScript unpickleScript;
-
-    @BeforeEach
-    void setUp() throws Exception {
-        final AtomicBoolean connected = new AtomicBoolean(true);
-        final AtomicBoolean closed = new AtomicBoolean(false);
-
-        when(socket.isConnected()).thenAnswer(invocation -> connected.get());
-
-        when(socket.isClosed()).thenAnswer(invocation -> closed.get());
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.math.BigInteger;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.concurrent.atomic.AtomicBoolean;
+import javax.net.SocketFactory;
+import javax.script.Bindings;
+import javax.script.Compilable;
+import javax.script.CompiledScript;
+import javax.script.ScriptEngine;
+import javax.script.ScriptEngineManager;
+import javax.script.SimpleBindings;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.python.core.PyList;
+import org.python.core.PyTuple;
 
-        doAnswer(invocation -> {
-            connected.set(false);
-            closed.set(true);
-            return null;
-        }).when(socket).close();
+final class PickledGraphiteTest {
+  private final SocketFactory socketFactory = mock();
+  private final InetSocketAddress address = new InetSocketAddress("example.com", 1234);
+  private final PickledGraphite graphite = new PickledGraphite(address, socketFactory, UTF_8, 2);
 
-        when(socket.getOutputStream()).thenReturn(output);
+  private final Socket socket = mock();
+  private final ByteArrayOutputStream output = spy();
 
-        // Mock behavior of socket.getOutputStream().close() calling socket.close();
-        doAnswer(invocation -> {
-            invocation.callRealMethod();
-            socket.close();
-            return null;
-        }).when(output).close();
+  private CompiledScript unpickleScript;
 
-        when(socketFactory.createSocket(any(InetAddress.class),
-            anyInt())).thenReturn(socket);
+  @BeforeEach
+  void setUp() throws Exception {
+    final AtomicBoolean connected = new AtomicBoolean(true);
+    final AtomicBoolean closed = new AtomicBoolean(false);
 
-        ScriptEngine engine = new ScriptEngineManager().getEngineByName("python");
-        Compilable compilable = (Compilable) engine;
-        try (InputStream is = PickledGraphiteTest.class.getResource("/upickle.py").openStream()) {
-            unpickleScript = compilable.compile(new InputStreamReader(is, UTF_8));
-        }
-    }
+    when(socket.isConnected()).thenAnswer(invocation -> connected.get());
 
-    @Test
-    void disconnectsFromGraphite() throws Exception {
-        graphite.connect();
-        graphite.close();
+    when(socket.isClosed()).thenAnswer(invocation -> closed.get());
 
-        verify(socket).close();
-    }
+    doAnswer(
+            invocation -> {
+              connected.set(false);
+              closed.set(true);
+              return null;
+            })
+        .when(socket)
+        .close();
 
-    @Test
-    void writesValuesToGraphite() throws Exception {
-        graphite.connect();
-        graphite.send("name", "value", 100);
-        graphite.close();
+    when(socket.getOutputStream()).thenReturn(output);
 
-        assertThat(unpickleOutput())
-            .isEqualTo("name value 100\n");
-    }
+    // Mock behavior of socket.getOutputStream().close() calling socket.close();
+    doAnswer(
+            invocation -> {
+              invocation.callRealMethod();
+              socket.close();
+              return null;
+            })
+        .when(output)
+        .close();
 
-    @Test
-    void writesFullBatch() throws Exception {
-        graphite.connect();
-        graphite.send("name", "value", 100);
-        graphite.send("name", "value2", 100);
-        graphite.close();
+    when(socketFactory.createSocket(any(InetAddress.class), anyInt())).thenReturn(socket);
 
-        assertThat(unpickleOutput())
-            .isEqualTo("name value 100\nname value2 100\n");
+    ScriptEngine engine = new ScriptEngineManager().getEngineByName("python");
+    Compilable compilable = (Compilable) engine;
+    try (InputStream is = PickledGraphiteTest.class.getResource("/upickle.py").openStream()) {
+      unpickleScript = compilable.compile(new InputStreamReader(is, UTF_8));
     }
-
-    @Test
-    void writesPastFullBatch() throws Exception {
-        graphite.connect();
-        graphite.send("name", "value", 100);
-        graphite.send("name", "value2", 100);
-        graphite.send("name", "value3", 100);
-        graphite.close();
-
-        assertThat(unpickleOutput())
-            .isEqualTo("name value 100\nname value2 100\nname value3 100\n");
+  }
+
+  @Test
+  void disconnectsFromGraphite() throws Exception {
+    graphite.connect();
+    graphite.close();
+
+    verify(socket).close();
+  }
+
+  @Test
+  void writesValuesToGraphite() throws Exception {
+    graphite.connect();
+    graphite.send("name", "value", 100);
+    graphite.close();
+
+    assertThat(unpickleOutput()).isEqualTo("name value 100\n");
+  }
+
+  @Test
+  void writesFullBatch() throws Exception {
+    graphite.connect();
+    graphite.send("name", "value", 100);
+    graphite.send("name", "value2", 100);
+    graphite.close();
+
+    assertThat(unpickleOutput()).isEqualTo("name value 100\nname value2 100\n");
+  }
+
+  @Test
+  void writesPastFullBatch() throws Exception {
+    graphite.connect();
+    graphite.send("name", "value", 100);
+    graphite.send("name", "value2", 100);
+    graphite.send("name", "value3", 100);
+    graphite.close();
+
+    assertThat(unpickleOutput()).isEqualTo("name value 100\nname value2 100\nname value3 100\n");
+  }
+
+  @Test
+  void sanitizesNames() throws Exception {
+    graphite.connect();
+    graphite.send("name woo", "value", 100);
+    graphite.close();
+
+    assertThat(unpickleOutput()).isEqualTo("name-woo value 100\n");
+  }
+
+  @Test
+  void sanitizesValues() throws Exception {
+    graphite.connect();
+    graphite.send("name", "value woo", 100);
+    graphite.close();
+
+    assertThat(unpickleOutput()).isEqualTo("name value-woo 100\n");
+  }
+
+  @Test
+  void doesNotAllowDoubleConnections() throws Exception {
+    graphite.connect();
+    try {
+      graphite.connect();
+      failBecauseExceptionWasNotThrown(IllegalStateException.class);
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).isEqualTo("Already connected");
     }
-
-    @Test
-    void sanitizesNames() throws Exception {
-        graphite.connect();
-        graphite.send("name woo", "value", 100);
-        graphite.close();
-
-        assertThat(unpickleOutput())
-            .isEqualTo("name-woo value 100\n");
+  }
+
+  private String unpickleOutput() throws Exception {
+    StringBuilder results = new StringBuilder();
+
+    // the charset is important. if the GraphitePickleReporter and this test
+    // don't agree, the header is not always correctly unpacked.
+    String payload = output.toString("UTF-8");
+
+    PyList result = new PyList();
+    int nextIndex = 0;
+    while (nextIndex < payload.length()) {
+      Bindings bindings = new SimpleBindings();
+      bindings.put("payload", payload.substring(nextIndex));
+      unpickleScript.eval(bindings);
+      result.addAll(result.size(), (PyList) bindings.get("metrics"));
+      nextIndex += ((BigInteger) bindings.get("batchLength")).intValue();
     }
 
-    @Test
-    void sanitizesValues() throws Exception {
-        graphite.connect();
-        graphite.send("name", "value woo", 100);
-        graphite.close();
+    for (Object aResult : result) {
+      PyTuple datapoint = (PyTuple) aResult;
+      String name = datapoint.get(0).toString();
+      PyTuple valueTuple = (PyTuple) datapoint.get(1);
+      Object timestamp = valueTuple.get(0);
+      Object value = valueTuple.get(1);
 
-        assertThat(unpickleOutput())
-            .isEqualTo("name value-woo 100\n");
+      results.append(name).append(" ").append(value).append(" ").append(timestamp).append("\n");
     }
 
-    @Test
-    void doesNotAllowDoubleConnections() throws Exception {
-        graphite.connect();
-        try {
-            graphite.connect();
-            failBecauseExceptionWasNotThrown(IllegalStateException.class);
-        } catch (IllegalStateException e) {
-            assertThat(e.getMessage())
-                .isEqualTo("Already connected");
-        }
-    }
-
-    private String unpickleOutput() throws Exception {
-        StringBuilder results = new StringBuilder();
-
-        // the charset is important. if the GraphitePickleReporter and this test
-        // don't agree, the header is not always correctly unpacked.
-        String payload = output.toString("UTF-8");
-
-        PyList result = new PyList();
-        int nextIndex = 0;
-        while (nextIndex < payload.length()) {
-            Bindings bindings = new SimpleBindings();
-            bindings.put("payload", payload.substring(nextIndex));
-            unpickleScript.eval(bindings);
-            result.addAll(result.size(), (PyList) bindings.get("metrics"));
-            nextIndex += ((BigInteger) bindings.get("batchLength")).intValue();
-        }
-
-        for (Object aResult : result) {
-            PyTuple datapoint = (PyTuple) aResult;
-            String name = datapoint.get(0).toString();
-            PyTuple valueTuple = (PyTuple) datapoint.get(1);
-            Object timestamp = valueTuple.get(0);
-            Object value = valueTuple.get(1);
-
-            results.append(name).append(" ").append(value).append(" ").append(timestamp).append("\n");
-        }
-
-        return results.toString();
-    }
+    return results.toString();
+  }
 }
--- a/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/AsyncHealthCheckDecorator.java
+++ b/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/AsyncHealthCheckDecorator.java
@@ -1,81 +1,84 @@
 package io.dropwizard.metrics5.health;
 
-import io.dropwizard.metrics5.health.annotation.Async;
-import io.dropwizard.metrics5.Clock;
-
+import static com.google.common.base.Preconditions.checkArgument;
 
+import io.dropwizard.metrics5.Clock;
+import io.dropwizard.metrics5.health.annotation.Async;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 
-/**
- * A health check decorator to manage asynchronous executions.
- */
+/** A health check decorator to manage asynchronous executions. */
 public class AsyncHealthCheckDecorator implements HealthCheck, Runnable {
-    private static final String NO_RESULT_YET_MESSAGE = "Waiting for first asynchronous check result.";
-    private final HealthCheck healthCheck;
-    private final ScheduledFuture<?> future;
-    private final long healthyTtl;
-    private final Clock clock;
-    private volatile Result result;
-
-    AsyncHealthCheckDecorator(HealthCheck healthCheck, ScheduledExecutorService executorService, Clock clock) {
-        check(healthCheck != null, "healthCheck cannot be null");
-        check(executorService != null, "executorService cannot be null");
-        Async async = healthCheck.getClass().getAnnotation(Async.class);
-        check(async != null, "healthCheck must contain Async annotation");
-        check(async.period() > 0, "period cannot be less than or equal to zero");
-        check(async.initialDelay() >= 0, "initialDelay cannot be less than zero");
-
+  private static final String NO_RESULT_YET_MESSAGE =
+      "Waiting for first asynchronous check result.";
+  private final HealthCheck healthCheck;
+  private final ScheduledFuture<?> future;
+  private final long healthyTtl;
+  private final Clock clock;
+  private volatile Result result;
 
-        this.clock = clock;
-        this.healthCheck = healthCheck;
-        this.healthyTtl = async.unit().toMillis(async.healthyTtl() <= 0 ? 2 * async.period() : async.healthyTtl());
-        result = Async.InitialState.HEALTHY.equals(async.initialState()) ? Result.healthy(NO_RESULT_YET_MESSAGE) :
-                Result.unhealthy(NO_RESULT_YET_MESSAGE);
-        if (Async.ScheduleType.FIXED_RATE.equals(async.scheduleType())) {
-            future = executorService.scheduleAtFixedRate(this, async.initialDelay(), async.period(), async.unit());
-        } else {
-            future = executorService.scheduleWithFixedDelay(this, async.initialDelay(), async.period(), async.unit());
-        }
+  AsyncHealthCheckDecorator(
+      HealthCheck healthCheck, ScheduledExecutorService executorService, Clock clock) {
+    check(healthCheck != null, "healthCheck cannot be null");
+    check(executorService != null, "executorService cannot be null");
+    Async async = healthCheck.getClass().getAnnotation(Async.class);
+    check(async != null, "healthCheck must contain Async annotation");
+    check(async.period() > 0, "period cannot be less than or equal to zero");
+    check(async.initialDelay() >= 0, "initialDelay cannot be less than zero");
 
+    this.clock = clock;
+    this.healthCheck = healthCheck;
+    this.healthyTtl =
+        async.unit().toMillis(async.healthyTtl() <= 0 ? 2 * async.period() : async.healthyTtl());
+    result =
+        Async.InitialState.HEALTHY == async.initialState()
+            ? Result.healthy(NO_RESULT_YET_MESSAGE)
+            : Result.unhealthy(NO_RESULT_YET_MESSAGE);
+    if (Async.ScheduleType.FIXED_RATE == async.scheduleType()) {
+      future =
+          executorService.scheduleAtFixedRate(
+              this, async.initialDelay(), async.period(), async.unit());
+    } else {
+      future =
+          executorService.scheduleWithFixedDelay(
+              this, async.initialDelay(), async.period(), async.unit());
     }
+  }
 
-    AsyncHealthCheckDecorator(HealthCheck healthCheck, ScheduledExecutorService executorService) {
-        this(healthCheck, executorService, Clock.defaultClock());
-    }
-
-    @Override
-    public void run() {
-        result = healthCheck.execute();
-    }
+  AsyncHealthCheckDecorator(HealthCheck healthCheck, ScheduledExecutorService executorService) {
+    this(healthCheck, executorService, Clock.defaultClock());
+  }
 
-    @Override
-    public Result check() throws Exception {
-        long expiration = clock.getTime() - result.getTime() - healthyTtl;
-        if (expiration > 0) {
-            return Result.builder()
-                    .unhealthy()
-                    .usingClock(clock)
-                    .withMessage("Result was %s but it expired %d milliseconds ago",
-                            result.isHealthy() ? "healthy" : "unhealthy",
-                            expiration)
-                    .build();
-        }
+  @Override
+  public void run() {
+    result = healthCheck.execute();
+  }
 
-        return result;
+  @Override
+  public Result check() throws Exception {
+    long expiration = clock.getTime() - result.getTime() - healthyTtl;
+    if (expiration > 0) {
+      return Result.builder()
+          .unhealthy()
+          .usingClock(clock)
+          .withMessage(
+              "Result was %s but it expired %d milliseconds ago",
+              result.isHealthy() ? "healthy" : "unhealthy", expiration)
+          .build();
     }
 
-    boolean tearDown() {
-        return future.cancel(true);
-    }
+    return result;
+  }
 
-    public HealthCheck getHealthCheck() {
-        return healthCheck;
-    }
+  boolean tearDown() {
+    return future.cancel(true);
+  }
 
-    private static void check(boolean expression, String message) {
-        if (!expression) {
-            throw new IllegalArgumentException(message);
-        }
-    }
+  public HealthCheck getHealthCheck() {
+    return healthCheck;
+  }
+
+  private static void check(boolean expression, String message) {
+    checkArgument(expression, message);
+  }
 }
--- a/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheck.java
+++ b/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheck.java
@@ -1,384 +1,386 @@
 package io.dropwizard.metrics5.health;
 
-import io.dropwizard.metrics5.Clock;
+import static java.util.Collections.unmodifiableMap;
 
+import io.dropwizard.metrics5.Clock;
 import java.time.Instant;
 import java.time.ZoneId;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
-/**
- * A health check for a component of your application.
- */
+/** A health check for a component of your application. */
 public interface HealthCheck {
+  /**
+   * The result of a {@link HealthCheck} being run. It can be healthy (with an optional message and
+   * optional details) or unhealthy (with either an error message or a thrown exception and optional
+   * details).
+   */
+  class Result {
+    private static final DateTimeFormatter DATE_FORMAT_PATTERN =
+        DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
+    private static final int PRIME = 31;
+
     /**
-     * The result of a {@link HealthCheck} being run. It can be healthy (with an optional message and optional details)
-     * or unhealthy (with either an error message or a thrown exception and optional details).
+     * Returns a healthy {@link Result} with no additional message.
+     *
+     * @return a healthy {@link Result} with no additional message
      */
-    class Result {
-        private static final DateTimeFormatter DATE_FORMAT_PATTERN =
-                DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
-        private static final int PRIME = 31;
-
-        /**
-         * Returns a healthy {@link Result} with no additional message.
-         *
-         * @return a healthy {@link Result} with no additional message
-         */
-        public static Result healthy() {
-            return new Result(true, null, null);
-        }
-
-        /**
-         * Returns a healthy {@link Result} with an additional message.
-         *
-         * @param message an informative message
-         * @return a healthy {@link Result} with an additional message
-         */
-        public static Result healthy(String message) {
-            return new Result(true, message, null);
-        }
+    public static Result healthy() {
+      return new Result(true, null, null);
+    }
 
-        /**
-         * Returns a healthy {@link Result} with a formatted message.
-         * <p>
-         * Message formatting follows the same rules as {@link String#format(String, Object...)}.
-         *
-         * @param message a message format
-         * @param args    the arguments apply to the message format
-         * @return a healthy {@link Result} with an additional message
-         * @see String#format(String, Object...)
-         */
-        public static Result healthy(String message, Object... args) {
-            return healthy(String.format(message, args));
-        }
+    /**
+     * Returns a healthy {@link Result} with an additional message.
+     *
+     * @param message an informative message
+     * @return a healthy {@link Result} with an additional message
+     */
+    public static Result healthy(String message) {
+      return new Result(true, message, null);
+    }
 
-        /**
-         * Returns an unhealthy {@link Result} with the given message.
-         *
-         * @param message an informative message describing how the health check failed
-         * @return an unhealthy {@link Result} with the given message
-         */
-        public static Result unhealthy(String message) {
-            return new Result(false, message, null);
-        }
+    /**
+     * Returns a healthy {@link Result} with a formatted message.
+     *
+     * <p>Message formatting follows the same rules as {@link String#format(String, Object...)}.
+     *
+     * @param message a message format
+     * @param args the arguments apply to the message format
+     * @return a healthy {@link Result} with an additional message
+     * @see String#format(String, Object...)
+     */
+    public static Result healthy(String message, Object... args) {
+      return healthy(String.format(message, args));
+    }
 
-        /**
-         * Returns an unhealthy {@link Result} with a formatted message.
-         * <p>
-         * Message formatting follows the same rules as {@link String#format(String, Object...)}.
-         *
-         * @param message a message format
-         * @param args    the arguments apply to the message format
-         * @return an unhealthy {@link Result} with an additional message
-         * @see String#format(String, Object...)
-         */
-        public static Result unhealthy(String message, Object... args) {
-            return unhealthy(String.format(message, args));
-        }
+    /**
+     * Returns an unhealthy {@link Result} with the given message.
+     *
+     * @param message an informative message describing how the health check failed
+     * @return an unhealthy {@link Result} with the given message
+     */
+    public static Result unhealthy(String message) {
+      return new Result(false, message, null);
+    }
 
-        /**
-         * Returns an unhealthy {@link Result} with the given error.
-         *
-         * @param error an exception thrown during the health check
-         * @return an unhealthy {@link Result} with the given {@code error}
-         */
-        public static Result unhealthy(Throwable error) {
-            return new Result(false, error.getMessage(), error);
-        }
+    /**
+     * Returns an unhealthy {@link Result} with a formatted message.
+     *
+     * <p>Message formatting follows the same rules as {@link String#format(String, Object...)}.
+     *
+     * @param message a message format
+     * @param args the arguments apply to the message format
+     * @return an unhealthy {@link Result} with an additional message
+     * @see String#format(String, Object...)
+     */
+    public static Result unhealthy(String message, Object... args) {
+      return unhealthy(String.format(message, args));
+    }
 
+    /**
+     * Returns an unhealthy {@link Result} with the given error.
+     *
+     * @param error an exception thrown during the health check
+     * @return an unhealthy {@link Result} with the given {@code error}
+     */
+    public static Result unhealthy(Throwable error) {
+      return new Result(false, error.getMessage(), error);
+    }
 
-        /**
-         * Returns a new {@link ResultBuilder}
-         *
-         * @return the {@link ResultBuilder}
-         */
-        public static ResultBuilder builder() {
-            return new ResultBuilder();
-        }
+    /**
+     * Returns a new {@link ResultBuilder}
+     *
+     * @return the {@link ResultBuilder}
+     */
+    public static ResultBuilder builder() {
+      return new ResultBuilder();
+    }
 
-        private final boolean healthy;
-        private final String message;
-        private final Throwable error;
-        private final Map<String, Object> details;
-        private final long time;
+    private final boolean healthy;
+    private final String message;
+    private final Throwable error;
+    private final Map<String, Object> details;
+    private final long time;
 
-        private long duration; // Calculated field
+    private long duration; // Calculated field
 
-        private Result(boolean isHealthy, String message, Throwable error) {
-            this(isHealthy, message, error, null, Clock.defaultClock());
-        }
+    private Result(boolean isHealthy, String message, Throwable error) {
+      this(isHealthy, message, error, null, Clock.defaultClock());
+    }
 
-        private Result(ResultBuilder builder) {
-            this(builder.healthy, builder.message, builder.error, builder.details, builder.clock);
-        }
+    private Result(ResultBuilder builder) {
+      this(builder.healthy, builder.message, builder.error, builder.details, builder.clock);
+    }
 
-        private Result(boolean isHealthy, String message, Throwable error, Map<String, Object> details, Clock clock) {
-            this.healthy = isHealthy;
-            this.message = message;
-            this.error = error;
-            this.details = details == null ? null : Collections.unmodifiableMap(details);
-            this.time = clock.getTime();
-        }
+    private Result(
+        boolean isHealthy,
+        String message,
+        Throwable error,
+        Map<String, Object> details,
+        Clock clock) {
+      this.healthy = isHealthy;
+      this.message = message;
+      this.error = error;
+      this.details = details == null ? null : unmodifiableMap(details);
+      this.time = clock.getTime();
+    }
 
-        /**
-         * Returns {@code true} if the result indicates the component is healthy; {@code false}
-         * otherwise.
-         *
-         * @return {@code true} if the result indicates the component is healthy
-         */
-        public boolean isHealthy() {
-            return healthy;
-        }
+    /**
+     * Returns {@code true} if the result indicates the component is healthy; {@code false}
+     * otherwise.
+     *
+     * @return {@code true} if the result indicates the component is healthy
+     */
+    public boolean isHealthy() {
+      return healthy;
+    }
 
-        /**
-         * Returns any additional message for the result, or {@code null} if the result has no
-         * message.
-         *
-         * @return any additional message for the result, or {@code null}
-         */
-        public String getMessage() {
-            return message;
-        }
+    /**
+     * Returns any additional message for the result, or {@code null} if the result has no message.
+     *
+     * @return any additional message for the result, or {@code null}
+     */
+    public String getMessage() {
+      return message;
+    }
 
-        /**
-         * Returns any exception for the result, or {@code null} if the result has no exception.
-         *
-         * @return any exception for the result, or {@code null}
-         */
-        public Throwable getError() {
-            return error;
-        }
+    /**
+     * Returns any exception for the result, or {@code null} if the result has no exception.
+     *
+     * @return any exception for the result, or {@code null}
+     */
+    public Throwable getError() {
+      return error;
+    }
 
-        /**
-         * Returns the timestamp when the result was created as a formatted String.
-         *
-         * @return a formatted timestamp
-         */
-        public String getTimestamp() {
-            Instant currentInstant = Instant.ofEpochMilli(time);
-            ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(currentInstant, ZoneId.systemDefault());
-            return DATE_FORMAT_PATTERN.format(zonedDateTime);
-        }
+    /**
+     * Returns the timestamp when the result was created as a formatted String.
+     *
+     * @return a formatted timestamp
+     */
+    public String getTimestamp() {
+      Instant currentInstant = Instant.ofEpochMilli(time);
+      ZonedDateTime zonedDateTime = currentInstant.atZone(ZoneId.systemDefault());
+      return DATE_FORMAT_PATTERN.format(zonedDateTime);
+    }
 
-        /**
-         * Returns the time when the result was created, in milliseconds since Epoch
-         *
-         * @return the time when the result was created
-         */
-        public long getTime() {
-            return time;
-        }
+    /**
+     * Returns the time when the result was created, in milliseconds since Epoch
+     *
+     * @return the time when the result was created
+     */
+    public long getTime() {
+      return time;
+    }
 
-        /**
-         * Returns the duration in milliseconds that the healthcheck took to run
-         *
-         * @return the duration
-         */
-        public long getDuration() {
-            return duration;
-        }
+    /**
+     * Returns the duration in milliseconds that the healthcheck took to run
+     *
+     * @return the duration
+     */
+    public long getDuration() {
+      return duration;
+    }
 
-        /**
-         * Sets the duration in milliseconds. This will indicate the time it took to run the individual healthcheck
-         *
-         * @param duration The duration in milliseconds
-         */
-        public void setDuration(long duration) {
-            this.duration = duration;
-        }
+    /**
+     * Sets the duration in milliseconds. This will indicate the time it took to run the individual
+     * healthcheck
+     *
+     * @param duration The duration in milliseconds
+     */
+    public void setDuration(long duration) {
+      this.duration = duration;
+    }
 
-        public Map<String, Object> getDetails() {
-            return details;
-        }
+    public Map<String, Object> getDetails() {
+      return details;
+    }
 
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-            final Result result = (Result) o;
-            return healthy == result.healthy &&
-                    !(error != null ? !error.equals(result.error) : result.error != null) &&
-                    !(message != null ? !message.equals(result.message) : result.message != null) &&
-                    time == result.time;
-        }
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+      final Result result = (Result) o;
+      return healthy == result.healthy
+          && !(error != null ? !error.equals(result.error) : result.error != null)
+          && !(message != null ? !message.equals(result.message) : result.message != null)
+          && time == result.time;
+    }
 
-        @Override
-        public int hashCode() {
-            int result = healthy ? 1 : 0;
-            result = PRIME * result + (message != null ? message.hashCode() : 0);
-            result = PRIME * result + (error != null ? error.hashCode() : 0);
-            result = PRIME * result + (Long.hashCode(time));
-            return result;
-        }
+    @Override
+    public int hashCode() {
+      int result = healthy ? 1 : 0;
+      result = PRIME * result + (message != null ? message.hashCode() : 0);
+      result = PRIME * result + (error != null ? error.hashCode() : 0);
+      return PRIME * result + (Long.hashCode(time));
+    }
 
-        @Override
-        public String toString() {
-            final StringBuilder builder = new StringBuilder("Result{isHealthy=");
-            builder.append(healthy);
-            if (message != null) {
-                builder.append(", message=").append(message);
-            }
-            if (error != null) {
-                builder.append(", error=").append(error);
-            }
-            builder.append(", duration=").append(duration);
-            builder.append(", timestamp=").append(getTimestamp());
-            if (details != null) {
-                for (Map.Entry<String, Object> e : details.entrySet()) {
-                    builder.append(", ");
-                    builder.append(e.getKey())
-                            .append("=")
-                            .append(String.valueOf(e.getValue()));
-                }
-            }
-            builder.append('}');
-            return builder.toString();
+    @Override
+    public String toString() {
+      final StringBuilder builder = new StringBuilder("Result{isHealthy=");
+      builder.append(healthy);
+      if (message != null) {
+        builder.append(", message=").append(message);
+      }
+      if (error != null) {
+        builder.append(", error=").append(error);
+      }
+      builder.append(", duration=").append(duration);
+      builder.append(", timestamp=").append(getTimestamp());
+      if (details != null) {
+        for (Map.Entry<String, Object> e : details.entrySet()) {
+          builder.append(", ");
+          builder.append(e.getKey()).append("=").append(e.getValue());
         }
+      }
+      builder.append('}');
+      return builder.toString();
+    }
+  }
+
+  /**
+   * This a convenient builder for an {@link HealthCheck.Result}. It can be health (with optional
+   * message and detail) or unhealthy (with optional message, error and detail)
+   */
+  class ResultBuilder {
+    private boolean healthy;
+    private String message;
+    private Throwable error;
+    private Map<String, Object> details;
+    private Clock clock;
+
+    protected ResultBuilder() {
+      this.healthy = true;
+      this.details = new LinkedHashMap<>();
+      this.clock = Clock.defaultClock();
     }
 
     /**
-     * This a convenient builder for an {@link HealthCheck.Result}. It can be health (with optional message and detail)
-     * or unhealthy (with optional message, error and detail)
+     * Configure an healthy result
+     *
+     * @return this builder with healthy status
      */
-    class ResultBuilder {
-        private boolean healthy;
-        private String message;
-        private Throwable error;
-        private Map<String, Object> details;
-        private Clock clock;
-
-        protected ResultBuilder() {
-            this.healthy = true;
-            this.details = new LinkedHashMap<>();
-            this.clock = Clock.defaultClock();
-        }
-
-        /**
-         * Configure an healthy result
-         *
-         * @return this builder with healthy status
-         */
-        public ResultBuilder healthy() {
-            this.healthy = true;
-            return this;
-        }
-
-        /**
-         * Configure an unhealthy result
-         *
-         * @return this builder with unhealthy status
-         */
-        public ResultBuilder unhealthy() {
-            this.healthy = false;
-            return this;
-        }
-
-        /**
-         * Configure an unhealthy result with an {@code error}
-         *
-         * @param error the error
-         * @return this builder with the given error
-         */
-        public ResultBuilder unhealthy(Throwable error) {
-            this.error = error;
-            return this.unhealthy().withMessage(error.getMessage());
-        }
-
-        /**
-         * Set an optional message
-         *
-         * @param message an informative message
-         * @return this builder with the given {@code message}
-         */
-        public ResultBuilder withMessage(String message) {
-            this.message = message;
-            return this;
-        }
+    public ResultBuilder healthy() {
+      this.healthy = true;
+      return this;
+    }
 
-        /**
-         * Set an optional formatted message
-         * <p>
-         * Message formatting follows the same rules as {@link String#format(String, Object...)}.
-         *
-         * @param message a message format
-         * @param args    the arguments apply to the message format
-         * @return this builder with the given formatted {@code message}
-         * @see String#format(String, Object...)
-         */
-        public ResultBuilder withMessage(String message, Object... args) {
-            return withMessage(String.format(message, args));
-        }
+    /**
+     * Configure an unhealthy result
+     *
+     * @return this builder with unhealthy status
+     */
+    public ResultBuilder unhealthy() {
+      this.healthy = false;
+      return this;
+    }
 
-        /**
-         * Add an optional detail
-         *
-         * @param key  a key for this detail
-         * @param data an object representing the detail data
-         * @return this builder with the given detail added
-         */
-        public ResultBuilder withDetail(String key, Object data) {
-            if (this.details == null) {
-                this.details = new LinkedHashMap<>();
-            }
-            this.details.put(key, data);
-            return this;
-        }
+    /**
+     * Configure an unhealthy result with an {@code error}
+     *
+     * @param error the error
+     * @return this builder with the given error
+     */
+    public ResultBuilder unhealthy(Throwable error) {
+      this.error = error;
+      return this.unhealthy().withMessage(error.getMessage());
+    }
 
-        /**
-         * Configure this {@link ResultBuilder} to use the given {@code clock} instead of the default clock.
-         * If not specified, the default clock is {@link Clock#defaultClock()}.
-         *
-         * @param clock the {@link Clock} to use when generating the health check timestamp (useful for unit testing)
-         * @return this builder configured to use the given {@code clock}
-         */
-        public ResultBuilder usingClock(Clock clock) {
-            this.clock = clock;
-            return this;
-        }
+    /**
+     * Set an optional message
+     *
+     * @param message an informative message
+     * @return this builder with the given {@code message}
+     */
+    public ResultBuilder withMessage(String message) {
+      this.message = message;
+      return this;
+    }
 
-        public Result build() {
-            return new Result(this);
-        }
+    /**
+     * Set an optional formatted message
+     *
+     * <p>Message formatting follows the same rules as {@link String#format(String, Object...)}.
+     *
+     * @param message a message format
+     * @param args the arguments apply to the message format
+     * @return this builder with the given formatted {@code message}
+     * @see String#format(String, Object...)
+     */
+    public ResultBuilder withMessage(String message, Object... args) {
+      return withMessage(String.format(message, args));
     }
 
     /**
-     * Perform a check of the application component.
+     * Add an optional detail
      *
-     * @return if the component is healthy, a healthy {@link Result}; otherwise, an unhealthy {@link
-     * Result} with a descriptive error message or exception
-     * @throws Exception if there is an unhandled error during the health check; this will result in
-     *                   a failed health check
+     * @param key a key for this detail
+     * @param data an object representing the detail data
+     * @return this builder with the given detail added
      */
-    Result check() throws Exception;
+    public ResultBuilder withDetail(String key, Object data) {
+      if (this.details == null) {
+        this.details = new LinkedHashMap<>();
+      }
+      this.details.put(key, data);
+      return this;
+    }
 
     /**
-     * Executes the health check, catching and handling any exceptions raised by {@link #check()}.
+     * Configure this {@link ResultBuilder} to use the given {@code clock} instead of the default
+     * clock. If not specified, the default clock is {@link Clock#defaultClock()}.
      *
-     * @return if the component is healthy, a healthy {@link Result}; otherwise, an unhealthy {@link
-     * Result} with a descriptive error message or exception
+     * @param clock the {@link Clock} to use when generating the health check timestamp (useful for
+     *     unit testing)
+     * @return this builder configured to use the given {@code clock}
      */
-    default Result execute() {
-        long start = clock().getTick();
-        Result result;
-        try {
-            result = check();
-        } catch (Exception e) {
-            result = Result.unhealthy(e);
-        }
-        result.setDuration(TimeUnit.MILLISECONDS.convert(clock().getTick() - start, TimeUnit.NANOSECONDS));
-        return result;
+    public ResultBuilder usingClock(Clock clock) {
+      this.clock = clock;
+      return this;
     }
 
-    default Clock clock() {
-        return Clock.defaultClock();
+    public Result build() {
+      return new Result(this);
+    }
+  }
+
+  /**
+   * Perform a check of the application component.
+   *
+   * @return if the component is healthy, a healthy {@link Result}; otherwise, an unhealthy {@link
+   *     Result} with a descriptive error message or exception
+   * @throws Exception if there is an unhandled error during the health check; this will result in a
+   *     failed health check
+   */
+  Result check() throws Exception;
+
+  /**
+   * Executes the health check, catching and handling any exceptions raised by {@link #check()}.
+   *
+   * @return if the component is healthy, a healthy {@link Result}; otherwise, an unhealthy {@link
+   *     Result} with a descriptive error message or exception
+   */
+  default Result execute() {
+    long start = clock().getTick();
+    Result result;
+    try {
+      result = check();
+    } catch (Exception e) {
+      result = Result.unhealthy(e);
     }
+    result.setDuration(
+        TimeUnit.MILLISECONDS.convert(clock().getTick() - start, TimeUnit.NANOSECONDS));
+    return result;
+  }
+
+  default Clock clock() {
+    return Clock.defaultClock();
+  }
 }
--- a/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckFilter.java
+++ b/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckFilter.java
@@ -1,21 +1,17 @@
 package io.dropwizard.metrics5.health;
 
-/**
- * A filter used to determine whether or not a health check should be reported.
- */
+/** A filter used to determine whether or not a health check should be reported. */
 @FunctionalInterface
 public interface HealthCheckFilter {
-    /**
-     * Matches all health checks, regardless of type or name.
-     */
-    HealthCheckFilter ALL = (name, healthCheck) -> true;
+  /** Matches all health checks, regardless of type or name. */
+  HealthCheckFilter ALL = (name, healthCheck) -> true;
 
-    /**
-     * Returns {@code true} if the health check matches the filter; {@code false} otherwise.
-     *
-     * @param name        the health check's name
-     * @param healthCheck the health check
-     * @return {@code true} if the health check matches the filter
-     */
-    boolean matches(String name, HealthCheck healthCheck);
+  /**
+   * Returns {@code true} if the health check matches the filter; {@code false} otherwise.
+   *
+   * @param name the health check's name
+   * @param healthCheck the health check
+   * @return {@code true} if the health check matches the filter
+   */
+  boolean matches(String name, HealthCheck healthCheck);
 }
--- a/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistry.java
+++ b/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistry.java
@@ -1,10 +1,11 @@
 package io.dropwizard.metrics5.health;
 
-import io.dropwizard.metrics5.health.annotation.Async;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import static com.google.common.base.Preconditions.checkArgument;
+import static io.dropwizard.metrics5.health.HealthCheck.Result;
+import static java.util.Collections.unmodifiableSortedMap;
+import static java.util.Collections.unmodifiableSortedSet;
 
-import java.util.Collections;
+import io.dropwizard.metrics5.health.annotation.Async;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -23,266 +24,260 @@ import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import static io.dropwizard.metrics5.health.HealthCheck.Result;
-
-/**
- * A registry for health checks.
- */
+/** A registry for health checks. */
 public class HealthCheckRegistry {
-    private static final Logger LOGGER = LoggerFactory.getLogger(HealthCheckRegistry.class);
-    private static final int ASYNC_EXECUTOR_POOL_SIZE = 2;
+  private static final Logger LOG = LoggerFactory.getLogger(HealthCheckRegistry.class);
+  private static final int ASYNC_EXECUTOR_POOL_SIZE = 2;
 
-    private final ConcurrentMap<String, HealthCheck> healthChecks;
-    private final List<HealthCheckRegistryListener> listeners;
-    private final ScheduledExecutorService asyncExecutorService;
-    private final Object lock = new Object();
+  private final ConcurrentMap<String, HealthCheck> healthChecks;
+  private final List<HealthCheckRegistryListener> listeners;
+  private final ScheduledExecutorService asyncExecutorService;
+  private final Object lock = new Object();
 
-    /**
-     * Creates a new {@link HealthCheckRegistry}.
-     */
-    public HealthCheckRegistry() {
-        this(ASYNC_EXECUTOR_POOL_SIZE);
-    }
+  /** Creates a new {@link HealthCheckRegistry}. */
+  public HealthCheckRegistry() {
+    this(ASYNC_EXECUTOR_POOL_SIZE);
+  }
 
-    /**
-     * Creates a new {@link HealthCheckRegistry}.
-     *
-     * @param asyncExecutorPoolSize core pool size for async health check executions
-     */
-    public HealthCheckRegistry(int asyncExecutorPoolSize) {
-        this(createExecutorService(asyncExecutorPoolSize));
-    }
+  /**
+   * Creates a new {@link HealthCheckRegistry}.
+   *
+   * @param asyncExecutorPoolSize core pool size for async health check executions
+   */
+  public HealthCheckRegistry(int asyncExecutorPoolSize) {
+    this(createExecutorService(asyncExecutorPoolSize));
+  }
 
-    /**
-     * Creates a new {@link HealthCheckRegistry}.
-     *
-     * @param asyncExecutorService executor service for async health check executions
-     */
-    public HealthCheckRegistry(ScheduledExecutorService asyncExecutorService) {
-        this.healthChecks = new ConcurrentHashMap<>();
-        this.listeners = new CopyOnWriteArrayList<>();
-        this.asyncExecutorService = asyncExecutorService;
-    }
+  /**
+   * Creates a new {@link HealthCheckRegistry}.
+   *
+   * @param asyncExecutorService executor service for async health check executions
+   */
+  public HealthCheckRegistry(ScheduledExecutorService asyncExecutorService) {
+    this.healthChecks = new ConcurrentHashMap<>();
+    this.listeners = new CopyOnWriteArrayList<>();
+    this.asyncExecutorService = asyncExecutorService;
+  }
 
-    /**
-     * Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check
-     * registration. Listeners will be notified in the order in which they are added. The listener will be notified of all
-     * existing health checks when it first registers.
-     *
-     * @param listener listener to add
-     */
-    public void addListener(HealthCheckRegistryListener listener) {
-        listeners.add(listener);
-        for (Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
-            listener.onHealthCheckAdded(entry.getKey(), entry.getValue());
-        }
+  /**
+   * Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified
+   * on health check registration. Listeners will be notified in the order in which they are added.
+   * The listener will be notified of all existing health checks when it first registers.
+   *
+   * @param listener listener to add
+   */
+  public void addListener(HealthCheckRegistryListener listener) {
+    listeners.add(listener);
+    for (Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
+      listener.onHealthCheckAdded(entry.getKey(), entry.getValue());
     }
+  }
 
-    /**
-     * Removes a {@link HealthCheckRegistryListener} from this registry's collection of listeners.
-     *
-     * @param listener listener to remove
-     */
-    public void removeListener(HealthCheckRegistryListener listener) {
-        listeners.remove(listener);
-    }
+  /**
+   * Removes a {@link HealthCheckRegistryListener} from this registry's collection of listeners.
+   *
+   * @param listener listener to remove
+   */
+  public void removeListener(HealthCheckRegistryListener listener) {
+    listeners.remove(listener);
+  }
 
-    /**
-     * Registers an application {@link HealthCheck}.
-     *
-     * @param name        the name of the health check
-     * @param healthCheck the {@link HealthCheck} instance
-     */
-    public void register(String name, HealthCheck healthCheck) {
-        HealthCheck registered;
-        synchronized (lock) {
-            if (healthChecks.containsKey(name)) {
-                throw new IllegalArgumentException("A health check named " + name + " already exists");
-            }
-            registered = healthCheck;
-            if (healthCheck.getClass().isAnnotationPresent(Async.class)) {
-                registered = new AsyncHealthCheckDecorator(healthCheck, asyncExecutorService);
-            }
-            healthChecks.put(name, registered);
-        }
-        onHealthCheckAdded(name, registered);
+  /**
+   * Registers an application {@link HealthCheck}.
+   *
+   * @param name the name of the health check
+   * @param healthCheck the {@link HealthCheck} instance
+   */
+  public void register(String name, HealthCheck healthCheck) {
+    HealthCheck registered;
+    synchronized (lock) {
+      checkArgument(
+          !healthChecks.containsKey(name), "A health check named %s already exists", name);
+      registered = healthCheck;
+      if (healthCheck.getClass().isAnnotationPresent(Async.class)) {
+        registered = new AsyncHealthCheckDecorator(healthCheck, asyncExecutorService);
+      }
+      healthChecks.put(name, registered);
     }
+    onHealthCheckAdded(name, registered);
+  }
 
-    /**
-     * Unregisters the application {@link HealthCheck} with the given name.
-     *
-     * @param name the name of the {@link HealthCheck} instance
-     */
-    public void unregister(String name) {
-        HealthCheck healthCheck;
-        synchronized (lock) {
-            healthCheck = healthChecks.remove(name);
-            if (healthCheck instanceof AsyncHealthCheckDecorator) {
-                ((AsyncHealthCheckDecorator) healthCheck).tearDown();
-            }
-        }
-        if (healthCheck != null) {
-            onHealthCheckRemoved(name, healthCheck);
-        }
+  /**
+   * Unregisters the application {@link HealthCheck} with the given name.
+   *
+   * @param name the name of the {@link HealthCheck} instance
+   */
+  public void unregister(String name) {
+    HealthCheck healthCheck;
+    synchronized (lock) {
+      healthCheck = healthChecks.remove(name);
+      if (healthCheck instanceof AsyncHealthCheckDecorator) {
+        ((AsyncHealthCheckDecorator) healthCheck).tearDown();
+      }
     }
-
-    /**
-     * Returns a set of the names of all registered health checks.
-     *
-     * @return the names of all registered health checks
-     */
-    public SortedSet<String> getNames() {
-        return Collections.unmodifiableSortedSet(new TreeSet<>(healthChecks.keySet()));
+    if (healthCheck != null) {
+      onHealthCheckRemoved(name, healthCheck);
     }
+  }
 
-    /**
-     * Returns the {@link HealthCheck} instance with a given name
-     *
-     * @param name the name of the {@link HealthCheck} instance
-     */
-    public HealthCheck getHealthCheck(String name) {
-        return healthChecks.get(name);
-    }
+  /**
+   * Returns a set of the names of all registered health checks.
+   *
+   * @return the names of all registered health checks
+   */
+  public SortedSet<String> getNames() {
+    return unmodifiableSortedSet(new TreeSet<>(healthChecks.keySet()));
+  }
 
-    /**
-     * Runs the health check with the given name.
-     *
-     * @param name the health check's name
-     * @return the result of the health check
-     * @throws NoSuchElementException if there is no health check with the given name
-     */
-    public HealthCheck.Result runHealthCheck(String name) throws NoSuchElementException {
-        final HealthCheck healthCheck = healthChecks.get(name);
-        if (healthCheck == null) {
-            throw new NoSuchElementException("No health check named " + name + " exists");
-        }
-        return healthCheck.execute();
-    }
+  /**
+   * Returns the {@link HealthCheck} instance with a given name
+   *
+   * @param name the name of the {@link HealthCheck} instance
+   */
+  public HealthCheck getHealthCheck(String name) {
+    return healthChecks.get(name);
+  }
 
-    /**
-     * Runs the registered health checks and returns a map of the results.
-     *
-     * @return a map of the health check results
-     */
-    public SortedMap<String, HealthCheck.Result> runHealthChecks() {
-        return runHealthChecks(HealthCheckFilter.ALL);
+  /**
+   * Runs the health check with the given name.
+   *
+   * @param name the health check's name
+   * @return the result of the health check
+   * @throws NoSuchElementException if there is no health check with the given name
+   */
+  public HealthCheck.Result runHealthCheck(String name) throws NoSuchElementException {
+    final HealthCheck healthCheck = healthChecks.get(name);
+    if (healthCheck == null) {
+      throw new NoSuchElementException("No health check named " + name + " exists");
     }
+    return healthCheck.execute();
+  }
 
-    /**
-     * Runs the registered health checks matching the filter and returns a map of the results.
-     *
-     * @param filter health check filter
-     * @return a map of the health check results
-     */
-    public SortedMap<String, HealthCheck.Result> runHealthChecks(HealthCheckFilter filter) {
-        final SortedMap<String, HealthCheck.Result> results = new TreeMap<>();
-        for (Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
-            final String name = entry.getKey();
-            final HealthCheck healthCheck = entry.getValue();
-            if (filter.matches(name, healthCheck)) {
-                final Result result = entry.getValue().execute();
-                results.put(entry.getKey(), result);
-            }
-        }
-        return Collections.unmodifiableSortedMap(results);
-    }
+  /**
+   * Runs the registered health checks and returns a map of the results.
+   *
+   * @return a map of the health check results
+   */
+  public SortedMap<String, HealthCheck.Result> runHealthChecks() {
+    return runHealthChecks(HealthCheckFilter.ALL);
+  }
 
-    /**
-     * Runs the registered health checks in parallel and returns a map of the results.
-     *
-     * @param executor object to launch and track health checks progress
-     * @return a map of the health check results
-     */
-    public SortedMap<String, HealthCheck.Result> runHealthChecks(ExecutorService executor) {
-        return runHealthChecks(executor, HealthCheckFilter.ALL);
+  /**
+   * Runs the registered health checks matching the filter and returns a map of the results.
+   *
+   * @param filter health check filter
+   * @return a map of the health check results
+   */
+  public SortedMap<String, HealthCheck.Result> runHealthChecks(HealthCheckFilter filter) {
+    final SortedMap<String, HealthCheck.Result> results = new TreeMap<>();
+    for (Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
+      final String name = entry.getKey();
+      final HealthCheck healthCheck = entry.getValue();
+      if (filter.matches(name, healthCheck)) {
+        final Result result = entry.getValue().execute();
+        results.put(entry.getKey(), result);
+      }
     }
+    return unmodifiableSortedMap(results);
+  }
 
-    /**
-     * Runs the registered health checks matching the filter in parallel and returns a map of the results.
-     *
-     * @param executor object to launch and track health checks progress
-     * @param filter   health check filter
-     * @return a map of the health check results
-     */
-    public SortedMap<String, HealthCheck.Result> runHealthChecks(ExecutorService executor, HealthCheckFilter filter) {
-        final Map<String, Future<HealthCheck.Result>> futures = new HashMap<>();
-        for (final Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
-            final String name = entry.getKey();
-            final HealthCheck healthCheck = entry.getValue();
-            if (filter.matches(name, healthCheck)) {
-                futures.put(name, executor.submit(healthCheck::execute));
-            }
-        }
+  /**
+   * Runs the registered health checks in parallel and returns a map of the results.
+   *
+   * @param executor object to launch and track health checks progress
+   * @return a map of the health check results
+   */
+  public SortedMap<String, HealthCheck.Result> runHealthChecks(ExecutorService executor) {
+    return runHealthChecks(executor, HealthCheckFilter.ALL);
+  }
 
-        final SortedMap<String, HealthCheck.Result> results = new TreeMap<>();
-        for (Map.Entry<String, Future<Result>> entry : futures.entrySet()) {
-            try {
-                results.put(entry.getKey(), entry.getValue().get());
-            } catch (Exception e) {
-                LOGGER.warn("Error executing health check {}", entry.getKey(), e);
-                results.put(entry.getKey(), HealthCheck.Result.unhealthy(e));
-            }
-        }
+  /**
+   * Runs the registered health checks matching the filter in parallel and returns a map of the
+   * results.
+   *
+   * @param executor object to launch and track health checks progress
+   * @param filter health check filter
+   * @return a map of the health check results
+   */
+  public SortedMap<String, HealthCheck.Result> runHealthChecks(
+      ExecutorService executor, HealthCheckFilter filter) {
+    final Map<String, Future<HealthCheck.Result>> futures = new HashMap<>();
+    for (final Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
+      final String name = entry.getKey();
+      final HealthCheck healthCheck = entry.getValue();
+      if (filter.matches(name, healthCheck)) {
+        futures.put(name, executor.submit(healthCheck::execute));
+      }
+    }
 
-        return Collections.unmodifiableSortedMap(results);
+    final SortedMap<String, HealthCheck.Result> results = new TreeMap<>();
+    for (Map.Entry<String, Future<Result>> entry : futures.entrySet()) {
+      try {
+        results.put(entry.getKey(), entry.getValue().get());
+      } catch (Exception e) {
+        LOG.warn("Error executing health check {}", entry.getKey(), e);
+        results.put(entry.getKey(), HealthCheck.Result.unhealthy(e));
+      }
     }
 
+    return unmodifiableSortedMap(results);
+  }
 
-    private void onHealthCheckAdded(String name, HealthCheck healthCheck) {
-        for (HealthCheckRegistryListener listener : listeners) {
-            listener.onHealthCheckAdded(name, healthCheck);
-        }
+  private void onHealthCheckAdded(String name, HealthCheck healthCheck) {
+    for (HealthCheckRegistryListener listener : listeners) {
+      listener.onHealthCheckAdded(name, healthCheck);
     }
+  }
 
-    private void onHealthCheckRemoved(String name, HealthCheck healthCheck) {
-        for (HealthCheckRegistryListener listener : listeners) {
-            listener.onHealthCheckRemoved(name, healthCheck);
-        }
+  private void onHealthCheckRemoved(String name, HealthCheck healthCheck) {
+    for (HealthCheckRegistryListener listener : listeners) {
+      listener.onHealthCheckRemoved(name, healthCheck);
     }
+  }
 
-    /**
-     * Shuts down the scheduled executor for async health checks
-     */
-    public void shutdown() {
-        asyncExecutorService.shutdown(); // Disable new health checks from being submitted
-        try {
-            // Give some time to the current healtch checks to finish gracefully
-            if (!asyncExecutorService.awaitTermination(1, TimeUnit.SECONDS)) {
-                asyncExecutorService.shutdownNow();
-            }
-        } catch (InterruptedException ie) {
-            asyncExecutorService.shutdownNow();
-            Thread.currentThread().interrupt();
-        }
+  /** Shuts down the scheduled executor for async health checks */
+  public void shutdown() {
+    asyncExecutorService.shutdown(); // Disable new health checks from being submitted
+    try {
+      // Give some time to the current healtch checks to finish gracefully
+      if (!asyncExecutorService.awaitTermination(1, TimeUnit.SECONDS)) {
+        asyncExecutorService.shutdownNow();
+      }
+    } catch (InterruptedException ie) {
+      asyncExecutorService.shutdownNow();
+      Thread.currentThread().interrupt();
     }
+  }
 
-    private static ScheduledExecutorService createExecutorService(int corePoolSize) {
-        final ScheduledThreadPoolExecutor asyncExecutorService = new ScheduledThreadPoolExecutor(corePoolSize,
-                new NamedThreadFactory("healthcheck-async-executor-"));
-        asyncExecutorService.setRemoveOnCancelPolicy(true);
-        return asyncExecutorService;
-    }
+  private static ScheduledExecutorService createExecutorService(int corePoolSize) {
+    final ScheduledThreadPoolExecutor asyncExecutorService =
+        new ScheduledThreadPoolExecutor(
+            corePoolSize, new NamedThreadFactory("healthcheck-async-executor-"));
+    asyncExecutorService.setRemoveOnCancelPolicy(true);
+    return asyncExecutorService;
+  }
 
-    private static class NamedThreadFactory implements ThreadFactory {
+  private static class NamedThreadFactory implements ThreadFactory {
 
-        private final ThreadGroup group;
-        private final AtomicInteger threadNumber = new AtomicInteger(1);
-        private final String namePrefix;
+    private final ThreadGroup group;
+    private final AtomicInteger threadNumber = new AtomicInteger(1);
+    private final String namePrefix;
 
-        NamedThreadFactory(String namePrefix) {
-            SecurityManager s = System.getSecurityManager();
-            group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
-            this.namePrefix = namePrefix;
-        }
+    NamedThreadFactory(String namePrefix) {
+      SecurityManager s = System.getSecurityManager();
+      group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();
+      this.namePrefix = namePrefix;
+    }
 
-        @Override
-        public Thread newThread(Runnable r) {
-            Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
-            t.setDaemon(true);
-            if (t.getPriority() != Thread.NORM_PRIORITY)
-                t.setPriority(Thread.NORM_PRIORITY);
-            return t;
-        }
+    @Override
+    public Thread newThread(Runnable r) {
+      Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);
+      t.setDaemon(true);
+      if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY);
+      return t;
     }
+  }
 }
--- a/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistryListener.java
+++ b/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistryListener.java
@@ -2,25 +2,22 @@ package io.dropwizard.metrics5.health;
 
 import java.util.EventListener;
 
-/**
- * A listener contract for {@link HealthCheckRegistry} events.
- */
+/** A listener contract for {@link HealthCheckRegistry} events. */
 public interface HealthCheckRegistryListener extends EventListener {
 
-    /**
-     * Called when a new {@link HealthCheck} is added to the registry.
-     *
-     * @param name        the name of the health check
-     * @param healthCheck the health check
-     */
-    void onHealthCheckAdded(String name, HealthCheck healthCheck);
-
-    /**
-     * Called when a {@link HealthCheck} is removed from the registry.
-     *
-     * @param name        the name of the health check
-     * @param healthCheck the health check
-     */
-    void onHealthCheckRemoved(String name, HealthCheck healthCheck);
+  /**
+   * Called when a new {@link HealthCheck} is added to the registry.
+   *
+   * @param name the name of the health check
+   * @param healthCheck the health check
+   */
+  void onHealthCheckAdded(String name, HealthCheck healthCheck);
 
+  /**
+   * Called when a {@link HealthCheck} is removed from the registry.
+   *
+   * @param name the name of the health check
+   * @param healthCheck the health check
+   */
+  void onHealthCheckRemoved(String name, HealthCheck healthCheck);
 }
--- a/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/SharedHealthCheckRegistries.java
+++ b/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/SharedHealthCheckRegistries.java
@@ -5,102 +5,103 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicReference;
 
-/**
- * A map of shared, named health registries.
- */
+/** A map of shared, named health registries. */
 public class SharedHealthCheckRegistries {
-    private static final ConcurrentMap<String, HealthCheckRegistry> REGISTRIES =
-            new ConcurrentHashMap<>();
+  private static final ConcurrentMap<String, HealthCheckRegistry> REGISTRIES =
+      new ConcurrentHashMap<>();
 
-    private static AtomicReference<String> defaultRegistryName = new AtomicReference<>();
+  private static AtomicReference<String> defaultRegistryName = new AtomicReference<>();
 
-    /* Visible for testing */
-    static void setDefaultRegistryName(AtomicReference<String> defaultRegistryName) {
-        SharedHealthCheckRegistries.defaultRegistryName = defaultRegistryName;
-    }
+  /* Visible for testing */
+  static void setDefaultRegistryName(AtomicReference<String> defaultRegistryName) {
+    SharedHealthCheckRegistries.defaultRegistryName = defaultRegistryName;
+  }
 
-    private SharedHealthCheckRegistries() { /* singleton */ }
+  private SharedHealthCheckRegistries() {
+    /* singleton */
+  }
 
-    public static void clear() {
-        REGISTRIES.clear();
-    }
+  public static void clear() {
+    REGISTRIES.clear();
+  }
 
-    public static Set<String> names() {
-        return REGISTRIES.keySet();
-    }
+  public static Set<String> names() {
+    return REGISTRIES.keySet();
+  }
 
-    public static void remove(String key) {
-        REGISTRIES.remove(key);
-    }
+  public static void remove(String key) {
+    REGISTRIES.remove(key);
+  }
 
-    public static HealthCheckRegistry add(String name, HealthCheckRegistry registry) {
-        return REGISTRIES.putIfAbsent(name, registry);
-    }
+  public static HealthCheckRegistry add(String name, HealthCheckRegistry registry) {
+    return REGISTRIES.putIfAbsent(name, registry);
+  }
 
-    public static HealthCheckRegistry getOrCreate(String name) {
-        final HealthCheckRegistry existing = REGISTRIES.get(name);
-        if (existing == null) {
-            final HealthCheckRegistry created = new HealthCheckRegistry();
-            final HealthCheckRegistry raced = add(name, created);
-            if (raced == null) {
-                return created;
-            }
-            return raced;
-        }
-        return existing;
+  public static HealthCheckRegistry getOrCreate(String name) {
+    final HealthCheckRegistry existing = REGISTRIES.get(name);
+    if (existing == null) {
+      final HealthCheckRegistry created = new HealthCheckRegistry();
+      final HealthCheckRegistry raced = add(name, created);
+      if (raced == null) {
+        return created;
+      }
+      return raced;
     }
+    return existing;
+  }
 
-    /**
-     * Creates a new registry and sets it as the default one under the provided name.
-     *
-     * @param name the registry name
-     * @return the default registry
-     * @throws IllegalStateException if the name has already been set
-     */
-    public synchronized static HealthCheckRegistry setDefault(String name) {
-        final HealthCheckRegistry registry = getOrCreate(name);
-        return setDefault(name, registry);
-    }
+  /**
+   * Creates a new registry and sets it as the default one under the provided name.
+   *
+   * @param name the registry name
+   * @return the default registry
+   * @throws IllegalStateException if the name has already been set
+   */
+  public static synchronized HealthCheckRegistry setDefault(String name) {
+    final HealthCheckRegistry registry = getOrCreate(name);
+    return setDefault(name, registry);
+  }
 
-    /**
-     * Sets the provided registry as the default one under the provided name
-     *
-     * @param name                the default registry name
-     * @param healthCheckRegistry the default registry
-     * @throws IllegalStateException if the default registry has already been set
-     */
-    public static HealthCheckRegistry setDefault(String name, HealthCheckRegistry healthCheckRegistry) {
-        if (defaultRegistryName.compareAndSet(null, name)) {
-            add(name, healthCheckRegistry);
-            return healthCheckRegistry;
-        }
-        throw new IllegalStateException("Default health check registry is already set.");
+  /**
+   * Sets the provided registry as the default one under the provided name
+   *
+   * @param name the default registry name
+   * @param healthCheckRegistry the default registry
+   * @throws IllegalStateException if the default registry has already been set
+   */
+  public static HealthCheckRegistry setDefault(
+      String name, HealthCheckRegistry healthCheckRegistry) {
+    if (defaultRegistryName.compareAndSet(null, name)) {
+      add(name, healthCheckRegistry);
+      return healthCheckRegistry;
     }
+    throw new IllegalStateException("Default health check registry is already set.");
+  }
 
-    /**
-     * Gets the name of the default registry, if it has been set
-     *
-     * @return the default registry
-     * @throws IllegalStateException if the default has not been set
-     */
-    public static HealthCheckRegistry getDefault() {
-        final HealthCheckRegistry healthCheckRegistry = tryGetDefault();
-        if (healthCheckRegistry != null) {
-            return healthCheckRegistry;
-        }
-        throw new IllegalStateException("Default registry name has not been set.");
+  /**
+   * Gets the name of the default registry, if it has been set
+   *
+   * @return the default registry
+   * @throws IllegalStateException if the default has not been set
+   */
+  public static HealthCheckRegistry getDefault() {
+    final HealthCheckRegistry healthCheckRegistry = tryGetDefault();
+    if (healthCheckRegistry != null) {
+      return healthCheckRegistry;
     }
+    throw new IllegalStateException("Default registry name has not been set.");
+  }
 
-    /**
-     * Same as {@link #getDefault()} except returns null when the default registry has not been set.
-     *
-     * @return the default registry or null
-     */
-    public static HealthCheckRegistry tryGetDefault() {
-        final String name = defaultRegistryName.get();
-        if (name != null) {
-            return getOrCreate(name);
-        }
-        return null;
+  /**
+   * Same as {@link #getDefault()} except returns null when the default registry has not been set.
+   *
+   * @return the default registry or null
+   */
+  public static HealthCheckRegistry tryGetDefault() {
+    final String name = defaultRegistryName.get();
+    if (name != null) {
+      return getOrCreate(name);
     }
+    return null;
+  }
 }
--- a/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/annotation/Async.java
+++ b/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/annotation/Async.java
@@ -6,70 +6,66 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 import java.util.concurrent.TimeUnit;
 
-/**
- * An annotation for marking asynchronous health check execution.
- */
+/** An annotation for marking asynchronous health check execution. */
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
 public @interface Async {
-    /**
-     * Enum representing the initial health states.
-     */
-    enum InitialState {
-        HEALTHY, UNHEALTHY
-    }
+  /** Enum representing the initial health states. */
+  enum InitialState {
+    HEALTHY,
+    UNHEALTHY
+  }
 
-    /**
-     * Enum representing the possible schedule types.
-     */
-    enum ScheduleType {
-        FIXED_RATE, FIXED_DELAY
-    }
+  /** Enum representing the possible schedule types. */
+  enum ScheduleType {
+    FIXED_RATE,
+    FIXED_DELAY
+  }
 
-    /**
-     * Period between executions.
-     *
-     * @return period
-     */
-    long period();
+  /**
+   * Period between executions.
+   *
+   * @return period
+   */
+  long period();
 
-    /**
-     * Scheduling type of asynchronous executions.
-     *
-     * @return schedule type
-     */
-    ScheduleType scheduleType() default ScheduleType.FIXED_RATE;
+  /**
+   * Scheduling type of asynchronous executions.
+   *
+   * @return schedule type
+   */
+  ScheduleType scheduleType() default ScheduleType.FIXED_RATE;
 
-    /**
-     * Initial delay of first execution.
-     *
-     * @return initial delay
-     */
-    long initialDelay() default 0;
+  /**
+   * Initial delay of first execution.
+   *
+   * @return initial delay
+   */
+  long initialDelay() default 0;
 
-    /**
-     * Time unit of initial delay, period and healthyTtl.
-     *
-     * @return time unit
-     */
-    TimeUnit unit() default TimeUnit.SECONDS;
+  /**
+   * Time unit of initial delay, period and healthyTtl.
+   *
+   * @return time unit
+   */
+  TimeUnit unit() default TimeUnit.SECONDS;
 
-    /**
-     * Initial health state until first asynchronous execution completes.
-     *
-     * @return initial health state
-     */
-    InitialState initialState() default InitialState.HEALTHY;
-
-    /**
-     * How long a healthy result is considered valid before being ignored.
-     *
-     * Handles cases where the asynchronous healthcheck did not run (for example thread starvation).
-     *
-     * Defaults to 2 * period
-     *
-     * @return healthy result time to live
-     */
-    long healthyTtl() default -1;
+  /**
+   * Initial health state until first asynchronous execution completes.
+   *
+   * @return initial health state
+   */
+  InitialState initialState() default InitialState.HEALTHY;
 
+  /**
+   * How long a healthy result is considered valid before being ignored.
+   *
+   * <p>Handles cases where the asynchronous healthcheck did not run (for example thread
+   * starvation).
+   *
+   * <p>Defaults to 2 * period
+   *
+   * @return healthy result time to live
+   */
+  long healthyTtl() default -1;
 }
--- a/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/jvm/ThreadDeadlockHealthCheck.java
+++ b/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/jvm/ThreadDeadlockHealthCheck.java
@@ -2,37 +2,32 @@ package io.dropwizard.metrics5.health.jvm;
 
 import io.dropwizard.metrics5.health.HealthCheck;
 import io.dropwizard.metrics5.jvm.ThreadDeadlockDetector;
-
 import java.util.Set;
 
-/**
- * A health check which returns healthy if no threads are deadlocked.
- */
+/** A health check which returns healthy if no threads are deadlocked. */
 public class ThreadDeadlockHealthCheck implements HealthCheck {
-    private final ThreadDeadlockDetector detector;
+  private final ThreadDeadlockDetector detector;
 
-    /**
-     * Creates a new health check.
-     */
-    public ThreadDeadlockHealthCheck() {
-        this(new ThreadDeadlockDetector());
-    }
+  /** Creates a new health check. */
+  public ThreadDeadlockHealthCheck() {
+    this(new ThreadDeadlockDetector());
+  }
 
-    /**
-     * Creates a new health check with the given detector.
-     *
-     * @param detector a thread deadlock detector
-     */
-    public ThreadDeadlockHealthCheck(ThreadDeadlockDetector detector) {
-        this.detector = detector;
-    }
+  /**
+   * Creates a new health check with the given detector.
+   *
+   * @param detector a thread deadlock detector
+   */
+  public ThreadDeadlockHealthCheck(ThreadDeadlockDetector detector) {
+    this.detector = detector;
+  }
 
-    @Override
-    public Result check() throws Exception {
-        final Set<String> threads = detector.getDeadlockedThreads();
-        if (threads.isEmpty()) {
-            return Result.healthy();
-        }
-        return Result.unhealthy(threads.toString());
+  @Override
+  public Result check() throws Exception {
+    final Set<String> threads = detector.getDeadlockedThreads();
+    if (threads.isEmpty()) {
+      return Result.healthy();
     }
+    return Result.unhealthy(threads.toString());
+  }
 }
--- a/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/AsyncHealthCheckDecoratorTest.java
+++ b/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/AsyncHealthCheckDecoratorTest.java
@@ -1,340 +1,388 @@
 package io.dropwizard.metrics5.health;
 
-import io.dropwizard.metrics5.Clock;
-import io.dropwizard.metrics5.health.annotation.Async;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.TimeUnit;
-
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.mockito.ArgumentCaptor.forClass;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.*;
+import static org.mockito.Mockito.verify;
 
-/**
- * Unit tests for {@link AsyncHealthCheckDecorator}.
- */
-class AsyncHealthCheckDecoratorTest {
-
-    private static final long CURRENT_TIME = 1551002401000L;
-
-    private static final Clock FIXED_CLOCK = clockWithFixedTime(CURRENT_TIME);
-
-    private static final HealthCheck.Result EXPECTED_EXPIRED_RESULT = HealthCheck.Result
-            .builder()
-            .usingClock(FIXED_CLOCK)
-            .unhealthy()
-            .withMessage("Result was healthy but it expired 1 milliseconds ago")
-            .build();
-
-    private final HealthCheck mockHealthCheck = mock(HealthCheck.class);
-    private final ScheduledExecutorService mockExecutorService = mock(ScheduledExecutorService.class);
-
-    @SuppressWarnings("rawtypes")
-    private final ScheduledFuture mockFuture = mock(ScheduledFuture.class);
-
-    @Test
-    void nullHealthCheckTriggersInstantiationFailure() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            new AsyncHealthCheckDecorator(null, mockExecutorService);
-        });
-    }
-
-    @Test
-    void nullExecutorServiceTriggersInstantiationFailure() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            new AsyncHealthCheckDecorator(mockHealthCheck, null);
-        });
-    }
-
-    @Test
-    void nonAsyncHealthCheckTriggersInstantiationFailure() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            new AsyncHealthCheckDecorator(mockHealthCheck, mockExecutorService);
-        });
-    }
-
-    @Test
-    void negativePeriodTriggersInstantiationFailure() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            new AsyncHealthCheckDecorator(new NegativePeriodAsyncHealthCheck(), mockExecutorService);
-        });
-    }
-
-    @Test
-    void zeroPeriodTriggersInstantiationFailure() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            new AsyncHealthCheckDecorator(new ZeroPeriodAsyncHealthCheck(), mockExecutorService);
-        });
-    }
-
-    @Test
-    void negativeInitialValueTriggersInstantiationFailure() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            new AsyncHealthCheckDecorator(new NegativeInitialDelayAsyncHealthCheck(), mockExecutorService);
-        });
-    }
-
-    @Test
-    void defaultAsyncHealthCheckTriggersSuccessfulInstantiationWithFixedRateAndHealthyState() throws Exception {
-        HealthCheck asyncHealthCheck = new DefaultAsyncHealthCheck();
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(asyncHealthCheck, mockExecutorService);
-
-        verify(mockExecutorService, times(1)).scheduleAtFixedRate(any(Runnable.class), eq(0L),
-                eq(1L), eq(TimeUnit.SECONDS));
-        assertThat(asyncDecorator.getHealthCheck()).isEqualTo(asyncHealthCheck);
-        assertThat(asyncDecorator.check().isHealthy()).isTrue();
-    }
-
-    @Test
-    void fixedDelayAsyncHealthCheckTriggersSuccessfulInstantiationWithFixedDelay() throws Exception {
-        HealthCheck asyncHealthCheck = new FixedDelayAsyncHealthCheck();
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(asyncHealthCheck, mockExecutorService);
-
-        verify(mockExecutorService, times(1)).scheduleWithFixedDelay(any(Runnable.class), eq(0L),
-                eq(1L), eq(TimeUnit.SECONDS));
-        assertThat(asyncDecorator.getHealthCheck()).isEqualTo(asyncHealthCheck);
-    }
-
-    @Test
-    void unhealthyAsyncHealthCheckTriggersSuccessfulInstantiationWithUnhealthyState() throws Exception {
-        HealthCheck asyncHealthCheck = new UnhealthyAsyncHealthCheck();
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(asyncHealthCheck, mockExecutorService);
-
-        assertThat(asyncDecorator.check().isHealthy()).isFalse();
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    void tearDownTriggersCancellation() throws Exception {
-        when(mockExecutorService.scheduleAtFixedRate(any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS))).
-                thenReturn(mockFuture);
-        when(mockFuture.cancel(true)).thenReturn(true);
-
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(new DefaultAsyncHealthCheck(), mockExecutorService);
-        asyncDecorator.tearDown();
-
-        verify(mockExecutorService, times(1)).scheduleAtFixedRate(any(Runnable.class), eq(0L),
-                eq(1L), eq(TimeUnit.SECONDS));
-        verify(mockFuture, times(1)).cancel(eq(true));
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    void afterFirstExecutionDecoratedHealthCheckResultIsProvided() throws Exception {
-        HealthCheck.Result expectedResult = HealthCheck.Result.healthy("AsyncHealthCheckTest");
-        when(mockExecutorService.scheduleAtFixedRate(any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS)))
-                .thenReturn(mockFuture);
-
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(new ConfigurableAsyncHealthCheck(expectedResult),
-                mockExecutorService);
-        HealthCheck.Result initialResult = asyncDecorator.check();
-
-        ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
-        verify(mockExecutorService, times(1)).scheduleAtFixedRate(runnableCaptor.capture(),
-                eq(0L), eq(1L), eq(TimeUnit.SECONDS));
-        Runnable capturedRunnable = runnableCaptor.getValue();
-        capturedRunnable.run();
-        HealthCheck.Result actualResult = asyncDecorator.check();
-
-        assertThat(actualResult).isEqualTo(expectedResult);
-        assertThat(actualResult).isNotEqualTo(initialResult);
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    void exceptionInDecoratedHealthCheckWontAffectAsyncDecorator() throws Exception {
-        Exception exception = new Exception("TestException");
-        when(mockExecutorService.scheduleAtFixedRate(any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS)))
-                .thenReturn(mockFuture);
-
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(new ConfigurableAsyncHealthCheck(exception),
-                mockExecutorService);
-
-        ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
-        verify(mockExecutorService, times(1)).scheduleAtFixedRate(runnableCaptor.capture(),
-                eq(0L), eq(1L), eq(TimeUnit.SECONDS));
-        Runnable capturedRunnable = runnableCaptor.getValue();
-        capturedRunnable.run();
-        HealthCheck.Result result = asyncDecorator.check();
-
-        assertThat(result.isHealthy()).isFalse();
-        assertThat(result.getError()).isEqualTo(exception);
-    }
-
-    @Test
-    void returnUnhealthyIfPreviousResultIsExpiredBasedOnTtl() throws Exception {
-        HealthCheck healthCheck = new HealthyAsyncHealthCheckWithExpiredExplicitTtlInMilliseconds();
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(healthCheck, mockExecutorService, FIXED_CLOCK);
-
-        ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
-        verify(mockExecutorService, times(1)).scheduleAtFixedRate(runnableCaptor.capture(),
-                eq(0L), eq(1000L), eq(TimeUnit.MILLISECONDS));
-        Runnable capturedRunnable = runnableCaptor.getValue();
-        capturedRunnable.run();
-
-        HealthCheck.Result result = asyncDecorator.check();
-
-        assertThat(result).isEqualTo(EXPECTED_EXPIRED_RESULT);
-    }
-
-    @Test
-    void returnUnhealthyIfPreviousResultIsExpiredBasedOnPeriod() throws Exception {
-        HealthCheck healthCheck = new HealthyAsyncHealthCheckWithExpiredTtlInMillisecondsBasedOnPeriod();
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(healthCheck, mockExecutorService, FIXED_CLOCK);
-
-        ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
-        verify(mockExecutorService, times(1)).scheduleAtFixedRate(runnableCaptor.capture(),
-                eq(0L), eq(1000L), eq(TimeUnit.MILLISECONDS));
-        Runnable capturedRunnable = runnableCaptor.getValue();
-        capturedRunnable.run();
-
-        HealthCheck.Result result = asyncDecorator.check();
+import io.dropwizard.metrics5.Clock;
+import io.dropwizard.metrics5.health.annotation.Async;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.Test;
+import org.mockito.ArgumentCaptor;
 
-        assertThat(result).isEqualTo(EXPECTED_EXPIRED_RESULT);
+/** Unit tests for {@link AsyncHealthCheckDecorator}. */
+final class AsyncHealthCheckDecoratorTest {
+
+  private static final long CURRENT_TIME = 1551002401000L;
+
+  private static final Clock FIXED_CLOCK = clockWithFixedTime(CURRENT_TIME);
+
+  private static final HealthCheck.Result EXPECTED_EXPIRED_RESULT =
+      HealthCheck.Result.builder()
+          .usingClock(FIXED_CLOCK)
+          .unhealthy()
+          .withMessage("Result was healthy but it expired 1 milliseconds ago")
+          .build();
+
+  private final HealthCheck mockHealthCheck = mock();
+  private final ScheduledExecutorService mockExecutorService = mock();
+
+  @SuppressWarnings("rawtypes")
+  private final ScheduledFuture mockFuture = mock();
+
+  @Test
+  void nullHealthCheckTriggersInstantiationFailure() {
+    assertThatThrownBy(
+            () -> {
+              new AsyncHealthCheckDecorator(null, mockExecutorService);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void nullExecutorServiceTriggersInstantiationFailure() {
+    assertThatThrownBy(
+            () -> {
+              new AsyncHealthCheckDecorator(mockHealthCheck, null);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void nonAsyncHealthCheckTriggersInstantiationFailure() {
+    assertThatThrownBy(
+            () -> {
+              new AsyncHealthCheckDecorator(mockHealthCheck, mockExecutorService);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void negativePeriodTriggersInstantiationFailure() {
+    assertThatThrownBy(
+            () -> {
+              new AsyncHealthCheckDecorator(
+                  new NegativePeriodAsyncHealthCheck(), mockExecutorService);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void zeroPeriodTriggersInstantiationFailure() {
+    assertThatThrownBy(
+            () -> {
+              new AsyncHealthCheckDecorator(new ZeroPeriodAsyncHealthCheck(), mockExecutorService);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void negativeInitialValueTriggersInstantiationFailure() {
+    assertThatThrownBy(
+            () -> {
+              new AsyncHealthCheckDecorator(
+                  new NegativeInitialDelayAsyncHealthCheck(), mockExecutorService);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void defaultAsyncHealthCheckTriggersSuccessfulInstantiationWithFixedRateAndHealthyState()
+      throws Exception {
+    HealthCheck asyncHealthCheck = new DefaultAsyncHealthCheck();
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(asyncHealthCheck, mockExecutorService);
+
+    verify(mockExecutorService)
+        .scheduleAtFixedRate(any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS));
+    assertThat(asyncDecorator.getHealthCheck()).isEqualTo(asyncHealthCheck);
+    assertThat(asyncDecorator.check().isHealthy()).isTrue();
+  }
+
+  @Test
+  void fixedDelayAsyncHealthCheckTriggersSuccessfulInstantiationWithFixedDelay() throws Exception {
+    HealthCheck asyncHealthCheck = new FixedDelayAsyncHealthCheck();
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(asyncHealthCheck, mockExecutorService);
+
+    verify(mockExecutorService)
+        .scheduleWithFixedDelay(any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS));
+    assertThat(asyncDecorator.getHealthCheck()).isEqualTo(asyncHealthCheck);
+  }
+
+  @Test
+  void unhealthyAsyncHealthCheckTriggersSuccessfulInstantiationWithUnhealthyState()
+      throws Exception {
+    HealthCheck asyncHealthCheck = new UnhealthyAsyncHealthCheck();
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(asyncHealthCheck, mockExecutorService);
+
+    assertThat(asyncDecorator.check().isHealthy()).isFalse();
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  void tearDownTriggersCancellation() throws Exception {
+    when(mockExecutorService.scheduleAtFixedRate(
+            any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS)))
+        .thenReturn(mockFuture);
+    when(mockFuture.cancel(true)).thenReturn(true);
+
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(new DefaultAsyncHealthCheck(), mockExecutorService);
+    asyncDecorator.tearDown();
+
+    verify(mockExecutorService)
+        .scheduleAtFixedRate(any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS));
+    verify(mockFuture).cancel(true);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  void afterFirstExecutionDecoratedHealthCheckResultIsProvided() throws Exception {
+    HealthCheck.Result expectedResult = HealthCheck.Result.healthy("AsyncHealthCheckTest");
+    when(mockExecutorService.scheduleAtFixedRate(
+            any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS)))
+        .thenReturn(mockFuture);
+
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(
+            new ConfigurableAsyncHealthCheck(expectedResult), mockExecutorService);
+    HealthCheck.Result initialResult = asyncDecorator.check();
+
+    ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
+    verify(mockExecutorService)
+        .scheduleAtFixedRate(runnableCaptor.capture(), eq(0L), eq(1L), eq(TimeUnit.SECONDS));
+    Runnable capturedRunnable = runnableCaptor.getValue();
+    capturedRunnable.run();
+    HealthCheck.Result actualResult = asyncDecorator.check();
+
+    assertThat(actualResult).isEqualTo(expectedResult);
+    assertThat(actualResult).isNotEqualTo(initialResult);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Test
+  void exceptionInDecoratedHealthCheckWontAffectAsyncDecorator() throws Exception {
+    Exception exception = new Exception("TestException");
+    when(mockExecutorService.scheduleAtFixedRate(
+            any(Runnable.class), eq(0L), eq(1L), eq(TimeUnit.SECONDS)))
+        .thenReturn(mockFuture);
+
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(
+            new ConfigurableAsyncHealthCheck(exception), mockExecutorService);
+
+    ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
+    verify(mockExecutorService)
+        .scheduleAtFixedRate(runnableCaptor.capture(), eq(0L), eq(1L), eq(TimeUnit.SECONDS));
+    Runnable capturedRunnable = runnableCaptor.getValue();
+    capturedRunnable.run();
+    HealthCheck.Result result = asyncDecorator.check();
+
+    assertThat(result.isHealthy()).isFalse();
+    assertThat(result.getError()).isEqualTo(exception);
+  }
+
+  @Test
+  void returnUnhealthyIfPreviousResultIsExpiredBasedOnTtl() throws Exception {
+    HealthCheck healthCheck = new HealthyAsyncHealthCheckWithExpiredExplicitTtlInMilliseconds();
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(healthCheck, mockExecutorService, FIXED_CLOCK);
+
+    ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
+    verify(mockExecutorService)
+        .scheduleAtFixedRate(
+            runnableCaptor.capture(), eq(0L), eq(1000L), eq(TimeUnit.MILLISECONDS));
+    Runnable capturedRunnable = runnableCaptor.getValue();
+    capturedRunnable.run();
+
+    HealthCheck.Result result = asyncDecorator.check();
+
+    assertThat(result).isEqualTo(EXPECTED_EXPIRED_RESULT);
+  }
+
+  @Test
+  void returnUnhealthyIfPreviousResultIsExpiredBasedOnPeriod() throws Exception {
+    HealthCheck healthCheck =
+        new HealthyAsyncHealthCheckWithExpiredTtlInMillisecondsBasedOnPeriod();
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(healthCheck, mockExecutorService, FIXED_CLOCK);
+
+    ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
+    verify(mockExecutorService)
+        .scheduleAtFixedRate(
+            runnableCaptor.capture(), eq(0L), eq(1000L), eq(TimeUnit.MILLISECONDS));
+    Runnable capturedRunnable = runnableCaptor.getValue();
+    capturedRunnable.run();
+
+    HealthCheck.Result result = asyncDecorator.check();
+
+    assertThat(result).isEqualTo(EXPECTED_EXPIRED_RESULT);
+  }
+
+  @Test
+  void convertTtlToMillisecondsWhenCheckingExpiration() throws Exception {
+    HealthCheck healthCheck = new HealthyAsyncHealthCheckWithExpiredExplicitTtlInSeconds();
+    AsyncHealthCheckDecorator asyncDecorator =
+        new AsyncHealthCheckDecorator(healthCheck, mockExecutorService, FIXED_CLOCK);
+
+    ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
+    verify(mockExecutorService)
+        .scheduleAtFixedRate(runnableCaptor.capture(), eq(0L), eq(1L), eq(TimeUnit.SECONDS));
+    Runnable capturedRunnable = runnableCaptor.getValue();
+    capturedRunnable.run();
+
+    HealthCheck.Result result = asyncDecorator.check();
+
+    assertThat(result).isEqualTo(EXPECTED_EXPIRED_RESULT);
+  }
+
+  @Async(period = -1)
+  private static class NegativePeriodAsyncHealthCheck implements HealthCheck {
+
+    @Override
+    public Result check() {
+      return null;
     }
+  }
 
-    @Test
-    void convertTtlToMillisecondsWhenCheckingExpiration() throws Exception {
-        HealthCheck healthCheck = new HealthyAsyncHealthCheckWithExpiredExplicitTtlInSeconds();
-        AsyncHealthCheckDecorator asyncDecorator = new AsyncHealthCheckDecorator(healthCheck, mockExecutorService, FIXED_CLOCK);
-
-        ArgumentCaptor<Runnable> runnableCaptor = forClass(Runnable.class);
-        verify(mockExecutorService, times(1)).scheduleAtFixedRate(runnableCaptor.capture(),
-                eq(0L), eq(1L), eq(TimeUnit.SECONDS));
-        Runnable capturedRunnable = runnableCaptor.getValue();
-        capturedRunnable.run();
-
-        HealthCheck.Result result = asyncDecorator.check();
+  @Async(period = 0)
+  private static class ZeroPeriodAsyncHealthCheck implements HealthCheck {
 
-        assertThat(result).isEqualTo(EXPECTED_EXPIRED_RESULT);
+    @Override
+    public Result check() {
+      return null;
     }
+  }
 
-    @Async(period = -1)
-    private static class NegativePeriodAsyncHealthCheck implements HealthCheck {
+  @Async(period = 1, initialDelay = -1)
+  private static class NegativeInitialDelayAsyncHealthCheck implements HealthCheck {
 
-        @Override
-        public Result check() {
-            return null;
-        }
+    @Override
+    public Result check() {
+      return null;
     }
+  }
 
-    @Async(period = 0)
-    private static class ZeroPeriodAsyncHealthCheck implements HealthCheck {
+  @Async(period = 1)
+  private static class DefaultAsyncHealthCheck implements HealthCheck {
 
-        @Override
-        public Result check() {
-            return null;
-        }
+    @Override
+    public Result check() {
+      return null;
     }
+  }
 
-    @Async(period = 1, initialDelay = -1)
-    private static class NegativeInitialDelayAsyncHealthCheck implements HealthCheck {
+  @Async(period = 1, scheduleType = Async.ScheduleType.FIXED_DELAY)
+  private static class FixedDelayAsyncHealthCheck implements HealthCheck {
 
-        @Override
-        public Result check() {
-            return null;
-        }
+    @Override
+    public Result check() {
+      return null;
     }
+  }
 
-    @Async(period = 1)
-    private static class DefaultAsyncHealthCheck implements HealthCheck {
+  @Async(period = 1, initialState = Async.InitialState.UNHEALTHY)
+  private static class UnhealthyAsyncHealthCheck implements HealthCheck {
 
-        @Override
-        public Result check() {
-            return null;
-        }
+    @Override
+    public Result check() {
+      return null;
     }
+  }
 
-    @Async(period = 1, scheduleType = Async.ScheduleType.FIXED_DELAY)
-    private static class FixedDelayAsyncHealthCheck implements HealthCheck {
+  @Async(period = 1, initialState = Async.InitialState.UNHEALTHY)
+  private static class ConfigurableAsyncHealthCheck implements HealthCheck {
+    private final Result result;
+    private final Exception exception;
 
-        @Override
-        public Result check() {
-            return null;
-        }
+    ConfigurableAsyncHealthCheck(Result result) {
+      this(result, null);
     }
 
-    @Async(period = 1, initialState = Async.InitialState.UNHEALTHY)
-    private static class UnhealthyAsyncHealthCheck implements HealthCheck {
-
-        @Override
-        public Result check() {
-            return null;
-        }
+    ConfigurableAsyncHealthCheck(Exception exception) {
+      this(null, exception);
     }
 
-    @Async(period = 1, initialState = Async.InitialState.UNHEALTHY)
-    private static class ConfigurableAsyncHealthCheck implements HealthCheck {
-        private final Result result;
-        private final Exception exception;
-
-        ConfigurableAsyncHealthCheck(Result result) {
-            this(result, null);
-        }
-
-        ConfigurableAsyncHealthCheck(Exception exception) {
-            this(null, exception);
-        }
-
-        private ConfigurableAsyncHealthCheck(Result result, Exception exception) {
-            this.result = result;
-            this.exception = exception;
-        }
-
-        @Override
-        public Result check() throws Exception {
-            if (exception != null) {
-                throw exception;
-            }
-            return result;
-        }
+    private ConfigurableAsyncHealthCheck(Result result, Exception exception) {
+      this.result = result;
+      this.exception = exception;
     }
 
-    @Async(period = 1000, initialState = Async.InitialState.UNHEALTHY, healthyTtl = 3000, unit = TimeUnit.MILLISECONDS)
-    private static class HealthyAsyncHealthCheckWithExpiredExplicitTtlInMilliseconds implements HealthCheck {
-
-        @Override
-        public Result check() {
-            return Result.builder().usingClock(clockWithFixedTime(CURRENT_TIME - 3001L)).healthy().build();
-        }
+    @Override
+    public Result check() throws Exception {
+      if (exception != null) {
+        throw exception;
+      }
+      return result;
     }
-
-    @Async(period = 1, initialState = Async.InitialState.UNHEALTHY, healthyTtl = 5, unit = TimeUnit.SECONDS)
-    private static class HealthyAsyncHealthCheckWithExpiredExplicitTtlInSeconds implements HealthCheck {
-
-        @Override
-        public Result check() {
-            return Result.builder().usingClock(clockWithFixedTime(CURRENT_TIME - 5001L)).healthy().build();
-        }
+  }
+
+  @Async(
+      period = 1000,
+      initialState = Async.InitialState.UNHEALTHY,
+      healthyTtl = 3000,
+      unit = TimeUnit.MILLISECONDS)
+  private static class HealthyAsyncHealthCheckWithExpiredExplicitTtlInMilliseconds
+      implements HealthCheck {
+
+    @Override
+    public Result check() {
+      return Result.builder()
+          .usingClock(clockWithFixedTime(CURRENT_TIME - 3001L))
+          .healthy()
+          .build();
     }
-
-    @Async(period = 1000, initialState = Async.InitialState.UNHEALTHY, unit = TimeUnit.MILLISECONDS)
-    private static class HealthyAsyncHealthCheckWithExpiredTtlInMillisecondsBasedOnPeriod implements HealthCheck {
-
-        @Override
-        public Result check() {
-            return Result.builder().usingClock(clockWithFixedTime(CURRENT_TIME - 2001L)).healthy().build();
-        }
+  }
+
+  @Async(
+      period = 1,
+      initialState = Async.InitialState.UNHEALTHY,
+      healthyTtl = 5,
+      unit = TimeUnit.SECONDS)
+  private static class HealthyAsyncHealthCheckWithExpiredExplicitTtlInSeconds
+      implements HealthCheck {
+
+    @Override
+    public Result check() {
+      return Result.builder()
+          .usingClock(clockWithFixedTime(CURRENT_TIME - 5001L))
+          .healthy()
+          .build();
     }
-
-    private static Clock clockWithFixedTime(final long time) {
-        return new Clock() {
-            @Override
-            public long getTick() {
-                return 0;
-            }
-
-            @Override
-            public long getTime() {
-                return time;
-            }
-        };
+  }
+
+  @Async(period = 1000, initialState = Async.InitialState.UNHEALTHY, unit = TimeUnit.MILLISECONDS)
+  private static class HealthyAsyncHealthCheckWithExpiredTtlInMillisecondsBasedOnPeriod
+      implements HealthCheck {
+
+    @Override
+    public Result check() {
+      return Result.builder()
+          .usingClock(clockWithFixedTime(CURRENT_TIME - 2001L))
+          .healthy()
+          .build();
     }
-
+  }
+
+  private static Clock clockWithFixedTime(final long time) {
+    return new Clock() {
+      @Override
+      public long getTick() {
+        return 0;
+      }
+
+      @Override
+      public long getTime() {
+        return time;
+      }
+    };
+  }
 }
--- a/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/HealthCheckFilterTest.java
+++ b/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/HealthCheckFilterTest.java
@@ -5,10 +5,10 @@ import static org.mockito.Mockito.mock;
 
 import org.junit.jupiter.api.Test;
 
-class HealthCheckFilterTest {
+final class HealthCheckFilterTest {
 
-    @Test
-    void theAllFilterMatchesAllHealthChecks() {
-        assertThat(HealthCheckFilter.ALL.matches("", mock(HealthCheck.class))).isTrue();
-    }
+  @Test
+  void theAllFilterMatchesAllHealthChecks() {
+    assertThat(HealthCheckFilter.ALL.matches("", mock(HealthCheck.class))).isTrue();
+  }
 }
--- a/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/HealthCheckRegistryTest.java
+++ b/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/HealthCheckRegistryTest.java
@@ -1,22 +1,9 @@
 package io.dropwizard.metrics5.health;
 
-import io.dropwizard.metrics5.health.annotation.Async;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.TimeUnit;
-
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
-import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.mockito.ArgumentCaptor.forClass;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.eq;
@@ -24,206 +11,224 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-class HealthCheckRegistryTest {
-    private final ScheduledExecutorService executorService = mock(ScheduledExecutorService.class);
-    private final HealthCheckRegistry registry = new HealthCheckRegistry(executorService);
-    private final HealthCheckRegistryListener listener = mock(HealthCheckRegistryListener.class);
-
-    private final HealthCheck hc1 = mock(HealthCheck.class);
-    private final HealthCheck hc2 = mock(HealthCheck.class);
-
-    private final HealthCheck.Result r1 = mock(HealthCheck.Result.class);
-    private final HealthCheck.Result r2 = mock(HealthCheck.Result.class);
-
-    private final HealthCheck.Result ar = mock(HealthCheck.Result.class);
-    private final HealthCheck ahc = new TestAsyncHealthCheck(ar);
-
-    @SuppressWarnings("rawtypes")
-    private final ScheduledFuture af = mock(ScheduledFuture.class);
-
-    @BeforeEach
-    @SuppressWarnings("unchecked")
-    void setUp() {
-        registry.addListener(listener);
-
-        when(hc1.execute()).thenReturn(r1);
-        when(hc2.execute()).thenReturn(r2);
-        when(executorService.scheduleAtFixedRate(any(AsyncHealthCheckDecorator.class), eq(0L), eq(10L), eq(TimeUnit.SECONDS)))
-                .thenReturn(af);
-
-        registry.register("hc1", hc1);
-        registry.register("hc2", hc2);
-        registry.register("ahc", ahc);
-    }
-
-    @Test
-    void asyncHealthCheckIsScheduledOnExecutor() {
-        ArgumentCaptor<AsyncHealthCheckDecorator> decoratorCaptor = forClass(AsyncHealthCheckDecorator.class);
-        verify(executorService).scheduleAtFixedRate(decoratorCaptor.capture(), eq(0L), eq(10L), eq(TimeUnit.SECONDS));
-        assertThat(decoratorCaptor.getValue().getHealthCheck()).isEqualTo(ahc);
-    }
-
-    @Test
-    void asyncHealthCheckIsCanceledOnRemove() {
-        registry.unregister("ahc");
-
-        verify(af).cancel(true);
-    }
-
-    @Test
-    void registeringHealthCheckTwiceThrowsException() {
-        assertThrows(IllegalArgumentException.class, () -> {
-            registry.register("hc1", hc1);
-        });
-    }
-
-    @Test
-    void registeringHealthCheckTriggersNotification() {
-        verify(listener).onHealthCheckAdded("hc1", hc1);
-        verify(listener).onHealthCheckAdded("hc2", hc2);
-        verify(listener).onHealthCheckAdded(eq("ahc"), any(AsyncHealthCheckDecorator.class));
-    }
-
-    @Test
-    void removingHealthCheckTriggersNotification() {
-        registry.unregister("hc1");
-        registry.unregister("hc2");
-        registry.unregister("ahc");
-
-        verify(listener).onHealthCheckRemoved("hc1", hc1);
-        verify(listener).onHealthCheckRemoved("hc2", hc2);
-        verify(listener).onHealthCheckRemoved(eq("ahc"), any(AsyncHealthCheckDecorator.class));
-    }
-
-    @Test
-    void addingListenerCatchesExistingHealthChecks() {
-        HealthCheckRegistryListener listener = mock(HealthCheckRegistryListener.class);
-        HealthCheckRegistry registry = new HealthCheckRegistry();
-        registry.register("hc1", hc1);
-        registry.register("hc2", hc2);
-        registry.register("ahc", ahc);
-        registry.addListener(listener);
-
-        verify(listener).onHealthCheckAdded("hc1", hc1);
-        verify(listener).onHealthCheckAdded("hc2", hc2);
-        verify(listener).onHealthCheckAdded(eq("ahc"), any(AsyncHealthCheckDecorator.class));
-    }
-
-    @Test
-    void removedListenerDoesNotReceiveUpdates() {
-        HealthCheckRegistryListener listener = mock(HealthCheckRegistryListener.class);
-        HealthCheckRegistry registry = new HealthCheckRegistry();
-        registry.addListener(listener);
-        registry.register("hc1", hc1);
-        registry.removeListener(listener);
-        registry.register("hc2", hc2);
-
-        verify(listener).onHealthCheckAdded("hc1", hc1);
-    }
-
-    @Test
-    void runsRegisteredHealthChecks() {
-        final Map<String, HealthCheck.Result> results = registry.runHealthChecks();
-
-        assertThat(results).contains(entry("hc1", r1));
-        assertThat(results).contains(entry("hc2", r2));
-        assertThat(results).containsKey("ahc");
-    }
-
-    @Test
-    void runsRegisteredHealthChecksWithFilter() {
-        final Map<String, HealthCheck.Result> results = registry.runHealthChecks((name, healthCheck) -> "hc1".equals(name));
-
-        assertThat(results).containsOnly(entry("hc1", r1));
-    }
-
-    @Test
-    void runsRegisteredHealthChecksWithNonMatchingFilter() {
-        final Map<String, HealthCheck.Result> results = registry.runHealthChecks((name, healthCheck) -> false);
-
-        assertThat(results).isEmpty();
-    }
-
-    @Test
-    void runsRegisteredHealthChecksInParallel() throws Exception {
-        final ExecutorService executor = Executors.newFixedThreadPool(10);
-        final Map<String, HealthCheck.Result> results = registry.runHealthChecks(executor);
-
-        executor.shutdown();
-        executor.awaitTermination(1, TimeUnit.SECONDS);
-
-        assertThat(results).contains(entry("hc1", r1));
-        assertThat(results).contains(entry("hc2", r2));
-        assertThat(results).containsKey("ahc");
-    }
-
-    @Test
-    void runsRegisteredHealthChecksInParallelWithNonMatchingFilter() throws Exception {
-        final ExecutorService executor = Executors.newFixedThreadPool(10);
-        final Map<String, HealthCheck.Result> results = registry.runHealthChecks(executor, (name, healthCheck) -> false);
-
-        executor.shutdown();
-        executor.awaitTermination(1, TimeUnit.SECONDS);
-
-        assertThat(results).isEmpty();
-    }
-
-    @Test
-    void runsRegisteredHealthChecksInParallelWithFilter() throws Exception {
-        final ExecutorService executor = Executors.newFixedThreadPool(10);
-        final Map<String, HealthCheck.Result> results = registry.runHealthChecks(executor,
-                (name, healthCheck) -> "hc2".equals(name));
-
-        executor.shutdown();
-        executor.awaitTermination(1, TimeUnit.SECONDS);
-
-        assertThat(results).containsOnly(entry("hc2", r2));
-    }
-
-    @Test
-    void removesRegisteredHealthChecks() {
-        registry.unregister("hc1");
-
-        final Map<String, HealthCheck.Result> results = registry.runHealthChecks();
-
-        assertThat(results).doesNotContainKey("hc1");
-        assertThat(results).containsKey("hc2");
-        assertThat(results).containsKey("ahc");
-    }
-
-    @Test
-    void hasASetOfHealthCheckNames() {
-        assertThat(registry.getNames()).containsOnly("hc1", "hc2", "ahc");
-    }
+import io.dropwizard.metrics5.health.annotation.Async;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.ArgumentCaptor;
 
-    @Test
-    void runsHealthChecksByName() {
-        assertThat(registry.runHealthCheck("hc1")).isEqualTo(r1);
-    }
+final class HealthCheckRegistryTest {
+  private final ScheduledExecutorService executorService = mock();
+  private final HealthCheckRegistry registry = new HealthCheckRegistry(executorService);
+  private final HealthCheckRegistryListener listener = mock();
+
+  private final HealthCheck hc1 = mock();
+  private final HealthCheck hc2 = mock();
+
+  private final HealthCheck.Result r1 = mock();
+  private final HealthCheck.Result r2 = mock();
+
+  private final HealthCheck.Result ar = mock();
+  private final HealthCheck ahc = new TestAsyncHealthCheck(ar);
+
+  @SuppressWarnings("rawtypes")
+  private final ScheduledFuture af = mock();
+
+  @BeforeEach
+  @SuppressWarnings("unchecked")
+  void setUp() {
+    registry.addListener(listener);
+
+    when(hc1.execute()).thenReturn(r1);
+    when(hc2.execute()).thenReturn(r2);
+    when(executorService.scheduleAtFixedRate(
+            any(AsyncHealthCheckDecorator.class), eq(0L), eq(10L), eq(TimeUnit.SECONDS)))
+        .thenReturn(af);
+
+    registry.register("hc1", hc1);
+    registry.register("hc2", hc2);
+    registry.register("ahc", ahc);
+  }
+
+  @Test
+  void asyncHealthCheckIsScheduledOnExecutor() {
+    ArgumentCaptor<AsyncHealthCheckDecorator> decoratorCaptor =
+        forClass(AsyncHealthCheckDecorator.class);
+    verify(executorService)
+        .scheduleAtFixedRate(decoratorCaptor.capture(), eq(0L), eq(10L), eq(TimeUnit.SECONDS));
+    assertThat(decoratorCaptor.getValue().getHealthCheck()).isEqualTo(ahc);
+  }
+
+  @Test
+  void asyncHealthCheckIsCanceledOnRemove() {
+    registry.unregister("ahc");
+
+    verify(af).cancel(true);
+  }
+
+  @Test
+  void registeringHealthCheckTwiceThrowsException() {
+    assertThatThrownBy(
+            () -> {
+              registry.register("hc1", hc1);
+            })
+        .isInstanceOf(IllegalArgumentException.class);
+  }
+
+  @Test
+  void registeringHealthCheckTriggersNotification() {
+    verify(listener).onHealthCheckAdded("hc1", hc1);
+    verify(listener).onHealthCheckAdded("hc2", hc2);
+    verify(listener).onHealthCheckAdded(eq("ahc"), any(AsyncHealthCheckDecorator.class));
+  }
+
+  @Test
+  void removingHealthCheckTriggersNotification() {
+    registry.unregister("hc1");
+    registry.unregister("hc2");
+    registry.unregister("ahc");
+
+    verify(listener).onHealthCheckRemoved("hc1", hc1);
+    verify(listener).onHealthCheckRemoved("hc2", hc2);
+    verify(listener).onHealthCheckRemoved(eq("ahc"), any(AsyncHealthCheckDecorator.class));
+  }
+
+  @Test
+  void addingListenerCatchesExistingHealthChecks() {
+    HealthCheckRegistryListener listener = mock();
+    HealthCheckRegistry registry = new HealthCheckRegistry();
+    registry.register("hc1", hc1);
+    registry.register("hc2", hc2);
+    registry.register("ahc", ahc);
+    registry.addListener(listener);
+
+    verify(listener).onHealthCheckAdded("hc1", hc1);
+    verify(listener).onHealthCheckAdded("hc2", hc2);
+    verify(listener).onHealthCheckAdded(eq("ahc"), any(AsyncHealthCheckDecorator.class));
+  }
+
+  @Test
+  void removedListenerDoesNotReceiveUpdates() {
+    HealthCheckRegistryListener listener = mock();
+    HealthCheckRegistry registry = new HealthCheckRegistry();
+    registry.addListener(listener);
+    registry.register("hc1", hc1);
+    registry.removeListener(listener);
+    registry.register("hc2", hc2);
+
+    verify(listener).onHealthCheckAdded("hc1", hc1);
+  }
+
+  @Test
+  void runsRegisteredHealthChecks() {
+    final Map<String, HealthCheck.Result> results = registry.runHealthChecks();
+
+    assertThat(results).contains(entry("hc1", r1));
+    assertThat(results).contains(entry("hc2", r2));
+    assertThat(results).containsKey("ahc");
+  }
+
+  @Test
+  void runsRegisteredHealthChecksWithFilter() {
+    final Map<String, HealthCheck.Result> results =
+        registry.runHealthChecks((name, healthCheck) -> "hc1".equals(name));
+
+    assertThat(results).containsOnly(entry("hc1", r1));
+  }
+
+  @Test
+  void runsRegisteredHealthChecksWithNonMatchingFilter() {
+    final Map<String, HealthCheck.Result> results =
+        registry.runHealthChecks((name, healthCheck) -> false);
+
+    assertThat(results).isEmpty();
+  }
+
+  @Test
+  void runsRegisteredHealthChecksInParallel() throws Exception {
+    final ExecutorService executor = Executors.newFixedThreadPool(10);
+    final Map<String, HealthCheck.Result> results = registry.runHealthChecks(executor);
+
+    executor.shutdown();
+    executor.awaitTermination(1, TimeUnit.SECONDS);
+
+    assertThat(results).contains(entry("hc1", r1));
+    assertThat(results).contains(entry("hc2", r2));
+    assertThat(results).containsKey("ahc");
+  }
+
+  @Test
+  void runsRegisteredHealthChecksInParallelWithNonMatchingFilter() throws Exception {
+    final ExecutorService executor = Executors.newFixedThreadPool(10);
+    final Map<String, HealthCheck.Result> results =
+        registry.runHealthChecks(executor, (name, healthCheck) -> false);
+
+    executor.shutdown();
+    executor.awaitTermination(1, TimeUnit.SECONDS);
+
+    assertThat(results).isEmpty();
+  }
+
+  @Test
+  void runsRegisteredHealthChecksInParallelWithFilter() throws Exception {
+    final ExecutorService executor = Executors.newFixedThreadPool(10);
+    final Map<String, HealthCheck.Result> results =
+        registry.runHealthChecks(executor, (name, healthCheck) -> "hc2".equals(name));
+
+    executor.shutdown();
+    executor.awaitTermination(1, TimeUnit.SECONDS);
+
+    assertThat(results).containsOnly(entry("hc2", r2));
+  }
+
+  @Test
+  void removesRegisteredHealthChecks() {
+    registry.unregister("hc1");
+
+    final Map<String, HealthCheck.Result> results = registry.runHealthChecks();
+
+    assertThat(results).doesNotContainKey("hc1");
+    assertThat(results).containsKey("hc2");
+    assertThat(results).containsKey("ahc");
+  }
+
+  @Test
+  void hasASetOfHealthCheckNames() {
+    assertThat(registry.getNames()).containsOnly("hc1", "hc2", "ahc");
+  }
+
+  @Test
+  void runsHealthChecksByName() {
+    assertThat(registry.runHealthCheck("hc1")).isEqualTo(r1);
+  }
+
+  @Test
+  void doesNotRunNonexistentHealthChecks() {
+    try {
+      registry.runHealthCheck("what");
+      failBecauseExceptionWasNotThrown(NoSuchElementException.class);
+    } catch (NoSuchElementException e) {
+      assertThat(e.getMessage()).isEqualTo("No health check named what exists");
+    }
+  }
 
-    @Test
-    void doesNotRunNonexistentHealthChecks()  {
-        try {
-            registry.runHealthCheck("what");
-            failBecauseExceptionWasNotThrown(NoSuchElementException.class);
-        } catch (NoSuchElementException e) {
-            assertThat(e.getMessage())
-                    .isEqualTo("No health check named what exists");
-        }
+  @Async(period = 10)
+  private static class TestAsyncHealthCheck implements HealthCheck {
+    private final Result result;
 
+    TestAsyncHealthCheck(Result result) {
+      this.result = result;
     }
 
-    @Async(period = 10)
-    private static class TestAsyncHealthCheck implements HealthCheck {
-        private final Result result;
-
-        TestAsyncHealthCheck(Result result) {
-            this.result = result;
-        }
-
-        @Override
-        public Result check() {
-            return result;
-        }
+    @Override
+    public Result check() {
+      return result;
     }
+  }
 }
--- a/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/HealthCheckTest.java
+++ b/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/HealthCheckTest.java
@@ -1,279 +1,231 @@
 package io.dropwizard.metrics5.health;
 
-import io.dropwizard.metrics5.Clock;
-import org.junit.jupiter.api.Test;
-
-import java.time.ZonedDateTime;
-import java.time.format.DateTimeFormatter;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-class HealthCheckTest {
+import io.dropwizard.metrics5.Clock;
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+import org.junit.jupiter.api.Test;
 
-    private static final DateTimeFormatter DATE_TIME_FORMATTER =
-            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
+final class HealthCheckTest {
 
-    private static class ExampleHealthCheck implements HealthCheck {
-        private final HealthCheck underlying;
+  private static final DateTimeFormatter DATE_TIME_FORMATTER =
+      DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
 
-        private ExampleHealthCheck(HealthCheck underlying) {
-            this.underlying = underlying;
-        }
+  private static class ExampleHealthCheck implements HealthCheck {
+    private final HealthCheck underlying;
 
-        @Override
-        public Result check() {
-            return underlying.execute();
-        }
+    private ExampleHealthCheck(HealthCheck underlying) {
+      this.underlying = underlying;
     }
 
-    private final HealthCheck underlying = mock(HealthCheck.class);
-    private final HealthCheck healthCheck = new ExampleHealthCheck(underlying);
+    @Override
+    public Result check() {
+      return underlying.execute();
+    }
+  }
 
-    @Test
-    void canHaveHealthyResults() {
-        final HealthCheck.Result result = HealthCheck.Result.healthy();
+  private final HealthCheck underlying = mock();
+  private final HealthCheck healthCheck = new ExampleHealthCheck(underlying);
 
-        assertThat(result.isHealthy())
-                .isTrue();
+  @Test
+  void canHaveHealthyResults() {
+    final HealthCheck.Result result = HealthCheck.Result.healthy();
 
-        assertThat(result.getMessage())
-                .isNull();
+    assertThat(result.isHealthy()).isTrue();
 
-        assertThat(result.getError())
-                .isNull();
-    }
+    assertThat(result.getMessage()).isNull();
 
-    @Test
-    void canHaveHealthyResultsWithMessages() {
-        final HealthCheck.Result result = HealthCheck.Result.healthy("woo");
+    assertThat(result.getError()).isNull();
+  }
 
-        assertThat(result.isHealthy())
-                .isTrue();
+  @Test
+  void canHaveHealthyResultsWithMessages() {
+    final HealthCheck.Result result = HealthCheck.Result.healthy("woo");
 
-        assertThat(result.getMessage())
-                .isEqualTo("woo");
+    assertThat(result.isHealthy()).isTrue();
 
-        assertThat(result.getError())
-                .isNull();
-    }
+    assertThat(result.getMessage()).isEqualTo("woo");
 
-    @Test
-    void canHaveHealthyResultsWithFormattedMessages() {
-        final HealthCheck.Result result = HealthCheck.Result.healthy("foo %s", "bar");
+    assertThat(result.getError()).isNull();
+  }
 
-        assertThat(result.isHealthy())
-                .isTrue();
+  @Test
+  void canHaveHealthyResultsWithFormattedMessages() {
+    final HealthCheck.Result result = HealthCheck.Result.healthy("foo %s", "bar");
 
-        assertThat(result.getMessage())
-                .isEqualTo("foo bar");
+    assertThat(result.isHealthy()).isTrue();
 
-        assertThat(result.getError())
-                .isNull();
-    }
+    assertThat(result.getMessage()).isEqualTo("foo bar");
 
-    @Test
-    void canHaveUnhealthyResults() {
-        final HealthCheck.Result result = HealthCheck.Result.unhealthy("bad");
+    assertThat(result.getError()).isNull();
+  }
 
-        assertThat(result.isHealthy())
-                .isFalse();
+  @Test
+  void canHaveUnhealthyResults() {
+    final HealthCheck.Result result = HealthCheck.Result.unhealthy("bad");
 
-        assertThat(result.getMessage())
-                .isEqualTo("bad");
+    assertThat(result.isHealthy()).isFalse();
 
-        assertThat(result.getError())
-                .isNull();
-    }
+    assertThat(result.getMessage()).isEqualTo("bad");
 
-    @Test
-    void canHaveUnhealthyResultsWithFormattedMessages() {
-        final HealthCheck.Result result = HealthCheck.Result.unhealthy("foo %s %d", "bar", 123);
+    assertThat(result.getError()).isNull();
+  }
 
-        assertThat(result.isHealthy())
-                .isFalse();
+  @Test
+  void canHaveUnhealthyResultsWithFormattedMessages() {
+    final HealthCheck.Result result = HealthCheck.Result.unhealthy("foo %s %d", "bar", 123);
 
-        assertThat(result.getMessage())
-                .isEqualTo("foo bar 123");
+    assertThat(result.isHealthy()).isFalse();
 
-        assertThat(result.getError())
-                .isNull();
-    }
+    assertThat(result.getMessage()).isEqualTo("foo bar 123");
 
-    @Test
-    void canHaveUnhealthyResultsWithExceptions() {
-        final RuntimeException e = mock(RuntimeException.class);
-        when(e.getMessage()).thenReturn("oh noes");
+    assertThat(result.getError()).isNull();
+  }
 
-        final HealthCheck.Result result = HealthCheck.Result.unhealthy(e);
+  @Test
+  void canHaveUnhealthyResultsWithExceptions() {
+    final RuntimeException e = mock();
+    when(e.getMessage()).thenReturn("oh noes");
 
-        assertThat(result.isHealthy())
-                .isFalse();
+    final HealthCheck.Result result = HealthCheck.Result.unhealthy(e);
 
-        assertThat(result.getMessage())
-                .isEqualTo("oh noes");
+    assertThat(result.isHealthy()).isFalse();
 
-        assertThat(result.getError())
-                .isEqualTo(e);
-    }
+    assertThat(result.getMessage()).isEqualTo("oh noes");
 
-    @Test
-    void canHaveHealthyBuilderWithFormattedMessage() {
-        final HealthCheck.Result result = HealthCheck.Result.builder()
-                .healthy()
-                .withMessage("There are %d %s in the %s", 42, "foos", "bar")
-                .build();
+    assertThat(result.getError()).isEqualTo(e);
+  }
 
-        assertThat(result.isHealthy())
-                .isTrue();
+  @Test
+  void canHaveHealthyBuilderWithFormattedMessage() {
+    final HealthCheck.Result result =
+        HealthCheck.Result.builder()
+            .healthy()
+            .withMessage("There are %d %s in the %s", 42, "foos", "bar")
+            .build();
 
-        assertThat(result.getMessage())
-                .isEqualTo("There are 42 foos in the bar");
-    }
+    assertThat(result.isHealthy()).isTrue();
 
-    @Test
-    void canHaveHealthyBuilderWithDetail() {
-        final HealthCheck.Result result = HealthCheck.Result.builder()
-                .healthy()
-                .withDetail("detail", "value")
-                .build();
+    assertThat(result.getMessage()).isEqualTo("There are 42 foos in the bar");
+  }
 
-        assertThat(result.isHealthy())
-                .isTrue();
+  @Test
+  void canHaveHealthyBuilderWithDetail() {
+    final HealthCheck.Result result =
+        HealthCheck.Result.builder().healthy().withDetail("detail", "value").build();
 
-        assertThat(result.getMessage())
-                .isNull();
+    assertThat(result.isHealthy()).isTrue();
 
-        assertThat(result.getError())
-                .isNull();
+    assertThat(result.getMessage()).isNull();
 
-        assertThat(result.getDetails())
-                .containsEntry("detail", "value");
-    }
+    assertThat(result.getError()).isNull();
 
-    @Test
-    void canHaveUnHealthyBuilderWithDetail() {
-        final HealthCheck.Result result = HealthCheck.Result.builder()
-                .unhealthy()
-                .withDetail("detail", "value")
-                .build();
+    assertThat(result.getDetails()).containsEntry("detail", "value");
+  }
 
-        assertThat(result.isHealthy())
-                .isFalse();
+  @Test
+  void canHaveUnHealthyBuilderWithDetail() {
+    final HealthCheck.Result result =
+        HealthCheck.Result.builder().unhealthy().withDetail("detail", "value").build();
 
-        assertThat(result.getMessage())
-                .isNull();
+    assertThat(result.isHealthy()).isFalse();
 
-        assertThat(result.getError())
-                .isNull();
+    assertThat(result.getMessage()).isNull();
 
-        assertThat(result.getDetails())
-                .containsEntry("detail", "value");
-    }
+    assertThat(result.getError()).isNull();
 
-    @Test
-    void canHaveUnHealthyBuilderWithDetailAndError() {
-        final RuntimeException e = mock(RuntimeException.class);
-        when(e.getMessage()).thenReturn("oh noes");
+    assertThat(result.getDetails()).containsEntry("detail", "value");
+  }
 
-        final HealthCheck.Result result = HealthCheck.Result
-                .builder()
-                .unhealthy(e)
-                .withDetail("detail", "value")
-                .build();
+  @Test
+  void canHaveUnHealthyBuilderWithDetailAndError() {
+    final RuntimeException e = mock();
+    when(e.getMessage()).thenReturn("oh noes");
 
-        assertThat(result.isHealthy())
-                .isFalse();
+    final HealthCheck.Result result =
+        HealthCheck.Result.builder().unhealthy(e).withDetail("detail", "value").build();
 
-        assertThat(result.getMessage())
-                .isEqualTo("oh noes");
+    assertThat(result.isHealthy()).isFalse();
 
-        assertThat(result.getError())
-                .isEqualTo(e);
+    assertThat(result.getMessage()).isEqualTo("oh noes");
 
-        assertThat(result.getDetails())
-                .containsEntry("detail", "value");
-    }
+    assertThat(result.getError()).isEqualTo(e);
 
-    @Test
-    void returnsResultsWhenExecuted() {
-        final HealthCheck.Result result = mock(HealthCheck.Result.class);
-        when(underlying.execute()).thenReturn(result);
+    assertThat(result.getDetails()).containsEntry("detail", "value");
+  }
 
-        assertThat(healthCheck.execute())
-                .isEqualTo(result);
+  @Test
+  void returnsResultsWhenExecuted() {
+    final HealthCheck.Result result = mock();
+    when(underlying.execute()).thenReturn(result);
 
-        verify(result).setDuration(anyLong());
-    }
+    assertThat(healthCheck.execute()).isEqualTo(result);
 
-    @Test
-    void wrapsExceptionsWhenExecuted() {
-        final RuntimeException e = mock(RuntimeException.class);
-        when(e.getMessage()).thenReturn("oh noes");
-
-        when(underlying.execute()).thenThrow(e);
-        HealthCheck.Result actual = healthCheck.execute();
-
-        assertThat(actual.isHealthy())
-                .isFalse();
-        assertThat(actual.getMessage())
-                .isEqualTo("oh noes");
-        assertThat(actual.getError())
-                .isEqualTo(e);
-        assertThat(actual.getDetails())
-                .isNull();
-        assertThat(actual.getDuration())
-                .isGreaterThanOrEqualTo(0);
-    }
+    verify(result).setDuration(anyLong());
+  }
 
-    @Test
-    void canHaveUserSuppliedClockForTimestamp() {
-        ZonedDateTime dateTime = ZonedDateTime.now().minusMinutes(10);
-        Clock clock = clockWithFixedTime(dateTime);
+  @Test
+  void wrapsExceptionsWhenExecuted() {
+    final RuntimeException e = mock();
+    when(e.getMessage()).thenReturn("oh noes");
 
-        HealthCheck.Result result = HealthCheck.Result.builder()
-                .healthy()
-                .usingClock(clock)
-                .build();
+    when(underlying.execute()).thenThrow(e);
+    HealthCheck.Result actual = healthCheck.execute();
 
-        assertThat(result.isHealthy()).isTrue();
+    assertThat(actual.isHealthy()).isFalse();
+    assertThat(actual.getMessage()).isEqualTo("oh noes");
+    assertThat(actual.getError()).isEqualTo(e);
+    assertThat(actual.getDetails()).isNull();
+    assertThat(actual.getDuration()).isNotNegative();
+  }
 
-        assertThat(result.getTime()).isEqualTo(clock.getTime());
+  @Test
+  void canHaveUserSuppliedClockForTimestamp() {
+    ZonedDateTime dateTime = ZonedDateTime.now().minusMinutes(10);
+    Clock clock = clockWithFixedTime(dateTime);
 
-        assertThat(result.getTimestamp())
-                .isEqualTo(DATE_TIME_FORMATTER.format(dateTime));
-    }
+    HealthCheck.Result result = HealthCheck.Result.builder().healthy().usingClock(clock).build();
 
-    @Test
-    void toStringWorksEvenForNullAttributes() {
-        ZonedDateTime dateTime = ZonedDateTime.now().minusMinutes(25);
-        Clock clock = clockWithFixedTime(dateTime);
-
-        final HealthCheck.Result resultWithNullDetailValue = HealthCheck.Result.builder()
-                .unhealthy()
-                .withDetail("aNullDetail", null)
-                .usingClock(clock)
-                .build();
-        assertThat(resultWithNullDetailValue.toString())
-                .contains(
-                        "Result{isHealthy=false, duration=0, timestamp=" + DATE_TIME_FORMATTER.format(dateTime),
-                        ", aNullDetail=null}");
-    }
+    assertThat(result.isHealthy()).isTrue();
 
-    private static Clock clockWithFixedTime(ZonedDateTime dateTime) {
-        return new Clock() {
-            @Override
-            public long getTick() {
-                return 0;
-            }
-
-            @Override
-            public long getTime() {
-                return dateTime.toInstant().toEpochMilli();
-            }
-        };
-    }
+    assertThat(result.getTime()).isEqualTo(clock.getTime());
+
+    assertThat(result.getTimestamp()).isEqualTo(DATE_TIME_FORMATTER.format(dateTime));
+  }
+
+  @Test
+  void toStringWorksEvenForNullAttributes() {
+    ZonedDateTime dateTime = ZonedDateTime.now().minusMinutes(25);
+    Clock clock = clockWithFixedTime(dateTime);
+
+    final HealthCheck.Result resultWithNullDetailValue =
+        HealthCheck.Result.builder()
+            .unhealthy()
+            .withDetail("aNullDetail", null)
+            .usingClock(clock)
+            .build();
+    assertThat(resultWithNullDetailValue.toString())
+        .contains(
+            "Result{isHealthy=false, duration=0, timestamp=" + DATE_TIME_FORMATTER.format(dateTime),
+            ", aNullDetail=null}");
+  }
+
+  private static Clock clockWithFixedTime(ZonedDateTime dateTime) {
+    return new Clock() {
+      @Override
+      public long getTick() {
+        return 0;
+      }
+
+      @Override
+      public long getTime() {
+        return dateTime.toInstant().toEpochMilli();
+      }
+    };
+  }
 }
--- a/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/SharedHealthCheckRegistriesTest.java
+++ b/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/SharedHealthCheckRegistriesTest.java
@@ -1,97 +1,103 @@
 package io.dropwizard.metrics5.health;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import java.util.concurrent.atomic.AtomicReference;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-class SharedHealthCheckRegistriesTest {
-
-    @BeforeEach
-    void setUp() {
-        SharedHealthCheckRegistries.setDefaultRegistryName(new AtomicReference<>());
-        SharedHealthCheckRegistries.clear();
-    }
-
-    @Test
-    void savesCreatedRegistry() {
-        final HealthCheckRegistry one = SharedHealthCheckRegistries.getOrCreate("db");
-        final HealthCheckRegistry two = SharedHealthCheckRegistries.getOrCreate("db");
-
-        assertThat(one).isSameAs(two);
-    }
-
-    @Test
-    void returnsSetOfCreatedRegistries() {
-        SharedHealthCheckRegistries.getOrCreate("db");
-
-        assertThat(SharedHealthCheckRegistries.names()).containsOnly("db");
-    }
-
-    @Test
-    void registryCanBeRemoved() {
-        final HealthCheckRegistry first = SharedHealthCheckRegistries.getOrCreate("db");
-        SharedHealthCheckRegistries.remove("db");
-
-        assertThat(SharedHealthCheckRegistries.names()).isEmpty();
-        assertThat(SharedHealthCheckRegistries.getOrCreate("db")).isNotEqualTo(first);
-    }
-
-    @Test
-    void registryCanBeCleared() {
-        SharedHealthCheckRegistries.getOrCreate("db");
-        SharedHealthCheckRegistries.getOrCreate("web");
 
-        SharedHealthCheckRegistries.clear();
-
-        assertThat(SharedHealthCheckRegistries.names()).isEmpty();
-    }
-
-    @Test
-    void defaultRegistryIsNotSetByDefault() {
-        Throwable exception = assertThrows(IllegalStateException.class, () -> {
-
-            SharedHealthCheckRegistries.getDefault();
-        });
-        assertTrue(exception.getMessage().contains("Default registry name has not been set."));
-    }
-
-    @Test
-    void defaultRegistryCanBeSet() {
-        HealthCheckRegistry registry = SharedHealthCheckRegistries.setDefault("default");
-
-        assertThat(SharedHealthCheckRegistries.getDefault()).isEqualTo(registry);
-    }
-
-    @Test
-    void specificRegistryCanBeSetAsDefault() {
-        HealthCheckRegistry registry = new HealthCheckRegistry();
-        SharedHealthCheckRegistries.setDefault("default", registry);
-
-        assertThat(SharedHealthCheckRegistries.getDefault()).isEqualTo(registry);
-    }
-
-    @Test
-    void unableToSetDefaultRegistryTwice() {
-        Throwable exception = assertThrows(IllegalStateException.class, () -> {
-
-            SharedHealthCheckRegistries.setDefault("default");
-            SharedHealthCheckRegistries.setDefault("default");
-        });
-        assertTrue(exception.getMessage().contains("Default health check registry is already set."));
-    }
-
-    @Test
-    void unableToSetCustomDefaultRegistryTwice() {
-        Throwable exception = assertThrows(IllegalStateException.class, () -> {
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-            SharedHealthCheckRegistries.setDefault("default", new HealthCheckRegistry());
-            SharedHealthCheckRegistries.setDefault("default", new HealthCheckRegistry());
-        });
-        assertTrue(exception.getMessage().contains("Default health check registry is already set."));
-    }
+final class SharedHealthCheckRegistriesTest {
+
+  @BeforeEach
+  void setUp() {
+    SharedHealthCheckRegistries.setDefaultRegistryName(new AtomicReference<>());
+    SharedHealthCheckRegistries.clear();
+  }
+
+  @Test
+  void savesCreatedRegistry() {
+    final HealthCheckRegistry one = SharedHealthCheckRegistries.getOrCreate("db");
+    final HealthCheckRegistry two = SharedHealthCheckRegistries.getOrCreate("db");
+
+    assertThat(one).isSameAs(two);
+  }
+
+  @Test
+  void returnsSetOfCreatedRegistries() {
+    SharedHealthCheckRegistries.getOrCreate("db");
+
+    assertThat(SharedHealthCheckRegistries.names()).containsExactly("db");
+  }
+
+  @Test
+  void registryCanBeRemoved() {
+    final HealthCheckRegistry first = SharedHealthCheckRegistries.getOrCreate("db");
+    SharedHealthCheckRegistries.remove("db");
+
+    assertThat(SharedHealthCheckRegistries.names()).isEmpty();
+    assertThat(SharedHealthCheckRegistries.getOrCreate("db")).isNotEqualTo(first);
+  }
+
+  @Test
+  void registryCanBeCleared() {
+    SharedHealthCheckRegistries.getOrCreate("db");
+    SharedHealthCheckRegistries.getOrCreate("web");
+
+    SharedHealthCheckRegistries.clear();
+
+    assertThat(SharedHealthCheckRegistries.names()).isEmpty();
+  }
+
+  @Test
+  void defaultRegistryIsNotSetByDefault() {
+    Throwable exception =
+        assertThrows(
+            IllegalStateException.class,
+            () -> {
+              SharedHealthCheckRegistries.getDefault();
+            });
+    assertThat(exception.getMessage().contains("Default registry name has not been set.")).isTrue();
+  }
+
+  @Test
+  void defaultRegistryCanBeSet() {
+    HealthCheckRegistry registry = SharedHealthCheckRegistries.setDefault("default");
+
+    assertThat(SharedHealthCheckRegistries.getDefault()).isEqualTo(registry);
+  }
+
+  @Test
+  void specificRegistryCanBeSetAsDefault() {
+    HealthCheckRegistry registry = new HealthCheckRegistry();
+    SharedHealthCheckRegistries.setDefault("default", registry);
+
+    assertThat(SharedHealthCheckRegistries.getDefault()).isEqualTo(registry);
+  }
+
+  @Test
+  void unableToSetDefaultRegistryTwice() {
+    Throwable exception =
+        assertThrows(
+            IllegalStateException.class,
+            () -> {
+              SharedHealthCheckRegistries.setDefault("default");
+              SharedHealthCheckRegistries.setDefault("default");
+            });
+    assertThat(exception.getMessage().contains("Default health check registry is already set."))
+        .isTrue();
+  }
+
+  @Test
+  void unableToSetCustomDefaultRegistryTwice() {
+    Throwable exception =
+        assertThrows(
+            IllegalStateException.class,
+            () -> {
+              SharedHealthCheckRegistries.setDefault("default", new HealthCheckRegistry());
+              SharedHealthCheckRegistries.setDefault("default", new HealthCheckRegistry());
+            });
+    assertThat(exception.getMessage().contains("Default health check registry is already set."))
+        .isTrue();
+  }
 }
--- a/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/jvm/ThreadDeadlockHealthCheckTest.java
+++ b/metrics-healthchecks/src/test/java/io/dropwizard/metrics5/health/jvm/ThreadDeadlockHealthCheckTest.java
@@ -1,54 +1,48 @@
 package io.dropwizard.metrics5.health.jvm;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.ImmutableSet;
 import io.dropwizard.metrics5.health.HealthCheck;
 import io.dropwizard.metrics5.jvm.ThreadDeadlockDetector;
-import org.assertj.core.api.Assertions;
-import org.junit.jupiter.api.Test;
-
-import java.util.Collections;
 import java.util.Set;
 import java.util.TreeSet;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-class ThreadDeadlockHealthCheckTest {
-    @Test
-    void isHealthyIfNoThreadsAreDeadlocked() {
-        final ThreadDeadlockDetector detector = mock(ThreadDeadlockDetector.class);
-        final ThreadDeadlockHealthCheck healthCheck = new ThreadDeadlockHealthCheck(detector);
+final class ThreadDeadlockHealthCheckTest {
+  @Test
+  void isHealthyIfNoThreadsAreDeadlocked() {
+    final ThreadDeadlockDetector detector = mock();
+    final ThreadDeadlockHealthCheck healthCheck = new ThreadDeadlockHealthCheck(detector);
 
-        when(detector.getDeadlockedThreads()).thenReturn(Collections.emptySet());
+    when(detector.getDeadlockedThreads()).thenReturn(ImmutableSet.of());
 
-        Assertions.assertThat(healthCheck.execute().isHealthy())
-                .isTrue();
-    }
+    assertThat(healthCheck.execute().isHealthy()).isTrue();
+  }
 
-    @Test
-    void isUnhealthyIfThreadsAreDeadlocked() {
-        final Set<String> threads = new TreeSet<>();
-        threads.add("one");
-        threads.add("two");
+  @Test
+  void isUnhealthyIfThreadsAreDeadlocked() {
+    final Set<String> threads = new TreeSet<>();
+    threads.add("one");
+    threads.add("two");
 
-        final ThreadDeadlockDetector detector = mock(ThreadDeadlockDetector.class);
-        final ThreadDeadlockHealthCheck healthCheck = new ThreadDeadlockHealthCheck(detector);
+    final ThreadDeadlockDetector detector = mock();
+    final ThreadDeadlockHealthCheck healthCheck = new ThreadDeadlockHealthCheck(detector);
 
-        when(detector.getDeadlockedThreads()).thenReturn(threads);
+    when(detector.getDeadlockedThreads()).thenReturn(threads);
 
-        final HealthCheck.Result result = healthCheck.execute();
+    final HealthCheck.Result result = healthCheck.execute();
 
-        assertThat(result.isHealthy())
-                .isFalse();
+    assertThat(result.isHealthy()).isFalse();
 
-        assertThat(result.getMessage())
-                .isEqualTo("[one, two]");
-    }
+    assertThat(result.getMessage()).isEqualTo("[one, two]");
+  }
 
-    @Test
-    void automaticallyUsesThePlatformThreadBeans() {
-        final ThreadDeadlockHealthCheck healthCheck = new ThreadDeadlockHealthCheck();
-        Assertions.assertThat(healthCheck.execute().isHealthy())
-                .isTrue();
-    }
+  @Test
+  void automaticallyUsesThePlatformThreadBeans() {
+    final ThreadDeadlockHealthCheck healthCheck = new ThreadDeadlockHealthCheck();
+    assertThat(healthCheck.execute().isHealthy()).isTrue();
+  }
 }
--- a/metrics-httpasyncclient/src/main/java/io/dropwizard/metrics5/httpasyncclient/InstrumentedNClientConnManager.java
+++ b/metrics-httpasyncclient/src/main/java/io/dropwizard/metrics5/httpasyncclient/InstrumentedNClientConnManager.java
@@ -1,6 +1,9 @@
 package io.dropwizard.metrics5.httpasyncclient;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.MetricRegistry;
+import java.util.concurrent.TimeUnit;
 import org.apache.http.config.Registry;
 import org.apache.http.conn.DnsResolver;
 import org.apache.http.conn.SchemePortResolver;
@@ -11,26 +14,41 @@ import org.apache.http.nio.conn.NHttpConnectionFactory;
 import org.apache.http.nio.conn.SchemeIOSessionStrategy;
 import org.apache.http.nio.reactor.ConnectingIOReactor;
 
-import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 public class InstrumentedNClientConnManager extends PoolingNHttpClientConnectionManager {
 
-    public InstrumentedNClientConnManager(final ConnectingIOReactor ioreactor, final NHttpConnectionFactory<ManagedNHttpClientConnection> connFactory, final SchemePortResolver schemePortResolver, final MetricRegistry metricRegistry, final Registry<SchemeIOSessionStrategy> iosessionFactoryRegistry, final long timeToLive, final TimeUnit tunit, final DnsResolver dnsResolver, final String name) {
-        super(ioreactor, connFactory, iosessionFactoryRegistry, schemePortResolver, dnsResolver, timeToLive, tunit);
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(NHttpClientConnectionManager.class, name, "available-connections"),
-                () -> getTotalStats().getAvailable());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(NHttpClientConnectionManager.class, name, "leased-connections"),
-                () -> getTotalStats().getLeased());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(NHttpClientConnectionManager.class, name, "max-connections"),
-                () -> getTotalStats().getMax());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(NHttpClientConnectionManager.class, name, "pending-connections"),
-                () -> getTotalStats().getPending());
-    }
-
+  public InstrumentedNClientConnManager(
+      final ConnectingIOReactor ioreactor,
+      final NHttpConnectionFactory<ManagedNHttpClientConnection> connFactory,
+      final SchemePortResolver schemePortResolver,
+      final MetricRegistry metricRegistry,
+      final Registry<SchemeIOSessionStrategy> iosessionFactoryRegistry,
+      final long timeToLive,
+      final TimeUnit tunit,
+      final DnsResolver dnsResolver,
+      final String name) {
+    super(
+        ioreactor,
+        connFactory,
+        iosessionFactoryRegistry,
+        schemePortResolver,
+        dnsResolver,
+        timeToLive,
+        tunit);
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(NHttpClientConnectionManager.class, name, "available-connections"),
+        () -> getTotalStats().getAvailable());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(NHttpClientConnectionManager.class, name, "leased-connections"),
+        () -> getTotalStats().getLeased());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(NHttpClientConnectionManager.class, name, "max-connections"),
+        () -> getTotalStats().getMax());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(NHttpClientConnectionManager.class, name, "pending-connections"),
+        () -> getTotalStats().getPending());
+  }
 }
--- a/metrics-httpasyncclient/src/main/java/io/dropwizard/metrics5/httpasyncclient/InstrumentedNHttpClientBuilder.java
+++ b/metrics-httpasyncclient/src/main/java/io/dropwizard/metrics5/httpasyncclient/InstrumentedNHttpClientBuilder.java
@@ -1,10 +1,14 @@
 package io.dropwizard.metrics5.httpasyncclient;
 
+import static java.util.Objects.requireNonNull;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies;
 import io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategy;
+import java.io.IOException;
+import java.util.concurrent.Future;
 import org.apache.http.HttpException;
 import org.apache.http.HttpRequest;
 import org.apache.http.concurrent.FutureCallback;
@@ -14,107 +18,109 @@ import org.apache.http.nio.protocol.HttpAsyncRequestProducer;
 import org.apache.http.nio.protocol.HttpAsyncResponseConsumer;
 import org.apache.http.protocol.HttpContext;
 
-import java.io.IOException;
-import java.util.concurrent.Future;
-
-import static java.util.Objects.requireNonNull;
-
 public class InstrumentedNHttpClientBuilder extends HttpAsyncClientBuilder {
-    private final MetricRegistry metricRegistry;
-    private final String name;
-    private final HttpClientMetricNameStrategy metricNameStrategy;
-
-    public InstrumentedNHttpClientBuilder(MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy, String name) {
-        super();
-        this.metricRegistry = metricRegistry;
-        this.metricNameStrategy = metricNameStrategy;
-        this.name = name;
-    }
-
-    public InstrumentedNHttpClientBuilder(MetricRegistry metricRegistry) {
-        this(metricRegistry, HttpClientMetricNameStrategies.METHOD_ONLY, null);
-    }
-
-    public InstrumentedNHttpClientBuilder(MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy) {
-        this(metricRegistry, metricNameStrategy, null);
-    }
-
-    public InstrumentedNHttpClientBuilder(MetricRegistry metricRegistry, String name) {
-        this(metricRegistry, HttpClientMetricNameStrategies.METHOD_ONLY, name);
+  private final MetricRegistry metricRegistry;
+  private final String name;
+  private final HttpClientMetricNameStrategy metricNameStrategy;
+
+  public InstrumentedNHttpClientBuilder(
+      MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy, String name) {
+    super();
+    this.metricRegistry = metricRegistry;
+    this.metricNameStrategy = metricNameStrategy;
+    this.name = name;
+  }
+
+  public InstrumentedNHttpClientBuilder(MetricRegistry metricRegistry) {
+    this(metricRegistry, HttpClientMetricNameStrategies.METHOD_ONLY, null);
+  }
+
+  public InstrumentedNHttpClientBuilder(
+      MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy) {
+    this(metricRegistry, metricNameStrategy, null);
+  }
+
+  public InstrumentedNHttpClientBuilder(MetricRegistry metricRegistry, String name) {
+    this(metricRegistry, HttpClientMetricNameStrategies.METHOD_ONLY, name);
+  }
+
+  private Timer timer(HttpRequest request) {
+    MetricName nameFor = metricNameStrategy.getNameFor(name, request);
+    return metricRegistry.timer(nameFor);
+  }
+
+  @Override
+  public CloseableHttpAsyncClient build() {
+    final CloseableHttpAsyncClient ac = super.build();
+    return new CloseableHttpAsyncClient() {
+
+      @Override
+      public boolean isRunning() {
+        return ac.isRunning();
+      }
+
+      @Override
+      public void start() {
+        ac.start();
+      }
+
+      @Override
+      public <T> Future<T> execute(
+          HttpAsyncRequestProducer requestProducer,
+          HttpAsyncResponseConsumer<T> responseConsumer,
+          HttpContext context,
+          FutureCallback<T> callback) {
+        final Timer.Context timerContext;
+        try {
+          timerContext = timer(requestProducer.generateRequest()).time();
+        } catch (IOException | HttpException ex) {
+          throw new RuntimeException(ex);
+        }
+        return ac.execute(
+            requestProducer,
+            responseConsumer,
+            context,
+            new TimingFutureCallback<>(callback, timerContext));
+      }
+
+      @Override
+      public void close() throws IOException {
+        ac.close();
+      }
+    };
+  }
+
+  private static class TimingFutureCallback<T> implements FutureCallback<T> {
+    private final FutureCallback<T> callback;
+    private final Timer.Context timerContext;
+
+    private TimingFutureCallback(FutureCallback<T> callback, Timer.Context timerContext) {
+      this.callback = callback;
+      this.timerContext = requireNonNull(timerContext, "timerContext");
     }
 
-    private Timer timer(HttpRequest request) {
-        MetricName nameFor = metricNameStrategy.getNameFor(name, request);
-        return metricRegistry.timer(nameFor);
+    @Override
+    public void completed(T result) {
+      timerContext.stop();
+      if (callback != null) {
+        callback.completed(result);
+      }
     }
 
     @Override
-    public CloseableHttpAsyncClient build() {
-        final CloseableHttpAsyncClient ac = super.build();
-        return new CloseableHttpAsyncClient() {
-
-            @Override
-            public boolean isRunning() {
-                return ac.isRunning();
-            }
-
-            @Override
-            public void start() {
-                ac.start();
-            }
-
-            @Override
-            public <T> Future<T> execute(HttpAsyncRequestProducer requestProducer, HttpAsyncResponseConsumer<T> responseConsumer, HttpContext context, FutureCallback<T> callback) {
-                final Timer.Context timerContext;
-                try {
-                    timerContext = timer(requestProducer.generateRequest()).time();
-                } catch (IOException | HttpException ex) {
-                    throw new RuntimeException(ex);
-                }
-                return ac.execute(requestProducer, responseConsumer, context,
-                        new TimingFutureCallback<>(callback, timerContext));
-            }
-
-            @Override
-            public void close() throws IOException {
-                ac.close();
-            }
-        };
+    public void failed(Exception ex) {
+      timerContext.stop();
+      if (callback != null) {
+        callback.failed(ex);
+      }
     }
 
-    private static class TimingFutureCallback<T> implements FutureCallback<T> {
-        private final FutureCallback<T> callback;
-        private final Timer.Context timerContext;
-
-        private TimingFutureCallback(FutureCallback<T> callback,
-                                     Timer.Context timerContext) {
-            this.callback = callback;
-            this.timerContext = requireNonNull(timerContext, "timerContext");
-        }
-
-        @Override
-        public void completed(T result) {
-            timerContext.stop();
-            if (callback != null) {
-                callback.completed(result);
-            }
-        }
-
-        @Override
-        public void failed(Exception ex) {
-            timerContext.stop();
-            if (callback != null) {
-                callback.failed(ex);
-            }
-        }
-
-        @Override
-        public void cancelled() {
-            timerContext.stop();
-            if (callback != null) {
-                callback.cancelled();
-            }
-        }
+    @Override
+    public void cancelled() {
+      timerContext.stop();
+      if (callback != null) {
+        callback.cancelled();
+      }
     }
-
+  }
 }
--- a/metrics-httpasyncclient/src/test/java/io/dropwizard/metrics5/httpasyncclient/HttpClientTestBase.java
+++ b/metrics-httpasyncclient/src/test/java/io/dropwizard/metrics5/httpasyncclient/HttpClientTestBase.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.httpasyncclient;
 
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.util.concurrent.TimeUnit;
 import org.apache.http.HttpHost;
 import org.apache.http.impl.nio.bootstrap.HttpServer;
 import org.apache.http.impl.nio.bootstrap.ServerBootstrap;
@@ -8,64 +12,59 @@ import org.apache.http.nio.reactor.ListenerEndpoint;
 import org.apache.http.protocol.HttpRequestHandler;
 import org.junit.jupiter.api.AfterEach;
 
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import java.util.concurrent.TimeUnit;
-
 public abstract class HttpClientTestBase {
 
-    /**
-     * {@link HttpRequestHandler} that responds with a {@code 200 OK}.
-     */
-    public static final HttpRequestHandler STATUS_OK = (request, response, context) -> response.setStatusCode(200);
+  /** {@link HttpRequestHandler} that responds with a {@code 200 OK}. */
+  public static final HttpRequestHandler STATUS_OK =
+      (request, response, context) -> response.setStatusCode(200);
 
-    private HttpServer server;
+  private HttpServer server;
 
-    /**
-     * @return A free local port or {@code -1} on error.
-     */
-    public static int findAvailableLocalPort() {
-        try (ServerSocket socket = new ServerSocket(0)) {
-            return socket.getLocalPort();
-        } catch (IOException e) {
-            return -1;
-        }
+  /**
+   * @return A free local port or {@code -1} on error.
+   */
+  public static int findAvailableLocalPort() {
+    try (ServerSocket socket = new ServerSocket(0)) {
+      return socket.getLocalPort();
+    } catch (IOException e) {
+      return -1;
     }
+  }
 
-    /**
-     * Start a local server that uses the {@code handler} to handle requests.
-     * <p>
-     * The server will be (if started) terminated in the {@link #tearDown()} {@link AfterEach} method.
-     *
-     * @param handler The request handler that will be used to respond to every request.
-     * @return The {@link HttpHost} of the server
-     * @throws IOException          in case it's not possible to start the server
-     * @throws InterruptedException in case the server's main thread was interrupted
-     */
-    public HttpHost startServerWithGlobalRequestHandler(HttpRequestHandler handler)
-            throws IOException, InterruptedException {
-        // If there is an existing instance, terminate it
-        tearDown();
+  /**
+   * Start a local server that uses the {@code handler} to handle requests.
+   *
+   * <p>The server will be (if started) terminated in the {@link #tearDown()} {@link AfterEach}
+   * method.
+   *
+   * @param handler The request handler that will be used to respond to every request.
+   * @return The {@link HttpHost} of the server
+   * @throws IOException in case it's not possible to start the server
+   * @throws InterruptedException in case the server's main thread was interrupted
+   */
+  public HttpHost startServerWithGlobalRequestHandler(HttpRequestHandler handler)
+      throws IOException, InterruptedException {
+    // If there is an existing instance, terminate it
+    tearDown();
 
-        ServerBootstrap serverBootstrap = ServerBootstrap.bootstrap();
+    ServerBootstrap serverBootstrap = ServerBootstrap.bootstrap();
 
-        serverBootstrap.registerHandler("/*", new BasicAsyncRequestHandler(handler));
+    serverBootstrap.registerHandler("/*", new BasicAsyncRequestHandler(handler));
 
-        server = serverBootstrap.create();
-        server.start();
+    server = serverBootstrap.create();
+    server.start();
 
-        ListenerEndpoint endpoint = server.getEndpoint();
-        endpoint.waitFor();
+    ListenerEndpoint endpoint = server.getEndpoint();
+    endpoint.waitFor();
 
-        InetSocketAddress address = (InetSocketAddress) endpoint.getAddress();
-        return new HttpHost("localhost", address.getPort(), "http");
-    }
+    InetSocketAddress address = (InetSocketAddress) endpoint.getAddress();
+    return new HttpHost("localhost", address.getPort(), "http");
+  }
 
-    @AfterEach
-    public void tearDown() {
-        if (server != null) {
-            server.shutdown(5, TimeUnit.SECONDS);
-        }
+  @AfterEach
+  public void tearDown() {
+    if (server != null) {
+      server.shutdown(5, TimeUnit.SECONDS);
     }
+  }
 }
--- a/metrics-httpasyncclient/src/test/java/io/dropwizard/metrics5/httpasyncclient/InstrumentedHttpClientsTest.java
+++ b/metrics-httpasyncclient/src/test/java/io/dropwizard/metrics5/httpasyncclient/InstrumentedHttpClientsTest.java
@@ -1,5 +1,10 @@
 package io.dropwizard.metrics5.httpasyncclient;
 
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricRegistryListener;
@@ -16,43 +21,34 @@ import org.junit.jupiter.api.extension.ExtendWith;
 import org.mockito.Mock;
 import org.mockito.junit.jupiter.MockitoExtension;
 
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-
 @ExtendWith(MockitoExtension.class)
-class InstrumentedHttpClientsTest extends HttpClientTestBase {
-
-    private final MetricRegistry metricRegistry = new MetricRegistry();
+final class InstrumentedHttpClientsTest extends HttpClientTestBase {
 
+  private final MetricRegistry metricRegistry = new MetricRegistry();
 
-    private HttpAsyncClient asyncHttpClient;
-    @Mock
-    private HttpClientMetricNameStrategy metricNameStrategy;
-    @Mock
-    private MetricRegistryListener registryListener;
+  private HttpAsyncClient asyncHttpClient;
+  @Mock private HttpClientMetricNameStrategy metricNameStrategy;
+  @Mock private MetricRegistryListener registryListener;
 
-    @Test
-    void registersExpectedMetricsGivenNameStrategy() throws Exception {
-        HttpHost host = startServerWithGlobalRequestHandler(STATUS_OK);
-        final HttpGet get = new HttpGet("/q=anything");
-        final MetricName metricName = MetricName.build("some.made.up.metric.name");
+  @Test
+  void registersExpectedMetricsGivenNameStrategy() throws Exception {
+    HttpHost host = startServerWithGlobalRequestHandler(STATUS_OK);
+    final HttpGet get = new HttpGet("/q=anything");
+    final MetricName metricName = MetricName.build("some.made.up.metric.name");
 
-        when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
-        .thenReturn(metricName);
+    when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class))).thenReturn(metricName);
 
-        asyncHttpClient.execute(host, get, null).get();
+    asyncHttpClient.execute(host, get, null).get();
 
-        verify(registryListener).onTimerAdded(eq(metricName), any(Timer.class));
-    }
+    verify(registryListener).onTimerAdded(eq(metricName), any(Timer.class));
+  }
 
-    @BeforeEach
-    void setUp() throws Exception {
-        CloseableHttpAsyncClient chac = new InstrumentedNHttpClientBuilder(metricRegistry, metricNameStrategy).build();
-        chac.start();
-        asyncHttpClient = chac;
-        metricRegistry.addListener(registryListener);
-    }
+  @BeforeEach
+  void setUp() throws Exception {
+    CloseableHttpAsyncClient chac =
+        new InstrumentedNHttpClientBuilder(metricRegistry, metricNameStrategy).build();
+    chac.start();
+    asyncHttpClient = chac;
+    metricRegistry.addListener(registryListener);
+  }
 }
--- a/metrics-httpasyncclient/src/test/java/io/dropwizard/metrics5/httpasyncclient/InstrumentedHttpClientsTimerTest.java
+++ b/metrics-httpasyncclient/src/test/java/io/dropwizard/metrics5/httpasyncclient/InstrumentedHttpClientsTimerTest.java
@@ -1,8 +1,19 @@
 package io.dropwizard.metrics5.httpasyncclient;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.timeout;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
 import org.apache.http.HttpHost;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
@@ -16,119 +27,105 @@ import org.junit.jupiter.api.extension.ExtendWith;
 import org.mockito.Mock;
 import org.mockito.junit.jupiter.MockitoExtension;
 
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.timeout;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @ExtendWith(MockitoExtension.class)
 @Disabled("The tests are flaky")
-class InstrumentedHttpClientsTimerTest extends HttpClientTestBase {
+final class InstrumentedHttpClientsTimerTest extends HttpClientTestBase {
 
-    private HttpAsyncClient asyncHttpClient;
+  private HttpAsyncClient asyncHttpClient;
 
-    @Mock
-    private Timer.Context context;
+  @Mock private Timer.Context context;
 
-    @Mock
-    private MetricRegistry metricRegistry;
+  @Mock private MetricRegistry metricRegistry;
 
+  @BeforeEach
+  void setUp() throws Exception {
+    CloseableHttpAsyncClient chac =
+        new InstrumentedNHttpClientBuilder(
+                metricRegistry, (name, request) -> MetricName.build("test"))
+            .build();
+    chac.start();
+    asyncHttpClient = chac;
 
-    @BeforeEach
-    void setUp() throws Exception {
-        CloseableHttpAsyncClient chac = new InstrumentedNHttpClientBuilder(metricRegistry,
-        (name, request) -> MetricName.build("test")).build();
-        chac.start();
-        asyncHttpClient = chac;
+    Timer timer = mock();
+    when(timer.time()).thenReturn(context);
+    when(metricRegistry.timer(MetricName.build("test"))).thenReturn(timer);
+  }
 
-        Timer timer = mock(Timer.class);
-        when(timer.time()).thenReturn(context);
-        when(metricRegistry.timer(MetricName.build("test"))).thenReturn(timer);
-    }
+  @Test
+  void timerIsStoppedCorrectly() throws Exception {
+    HttpHost host = startServerWithGlobalRequestHandler(STATUS_OK);
+    HttpGet get = new HttpGet("/?q=anything");
 
-    @Test
-    void timerIsStoppedCorrectly() throws Exception {
-        HttpHost host = startServerWithGlobalRequestHandler(STATUS_OK);
-        HttpGet get = new HttpGet("/?q=anything");
+    // Timer hasn't been stopped prior to executing the request
+    verify(context, never()).stop();
 
-        // Timer hasn't been stopped prior to executing the request
-        verify(context, never()).stop();
+    Future<HttpResponse> responseFuture = asyncHttpClient.execute(host, get, null);
 
-        Future<HttpResponse> responseFuture = asyncHttpClient.execute(host, get, null);
+    // Timer should still be running
+    verify(context, never()).stop();
 
-        // Timer should still be running
-        verify(context, never()).stop();
+    responseFuture.get(20, TimeUnit.SECONDS);
 
-        responseFuture.get(20, TimeUnit.SECONDS);
+    // After the computation is complete timer must be stopped
+    // Materialzing the future and calling the future callback is not an atomic operation so
+    // we need to wait for callback to succeed
+    verify(context, timeout(200).times(1)).stop();
+  }
 
-        // After the computation is complete timer must be stopped
-        // Materialzing the future and calling the future callback is not an atomic operation so
-        // we need to wait for callback to succeed
-        verify(context, timeout(200).times(1)).stop();
-    }
+  @SuppressWarnings("unchecked")
+  @Test
+  void timerIsStoppedCorrectlyWithProvidedFutureCallbackCompleted() throws Exception {
+    HttpHost host = startServerWithGlobalRequestHandler(STATUS_OK);
+    HttpGet get = new HttpGet("/?q=something");
 
-    @Test
-    @SuppressWarnings("unchecked")
-    void timerIsStoppedCorrectlyWithProvidedFutureCallbackCompleted() throws Exception {
-        HttpHost host = startServerWithGlobalRequestHandler(STATUS_OK);
-        HttpGet get = new HttpGet("/?q=something");
+    FutureCallback<HttpResponse> futureCallback = mock();
 
-        FutureCallback<HttpResponse> futureCallback = mock(FutureCallback.class);
+    // Timer hasn't been stopped prior to executing the request
+    verify(context, never()).stop();
 
-        // Timer hasn't been stopped prior to executing the request
-        verify(context, never()).stop();
+    Future<HttpResponse> responseFuture = asyncHttpClient.execute(host, get, futureCallback);
 
-        Future<HttpResponse> responseFuture = asyncHttpClient.execute(host, get, futureCallback);
+    // Timer should still be running
+    verify(context, never()).stop();
 
-        // Timer should still be running
-        verify(context, never()).stop();
+    responseFuture.get(20, TimeUnit.SECONDS);
 
-        responseFuture.get(20, TimeUnit.SECONDS);
+    // Callback must have been called
+    assertThat(responseFuture.isDone()).isTrue();
+    // After the computation is complete timer must be stopped
+    // Materialzing the future and calling the future callback is not an atomic operation so
+    // we need to wait for callback to succeed
+    verify(futureCallback, timeout(200).times(1)).completed(any(HttpResponse.class));
+    verify(context, timeout(200).times(1)).stop();
+  }
 
-        // Callback must have been called
-        assertThat(responseFuture.isDone()).isTrue();
-        // After the computation is complete timer must be stopped
-        // Materialzing the future and calling the future callback is not an atomic operation so
-        // we need to wait for callback to succeed
-        verify(futureCallback, timeout(200).times(1)).completed(any(HttpResponse.class));
-        verify(context, timeout(200).times(1)).stop();
-    }
+  @SuppressWarnings("unchecked")
+  @Test
+  void timerIsStoppedCorrectlyWithProvidedFutureCallbackFailed() throws Exception {
+    // There should be nothing listening on this port
+    HttpHost host = HttpHost.create(String.format("http://127.0.0.1:%d", findAvailableLocalPort()));
+    HttpGet get = new HttpGet("/?q=something");
 
-    @Test
-    @SuppressWarnings("unchecked")
-    void timerIsStoppedCorrectlyWithProvidedFutureCallbackFailed() throws Exception {
-        // There should be nothing listening on this port
-        HttpHost host = HttpHost.create(String.format("http://127.0.0.1:%d", findAvailableLocalPort()));
-        HttpGet get = new HttpGet("/?q=something");
-
-        FutureCallback<HttpResponse> futureCallback = mock(FutureCallback.class);
-
-        // Timer hasn't been stopped prior to executing the request
-        verify(context, never()).stop();
-
-        Future<HttpResponse> responseFuture = asyncHttpClient.execute(host, get, futureCallback);
-
-        // Timer should still be running
-        verify(context, never()).stop();
-
-        try {
-            responseFuture.get(20, TimeUnit.SECONDS);
-            fail("This should fail as the client should not be able to connect");
-        } catch (Exception e) {
-            // Ignore
-        }
-        // After the computation is complete timer must be stopped
-        // Materialzing the future and calling the future callback is not an atomic operation so
-        // we need to wait for callback to succeed
-        verify(futureCallback, timeout(200).times(1)).failed(any(Exception.class));
-        verify(context, timeout(200).times(1)).stop();
-    }
+    FutureCallback<HttpResponse> futureCallback = mock();
+
+    // Timer hasn't been stopped prior to executing the request
+    verify(context, never()).stop();
 
+    Future<HttpResponse> responseFuture = asyncHttpClient.execute(host, get, futureCallback);
+
+    // Timer should still be running
+    verify(context, never()).stop();
+
+    try {
+      responseFuture.get(20, TimeUnit.SECONDS);
+      fail("This should fail as the client should not be able to connect");
+    } catch (Exception e) {
+      // Ignore
+    }
+    // After the computation is complete timer must be stopped
+    // Materialzing the future and calling the future callback is not an atomic operation so
+    // we need to wait for callback to succeed
+    verify(futureCallback, timeout(200).times(1)).failed(any(Exception.class));
+    verify(context, timeout(200).times(1)).stop();
+  }
 }
--- a/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/HttpClientMetricNameStrategies.java
+++ b/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/HttpClientMetricNameStrategies.java
@@ -1,61 +1,54 @@
 package io.dropwizard.metrics5.httpclient;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
+import java.net.URI;
+import java.net.URISyntaxException;
 import org.apache.http.HttpRequest;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.methods.HttpRequestWrapper;
 import org.apache.http.client.methods.HttpUriRequest;
 import org.apache.http.client.utils.URIBuilder;
 
-import java.net.URI;
-import java.net.URISyntaxException;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 public class HttpClientMetricNameStrategies {
 
-    public static final HttpClientMetricNameStrategy METHOD_ONLY =
-        (name, request) -> name(HttpClient.class,
-            name,
-            methodNameString(request));
-
-    public static final HttpClientMetricNameStrategy HOST_AND_METHOD =
-        (name, request) -> name(HttpClient.class,
-            name,
-            requestURI(request).getHost(),
-            methodNameString(request));
-
-    public static final HttpClientMetricNameStrategy PATH_AND_METHOD =
-        (name, request) -> {
-            final URIBuilder url = new URIBuilder(requestURI(request));
-            return name(HttpClient.class,
-                name,
-                url.getPath(),
-                methodNameString(request));
-        };
-
-    public static final HttpClientMetricNameStrategy QUERYLESS_URL_AND_METHOD =
-        (name, request) -> {
-            try {
-                final URIBuilder url = new URIBuilder(requestURI(request));
-                return name(HttpClient.class,
-                    name,
-                    url.removeQuery().build().toString(),
-                    methodNameString(request));
-            } catch (URISyntaxException e) {
-                throw new IllegalArgumentException(e);
-            }
-        };
-
-    private static String methodNameString(HttpRequest request) {
-        return request.getRequestLine().getMethod().toLowerCase() + "-requests";
-    }
-
-    private static URI requestURI(HttpRequest request) {
-        if (request instanceof HttpRequestWrapper)
-            return requestURI(((HttpRequestWrapper) request).getOriginal());
-
-        return (request instanceof HttpUriRequest) ?
-            ((HttpUriRequest) request).getURI() :
-            URI.create(request.getRequestLine().getUri());
-    }
+  public static final HttpClientMetricNameStrategy METHOD_ONLY =
+      (name, request) -> name(HttpClient.class, name, methodNameString(request));
+
+  public static final HttpClientMetricNameStrategy HOST_AND_METHOD =
+      (name, request) ->
+          name(HttpClient.class, name, requestURI(request).getHost(), methodNameString(request));
+
+  public static final HttpClientMetricNameStrategy PATH_AND_METHOD =
+      (name, request) -> {
+        final URIBuilder url = new URIBuilder(requestURI(request));
+        return name(HttpClient.class, name, url.getPath(), methodNameString(request));
+      };
+
+  public static final HttpClientMetricNameStrategy QUERYLESS_URL_AND_METHOD =
+      (name, request) -> {
+        try {
+          final URIBuilder url = new URIBuilder(requestURI(request));
+          return name(
+              HttpClient.class,
+              name,
+              url.removeQuery().build().toString(),
+              methodNameString(request));
+        } catch (URISyntaxException e) {
+          throw new IllegalArgumentException(e);
+        }
+      };
+
+  private static String methodNameString(HttpRequest request) {
+    return request.getRequestLine().getMethod().toLowerCase() + "-requests";
+  }
+
+  private static URI requestURI(HttpRequest request) {
+    if (request instanceof HttpRequestWrapper)
+      return requestURI(((HttpRequestWrapper) request).getOriginal());
+
+    return (request instanceof HttpUriRequest)
+        ? ((HttpUriRequest) request).getURI()
+        : URI.create(request.getRequestLine().getUri());
+  }
 }
--- a/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/HttpClientMetricNameStrategy.java
+++ b/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/HttpClientMetricNameStrategy.java
@@ -8,11 +8,9 @@ import org.apache.http.client.HttpClient;
 @FunctionalInterface
 public interface HttpClientMetricNameStrategy {
 
-    MetricName getNameFor(String name, HttpRequest request);
+  MetricName getNameFor(String name, HttpRequest request);
 
-    default MetricName getNameFor(String name, Exception exception) {
-        return MetricRegistry.name(HttpClient.class,
-                name,
-                exception.getClass().getSimpleName());
-    }
+  default MetricName getNameFor(String name, Exception exception) {
+    return MetricRegistry.name(HttpClient.class, name, exception.getClass().getSimpleName());
+  }
 }
--- a/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpClientConnectionManager.java
+++ b/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpClientConnectionManager.java
@@ -1,6 +1,9 @@
 package io.dropwizard.metrics5.httpclient;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.MetricRegistry;
+import java.util.concurrent.TimeUnit;
 import org.apache.http.config.Registry;
 import org.apache.http.config.RegistryBuilder;
 import org.apache.http.conn.DnsResolver;
@@ -17,184 +20,198 @@ import org.apache.http.impl.conn.DefaultHttpClientConnectionOperator;
 import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
 import org.apache.http.impl.conn.SystemDefaultDnsResolver;
 
-import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
-/**
- * A {@link HttpClientConnectionManager} which monitors the number of open connections.
- */
+/** A {@link HttpClientConnectionManager} which monitors the number of open connections. */
 public class InstrumentedHttpClientConnectionManager extends PoolingHttpClientConnectionManager {
 
-
-    protected static Registry<ConnectionSocketFactory> getDefaultRegistry() {
-        return RegistryBuilder.<ConnectionSocketFactory>create()
-            .register("http", PlainConnectionSocketFactory.getSocketFactory())
-            .register("https", SSLConnectionSocketFactory.getSocketFactory())
-            .build();
+  protected static Registry<ConnectionSocketFactory> getDefaultRegistry() {
+    return RegistryBuilder.<ConnectionSocketFactory>create()
+        .register("http", PlainConnectionSocketFactory.getSocketFactory())
+        .register("https", SSLConnectionSocketFactory.getSocketFactory())
+        .build();
+  }
+
+  private final MetricRegistry metricsRegistry;
+  private final String name;
+
+  /**
+   * @deprecated Use {@link #builder(MetricRegistry)} instead.
+   */
+  @Deprecated
+  public InstrumentedHttpClientConnectionManager(MetricRegistry metricRegistry) {
+    this(metricRegistry, getDefaultRegistry());
+  }
+
+  /**
+   * @deprecated Use {@link #builder(MetricRegistry)} instead.
+   */
+  @Deprecated
+  public InstrumentedHttpClientConnectionManager(
+      MetricRegistry metricsRegistry, Registry<ConnectionSocketFactory> socketFactoryRegistry) {
+    this(metricsRegistry, socketFactoryRegistry, -1, TimeUnit.MILLISECONDS);
+  }
+
+  /**
+   * @deprecated Use {@link #builder(MetricRegistry)} instead.
+   */
+  @Deprecated
+  public InstrumentedHttpClientConnectionManager(
+      MetricRegistry metricsRegistry,
+      Registry<ConnectionSocketFactory> socketFactoryRegistry,
+      long connTTL,
+      TimeUnit connTTLTimeUnit) {
+    this(
+        metricsRegistry,
+        socketFactoryRegistry,
+        null,
+        null,
+        SystemDefaultDnsResolver.INSTANCE,
+        connTTL,
+        connTTLTimeUnit,
+        null);
+  }
+
+  /**
+   * @deprecated Use {@link #builder(MetricRegistry)} instead.
+   */
+  @Deprecated
+  public InstrumentedHttpClientConnectionManager(
+      MetricRegistry metricsRegistry,
+      Registry<ConnectionSocketFactory> socketFactoryRegistry,
+      HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> connFactory,
+      SchemePortResolver schemePortResolver,
+      DnsResolver dnsResolver,
+      long connTTL,
+      TimeUnit connTTLTimeUnit,
+      String name) {
+    this(
+        metricsRegistry,
+        new DefaultHttpClientConnectionOperator(
+            socketFactoryRegistry, schemePortResolver, dnsResolver),
+        connFactory,
+        connTTL,
+        connTTLTimeUnit,
+        name);
+  }
+
+  /**
+   * @deprecated Use {@link #builder(MetricRegistry)} instead.
+   */
+  @Deprecated
+  public InstrumentedHttpClientConnectionManager(
+      MetricRegistry metricsRegistry,
+      HttpClientConnectionOperator httpClientConnectionOperator,
+      HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> connFactory,
+      long connTTL,
+      TimeUnit connTTLTimeUnit,
+      String name) {
+    super(httpClientConnectionOperator, connFactory, connTTL, connTTLTimeUnit);
+    this.metricsRegistry = metricsRegistry;
+    this.name = name;
+
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricsRegistry.registerGauge(
+        name(HttpClientConnectionManager.class, name, "available-connections"),
+        () -> getTotalStats().getAvailable());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricsRegistry.registerGauge(
+        name(HttpClientConnectionManager.class, name, "leased-connections"),
+        () -> getTotalStats().getLeased());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricsRegistry.registerGauge(
+        name(HttpClientConnectionManager.class, name, "max-connections"),
+        () -> getTotalStats().getMax());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricsRegistry.registerGauge(
+        name(HttpClientConnectionManager.class, name, "pending-connections"),
+        () -> getTotalStats().getPending());
+  }
+
+  @Override
+  public void shutdown() {
+    super.shutdown();
+    metricsRegistry.remove(name(HttpClientConnectionManager.class, name, "available-connections"));
+    metricsRegistry.remove(name(HttpClientConnectionManager.class, name, "leased-connections"));
+    metricsRegistry.remove(name(HttpClientConnectionManager.class, name, "max-connections"));
+    metricsRegistry.remove(name(HttpClientConnectionManager.class, name, "pending-connections"));
+  }
+
+  public static Builder builder(MetricRegistry metricsRegistry) {
+    return new Builder().metricsRegistry(metricsRegistry);
+  }
+
+  public static class Builder {
+    private MetricRegistry metricsRegistry;
+    private HttpClientConnectionOperator httpClientConnectionOperator;
+    private Registry<ConnectionSocketFactory> socketFactoryRegistry = getDefaultRegistry();
+    private HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> connFactory;
+    private SchemePortResolver schemePortResolver;
+    private DnsResolver dnsResolver = SystemDefaultDnsResolver.INSTANCE;
+    private long connTTL = -1;
+    private TimeUnit connTTLTimeUnit = TimeUnit.MILLISECONDS;
+    private String name;
+
+    Builder() {}
+
+    public Builder metricsRegistry(MetricRegistry metricsRegistry) {
+      this.metricsRegistry = metricsRegistry;
+      return this;
     }
 
-    private final MetricRegistry metricsRegistry;
-    private final String name;
-
-    /**
-     * @deprecated Use {@link #builder(MetricRegistry)} instead.
-     */
-    @Deprecated
-    public InstrumentedHttpClientConnectionManager(MetricRegistry metricRegistry) {
-        this(metricRegistry, getDefaultRegistry());
+    public Builder socketFactoryRegistry(Registry<ConnectionSocketFactory> socketFactoryRegistry) {
+      this.socketFactoryRegistry = socketFactoryRegistry;
+      return this;
     }
 
-    /**
-     * @deprecated Use {@link #builder(MetricRegistry)} instead.
-     */
-    @Deprecated
-    public InstrumentedHttpClientConnectionManager(MetricRegistry metricsRegistry,
-                                                   Registry<ConnectionSocketFactory> socketFactoryRegistry) {
-        this(metricsRegistry, socketFactoryRegistry, -1, TimeUnit.MILLISECONDS);
+    public Builder connFactory(
+        HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> connFactory) {
+      this.connFactory = connFactory;
+      return this;
     }
 
-
-    /**
-     * @deprecated Use {@link #builder(MetricRegistry)} instead.
-     */
-    @Deprecated
-    public InstrumentedHttpClientConnectionManager(MetricRegistry metricsRegistry,
-                                                   Registry<ConnectionSocketFactory> socketFactoryRegistry,
-                                                   long connTTL,
-                                                   TimeUnit connTTLTimeUnit) {
-        this(metricsRegistry, socketFactoryRegistry, null, null, SystemDefaultDnsResolver.INSTANCE, connTTL, connTTLTimeUnit, null);
+    public Builder schemePortResolver(SchemePortResolver schemePortResolver) {
+      this.schemePortResolver = schemePortResolver;
+      return this;
     }
 
-
-    /**
-     * @deprecated Use {@link #builder(MetricRegistry)} instead.
-     */
-    @Deprecated
-    public InstrumentedHttpClientConnectionManager(MetricRegistry metricsRegistry,
-                                                   Registry<ConnectionSocketFactory> socketFactoryRegistry,
-                                                   HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection>
-                                                           connFactory,
-                                                   SchemePortResolver schemePortResolver,
-                                                   DnsResolver dnsResolver,
-                                                   long connTTL,
-                                                   TimeUnit connTTLTimeUnit,
-                                                   String name) {
-        this(metricsRegistry,
-             new DefaultHttpClientConnectionOperator(socketFactoryRegistry, schemePortResolver, dnsResolver),
-             connFactory,
-             connTTL,
-             connTTLTimeUnit,
-             name);
+    public Builder dnsResolver(DnsResolver dnsResolver) {
+      this.dnsResolver = dnsResolver;
+      return this;
     }
 
-    /**
-     * @deprecated Use {@link #builder(MetricRegistry)} instead.
-     */
-    @Deprecated
-    public InstrumentedHttpClientConnectionManager(MetricRegistry metricsRegistry,
-                                                   HttpClientConnectionOperator httpClientConnectionOperator,
-                                                   HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection>
-                                                           connFactory,
-                                                   long connTTL,
-                                                   TimeUnit connTTLTimeUnit,
-                                                   String name) {
-        super(httpClientConnectionOperator, connFactory, connTTL, connTTLTimeUnit);
-        this.metricsRegistry = metricsRegistry;
-        this.name = name;
-
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricsRegistry.registerGauge(name(HttpClientConnectionManager.class, name, "available-connections"),
-                () -> getTotalStats().getAvailable());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricsRegistry.registerGauge(name(HttpClientConnectionManager.class, name, "leased-connections"),
-                () -> getTotalStats().getLeased());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricsRegistry.registerGauge(name(HttpClientConnectionManager.class, name, "max-connections"),
-                () -> getTotalStats().getMax());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricsRegistry.registerGauge(name(HttpClientConnectionManager.class, name, "pending-connections"),
-                () -> getTotalStats().getPending());
+    public Builder connTTL(long connTTL) {
+      this.connTTL = connTTL;
+      return this;
     }
 
-    @Override
-    public void shutdown() {
-        super.shutdown();
-        metricsRegistry.remove(name(HttpClientConnectionManager.class, name, "available-connections"));
-        metricsRegistry.remove(name(HttpClientConnectionManager.class, name, "leased-connections"));
-        metricsRegistry.remove(name(HttpClientConnectionManager.class, name, "max-connections"));
-        metricsRegistry.remove(name(HttpClientConnectionManager.class, name, "pending-connections"));
+    public Builder connTTLTimeUnit(TimeUnit connTTLTimeUnit) {
+      this.connTTLTimeUnit = connTTLTimeUnit;
+      return this;
     }
 
-    public static Builder builder(MetricRegistry metricsRegistry) {
-        return new Builder().metricsRegistry(metricsRegistry);
+    public Builder httpClientConnectionOperator(
+        HttpClientConnectionOperator httpClientConnectionOperator) {
+      this.httpClientConnectionOperator = httpClientConnectionOperator;
+      return this;
     }
 
-    public static class Builder {
-        private MetricRegistry metricsRegistry;
-        private HttpClientConnectionOperator httpClientConnectionOperator;
-        private Registry<ConnectionSocketFactory> socketFactoryRegistry = getDefaultRegistry();
-        private HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> connFactory;
-        private SchemePortResolver schemePortResolver;
-        private DnsResolver dnsResolver = SystemDefaultDnsResolver.INSTANCE;
-        private long connTTL = -1;
-        private TimeUnit connTTLTimeUnit = TimeUnit.MILLISECONDS;
-        private String name;
-
-        Builder() {
-        }
-
-        public Builder metricsRegistry(MetricRegistry metricsRegistry) {
-            this.metricsRegistry = metricsRegistry;
-            return this;
-        }
-
-        public Builder socketFactoryRegistry(Registry<ConnectionSocketFactory> socketFactoryRegistry) {
-            this.socketFactoryRegistry = socketFactoryRegistry;
-            return this;
-        }
-
-        public Builder connFactory(HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> connFactory) {
-            this.connFactory = connFactory;
-            return this;
-        }
-
-        public Builder schemePortResolver(SchemePortResolver schemePortResolver) {
-            this.schemePortResolver = schemePortResolver;
-            return this;
-        }
-
-        public Builder dnsResolver(DnsResolver dnsResolver) {
-            this.dnsResolver = dnsResolver;
-            return this;
-        }
-
-        public Builder connTTL(long connTTL) {
-            this.connTTL = connTTL;
-            return this;
-        }
-
-        public Builder connTTLTimeUnit(TimeUnit connTTLTimeUnit) {
-            this.connTTLTimeUnit = connTTLTimeUnit;
-            return this;
-        }
-
-        public Builder httpClientConnectionOperator(HttpClientConnectionOperator httpClientConnectionOperator) {
-            this.httpClientConnectionOperator = httpClientConnectionOperator;
-            return this;
-        }
-
-        public Builder name(final String name) {
-            this.name = name;
-            return this;
-        }
-
-        public InstrumentedHttpClientConnectionManager build() {
-            if (httpClientConnectionOperator == null) {
-                httpClientConnectionOperator = new DefaultHttpClientConnectionOperator(socketFactoryRegistry, schemePortResolver, dnsResolver);
-            }
-            return new InstrumentedHttpClientConnectionManager(metricsRegistry, httpClientConnectionOperator, connFactory, connTTL, connTTLTimeUnit, name);
-        }
+    public Builder name(final String name) {
+      this.name = name;
+      return this;
     }
 
+    public InstrumentedHttpClientConnectionManager build() {
+      if (httpClientConnectionOperator == null) {
+        httpClientConnectionOperator =
+            new DefaultHttpClientConnectionOperator(
+                socketFactoryRegistry, schemePortResolver, dnsResolver);
+      }
+      return new InstrumentedHttpClientConnectionManager(
+          metricsRegistry,
+          httpClientConnectionOperator,
+          connFactory,
+          connTTL,
+          connTTLTimeUnit,
+          name);
+    }
+  }
 }
--- a/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpClients.java
+++ b/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpClients.java
@@ -5,28 +5,28 @@ import org.apache.http.impl.client.CloseableHttpClient;
 import org.apache.http.impl.client.HttpClientBuilder;
 
 public class InstrumentedHttpClients {
-    private InstrumentedHttpClients() {
-        super();
-    }
+  private InstrumentedHttpClients() {
+    super();
+  }
 
-    public static CloseableHttpClient createDefault(MetricRegistry metricRegistry) {
-        return createDefault(metricRegistry, HttpClientMetricNameStrategies.METHOD_ONLY);
-    }
+  public static CloseableHttpClient createDefault(MetricRegistry metricRegistry) {
+    return createDefault(metricRegistry, HttpClientMetricNameStrategies.METHOD_ONLY);
+  }
 
-    public static CloseableHttpClient createDefault(MetricRegistry metricRegistry,
-                                                    HttpClientMetricNameStrategy metricNameStrategy) {
-        return custom(metricRegistry, metricNameStrategy).build();
-    }
+  public static CloseableHttpClient createDefault(
+      MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy) {
+    return custom(metricRegistry, metricNameStrategy).build();
+  }
 
-    public static HttpClientBuilder custom(MetricRegistry metricRegistry) {
-        return custom(metricRegistry, HttpClientMetricNameStrategies.METHOD_ONLY);
-    }
-
-    public static HttpClientBuilder custom(MetricRegistry metricRegistry,
-                                           HttpClientMetricNameStrategy metricNameStrategy) {
-        return HttpClientBuilder.create()
-                .setRequestExecutor(new InstrumentedHttpRequestExecutor(metricRegistry, metricNameStrategy))
-                .setConnectionManager(InstrumentedHttpClientConnectionManager.builder(metricRegistry).build());
-    }
+  public static HttpClientBuilder custom(MetricRegistry metricRegistry) {
+    return custom(metricRegistry, HttpClientMetricNameStrategies.METHOD_ONLY);
+  }
 
+  public static HttpClientBuilder custom(
+      MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy) {
+    return HttpClientBuilder.create()
+        .setRequestExecutor(new InstrumentedHttpRequestExecutor(metricRegistry, metricNameStrategy))
+        .setConnectionManager(
+            InstrumentedHttpClientConnectionManager.builder(metricRegistry).build());
+  }
 }
--- a/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpRequestExecutor.java
+++ b/metrics-httpclient/src/main/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpRequestExecutor.java
@@ -3,6 +3,7 @@ package io.dropwizard.metrics5.httpclient;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.io.IOException;
 import org.apache.http.HttpClientConnection;
 import org.apache.http.HttpException;
 import org.apache.http.HttpRequest;
@@ -10,52 +11,51 @@ import org.apache.http.HttpResponse;
 import org.apache.http.protocol.HttpContext;
 import org.apache.http.protocol.HttpRequestExecutor;
 
-import java.io.IOException;
-
 public class InstrumentedHttpRequestExecutor extends HttpRequestExecutor {
-    private final MetricRegistry registry;
-    private final HttpClientMetricNameStrategy metricNameStrategy;
-    private final String name;
-
-    public InstrumentedHttpRequestExecutor(MetricRegistry registry,
-                                           HttpClientMetricNameStrategy metricNameStrategy) {
-        this(registry, metricNameStrategy, null);
-    }
-
-    public InstrumentedHttpRequestExecutor(MetricRegistry registry,
-                                           HttpClientMetricNameStrategy metricNameStrategy,
-                                           String name) {
-        this(registry, metricNameStrategy, name, HttpRequestExecutor.DEFAULT_WAIT_FOR_CONTINUE);
+  private final MetricRegistry registry;
+  private final HttpClientMetricNameStrategy metricNameStrategy;
+  private final String name;
+
+  public InstrumentedHttpRequestExecutor(
+      MetricRegistry registry, HttpClientMetricNameStrategy metricNameStrategy) {
+    this(registry, metricNameStrategy, null);
+  }
+
+  public InstrumentedHttpRequestExecutor(
+      MetricRegistry registry, HttpClientMetricNameStrategy metricNameStrategy, String name) {
+    this(registry, metricNameStrategy, name, HttpRequestExecutor.DEFAULT_WAIT_FOR_CONTINUE);
+  }
+
+  public InstrumentedHttpRequestExecutor(
+      MetricRegistry registry,
+      HttpClientMetricNameStrategy metricNameStrategy,
+      String name,
+      int waitForContinue) {
+    super(waitForContinue);
+    this.registry = registry;
+    this.name = name;
+    this.metricNameStrategy = metricNameStrategy;
+  }
+
+  @Override
+  public HttpResponse execute(HttpRequest request, HttpClientConnection conn, HttpContext context)
+      throws HttpException, IOException {
+    final Timer.Context timerContext = timer(request).time();
+    try {
+      return super.execute(request, conn, context);
+    } catch (HttpException | IOException e) {
+      meter(e).mark();
+      throw e;
+    } finally {
+      timerContext.stop();
     }
+  }
 
-    public InstrumentedHttpRequestExecutor(MetricRegistry registry,
-                                           HttpClientMetricNameStrategy metricNameStrategy,
-                                           String name,
-                                           int waitForContinue) {
-        super(waitForContinue);
-        this.registry = registry;
-        this.name = name;
-        this.metricNameStrategy = metricNameStrategy;
-    }
-
-    @Override
-    public HttpResponse execute(HttpRequest request, HttpClientConnection conn, HttpContext context) throws HttpException, IOException {
-        final Timer.Context timerContext = timer(request).time();
-        try {
-            return super.execute(request, conn, context);
-        } catch (HttpException | IOException e) {
-            meter(e).mark();
-            throw e;
-        } finally {
-            timerContext.stop();
-        }
-    }
+  private Timer timer(HttpRequest request) {
+    return registry.timer(metricNameStrategy.getNameFor(name, request));
+  }
 
-    private Timer timer(HttpRequest request) {
-        return registry.timer(metricNameStrategy.getNameFor(name, request));
-    }
-
-    private Meter meter(Exception e) {
-        return registry.meter(metricNameStrategy.getNameFor(name, e));
-    }
+  private Meter meter(Exception e) {
+    return registry.meter(metricNameStrategy.getNameFor(name, e));
+  }
 }
--- a/metrics-httpclient/src/test/java/io/dropwizard/metrics5/httpclient/HttpClientMetricNameStrategiesTest.java
+++ b/metrics-httpclient/src/test/java/io/dropwizard/metrics5/httpclient/HttpClientMetricNameStrategiesTest.java
@@ -1,6 +1,14 @@
 package io.dropwizard.metrics5.httpclient;
 
+import static io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies.HOST_AND_METHOD;
+import static io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies.METHOD_ONLY;
+import static io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies.PATH_AND_METHOD;
+import static io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies.QUERYLESS_URL_AND_METHOD;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricName;
+import java.net.URI;
+import java.net.URISyntaxException;
 import org.apache.http.HttpRequest;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
@@ -9,103 +17,113 @@ import org.apache.http.client.methods.HttpRequestWrapper;
 import org.apache.http.client.utils.URIUtils;
 import org.junit.jupiter.api.Test;
 
-import java.net.URI;
-import java.net.URISyntaxException;
-
-import static io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies.HOST_AND_METHOD;
-import static io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies.METHOD_ONLY;
-import static io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies.PATH_AND_METHOD;
-import static io.dropwizard.metrics5.httpclient.HttpClientMetricNameStrategies.QUERYLESS_URL_AND_METHOD;
-import static org.assertj.core.api.Assertions.assertThat;
-
-class HttpClientMetricNameStrategiesTest {
-
-    @Test
-    void methodOnlyWithName() {
-        assertThat(METHOD_ONLY.getNameFor("some-service", new HttpGet("/whatever")))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.some-service.get-requests"));
-    }
-
-    @Test
-    void methodOnlyWithoutName() {
-        assertThat(METHOD_ONLY.getNameFor(null, new HttpGet("/whatever")))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.get-requests"));
-    }
-
-    @Test
-    void hostAndMethodWithName() {
-        assertThat(HOST_AND_METHOD.getNameFor("some-service", new HttpPost("http://my.host.com/whatever")))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.some-service.my.host.com.post-requests"));
-    }
-
-    @Test
-    void hostAndMethodWithoutName() {
-        assertThat(HOST_AND_METHOD.getNameFor(null, new HttpPost("http://my.host.com/whatever")))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.my.host.com.post-requests"));
-    }
-
-    @Test
-    void hostAndMethodWithNameInWrappedRequest() throws URISyntaxException {
-        HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
-
-        assertThat(HOST_AND_METHOD.getNameFor("some-service", request))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.some-service.my.host.com.post-requests"));
-    }
-
-    @Test
-    void hostAndMethodWithoutNameInWrappedRequest() throws URISyntaxException {
-        HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
-
-        assertThat(HOST_AND_METHOD.getNameFor(null, request))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.my.host.com.post-requests"));
-    }
-
-    @Test
-    void pathAndMethodWithName() {
-        assertThat(PATH_AND_METHOD.getNameFor("some-service", new HttpPost("http://my.host.com/whatever/happens")))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.some-service./whatever/happens.post-requests"));
-    }
-
-    @Test
-    void pathAndMethodWithoutName() {
-        assertThat(PATH_AND_METHOD.getNameFor(null, new HttpPost("http://my.host.com/whatever/happens")))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient./whatever/happens.post-requests"));
-    }
-
-    @Test
-    void pathAndMethodWithNameInWrappedRequest() throws URISyntaxException {
-        HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever/happens"));
-        assertThat(PATH_AND_METHOD.getNameFor("some-service", request))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.some-service./whatever/happens.post-requests"));
-    }
-
-    @Test
-    void pathAndMethodWithoutNameInWrappedRequest() throws URISyntaxException {
-        HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever/happens"));
-        assertThat(PATH_AND_METHOD.getNameFor(null, request))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient./whatever/happens.post-requests"));
-    }
-
-    @Test
-    void querylessUrlAndMethodWithName() {
-        assertThat(QUERYLESS_URL_AND_METHOD.getNameFor(
-                "some-service",
-                new HttpPut("https://thing.com:8090/my/path?ignore=this&and=this")))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.some-service.https://thing.com:8090/my/path.put-requests"));
-    }
-
-    @Test
-    void querylessUrlAndMethodWithNameInWrappedRequest() throws URISyntaxException {
-        HttpRequest request = rewriteRequestURI(new HttpPut("https://thing.com:8090/my/path?ignore=this&and=this"));
-        assertThat(QUERYLESS_URL_AND_METHOD.getNameFor("some-service", request))
-                .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.some-service.https://thing.com:8090/my/path.put-requests"));
-    }
-
-    private static HttpRequest rewriteRequestURI(HttpRequest request) throws URISyntaxException {
-        HttpRequestWrapper wrapper = HttpRequestWrapper.wrap(request);
-        URI uri = URIUtils.rewriteURI(wrapper.getURI(), null, true);
-        wrapper.setURI(uri);
-
-        return wrapper;
-    }
+final class HttpClientMetricNameStrategiesTest {
+
+  @Test
+  void methodOnlyWithName() {
+    assertThat(METHOD_ONLY.getNameFor("some-service", new HttpGet("/whatever")))
+        .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.some-service.get-requests"));
+  }
+
+  @Test
+  void methodOnlyWithoutName() {
+    assertThat(METHOD_ONLY.getNameFor(null, new HttpGet("/whatever")))
+        .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.get-requests"));
+  }
+
+  @Test
+  void hostAndMethodWithName() {
+    assertThat(
+            HOST_AND_METHOD.getNameFor("some-service", new HttpPost("http://my.host.com/whatever")))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.http.client.HttpClient.some-service.my.host.com.post-requests"));
+  }
+
+  @Test
+  void hostAndMethodWithoutName() {
+    assertThat(HOST_AND_METHOD.getNameFor(null, new HttpPost("http://my.host.com/whatever")))
+        .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.my.host.com.post-requests"));
+  }
+
+  @Test
+  void hostAndMethodWithNameInWrappedRequest() throws URISyntaxException {
+    HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
+
+    assertThat(HOST_AND_METHOD.getNameFor("some-service", request))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.http.client.HttpClient.some-service.my.host.com.post-requests"));
+  }
+
+  @Test
+  void hostAndMethodWithoutNameInWrappedRequest() throws URISyntaxException {
+    HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
+
+    assertThat(HOST_AND_METHOD.getNameFor(null, request))
+        .isEqualTo(MetricName.build("org.apache.http.client.HttpClient.my.host.com.post-requests"));
+  }
+
+  @Test
+  void pathAndMethodWithName() {
+    assertThat(
+            PATH_AND_METHOD.getNameFor(
+                "some-service", new HttpPost("http://my.host.com/whatever/happens")))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.http.client.HttpClient.some-service./whatever/happens.post-requests"));
+  }
+
+  @Test
+  void pathAndMethodWithoutName() {
+    assertThat(
+            PATH_AND_METHOD.getNameFor(null, new HttpPost("http://my.host.com/whatever/happens")))
+        .isEqualTo(
+            MetricName.build("org.apache.http.client.HttpClient./whatever/happens.post-requests"));
+  }
+
+  @Test
+  void pathAndMethodWithNameInWrappedRequest() throws URISyntaxException {
+    HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever/happens"));
+    assertThat(PATH_AND_METHOD.getNameFor("some-service", request))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.http.client.HttpClient.some-service./whatever/happens.post-requests"));
+  }
+
+  @Test
+  void pathAndMethodWithoutNameInWrappedRequest() throws URISyntaxException {
+    HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever/happens"));
+    assertThat(PATH_AND_METHOD.getNameFor(null, request))
+        .isEqualTo(
+            MetricName.build("org.apache.http.client.HttpClient./whatever/happens.post-requests"));
+  }
+
+  @Test
+  void querylessUrlAndMethodWithName() {
+    assertThat(
+            QUERYLESS_URL_AND_METHOD.getNameFor(
+                "some-service", new HttpPut("https://thing.com:8090/my/path?ignore=this&and=this")))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.http.client.HttpClient.some-service.https://thing.com:8090/my/path.put-requests"));
+  }
+
+  @Test
+  void querylessUrlAndMethodWithNameInWrappedRequest() throws URISyntaxException {
+    HttpRequest request =
+        rewriteRequestURI(new HttpPut("https://thing.com:8090/my/path?ignore=this&and=this"));
+    assertThat(QUERYLESS_URL_AND_METHOD.getNameFor("some-service", request))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.http.client.HttpClient.some-service.https://thing.com:8090/my/path.put-requests"));
+  }
+
+  private static HttpRequest rewriteRequestURI(HttpRequest request) throws URISyntaxException {
+    HttpRequestWrapper wrapper = HttpRequestWrapper.wrap(request);
+    URI uri = URIUtils.rewriteURI(wrapper.getURI(), null, true);
+    wrapper.setURI(uri);
+
+    return wrapper;
+  }
 }
--- a/metrics-httpclient/src/test/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpClientConnectionManagerTest.java
+++ b/metrics-httpclient/src/test/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpClientConnectionManagerTest.java
@@ -1,50 +1,53 @@
 package io.dropwizard.metrics5.httpclient;
 
-import io.dropwizard.metrics5.MetricName;
-import io.dropwizard.metrics5.MetricRegistry;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mockito;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.atLeast;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 
+import io.dropwizard.metrics5.MetricName;
+import io.dropwizard.metrics5.MetricRegistry;
+import org.junit.jupiter.api.Test;
+import org.mockito.ArgumentCaptor;
 
-class InstrumentedHttpClientConnectionManagerTest {
-    private final MetricRegistry metricRegistry = new MetricRegistry();
+final class InstrumentedHttpClientConnectionManagerTest {
+  private final MetricRegistry metricRegistry = new MetricRegistry();
 
-    @Test
-    void shouldRemoveGauges() {
-        final InstrumentedHttpClientConnectionManager instrumentedHttpClientConnectionManager = InstrumentedHttpClientConnectionManager.builder(metricRegistry).build();
-        assertThat(metricRegistry.getGauges().entrySet().stream()
+  @Test
+  void shouldRemoveGauges() {
+    final InstrumentedHttpClientConnectionManager instrumentedHttpClientConnectionManager =
+        InstrumentedHttpClientConnectionManager.builder(metricRegistry).build();
+    assertThat(
+            metricRegistry.getGauges().entrySet().stream()
                 .map(e -> entry(e.getKey().getKey(), (Integer) e.getValue().getValue())))
-                .containsOnly(entry("org.apache.http.conn.HttpClientConnectionManager.available-connections", 0),
-                        entry("org.apache.http.conn.HttpClientConnectionManager.leased-connections", 0),
-                        entry("org.apache.http.conn.HttpClientConnectionManager.max-connections", 20),
-                        entry("org.apache.http.conn.HttpClientConnectionManager.pending-connections", 0));
-
-        instrumentedHttpClientConnectionManager.close();
-        assertEquals(0, metricRegistry.getGauges().size());
-
-        // should be able to create another one with the same name ("")
-        InstrumentedHttpClientConnectionManager.builder(metricRegistry).build().close();
-    }
-
-    @Test
-    void configurableViaBuilder() {
-        final MetricRegistry registry = Mockito.mock(MetricRegistry.class);
-
-        InstrumentedHttpClientConnectionManager.builder(registry)
-                .name("some-name")
-                .name("some-other-name")
-                .build()
-                .close();
-
-        ArgumentCaptor<MetricName> argumentCaptor = ArgumentCaptor.forClass(MetricName.class);
-        Mockito.verify(registry, Mockito.atLeast(1)).registerGauge(argumentCaptor.capture(), any());
-        assertTrue(argumentCaptor.getValue().getKey().contains("some-other-name"));
-    }
+        .containsOnly(
+            entry("org.apache.http.conn.HttpClientConnectionManager.available-connections", 0),
+            entry("org.apache.http.conn.HttpClientConnectionManager.leased-connections", 0),
+            entry("org.apache.http.conn.HttpClientConnectionManager.max-connections", 20),
+            entry("org.apache.http.conn.HttpClientConnectionManager.pending-connections", 0));
+
+    instrumentedHttpClientConnectionManager.close();
+    assertEquals(0, metricRegistry.getGauges().size());
+
+    // should be able to create another one with the same name ("")
+    InstrumentedHttpClientConnectionManager.builder(metricRegistry).build().close();
+  }
+
+  @Test
+  void configurableViaBuilder() {
+    final MetricRegistry registry = mock();
+
+    InstrumentedHttpClientConnectionManager.builder(registry)
+        .name("some-name")
+        .name("some-other-name")
+        .build()
+        .close();
+
+    ArgumentCaptor<MetricName> argumentCaptor = ArgumentCaptor.forClass(MetricName.class);
+    verify(registry, atLeast(1)).registerGauge(argumentCaptor.capture(), any());
+    assertThat(argumentCaptor.getValue().getKey().contains("some-other-name")).isTrue();
+  }
 }
--- a/metrics-httpclient/src/test/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpClientsTest.java
+++ b/metrics-httpclient/src/test/java/io/dropwizard/metrics5/httpclient/InstrumentedHttpClientsTest.java
@@ -1,11 +1,20 @@
 package io.dropwizard.metrics5.httpclient;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.sun.net.httpserver.HttpExchange;
 import com.sun.net.httpserver.HttpServer;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricRegistryListener;
 import io.dropwizard.metrics5.Timer;
+import java.net.InetSocketAddress;
 import org.apache.http.HttpRequest;
 import org.apache.http.NoHttpResponseException;
 import org.apache.http.client.HttpClient;
@@ -13,66 +22,55 @@ import org.apache.http.client.methods.HttpGet;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.net.InetSocketAddress;
+final class InstrumentedHttpClientsTest {
+  private final HttpClientMetricNameStrategy metricNameStrategy = mock();
+  private final MetricRegistryListener registryListener = mock();
+  private final MetricRegistry metricRegistry = new MetricRegistry();
+  private final HttpClient client =
+      InstrumentedHttpClients.custom(metricRegistry, metricNameStrategy)
+          .disableAutomaticRetries()
+          .build();
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+  @BeforeEach
+  void setUp() {
+    metricRegistry.addListener(registryListener);
+  }
 
-class InstrumentedHttpClientsTest {
-    private final HttpClientMetricNameStrategy metricNameStrategy =
-            mock(HttpClientMetricNameStrategy.class);
-    private final MetricRegistryListener registryListener =
-            mock(MetricRegistryListener.class);
-    private final MetricRegistry metricRegistry = new MetricRegistry();
-    private final HttpClient client =
-            InstrumentedHttpClients.custom(metricRegistry, metricNameStrategy).disableAutomaticRetries().build();
+  @Test
+  void registersExpectedMetricsGivenNameStrategy() throws Exception {
+    final HttpGet get = new HttpGet("http://example.com?q=anything");
+    final MetricName metricName = MetricName.build("some.made.up.metric.name");
 
-    @BeforeEach
-    void setUp() {
-        metricRegistry.addListener(registryListener);
-    }
-
-    @Test
-    void registersExpectedMetricsGivenNameStrategy() throws Exception {
-        final HttpGet get = new HttpGet("http://example.com?q=anything");
-        final MetricName metricName = MetricName.build("some.made.up.metric.name");
+    when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class))).thenReturn(metricName);
 
-        when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
-                .thenReturn(metricName);
+    client.execute(get);
 
-        client.execute(get);
-
-        verify(registryListener).onTimerAdded(eq(metricName), any(Timer.class));
-    }
+    verify(registryListener).onTimerAdded(eq(metricName), any(Timer.class));
+  }
 
-    @Test
-    void registersExpectedExceptionMetrics() throws Exception {
-        HttpServer httpServer = HttpServer.create(new InetSocketAddress(0), 0);
+  @Test
+  void registersExpectedExceptionMetrics() throws Exception {
+    HttpServer httpServer = HttpServer.create(new InetSocketAddress(0), 0);
 
-        final HttpGet get = new HttpGet("http://localhost:" + httpServer.getAddress().getPort() + "/");
-        final MetricName requestMetricName = MetricName.build("request");
-        final MetricName exceptionMetricName = MetricName.build("exception");
+    final HttpGet get = new HttpGet("http://localhost:" + httpServer.getAddress().getPort() + "/");
+    final MetricName requestMetricName = MetricName.build("request");
+    final MetricName exceptionMetricName = MetricName.build("exception");
 
-        httpServer.createContext("/", HttpExchange::close);
-        httpServer.start();
+    httpServer.createContext("/", HttpExchange::close);
+    httpServer.start();
 
-        when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
-                .thenReturn(requestMetricName);
-        when(metricNameStrategy.getNameFor(any(), any(Exception.class)))
-                .thenReturn(exceptionMetricName);
+    when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
+        .thenReturn(requestMetricName);
+    when(metricNameStrategy.getNameFor(any(), any(Exception.class)))
+        .thenReturn(exceptionMetricName);
 
-        try {
-            client.execute(get);
-            fail();
-        } catch (NoHttpResponseException expected) {
-            assertThat(metricRegistry.getMeters()).containsKey(MetricName.build("exception"));
-        } finally {
-            httpServer.stop(0);
-        }
+    try {
+      client.execute(get);
+      fail();
+    } catch (NoHttpResponseException expected) {
+      assertThat(metricRegistry.getMeters()).containsKey(MetricName.build("exception"));
+    } finally {
+      httpServer.stop(0);
     }
+  }
 }
--- a/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/HttpClientMetricNameStrategies.java
+++ b/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/HttpClientMetricNameStrategies.java
@@ -1,48 +1,43 @@
 package io.dropwizard.metrics5.httpclient5;
 
-import org.apache.hc.client5.http.classic.HttpClient;
-import org.apache.hc.core5.http.HttpRequest;
-import org.apache.hc.core5.net.URIBuilder;
+import static io.dropwizard.metrics5.MetricRegistry.name;
 
 import java.net.URISyntaxException;
 import java.util.Locale;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
+import org.apache.hc.client5.http.classic.HttpClient;
+import org.apache.hc.core5.http.HttpRequest;
+import org.apache.hc.core5.net.URIBuilder;
 
 public class HttpClientMetricNameStrategies {
 
-    public static final HttpClientMetricNameStrategy METHOD_ONLY =
-            (name, request) -> name(HttpClient.class,
-                    name,
-                    methodNameString(request));
-
-    public static final HttpClientMetricNameStrategy HOST_AND_METHOD =
-            (name, request) -> {
-                try {
-                    return name(HttpClient.class,
-                            name,
-                            request.getUri().getHost(),
-                            methodNameString(request));
-                } catch (URISyntaxException e) {
-                    throw new IllegalArgumentException(e);
-                }
-            };
-
-    public static final HttpClientMetricNameStrategy QUERYLESS_URL_AND_METHOD =
-            (name, request) -> {
-                try {
-                    final URIBuilder url = new URIBuilder(request.getUri());
-                    return name(HttpClient.class,
-                            name,
-                            url.removeQuery().build().toString(),
-                            methodNameString(request));
-                } catch (URISyntaxException e) {
-                    throw new IllegalArgumentException(e);
-                }
-            };
-
-    private static String methodNameString(HttpRequest request) {
-        return request.getMethod().toLowerCase(Locale.ROOT) + "-requests";
-    }
-
+  public static final HttpClientMetricNameStrategy METHOD_ONLY =
+      (name, request) -> name(HttpClient.class, name, methodNameString(request));
+
+  public static final HttpClientMetricNameStrategy HOST_AND_METHOD =
+      (name, request) -> {
+        try {
+          return name(
+              HttpClient.class, name, request.getUri().getHost(), methodNameString(request));
+        } catch (URISyntaxException e) {
+          throw new IllegalArgumentException(e);
+        }
+      };
+
+  public static final HttpClientMetricNameStrategy QUERYLESS_URL_AND_METHOD =
+      (name, request) -> {
+        try {
+          final URIBuilder url = new URIBuilder(request.getUri());
+          return name(
+              HttpClient.class,
+              name,
+              url.removeQuery().build().toString(),
+              methodNameString(request));
+        } catch (URISyntaxException e) {
+          throw new IllegalArgumentException(e);
+        }
+      };
+
+  private static String methodNameString(HttpRequest request) {
+    return request.getMethod().toLowerCase(Locale.ROOT) + "-requests";
+  }
 }
--- a/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/HttpClientMetricNameStrategy.java
+++ b/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/HttpClientMetricNameStrategy.java
@@ -8,11 +8,9 @@ import org.apache.hc.core5.http.HttpRequest;
 @FunctionalInterface
 public interface HttpClientMetricNameStrategy {
 
-    MetricName getNameFor(String name, HttpRequest request);
+  MetricName getNameFor(String name, HttpRequest request);
 
-    default MetricName getNameFor(String name, Exception exception) {
-        return MetricRegistry.name(HttpClient.class,
-                name,
-                exception.getClass().getSimpleName());
-    }
+  default MetricName getNameFor(String name, Exception exception) {
+    return MetricRegistry.name(HttpClient.class, name, exception.getClass().getSimpleName());
+  }
 }
--- a/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedAsyncClientConnectionManager.java
+++ b/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedAsyncClientConnectionManager.java
@@ -1,5 +1,8 @@
 package io.dropwizard.metrics5.httpclient5;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static java.util.Objects.requireNonNull;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import org.apache.hc.client5.http.DnsResolver;
 import org.apache.hc.client5.http.SchemePortResolver;
@@ -17,139 +20,135 @@ import org.apache.hc.core5.pool.PoolConcurrencyPolicy;
 import org.apache.hc.core5.pool.PoolReusePolicy;
 import org.apache.hc.core5.util.TimeValue;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static java.util.Objects.requireNonNull;
-
-/**
- * A {@link HttpClientConnectionManager} which monitors the number of open connections.
- */
+/** A {@link HttpClientConnectionManager} which monitors the number of open connections. */
 public class InstrumentedAsyncClientConnectionManager extends PoolingAsyncClientConnectionManager {
-    private static final String METRICS_PREFIX = AsyncClientConnectionManager.class.getName();
+  private static final String METRICS_PREFIX = AsyncClientConnectionManager.class.getName();
+
+  protected static Registry<TlsStrategy> getDefaultTlsStrategy() {
+    return RegistryBuilder.<TlsStrategy>create()
+        .register(URIScheme.HTTPS.id, DefaultClientTlsStrategy.getDefault())
+        .build();
+  }
+
+  private final MetricRegistry metricsRegistry;
+  private final String name;
+
+  InstrumentedAsyncClientConnectionManager(
+      final MetricRegistry metricRegistry,
+      final String name,
+      final Lookup<TlsStrategy> tlsStrategyLookup,
+      final PoolConcurrencyPolicy poolConcurrencyPolicy,
+      final PoolReusePolicy poolReusePolicy,
+      final TimeValue timeToLive,
+      final SchemePortResolver schemePortResolver,
+      final DnsResolver dnsResolver) {
+
+    super(
+        tlsStrategyLookup,
+        poolConcurrencyPolicy,
+        poolReusePolicy,
+        timeToLive,
+        schemePortResolver,
+        dnsResolver);
+    this.metricsRegistry = requireNonNull(metricRegistry, "metricRegistry");
+    this.name = name;
+
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(METRICS_PREFIX, name, "available-connections"), () -> getTotalStats().getAvailable());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(METRICS_PREFIX, name, "leased-connections"), () -> getTotalStats().getLeased());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(METRICS_PREFIX, name, "max-connections"), () -> getTotalStats().getMax());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(METRICS_PREFIX, name, "pending-connections"), () -> getTotalStats().getPending());
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void close() {
+    close(CloseMode.GRACEFUL);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void close(CloseMode closeMode) {
+    super.close(closeMode);
+    metricsRegistry.remove(name(METRICS_PREFIX, name, "available-connections"));
+    metricsRegistry.remove(name(METRICS_PREFIX, name, "leased-connections"));
+    metricsRegistry.remove(name(METRICS_PREFIX, name, "max-connections"));
+    metricsRegistry.remove(name(METRICS_PREFIX, name, "pending-connections"));
+  }
+
+  public static Builder builder(MetricRegistry metricsRegistry) {
+    return new Builder().metricsRegistry(metricsRegistry);
+  }
+
+  public static class Builder {
+    private MetricRegistry metricsRegistry;
+    private String name;
+    private Lookup<TlsStrategy> tlsStrategyLookup = getDefaultTlsStrategy();
+    private SchemePortResolver schemePortResolver;
+    private DnsResolver dnsResolver;
+    private PoolConcurrencyPolicy poolConcurrencyPolicy;
+    private PoolReusePolicy poolReusePolicy;
+    private TimeValue timeToLive = TimeValue.NEG_ONE_MILLISECOND;
+
+    Builder() {}
+
+    public Builder metricsRegistry(MetricRegistry metricRegistry) {
+      this.metricsRegistry = requireNonNull(metricRegistry, "metricRegistry");
+      return this;
+    }
 
-    protected static Registry<TlsStrategy> getDefaultTlsStrategy() {
-        return RegistryBuilder.<TlsStrategy>create()
-                .register(URIScheme.HTTPS.id, DefaultClientTlsStrategy.getDefault())
-                .build();
+    public Builder name(final String name) {
+      this.name = name;
+      return this;
     }
 
-    private final MetricRegistry metricsRegistry;
-    private final String name;
-
-    InstrumentedAsyncClientConnectionManager(final MetricRegistry metricRegistry,
-                                             final String name,
-                                             final Lookup<TlsStrategy> tlsStrategyLookup,
-                                             final PoolConcurrencyPolicy poolConcurrencyPolicy,
-                                             final PoolReusePolicy poolReusePolicy,
-                                             final TimeValue timeToLive,
-                                             final SchemePortResolver schemePortResolver,
-                                             final DnsResolver dnsResolver) {
-
-        super(tlsStrategyLookup, poolConcurrencyPolicy, poolReusePolicy, timeToLive, schemePortResolver, dnsResolver);
-        this.metricsRegistry = requireNonNull(metricRegistry, "metricRegistry");
-        this.name = name;
-
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(METRICS_PREFIX, name, "available-connections"),
-                () -> getTotalStats().getAvailable());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(METRICS_PREFIX, name, "leased-connections"),
-                () -> getTotalStats().getLeased());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(METRICS_PREFIX, name, "max-connections"),
-                () -> getTotalStats().getMax());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(METRICS_PREFIX, name, "pending-connections"),
-                () -> getTotalStats().getPending());
+    public Builder schemePortResolver(SchemePortResolver schemePortResolver) {
+      this.schemePortResolver = schemePortResolver;
+      return this;
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void close() {
-        close(CloseMode.GRACEFUL);
+    public Builder dnsResolver(DnsResolver dnsResolver) {
+      this.dnsResolver = dnsResolver;
+      return this;
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void close(CloseMode closeMode) {
-        super.close(closeMode);
-        metricsRegistry.remove(name(METRICS_PREFIX, name, "available-connections"));
-        metricsRegistry.remove(name(METRICS_PREFIX, name, "leased-connections"));
-        metricsRegistry.remove(name(METRICS_PREFIX, name, "max-connections"));
-        metricsRegistry.remove(name(METRICS_PREFIX, name, "pending-connections"));
+    public Builder timeToLive(TimeValue timeToLive) {
+      this.timeToLive = timeToLive;
+      return this;
     }
 
-    public static Builder builder(MetricRegistry metricsRegistry) {
-        return new Builder().metricsRegistry(metricsRegistry);
+    public Builder tlsStrategyLookup(Lookup<TlsStrategy> tlsStrategyLookup) {
+      this.tlsStrategyLookup = tlsStrategyLookup;
+      return this;
     }
 
-    public static class Builder {
-        private MetricRegistry metricsRegistry;
-        private String name;
-        private Lookup<TlsStrategy> tlsStrategyLookup = getDefaultTlsStrategy();
-        private SchemePortResolver schemePortResolver;
-        private DnsResolver dnsResolver;
-        private PoolConcurrencyPolicy poolConcurrencyPolicy;
-        private PoolReusePolicy poolReusePolicy;
-        private TimeValue timeToLive = TimeValue.NEG_ONE_MILLISECOND;
-
-        Builder() {
-        }
-
-        public Builder metricsRegistry(MetricRegistry metricRegistry) {
-            this.metricsRegistry = requireNonNull(metricRegistry, "metricRegistry");
-            return this;
-        }
-
-        public Builder name(final String name) {
-            this.name = name;
-            return this;
-        }
-
-        public Builder schemePortResolver(SchemePortResolver schemePortResolver) {
-            this.schemePortResolver = schemePortResolver;
-            return this;
-        }
-
-        public Builder dnsResolver(DnsResolver dnsResolver) {
-            this.dnsResolver = dnsResolver;
-            return this;
-        }
-
-        public Builder timeToLive(TimeValue timeToLive) {
-            this.timeToLive = timeToLive;
-            return this;
-        }
-
-        public Builder tlsStrategyLookup(Lookup<TlsStrategy> tlsStrategyLookup) {
-            this.tlsStrategyLookup = tlsStrategyLookup;
-            return this;
-        }
-
-        public Builder poolConcurrencyPolicy(PoolConcurrencyPolicy poolConcurrencyPolicy) {
-            this.poolConcurrencyPolicy = poolConcurrencyPolicy;
-            return this;
-        }
-
-        public Builder poolReusePolicy(PoolReusePolicy poolReusePolicy) {
-            this.poolReusePolicy = poolReusePolicy;
-            return this;
-        }
-
-        public InstrumentedAsyncClientConnectionManager build() {
-            return new InstrumentedAsyncClientConnectionManager(
-                    metricsRegistry,
-                    name,
-                    tlsStrategyLookup,
-                    poolConcurrencyPolicy,
-                    poolReusePolicy,
-                    timeToLive,
-                    schemePortResolver,
-                    dnsResolver);
-        }
+    public Builder poolConcurrencyPolicy(PoolConcurrencyPolicy poolConcurrencyPolicy) {
+      this.poolConcurrencyPolicy = poolConcurrencyPolicy;
+      return this;
     }
 
+    public Builder poolReusePolicy(PoolReusePolicy poolReusePolicy) {
+      this.poolReusePolicy = poolReusePolicy;
+      return this;
+    }
+
+    public InstrumentedAsyncClientConnectionManager build() {
+      return new InstrumentedAsyncClientConnectionManager(
+          metricsRegistry,
+          name,
+          tlsStrategyLookup,
+          poolConcurrencyPolicy,
+          poolReusePolicy,
+          timeToLive,
+          schemePortResolver,
+          dnsResolver);
+    }
+  }
 }
--- a/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedAsyncExecChainHandler.java
+++ b/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedAsyncExecChainHandler.java
@@ -1,8 +1,11 @@
 package io.dropwizard.metrics5.httpclient5;
 
+import static java.util.Objects.requireNonNull;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.io.IOException;
 import org.apache.hc.client5.http.async.AsyncExecCallback;
 import org.apache.hc.client5.http.async.AsyncExecChain;
 import org.apache.hc.client5.http.async.AsyncExecChainHandler;
@@ -13,87 +16,87 @@ import org.apache.hc.core5.http.HttpResponse;
 import org.apache.hc.core5.http.nio.AsyncDataConsumer;
 import org.apache.hc.core5.http.nio.AsyncEntityProducer;
 
-import java.io.IOException;
-
-import static java.util.Objects.requireNonNull;
-
 class InstrumentedAsyncExecChainHandler implements AsyncExecChainHandler {
+  private final MetricRegistry registry;
+  private final HttpClientMetricNameStrategy metricNameStrategy;
+  private final String name;
+
+  public InstrumentedAsyncExecChainHandler(
+      MetricRegistry registry, HttpClientMetricNameStrategy metricNameStrategy) {
+    this(registry, metricNameStrategy, null);
+  }
+
+  public InstrumentedAsyncExecChainHandler(
+      MetricRegistry registry, HttpClientMetricNameStrategy metricNameStrategy, String name) {
+    this.registry = requireNonNull(registry, "registry");
+    this.metricNameStrategy = requireNonNull(metricNameStrategy, "metricNameStrategy");
+    this.name = name;
+  }
+
+  @Override
+  public void execute(
+      HttpRequest request,
+      AsyncEntityProducer entityProducer,
+      AsyncExecChain.Scope scope,
+      AsyncExecChain chain,
+      AsyncExecCallback asyncExecCallback)
+      throws HttpException, IOException {
+    final InstrumentedAsyncExecCallback instrumentedAsyncExecCallback =
+        new InstrumentedAsyncExecCallback(
+            registry, metricNameStrategy, name, asyncExecCallback, request);
+    chain.proceed(request, entityProducer, scope, instrumentedAsyncExecCallback);
+  }
+
+  static final class InstrumentedAsyncExecCallback implements AsyncExecCallback {
     private final MetricRegistry registry;
     private final HttpClientMetricNameStrategy metricNameStrategy;
     private final String name;
-
-    public InstrumentedAsyncExecChainHandler(MetricRegistry registry, HttpClientMetricNameStrategy metricNameStrategy) {
-        this(registry, metricNameStrategy, null);
+    private final AsyncExecCallback delegate;
+    private final Timer.Context timerContext;
+
+    public InstrumentedAsyncExecCallback(
+        MetricRegistry registry,
+        HttpClientMetricNameStrategy metricNameStrategy,
+        String name,
+        AsyncExecCallback delegate,
+        HttpRequest request) {
+      this.registry = registry;
+      this.metricNameStrategy = metricNameStrategy;
+      this.name = name;
+      this.delegate = delegate;
+      this.timerContext = timer(request).time();
     }
 
-    public InstrumentedAsyncExecChainHandler(MetricRegistry registry,
-                                             HttpClientMetricNameStrategy metricNameStrategy,
-                                             String name) {
-        this.registry = requireNonNull(registry, "registry");
-        this.metricNameStrategy = requireNonNull(metricNameStrategy, "metricNameStrategy");
-        this.name = name;
+    @Override
+    public AsyncDataConsumer handleResponse(HttpResponse response, EntityDetails entityDetails)
+        throws HttpException, IOException {
+      return delegate.handleResponse(response, entityDetails);
     }
 
     @Override
-    public void execute(HttpRequest request,
-                        AsyncEntityProducer entityProducer,
-                        AsyncExecChain.Scope scope,
-                        AsyncExecChain chain,
-                        AsyncExecCallback asyncExecCallback) throws HttpException, IOException {
-        final InstrumentedAsyncExecCallback instrumentedAsyncExecCallback =
-                new InstrumentedAsyncExecCallback(registry, metricNameStrategy, name, asyncExecCallback, request);
-        chain.proceed(request, entityProducer, scope, instrumentedAsyncExecCallback);
-
+    public void handleInformationResponse(HttpResponse response) throws HttpException, IOException {
+      delegate.handleInformationResponse(response);
     }
 
-    final static class InstrumentedAsyncExecCallback implements AsyncExecCallback {
-        private final MetricRegistry registry;
-        private final HttpClientMetricNameStrategy metricNameStrategy;
-        private final String name;
-        private final AsyncExecCallback delegate;
-        private final Timer.Context timerContext;
-
-        public InstrumentedAsyncExecCallback(MetricRegistry registry,
-                                             HttpClientMetricNameStrategy metricNameStrategy,
-                                             String name,
-                                             AsyncExecCallback delegate,
-                                             HttpRequest request) {
-            this.registry = registry;
-            this.metricNameStrategy = metricNameStrategy;
-            this.name = name;
-            this.delegate = delegate;
-            this.timerContext = timer(request).time();
-        }
-
-        @Override
-        public AsyncDataConsumer handleResponse(HttpResponse response, EntityDetails entityDetails) throws HttpException, IOException {
-            return delegate.handleResponse(response, entityDetails);
-        }
-
-        @Override
-        public void handleInformationResponse(HttpResponse response) throws HttpException, IOException {
-            delegate.handleInformationResponse(response);
-        }
-
-        @Override
-        public void completed() {
-            delegate.completed();
-            timerContext.stop();
-        }
+    @Override
+    public void completed() {
+      delegate.completed();
+      timerContext.stop();
+    }
 
-        @Override
-        public void failed(Exception cause) {
-            delegate.failed(cause);
-            meter(cause).mark();
-            timerContext.stop();
-        }
+    @Override
+    public void failed(Exception cause) {
+      delegate.failed(cause);
+      meter(cause).mark();
+      timerContext.stop();
+    }
 
-        private Timer timer(HttpRequest request) {
-            return registry.timer(metricNameStrategy.getNameFor(name, request));
-        }
+    private Timer timer(HttpRequest request) {
+      return registry.timer(metricNameStrategy.getNameFor(name, request));
+    }
 
-        private Meter meter(Exception e) {
-            return registry.meter(metricNameStrategy.getNameFor(name, e));
-        }
+    private Meter meter(Exception e) {
+      return registry.meter(metricNameStrategy.getNameFor(name, e));
     }
+  }
 }
--- a/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpAsyncClients.java
+++ b/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpAsyncClients.java
@@ -1,43 +1,48 @@
 package io.dropwizard.metrics5.httpclient5;
 
+import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.METHOD_ONLY;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import org.apache.hc.client5.http.impl.ChainElement;
 import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;
 import org.apache.hc.client5.http.impl.async.HttpAsyncClientBuilder;
 import org.apache.hc.client5.http.nio.AsyncClientConnectionManager;
 
-import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.METHOD_ONLY;
-
 public class InstrumentedHttpAsyncClients {
-    private InstrumentedHttpAsyncClients() {
-        super();
-    }
-
-    public static CloseableHttpAsyncClient createDefault(MetricRegistry metricRegistry) {
-        return createDefault(metricRegistry, METHOD_ONLY);
-    }
-
-    public static CloseableHttpAsyncClient createDefault(MetricRegistry metricRegistry,
-                                                         HttpClientMetricNameStrategy metricNameStrategy) {
-        return custom(metricRegistry, metricNameStrategy).build();
-    }
-
-    public static HttpAsyncClientBuilder custom(MetricRegistry metricRegistry) {
-        return custom(metricRegistry, METHOD_ONLY);
-    }
-
-    public static HttpAsyncClientBuilder custom(MetricRegistry metricRegistry,
-                                                HttpClientMetricNameStrategy metricNameStrategy) {
-        return custom(metricRegistry, metricNameStrategy, InstrumentedAsyncClientConnectionManager.builder(metricRegistry).build());
-    }
-
-    public static HttpAsyncClientBuilder custom(MetricRegistry metricRegistry,
-                                                HttpClientMetricNameStrategy metricNameStrategy,
-                                                AsyncClientConnectionManager clientConnectionManager) {
-        return HttpAsyncClientBuilder.create()
-                .setConnectionManager(clientConnectionManager)
-                .addExecInterceptorBefore(ChainElement.CONNECT.name(), "dropwizard-metrics",
-                        new InstrumentedAsyncExecChainHandler(metricRegistry, metricNameStrategy));
-    }
-
+  private InstrumentedHttpAsyncClients() {
+    super();
+  }
+
+  public static CloseableHttpAsyncClient createDefault(MetricRegistry metricRegistry) {
+    return createDefault(metricRegistry, METHOD_ONLY);
+  }
+
+  public static CloseableHttpAsyncClient createDefault(
+      MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy) {
+    return custom(metricRegistry, metricNameStrategy).build();
+  }
+
+  public static HttpAsyncClientBuilder custom(MetricRegistry metricRegistry) {
+    return custom(metricRegistry, METHOD_ONLY);
+  }
+
+  public static HttpAsyncClientBuilder custom(
+      MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy) {
+    return custom(
+        metricRegistry,
+        metricNameStrategy,
+        InstrumentedAsyncClientConnectionManager.builder(metricRegistry).build());
+  }
+
+  public static HttpAsyncClientBuilder custom(
+      MetricRegistry metricRegistry,
+      HttpClientMetricNameStrategy metricNameStrategy,
+      AsyncClientConnectionManager clientConnectionManager) {
+    return HttpAsyncClientBuilder.create()
+        .setConnectionManager(clientConnectionManager)
+        .addExecInterceptorBefore(
+            ChainElement.CONNECT.name(),
+            "dropwizard-metrics",
+            new InstrumentedAsyncExecChainHandler(metricRegistry, metricNameStrategy));
+  }
 }
--- a/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpClientConnectionManager.java
+++ b/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpClientConnectionManager.java
@@ -1,5 +1,8 @@
 package io.dropwizard.metrics5.httpclient5;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static java.util.Objects.requireNonNull;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import org.apache.hc.client5.http.DnsResolver;
 import org.apache.hc.client5.http.SchemePortResolver;
@@ -20,156 +23,152 @@ import org.apache.hc.core5.pool.PoolConcurrencyPolicy;
 import org.apache.hc.core5.pool.PoolReusePolicy;
 import org.apache.hc.core5.util.TimeValue;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static java.util.Objects.requireNonNull;
-
-/**
- * A {@link HttpClientConnectionManager} which monitors the number of open connections.
- */
+/** A {@link HttpClientConnectionManager} which monitors the number of open connections. */
 public class InstrumentedHttpClientConnectionManager extends PoolingHttpClientConnectionManager {
-    private static final String METRICS_PREFIX = HttpClientConnectionManager.class.getName();
+  private static final String METRICS_PREFIX = HttpClientConnectionManager.class.getName();
+
+  protected static Registry<ConnectionSocketFactory> getDefaultRegistry() {
+    return RegistryBuilder.<ConnectionSocketFactory>create()
+        .register(URIScheme.HTTP.id, PlainConnectionSocketFactory.getSocketFactory())
+        .register(URIScheme.HTTPS.id, SSLConnectionSocketFactory.getSocketFactory())
+        .build();
+  }
+
+  private final MetricRegistry metricsRegistry;
+  private final String name;
+
+  InstrumentedHttpClientConnectionManager(
+      final MetricRegistry metricRegistry,
+      final String name,
+      final HttpClientConnectionOperator httpClientConnectionOperator,
+      final PoolConcurrencyPolicy poolConcurrencyPolicy,
+      final PoolReusePolicy poolReusePolicy,
+      final TimeValue timeToLive,
+      final HttpConnectionFactory<ManagedHttpClientConnection> connFactory) {
+
+    super(
+        httpClientConnectionOperator,
+        poolConcurrencyPolicy,
+        poolReusePolicy,
+        timeToLive,
+        connFactory);
+    this.metricsRegistry = requireNonNull(metricRegistry, "metricRegistry");
+    this.name = name;
+
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(METRICS_PREFIX, name, "available-connections"), () -> getTotalStats().getAvailable());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(METRICS_PREFIX, name, "leased-connections"), () -> getTotalStats().getLeased());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(METRICS_PREFIX, name, "max-connections"), () -> getTotalStats().getMax());
+    // this acquires a lock on the connection pool; remove if contention sucks
+    metricRegistry.registerGauge(
+        name(METRICS_PREFIX, name, "pending-connections"), () -> getTotalStats().getPending());
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void close() {
+    close(CloseMode.GRACEFUL);
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public void close(CloseMode closeMode) {
+    super.close(closeMode);
+    metricsRegistry.remove(name(METRICS_PREFIX, name, "available-connections"));
+    metricsRegistry.remove(name(METRICS_PREFIX, name, "leased-connections"));
+    metricsRegistry.remove(name(METRICS_PREFIX, name, "max-connections"));
+    metricsRegistry.remove(name(METRICS_PREFIX, name, "pending-connections"));
+  }
+
+  public static Builder builder(MetricRegistry metricsRegistry) {
+    return new Builder().metricsRegistry(metricsRegistry);
+  }
+
+  public static class Builder {
+    private MetricRegistry metricsRegistry;
+    private String name;
+    private HttpClientConnectionOperator httpClientConnectionOperator;
+    private Registry<ConnectionSocketFactory> socketFactoryRegistry = getDefaultRegistry();
+    private SchemePortResolver schemePortResolver;
+    private DnsResolver dnsResolver;
+    private PoolConcurrencyPolicy poolConcurrencyPolicy;
+    private PoolReusePolicy poolReusePolicy;
+    private TimeValue timeToLive = TimeValue.NEG_ONE_MILLISECOND;
+    private HttpConnectionFactory<ManagedHttpClientConnection> connFactory;
+
+    Builder() {}
+
+    public Builder metricsRegistry(MetricRegistry metricRegistry) {
+      this.metricsRegistry = requireNonNull(metricRegistry, "metricRegistry");
+      return this;
+    }
+
+    public Builder name(final String name) {
+      this.name = name;
+      return this;
+    }
+
+    public Builder socketFactoryRegistry(Registry<ConnectionSocketFactory> socketFactoryRegistry) {
+      this.socketFactoryRegistry = requireNonNull(socketFactoryRegistry, "socketFactoryRegistry");
+      return this;
+    }
+
+    public Builder connFactory(HttpConnectionFactory<ManagedHttpClientConnection> connFactory) {
+      this.connFactory = connFactory;
+      return this;
+    }
+
+    public Builder schemePortResolver(SchemePortResolver schemePortResolver) {
+      this.schemePortResolver = schemePortResolver;
+      return this;
+    }
 
-    protected static Registry<ConnectionSocketFactory> getDefaultRegistry() {
-        return RegistryBuilder.<ConnectionSocketFactory>create()
-                .register(URIScheme.HTTP.id, PlainConnectionSocketFactory.getSocketFactory())
-                .register(URIScheme.HTTPS.id, SSLConnectionSocketFactory.getSocketFactory())
-                .build();
+    public Builder dnsResolver(DnsResolver dnsResolver) {
+      this.dnsResolver = dnsResolver;
+      return this;
     }
 
-    private final MetricRegistry metricsRegistry;
-    private final String name;
-
-    InstrumentedHttpClientConnectionManager(final MetricRegistry metricRegistry,
-                                            final String name,
-                                            final HttpClientConnectionOperator httpClientConnectionOperator,
-                                            final PoolConcurrencyPolicy poolConcurrencyPolicy,
-                                            final PoolReusePolicy poolReusePolicy,
-                                            final TimeValue timeToLive,
-                                            final HttpConnectionFactory<ManagedHttpClientConnection> connFactory) {
-
-        super(httpClientConnectionOperator, poolConcurrencyPolicy, poolReusePolicy, timeToLive, connFactory);
-        this.metricsRegistry = requireNonNull(metricRegistry, "metricRegistry");
-        this.name = name;
-
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(METRICS_PREFIX, name, "available-connections"),
-                () -> getTotalStats().getAvailable());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(METRICS_PREFIX, name, "leased-connections"),
-                () -> getTotalStats().getLeased());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(METRICS_PREFIX, name, "max-connections"),
-                () -> getTotalStats().getMax());
-        // this acquires a lock on the connection pool; remove if contention sucks
-        metricRegistry.registerGauge(name(METRICS_PREFIX, name, "pending-connections"),
-                () -> getTotalStats().getPending());
+    public Builder timeToLive(TimeValue timeToLive) {
+      this.timeToLive = timeToLive;
+      return this;
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void close() {
-        close(CloseMode.GRACEFUL);
+    public Builder httpClientConnectionOperator(
+        HttpClientConnectionOperator httpClientConnectionOperator) {
+      this.httpClientConnectionOperator = httpClientConnectionOperator;
+      return this;
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void close(CloseMode closeMode) {
-        super.close(closeMode);
-        metricsRegistry.remove(name(METRICS_PREFIX, name, "available-connections"));
-        metricsRegistry.remove(name(METRICS_PREFIX, name, "leased-connections"));
-        metricsRegistry.remove(name(METRICS_PREFIX, name, "max-connections"));
-        metricsRegistry.remove(name(METRICS_PREFIX, name, "pending-connections"));
+    public Builder poolConcurrencyPolicy(PoolConcurrencyPolicy poolConcurrencyPolicy) {
+      this.poolConcurrencyPolicy = poolConcurrencyPolicy;
+      return this;
     }
 
-    public static Builder builder(MetricRegistry metricsRegistry) {
-        return new Builder().metricsRegistry(metricsRegistry);
+    public Builder poolReusePolicy(PoolReusePolicy poolReusePolicy) {
+      this.poolReusePolicy = poolReusePolicy;
+      return this;
     }
 
-    public static class Builder {
-        private MetricRegistry metricsRegistry;
-        private String name;
-        private HttpClientConnectionOperator httpClientConnectionOperator;
-        private Registry<ConnectionSocketFactory> socketFactoryRegistry = getDefaultRegistry();
-        private SchemePortResolver schemePortResolver;
-        private DnsResolver dnsResolver;
-        private PoolConcurrencyPolicy poolConcurrencyPolicy;
-        private PoolReusePolicy poolReusePolicy;
-        private TimeValue timeToLive = TimeValue.NEG_ONE_MILLISECOND;
-        private HttpConnectionFactory<ManagedHttpClientConnection> connFactory;
-
-        Builder() {
-        }
-
-        public Builder metricsRegistry(MetricRegistry metricRegistry) {
-            this.metricsRegistry = requireNonNull(metricRegistry, "metricRegistry");
-            return this;
-        }
-
-        public Builder name(final String name) {
-            this.name = name;
-            return this;
-        }
-
-        public Builder socketFactoryRegistry(Registry<ConnectionSocketFactory> socketFactoryRegistry) {
-            this.socketFactoryRegistry = requireNonNull(socketFactoryRegistry, "socketFactoryRegistry");
-            return this;
-        }
-
-        public Builder connFactory(HttpConnectionFactory<ManagedHttpClientConnection> connFactory) {
-            this.connFactory = connFactory;
-            return this;
-        }
-
-        public Builder schemePortResolver(SchemePortResolver schemePortResolver) {
-            this.schemePortResolver = schemePortResolver;
-            return this;
-        }
-
-        public Builder dnsResolver(DnsResolver dnsResolver) {
-            this.dnsResolver = dnsResolver;
-            return this;
-        }
-
-        public Builder timeToLive(TimeValue timeToLive) {
-            this.timeToLive = timeToLive;
-            return this;
-        }
-
-        public Builder httpClientConnectionOperator(HttpClientConnectionOperator httpClientConnectionOperator) {
-            this.httpClientConnectionOperator = httpClientConnectionOperator;
-            return this;
-        }
-
-        public Builder poolConcurrencyPolicy(PoolConcurrencyPolicy poolConcurrencyPolicy) {
-            this.poolConcurrencyPolicy = poolConcurrencyPolicy;
-            return this;
-        }
-
-        public Builder poolReusePolicy(PoolReusePolicy poolReusePolicy) {
-            this.poolReusePolicy = poolReusePolicy;
-            return this;
-        }
-
-        public InstrumentedHttpClientConnectionManager build() {
-            if (httpClientConnectionOperator == null) {
-                httpClientConnectionOperator = new DefaultHttpClientConnectionOperator(
-                        socketFactoryRegistry,
-                        schemePortResolver,
-                        dnsResolver);
-            }
-
-            return new InstrumentedHttpClientConnectionManager(
-                    metricsRegistry,
-                    name,
-                    httpClientConnectionOperator,
-                    poolConcurrencyPolicy,
-                    poolReusePolicy,
-                    timeToLive,
-                    connFactory);
-        }
+    public InstrumentedHttpClientConnectionManager build() {
+      if (httpClientConnectionOperator == null) {
+        httpClientConnectionOperator =
+            new DefaultHttpClientConnectionOperator(
+                socketFactoryRegistry, schemePortResolver, dnsResolver);
+      }
+
+      return new InstrumentedHttpClientConnectionManager(
+          metricsRegistry,
+          name,
+          httpClientConnectionOperator,
+          poolConcurrencyPolicy,
+          poolReusePolicy,
+          timeToLive,
+          connFactory);
     }
+  }
 }
--- a/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpClients.java
+++ b/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpClients.java
@@ -1,34 +1,34 @@
 package io.dropwizard.metrics5.httpclient5;
 
+import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.METHOD_ONLY;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
 import org.apache.hc.client5.http.impl.classic.HttpClientBuilder;
 
-import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.METHOD_ONLY;
-
 public class InstrumentedHttpClients {
-    private InstrumentedHttpClients() {
-        super();
-    }
-
-    public static CloseableHttpClient createDefault(MetricRegistry metricRegistry) {
-        return createDefault(metricRegistry, METHOD_ONLY);
-    }
-
-    public static CloseableHttpClient createDefault(MetricRegistry metricRegistry,
-                                                    HttpClientMetricNameStrategy metricNameStrategy) {
-        return custom(metricRegistry, metricNameStrategy).build();
-    }
-
-    public static HttpClientBuilder custom(MetricRegistry metricRegistry) {
-        return custom(metricRegistry, METHOD_ONLY);
-    }
-
-    public static HttpClientBuilder custom(MetricRegistry metricRegistry,
-                                           HttpClientMetricNameStrategy metricNameStrategy) {
-        return HttpClientBuilder.create()
-                .setRequestExecutor(new InstrumentedHttpRequestExecutor(metricRegistry, metricNameStrategy))
-                .setConnectionManager(InstrumentedHttpClientConnectionManager.builder(metricRegistry).build());
-    }
-
+  private InstrumentedHttpClients() {
+    super();
+  }
+
+  public static CloseableHttpClient createDefault(MetricRegistry metricRegistry) {
+    return createDefault(metricRegistry, METHOD_ONLY);
+  }
+
+  public static CloseableHttpClient createDefault(
+      MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy) {
+    return custom(metricRegistry, metricNameStrategy).build();
+  }
+
+  public static HttpClientBuilder custom(MetricRegistry metricRegistry) {
+    return custom(metricRegistry, METHOD_ONLY);
+  }
+
+  public static HttpClientBuilder custom(
+      MetricRegistry metricRegistry, HttpClientMetricNameStrategy metricNameStrategy) {
+    return HttpClientBuilder.create()
+        .setRequestExecutor(new InstrumentedHttpRequestExecutor(metricRegistry, metricNameStrategy))
+        .setConnectionManager(
+            InstrumentedHttpClientConnectionManager.builder(metricRegistry).build());
+  }
 }
--- a/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpRequestExecutor.java
+++ b/metrics-httpclient5/src/main/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpRequestExecutor.java
@@ -3,6 +3,7 @@ package io.dropwizard.metrics5.httpclient5;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.io.IOException;
 import org.apache.hc.core5.http.ClassicHttpRequest;
 import org.apache.hc.core5.http.ClassicHttpResponse;
 import org.apache.hc.core5.http.ConnectionReuseStrategy;
@@ -15,64 +16,66 @@ import org.apache.hc.core5.http.io.HttpResponseInformationCallback;
 import org.apache.hc.core5.http.protocol.HttpContext;
 import org.apache.hc.core5.util.Timeout;
 
-import java.io.IOException;
-
 public class InstrumentedHttpRequestExecutor extends HttpRequestExecutor {
-    private final MetricRegistry registry;
-    private final HttpClientMetricNameStrategy metricNameStrategy;
-    private final String name;
+  private final MetricRegistry registry;
+  private final HttpClientMetricNameStrategy metricNameStrategy;
+  private final String name;
 
-    public InstrumentedHttpRequestExecutor(MetricRegistry registry,
-                                           HttpClientMetricNameStrategy metricNameStrategy) {
-        this(registry, metricNameStrategy, null);
-    }
+  public InstrumentedHttpRequestExecutor(
+      MetricRegistry registry, HttpClientMetricNameStrategy metricNameStrategy) {
+    this(registry, metricNameStrategy, null);
+  }
 
-    public InstrumentedHttpRequestExecutor(MetricRegistry registry,
-                                           HttpClientMetricNameStrategy metricNameStrategy,
-                                           String name) {
-        this(registry, metricNameStrategy, name, HttpRequestExecutor.DEFAULT_WAIT_FOR_CONTINUE);
-    }
+  public InstrumentedHttpRequestExecutor(
+      MetricRegistry registry, HttpClientMetricNameStrategy metricNameStrategy, String name) {
+    this(registry, metricNameStrategy, name, HttpRequestExecutor.DEFAULT_WAIT_FOR_CONTINUE);
+  }
 
-    public InstrumentedHttpRequestExecutor(MetricRegistry registry,
-                                           HttpClientMetricNameStrategy metricNameStrategy,
-                                           String name,
-                                           Timeout waitForContinue) {
-        this(registry, metricNameStrategy, name, waitForContinue, null, null);
-    }
+  public InstrumentedHttpRequestExecutor(
+      MetricRegistry registry,
+      HttpClientMetricNameStrategy metricNameStrategy,
+      String name,
+      Timeout waitForContinue) {
+    this(registry, metricNameStrategy, name, waitForContinue, null, null);
+  }
 
-    public InstrumentedHttpRequestExecutor(MetricRegistry registry,
-                                           HttpClientMetricNameStrategy metricNameStrategy,
-                                           String name,
-                                           Timeout waitForContinue,
-                                           ConnectionReuseStrategy connReuseStrategy,
-                                           Http1StreamListener streamListener) {
-        super(waitForContinue, connReuseStrategy, streamListener);
-        this.registry = registry;
-        this.name = name;
-        this.metricNameStrategy = metricNameStrategy;
-    }
+  public InstrumentedHttpRequestExecutor(
+      MetricRegistry registry,
+      HttpClientMetricNameStrategy metricNameStrategy,
+      String name,
+      Timeout waitForContinue,
+      ConnectionReuseStrategy connReuseStrategy,
+      Http1StreamListener streamListener) {
+    super(waitForContinue, connReuseStrategy, streamListener);
+    this.registry = registry;
+    this.name = name;
+    this.metricNameStrategy = metricNameStrategy;
+  }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ClassicHttpResponse execute(ClassicHttpRequest request, HttpClientConnection conn, HttpResponseInformationCallback informationCallback, HttpContext context) throws IOException, HttpException {
-        final Timer.Context timerContext = timer(request).time();
-        try {
-            return super.execute(request, conn, informationCallback, context);
-        } catch (HttpException | IOException e) {
-            meter(e).mark();
-            throw e;
-        } finally {
-            timerContext.stop();
-        }
+  /** {@inheritDoc} */
+  @Override
+  public ClassicHttpResponse execute(
+      ClassicHttpRequest request,
+      HttpClientConnection conn,
+      HttpResponseInformationCallback informationCallback,
+      HttpContext context)
+      throws IOException, HttpException {
+    final Timer.Context timerContext = timer(request).time();
+    try {
+      return super.execute(request, conn, informationCallback, context);
+    } catch (HttpException | IOException e) {
+      meter(e).mark();
+      throw e;
+    } finally {
+      timerContext.stop();
     }
+  }
 
-    private Timer timer(HttpRequest request) {
-        return registry.timer(metricNameStrategy.getNameFor(name, request));
-    }
+  private Timer timer(HttpRequest request) {
+    return registry.timer(metricNameStrategy.getNameFor(name, request));
+  }
 
-    private Meter meter(Exception e) {
-        return registry.meter(metricNameStrategy.getNameFor(name, e));
-    }
+  private Meter meter(Exception e) {
+    return registry.meter(metricNameStrategy.getNameFor(name, e));
+  }
 }
--- a/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/HttpClientMetricNameStrategiesTest.java
+++ b/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/HttpClientMetricNameStrategiesTest.java
@@ -1,6 +1,13 @@
 package io.dropwizard.metrics5.httpclient5;
 
+import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.HOST_AND_METHOD;
+import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.METHOD_ONLY;
+import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.QUERYLESS_URL_AND_METHOD;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricName;
+import java.net.URI;
+import java.net.URISyntaxException;
 import org.apache.hc.client5.http.classic.methods.HttpGet;
 import org.apache.hc.client5.http.classic.methods.HttpPost;
 import org.apache.hc.client5.http.classic.methods.HttpPut;
@@ -9,76 +16,84 @@ import org.apache.hc.core5.http.message.HttpRequestWrapper;
 import org.apache.hc.core5.net.URIBuilder;
 import org.junit.jupiter.api.Test;
 
-import java.net.URI;
-import java.net.URISyntaxException;
-
-import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.HOST_AND_METHOD;
-import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.METHOD_ONLY;
-import static io.dropwizard.metrics5.httpclient5.HttpClientMetricNameStrategies.QUERYLESS_URL_AND_METHOD;
-import static org.assertj.core.api.Assertions.assertThat;
-
-class HttpClientMetricNameStrategiesTest {
-
-    @Test
-    void methodOnlyWithName() {
-        assertThat(METHOD_ONLY.getNameFor("some-service", new HttpGet("/whatever")))
-                .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.some-service.get-requests"));
-    }
-
-    @Test
-    void methodOnlyWithoutName() {
-        assertThat(METHOD_ONLY.getNameFor(null, new HttpGet("/whatever")))
-                .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.get-requests"));
-    }
-
-    @Test
-    void hostAndMethodWithName() {
-        assertThat(HOST_AND_METHOD.getNameFor("some-service", new HttpPost("http://my.host.com/whatever")))
-                .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.some-service.my.host.com.post-requests"));
-    }
-
-    @Test
-    void hostAndMethodWithoutName() {
-        assertThat(HOST_AND_METHOD.getNameFor(null, new HttpPost("http://my.host.com/whatever")))
-                .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.my.host.com.post-requests"));
-    }
-
-    @Test
-    void hostAndMethodWithNameInWrappedRequest() throws URISyntaxException {
-        HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
-
-        assertThat(HOST_AND_METHOD.getNameFor("some-service", request))
-                .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.some-service.my.host.com.post-requests"));
-    }
-
-    @Test
-    void hostAndMethodWithoutNameInWrappedRequest() throws URISyntaxException {
-        HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
-
-        assertThat(HOST_AND_METHOD.getNameFor(null, request))
-                .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.my.host.com.post-requests"));
-    }
-
-    @Test
-    void querylessUrlAndMethodWithName() {
-        assertThat(QUERYLESS_URL_AND_METHOD.getNameFor(
-                "some-service",
-                new HttpPut("https://thing.com:8090/my/path?ignore=this&and=this")))
-                .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.some-service.https://thing.com:8090/my/path.put-requests"));
-    }
-
-    @Test
-    void querylessUrlAndMethodWithNameInWrappedRequest() throws URISyntaxException {
-        HttpRequest request = rewriteRequestURI(new HttpPut("https://thing.com:8090/my/path?ignore=this&and=this"));
-        assertThat(QUERYLESS_URL_AND_METHOD.getNameFor("some-service", request))
-                .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.some-service.https://thing.com:8090/my/path.put-requests"));
-    }
-
-    private static HttpRequest rewriteRequestURI(HttpRequest request) throws URISyntaxException {
-        URI uri = new URIBuilder(request.getUri()).setFragment(null).build();
-        HttpRequestWrapper wrapper = new HttpRequestWrapper(request);
-        wrapper.setUri(uri);
-
-        return wrapper;
-    }
+final class HttpClientMetricNameStrategiesTest {
+
+  @Test
+  void methodOnlyWithName() {
+    assertThat(METHOD_ONLY.getNameFor("some-service", new HttpGet("/whatever")))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.hc.client5.http.classic.HttpClient.some-service.get-requests"));
+  }
+
+  @Test
+  void methodOnlyWithoutName() {
+    assertThat(METHOD_ONLY.getNameFor(null, new HttpGet("/whatever")))
+        .isEqualTo(MetricName.build("org.apache.hc.client5.http.classic.HttpClient.get-requests"));
+  }
+
+  @Test
+  void hostAndMethodWithName() {
+    assertThat(
+            HOST_AND_METHOD.getNameFor("some-service", new HttpPost("http://my.host.com/whatever")))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.hc.client5.http.classic.HttpClient.some-service.my.host.com.post-requests"));
+  }
+
+  @Test
+  void hostAndMethodWithoutName() {
+    assertThat(HOST_AND_METHOD.getNameFor(null, new HttpPost("http://my.host.com/whatever")))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.hc.client5.http.classic.HttpClient.my.host.com.post-requests"));
+  }
+
+  @Test
+  void hostAndMethodWithNameInWrappedRequest() throws URISyntaxException {
+    HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
+
+    assertThat(HOST_AND_METHOD.getNameFor("some-service", request))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.hc.client5.http.classic.HttpClient.some-service.my.host.com.post-requests"));
+  }
+
+  @Test
+  void hostAndMethodWithoutNameInWrappedRequest() throws URISyntaxException {
+    HttpRequest request = rewriteRequestURI(new HttpPost("http://my.host.com/whatever"));
+
+    assertThat(HOST_AND_METHOD.getNameFor(null, request))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.hc.client5.http.classic.HttpClient.my.host.com.post-requests"));
+  }
+
+  @Test
+  void querylessUrlAndMethodWithName() {
+    assertThat(
+            QUERYLESS_URL_AND_METHOD.getNameFor(
+                "some-service", new HttpPut("https://thing.com:8090/my/path?ignore=this&and=this")))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.hc.client5.http.classic.HttpClient.some-service.https://thing.com:8090/my/path.put-requests"));
+  }
+
+  @Test
+  void querylessUrlAndMethodWithNameInWrappedRequest() throws URISyntaxException {
+    HttpRequest request =
+        rewriteRequestURI(new HttpPut("https://thing.com:8090/my/path?ignore=this&and=this"));
+    assertThat(QUERYLESS_URL_AND_METHOD.getNameFor("some-service", request))
+        .isEqualTo(
+            MetricName.build(
+                "org.apache.hc.client5.http.classic.HttpClient.some-service.https://thing.com:8090/my/path.put-requests"));
+  }
+
+  private static HttpRequest rewriteRequestURI(HttpRequest request) throws URISyntaxException {
+    URI uri = new URIBuilder(request.getUri()).setFragment(null).build();
+    HttpRequestWrapper wrapper = new HttpRequestWrapper(request);
+    wrapper.setUri(uri);
+
+    return wrapper;
+  }
 }
--- a/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/InstrumentedAsyncClientConnectionManagerTest.java
+++ b/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/InstrumentedAsyncClientConnectionManagerTest.java
@@ -1,49 +1,60 @@
 package io.dropwizard.metrics5.httpclient5;
 
-import io.dropwizard.metrics5.MetricName;
-import io.dropwizard.metrics5.MetricRegistry;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mockito;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.atLeast;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import io.dropwizard.metrics5.MetricName;
+import io.dropwizard.metrics5.MetricRegistry;
+import org.junit.jupiter.api.Test;
+import org.mockito.ArgumentCaptor;
 
-class InstrumentedAsyncClientConnectionManagerTest {
-    private final MetricRegistry metricRegistry = new MetricRegistry();
+final class InstrumentedAsyncClientConnectionManagerTest {
+  private final MetricRegistry metricRegistry = new MetricRegistry();
 
-    @Test
-    void shouldRemoveGauges() {
-        final InstrumentedAsyncClientConnectionManager instrumentedHttpClientConnectionManager = InstrumentedAsyncClientConnectionManager.builder(metricRegistry).build();
-        assertThat(metricRegistry.getGauges().entrySet().stream()
+  @Test
+  void shouldRemoveGauges() {
+    final InstrumentedAsyncClientConnectionManager instrumentedHttpClientConnectionManager =
+        InstrumentedAsyncClientConnectionManager.builder(metricRegistry).build();
+    assertThat(
+            metricRegistry.getGauges().entrySet().stream()
                 .map(e -> entry(e.getKey().getKey(), (Integer) e.getValue().getValue())))
-                .containsOnly(entry("org.apache.hc.client5.http.nio.AsyncClientConnectionManager.available-connections", 0),
-                        entry("org.apache.hc.client5.http.nio.AsyncClientConnectionManager.leased-connections", 0),
-                        entry("org.apache.hc.client5.http.nio.AsyncClientConnectionManager.max-connections", 25),
-                        entry("org.apache.hc.client5.http.nio.AsyncClientConnectionManager.pending-connections", 0));
-
-        instrumentedHttpClientConnectionManager.close();
-        assertEquals(0, metricRegistry.getGauges().size());
-
-        // should be able to create another one with the same name ("")
-        InstrumentedHttpClientConnectionManager.builder(metricRegistry).build().close();
-    }
-
-    @Test
-    void configurableViaBuilder() {
-        final MetricRegistry registry = Mockito.mock(MetricRegistry.class);
-
-        InstrumentedAsyncClientConnectionManager.builder(registry)
-                .name("some-name")
-                .name("some-other-name")
-                .build()
-                .close();
-
-        ArgumentCaptor<MetricName> argumentCaptor = ArgumentCaptor.forClass(MetricName.class);
-        Mockito.verify(registry, Mockito.atLeast(1)).registerGauge(argumentCaptor.capture(), any());
-        assertTrue(argumentCaptor.getValue().getKey().contains("some-other-name"));
-    }
+        .containsOnly(
+            entry(
+                "org.apache.hc.client5.http.nio.AsyncClientConnectionManager.available-connections",
+                0),
+            entry(
+                "org.apache.hc.client5.http.nio.AsyncClientConnectionManager.leased-connections",
+                0),
+            entry(
+                "org.apache.hc.client5.http.nio.AsyncClientConnectionManager.max-connections", 25),
+            entry(
+                "org.apache.hc.client5.http.nio.AsyncClientConnectionManager.pending-connections",
+                0));
+
+    instrumentedHttpClientConnectionManager.close();
+    assertEquals(0, metricRegistry.getGauges().size());
+
+    // should be able to create another one with the same name ("")
+    InstrumentedHttpClientConnectionManager.builder(metricRegistry).build().close();
+  }
+
+  @Test
+  void configurableViaBuilder() {
+    final MetricRegistry registry = mock();
+
+    InstrumentedAsyncClientConnectionManager.builder(registry)
+        .name("some-name")
+        .name("some-other-name")
+        .build()
+        .close();
+
+    ArgumentCaptor<MetricName> argumentCaptor = ArgumentCaptor.forClass(MetricName.class);
+    verify(registry, atLeast(1)).registerGauge(argumentCaptor.capture(), any());
+    assertThat(argumentCaptor.getValue().getKey().contains("some-other-name")).isTrue();
+  }
 }
--- a/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpAsyncClientsTest.java
+++ b/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpAsyncClientsTest.java
@@ -1,11 +1,28 @@
 package io.dropwizard.metrics5.httpclient5;
 
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.awaitility.Awaitility.await;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.sun.net.httpserver.HttpExchange;
 import com.sun.net.httpserver.HttpServer;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricRegistryListener;
 import io.dropwizard.metrics5.Timer;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
 import org.apache.hc.client5.http.async.methods.SimpleHttpRequest;
 import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;
 import org.apache.hc.client5.http.async.methods.SimpleRequestBuilder;
@@ -21,182 +38,191 @@ import org.junit.jupiter.api.extension.ExtendWith;
 import org.mockito.Mock;
 import org.mockito.junit.jupiter.MockitoExtension;
 
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.nio.charset.StandardCharsets;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.awaitility.Awaitility.await;
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @ExtendWith(MockitoExtension.class)
-class InstrumentedHttpAsyncClientsTest {
-
-    @Mock
-    private HttpClientMetricNameStrategy metricNameStrategy;
-    @Mock
-    private MetricRegistryListener registryListener;
-    private HttpServer httpServer;
-    private MetricRegistry metricRegistry;
-    private CloseableHttpAsyncClient client;
-
-    @BeforeEach
-    void setUp() throws IOException {
-        httpServer = HttpServer.create(new InetSocketAddress(0), 0);
-
-        metricRegistry = new MetricRegistry();
-        metricRegistry.addListener(registryListener);
+final class InstrumentedHttpAsyncClientsTest {
+
+  @Mock private HttpClientMetricNameStrategy metricNameStrategy;
+  @Mock private MetricRegistryListener registryListener;
+  private HttpServer httpServer;
+  private MetricRegistry metricRegistry;
+  private CloseableHttpAsyncClient client;
+
+  @BeforeEach
+  void setUp() throws IOException {
+    httpServer = HttpServer.create(new InetSocketAddress(0), 0);
+
+    metricRegistry = new MetricRegistry();
+    metricRegistry.addListener(registryListener);
+  }
+
+  @AfterEach
+  void tearDown() throws IOException {
+    if (client != null) {
+      client.close();
     }
-
-    @AfterEach
-    void tearDown() throws IOException {
-        if (client != null) {
-            client.close();
-        }
-        if (httpServer != null) {
-            httpServer.stop(0);
-        }
+    if (httpServer != null) {
+      httpServer.stop(0);
     }
-
-    @Test
-    void registersExpectedMetricsGivenNameStrategy() throws Exception {
-        client = InstrumentedHttpAsyncClients.custom(metricRegistry, metricNameStrategy).disableAutomaticRetries().build();
-        client.start();
-
-        final SimpleHttpRequest request = SimpleRequestBuilder
-                .get("http://localhost:" + httpServer.getAddress().getPort() + "/")
-                .build();
-        final MetricName metricName = MetricName.build("some.made.up.metric.name");
-
-        httpServer.createContext("/", exchange -> {
-            exchange.sendResponseHeaders(200, 0L);
-            exchange.setStreams(null, null);
-            exchange.getResponseBody().write("TEST".getBytes(StandardCharsets.US_ASCII));
-            exchange.close();
+  }
+
+  @Test
+  void registersExpectedMetricsGivenNameStrategy() throws Exception {
+    client =
+        InstrumentedHttpAsyncClients.custom(metricRegistry, metricNameStrategy)
+            .disableAutomaticRetries()
+            .build();
+    client.start();
+
+    final SimpleHttpRequest request =
+        SimpleRequestBuilder.get("http://localhost:" + httpServer.getAddress().getPort() + "/")
+            .build();
+    final MetricName metricName = MetricName.build("some.made.up.metric.name");
+
+    httpServer.createContext(
+        "/",
+        exchange -> {
+          exchange.sendResponseHeaders(200, 0L);
+          exchange.setStreams(null, null);
+          exchange.getResponseBody().write("TEST".getBytes(US_ASCII));
+          exchange.close();
         });
-        httpServer.start();
+    httpServer.start();
 
-        when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class))).thenReturn(metricName);
+    when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class))).thenReturn(metricName);
 
-        final Future<SimpleHttpResponse> responseFuture = client.execute(request, new FutureCallback<SimpleHttpResponse>() {
-            @Override
-            public void completed(SimpleHttpResponse result) {
+    final Future<SimpleHttpResponse> responseFuture =
+        client.execute(
+            request,
+            new FutureCallback<SimpleHttpResponse>() {
+              @Override
+              public void completed(SimpleHttpResponse result) {
                 assertThat(result.getBodyText()).isEqualTo("TEST");
-            }
+              }
 
-            @Override
-            public void failed(Exception ex) {
+              @Override
+              public void failed(Exception ex) {
                 fail();
-            }
+              }
 
-            @Override
-            public void cancelled() {
+              @Override
+              public void cancelled() {
                 fail();
-            }
-        });
-        responseFuture.get(1L, TimeUnit.SECONDS);
-
-        verify(registryListener).onTimerAdded(eq(metricName), any(Timer.class));
-    }
-
-    @Test
-    void registersExpectedExceptionMetrics() throws Exception {
-        client = InstrumentedHttpAsyncClients.custom(metricRegistry, metricNameStrategy).disableAutomaticRetries().build();
-        client.start();
-
-        final CountDownLatch countDownLatch = new CountDownLatch(1);
-        final SimpleHttpRequest request = SimpleRequestBuilder
-                .get("http://localhost:" + httpServer.getAddress().getPort() + "/")
-                .build();
-        final MetricName requestMetricName = MetricName.build("request");
-        final MetricName exceptionMetricName = MetricName.build("exception");
-
-        httpServer.createContext("/", HttpExchange::close);
-        httpServer.start();
-
-        when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
-                .thenReturn(requestMetricName);
-        when(metricNameStrategy.getNameFor(any(), any(Exception.class)))
-                .thenReturn(exceptionMetricName);
-
-        try {
-            final Future<SimpleHttpResponse> responseFuture = client.execute(request, new FutureCallback<SimpleHttpResponse>() {
+              }
+            });
+    responseFuture.get(1L, TimeUnit.SECONDS);
+
+    verify(registryListener).onTimerAdded(eq(metricName), any(Timer.class));
+  }
+
+  @Test
+  void registersExpectedExceptionMetrics() throws Exception {
+    client =
+        InstrumentedHttpAsyncClients.custom(metricRegistry, metricNameStrategy)
+            .disableAutomaticRetries()
+            .build();
+    client.start();
+
+    final CountDownLatch countDownLatch = new CountDownLatch(1);
+    final SimpleHttpRequest request =
+        SimpleRequestBuilder.get("http://localhost:" + httpServer.getAddress().getPort() + "/")
+            .build();
+    final MetricName requestMetricName = MetricName.build("request");
+    final MetricName exceptionMetricName = MetricName.build("exception");
+
+    httpServer.createContext("/", HttpExchange::close);
+    httpServer.start();
+
+    when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
+        .thenReturn(requestMetricName);
+    when(metricNameStrategy.getNameFor(any(), any(Exception.class)))
+        .thenReturn(exceptionMetricName);
+
+    try {
+      final Future<SimpleHttpResponse> responseFuture =
+          client.execute(
+              request,
+              new FutureCallback<SimpleHttpResponse>() {
                 @Override
                 public void completed(SimpleHttpResponse result) {
-                    fail();
+                  fail();
                 }
 
                 @Override
                 public void failed(Exception ex) {
-                    countDownLatch.countDown();
+                  countDownLatch.countDown();
                 }
 
                 @Override
                 public void cancelled() {
-                    fail();
+                  fail();
                 }
-            });
-            countDownLatch.await(5, TimeUnit.SECONDS);
-            responseFuture.get(5, TimeUnit.SECONDS);
-
-            fail();
-        } catch (ExecutionException e) {
-            assertThat(e).hasCauseInstanceOf(ConnectionClosedException.class);
-            await().atMost(5, TimeUnit.SECONDS)
-                    .untilAsserted(() -> assertThat(metricRegistry.getMeters()).containsKey(MetricName.build("exception")));
-        }
+              });
+      countDownLatch.await(5, TimeUnit.SECONDS);
+      responseFuture.get(5, TimeUnit.SECONDS);
+
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e).hasCauseInstanceOf(ConnectionClosedException.class);
+      await()
+          .atMost(5, TimeUnit.SECONDS)
+          .untilAsserted(
+              () ->
+                  assertThat(metricRegistry.getMeters())
+                      .containsKey(MetricName.build("exception")));
     }
+  }
+
+  @Test
+  void usesCustomClientConnectionManager() throws Exception {
+    try (PoolingAsyncClientConnectionManager clientConnectionManager =
+        spy(new PoolingAsyncClientConnectionManager())) {
+      client =
+          InstrumentedHttpAsyncClients.custom(
+                  metricRegistry, metricNameStrategy, clientConnectionManager)
+              .disableAutomaticRetries()
+              .build();
+      client.start();
+
+      final SimpleHttpRequest request =
+          SimpleRequestBuilder.get("http://localhost:" + httpServer.getAddress().getPort() + "/")
+              .build();
+      final MetricName metricName = MetricName.build("some.made.up.metric.name");
+
+      httpServer.createContext(
+          "/",
+          exchange -> {
+            exchange.sendResponseHeaders(200, 0L);
+            exchange.setStreams(null, null);
+            exchange.getResponseBody().write("TEST".getBytes(US_ASCII));
+            exchange.close();
+          });
+      httpServer.start();
 
-    @Test
-    void usesCustomClientConnectionManager() throws Exception {
-        try (PoolingAsyncClientConnectionManager clientConnectionManager = spy(new PoolingAsyncClientConnectionManager())) {
-            client = InstrumentedHttpAsyncClients.custom(metricRegistry, metricNameStrategy, clientConnectionManager).disableAutomaticRetries().build();
-            client.start();
-
-            final SimpleHttpRequest request = SimpleRequestBuilder
-                    .get("http://localhost:" + httpServer.getAddress().getPort() + "/")
-                    .build();
-            final MetricName metricName = MetricName.build("some.made.up.metric.name");
-
-            httpServer.createContext("/", exchange -> {
-                exchange.sendResponseHeaders(200, 0L);
-                exchange.setStreams(null, null);
-                exchange.getResponseBody().write("TEST".getBytes(StandardCharsets.US_ASCII));
-                exchange.close();
-            });
-            httpServer.start();
-
-            when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class))).thenReturn(metricName);
+      when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class))).thenReturn(metricName);
 
-            final Future<SimpleHttpResponse> responseFuture = client.execute(request, new FutureCallback<SimpleHttpResponse>() {
+      final Future<SimpleHttpResponse> responseFuture =
+          client.execute(
+              request,
+              new FutureCallback<SimpleHttpResponse>() {
                 @Override
                 public void completed(SimpleHttpResponse result) {
-                    assertThat(result.getCode()).isEqualTo(200);
+                  assertThat(result.getCode()).isEqualTo(200);
                 }
 
                 @Override
                 public void failed(Exception ex) {
-                    fail();
+                  fail();
                 }
 
                 @Override
                 public void cancelled() {
-                    fail();
+                  fail();
                 }
-            });
-            responseFuture.get(1L, TimeUnit.SECONDS);
+              });
+      responseFuture.get(1L, TimeUnit.SECONDS);
 
-            verify(clientConnectionManager, atLeastOnce()).connect(any(), any(), any(), any(), any(), any());
-        }
+      verify(clientConnectionManager, atLeastOnce())
+          .connect(any(), any(), any(), any(), any(), any());
     }
+  }
 }
--- a/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpClientConnectionManagerTest.java
+++ b/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpClientConnectionManagerTest.java
@@ -1,49 +1,58 @@
 package io.dropwizard.metrics5.httpclient5;
 
-import io.dropwizard.metrics5.MetricName;
-import io.dropwizard.metrics5.MetricRegistry;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mockito;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.atLeast;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import io.dropwizard.metrics5.MetricName;
+import io.dropwizard.metrics5.MetricRegistry;
+import org.junit.jupiter.api.Test;
+import org.mockito.ArgumentCaptor;
 
-class InstrumentedHttpClientConnectionManagerTest {
-    private final MetricRegistry metricRegistry = new MetricRegistry();
+final class InstrumentedHttpClientConnectionManagerTest {
+  private final MetricRegistry metricRegistry = new MetricRegistry();
 
-    @Test
-    void shouldRemoveGauges() {
-        final InstrumentedHttpClientConnectionManager instrumentedHttpClientConnectionManager = InstrumentedHttpClientConnectionManager.builder(metricRegistry).build();
-        assertThat(metricRegistry.getGauges().entrySet().stream()
+  @Test
+  void shouldRemoveGauges() {
+    final InstrumentedHttpClientConnectionManager instrumentedHttpClientConnectionManager =
+        InstrumentedHttpClientConnectionManager.builder(metricRegistry).build();
+    assertThat(
+            metricRegistry.getGauges().entrySet().stream()
                 .map(e -> entry(e.getKey().getKey(), (Integer) e.getValue().getValue())))
-                .containsOnly(entry("org.apache.hc.client5.http.io.HttpClientConnectionManager.available-connections", 0),
-                        entry("org.apache.hc.client5.http.io.HttpClientConnectionManager.leased-connections", 0),
-                        entry("org.apache.hc.client5.http.io.HttpClientConnectionManager.max-connections", 25),
-                        entry("org.apache.hc.client5.http.io.HttpClientConnectionManager.pending-connections", 0));
-
-        instrumentedHttpClientConnectionManager.close();
-        assertEquals(0, metricRegistry.getGauges().size());
-
-        // should be able to create another one with the same name ("")
-        InstrumentedHttpClientConnectionManager.builder(metricRegistry).build().close();
-    }
-
-    @Test
-    void configurableViaBuilder() {
-        final MetricRegistry registry = Mockito.mock(MetricRegistry.class);
-
-        InstrumentedHttpClientConnectionManager.builder(registry)
-                .name("some-name")
-                .name("some-other-name")
-                .build()
-                .close();
-
-        ArgumentCaptor<MetricName> argumentCaptor = ArgumentCaptor.forClass(MetricName.class);
-        Mockito.verify(registry, Mockito.atLeast(1)).registerGauge(argumentCaptor.capture(), any());
-        assertTrue(argumentCaptor.getValue().getKey().contains("some-other-name"));
-    }
+        .containsOnly(
+            entry(
+                "org.apache.hc.client5.http.io.HttpClientConnectionManager.available-connections",
+                0),
+            entry(
+                "org.apache.hc.client5.http.io.HttpClientConnectionManager.leased-connections", 0),
+            entry("org.apache.hc.client5.http.io.HttpClientConnectionManager.max-connections", 25),
+            entry(
+                "org.apache.hc.client5.http.io.HttpClientConnectionManager.pending-connections",
+                0));
+
+    instrumentedHttpClientConnectionManager.close();
+    assertEquals(0, metricRegistry.getGauges().size());
+
+    // should be able to create another one with the same name ("")
+    InstrumentedHttpClientConnectionManager.builder(metricRegistry).build().close();
+  }
+
+  @Test
+  void configurableViaBuilder() {
+    final MetricRegistry registry = mock();
+
+    InstrumentedHttpClientConnectionManager.builder(registry)
+        .name("some-name")
+        .name("some-other-name")
+        .build()
+        .close();
+
+    ArgumentCaptor<MetricName> argumentCaptor = ArgumentCaptor.forClass(MetricName.class);
+    verify(registry, atLeast(1)).registerGauge(argumentCaptor.capture(), any());
+    assertThat(argumentCaptor.getValue().getKey().contains("some-other-name")).isTrue();
+  }
 }
--- a/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpClientsTest.java
+++ b/metrics-httpclient5/src/test/java/io/dropwizard/metrics5/httpclient5/InstrumentedHttpClientsTest.java
@@ -1,11 +1,20 @@
 package io.dropwizard.metrics5.httpclient5;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.sun.net.httpserver.HttpExchange;
 import com.sun.net.httpserver.HttpServer;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricRegistryListener;
 import io.dropwizard.metrics5.Timer;
+import java.net.InetSocketAddress;
 import org.apache.hc.client5.http.classic.HttpClient;
 import org.apache.hc.client5.http.classic.methods.HttpGet;
 import org.apache.hc.core5.http.HttpRequest;
@@ -13,66 +22,55 @@ import org.apache.hc.core5.http.NoHttpResponseException;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.net.InetSocketAddress;
+final class InstrumentedHttpClientsTest {
+  private final HttpClientMetricNameStrategy metricNameStrategy = mock();
+  private final MetricRegistryListener registryListener = mock();
+  private final MetricRegistry metricRegistry = new MetricRegistry();
+  private final HttpClient client =
+      InstrumentedHttpClients.custom(metricRegistry, metricNameStrategy)
+          .disableAutomaticRetries()
+          .build();
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+  @BeforeEach
+  void setUp() {
+    metricRegistry.addListener(registryListener);
+  }
 
-class InstrumentedHttpClientsTest {
-    private final HttpClientMetricNameStrategy metricNameStrategy =
-            mock(HttpClientMetricNameStrategy.class);
-    private final MetricRegistryListener registryListener =
-            mock(MetricRegistryListener.class);
-    private final MetricRegistry metricRegistry = new MetricRegistry();
-    private final HttpClient client =
-            InstrumentedHttpClients.custom(metricRegistry, metricNameStrategy).disableAutomaticRetries().build();
+  @Test
+  void registersExpectedMetricsGivenNameStrategy() throws Exception {
+    final HttpGet get = new HttpGet("http://example.com?q=anything");
+    final MetricName metricName = MetricName.build("some.made.up.metric.name");
 
-    @BeforeEach
-    void setUp() {
-        metricRegistry.addListener(registryListener);
-    }
-
-    @Test
-    void registersExpectedMetricsGivenNameStrategy() throws Exception {
-        final HttpGet get = new HttpGet("http://example.com?q=anything");
-        final MetricName metricName = MetricName.build("some.made.up.metric.name");
+    when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class))).thenReturn(metricName);
 
-        when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
-                .thenReturn(metricName);
+    client.execute(get);
 
-        client.execute(get);
-
-        verify(registryListener).onTimerAdded(eq(metricName), any(Timer.class));
-    }
+    verify(registryListener).onTimerAdded(eq(metricName), any(Timer.class));
+  }
 
-    @Test
-    void registersExpectedExceptionMetrics() throws Exception {
-        HttpServer httpServer = HttpServer.create(new InetSocketAddress(0), 0);
+  @Test
+  void registersExpectedExceptionMetrics() throws Exception {
+    HttpServer httpServer = HttpServer.create(new InetSocketAddress(0), 0);
 
-        final HttpGet get = new HttpGet("http://localhost:" + httpServer.getAddress().getPort() + "/");
-        final MetricName requestMetricName = MetricName.build("request");
-        final MetricName exceptionMetricName = MetricName.build("exception");
+    final HttpGet get = new HttpGet("http://localhost:" + httpServer.getAddress().getPort() + "/");
+    final MetricName requestMetricName = MetricName.build("request");
+    final MetricName exceptionMetricName = MetricName.build("exception");
 
-        httpServer.createContext("/", HttpExchange::close);
-        httpServer.start();
+    httpServer.createContext("/", HttpExchange::close);
+    httpServer.start();
 
-        when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
-                .thenReturn(requestMetricName);
-        when(metricNameStrategy.getNameFor(any(), any(Exception.class)))
-                .thenReturn(exceptionMetricName);
+    when(metricNameStrategy.getNameFor(any(), any(HttpRequest.class)))
+        .thenReturn(requestMetricName);
+    when(metricNameStrategy.getNameFor(any(), any(Exception.class)))
+        .thenReturn(exceptionMetricName);
 
-        try {
-            client.execute(get);
-            fail();
-        } catch (NoHttpResponseException expected) {
-            assertThat(metricRegistry.getMeters()).containsKey(MetricName.build("exception"));
-        } finally {
-            httpServer.stop(0);
-        }
+    try {
+      client.execute(get);
+      fail();
+    } catch (NoHttpResponseException expected) {
+      assertThat(metricRegistry.getMeters()).containsKey(MetricName.build("exception"));
+    } finally {
+      httpServer.stop(0);
     }
+  }
 }
--- a/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/GarbageFreeScheduledReporter.java
+++ b/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/GarbageFreeScheduledReporter.java
@@ -11,7 +11,6 @@ import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricRegistryListener;
 import io.dropwizard.metrics5.ScheduledReporter;
 import io.dropwizard.metrics5.Timer;
-
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.concurrent.ConcurrentSkipListMap;
@@ -20,135 +19,149 @@ import java.util.concurrent.TimeUnit;
 
 abstract class GarbageFreeScheduledReporter extends ScheduledReporter {
 
-    private final MetricRegistry registry;
-    private final RegistryMirror mirror;
+  private final MetricRegistry registry;
+  private final RegistryMirror mirror;
+
+  protected GarbageFreeScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes) {
+    super(
+        registry,
+        name,
+        filter,
+        rateUnit,
+        durationUnit,
+        executor,
+        shutdownExecutorOnStop,
+        disabledMetricAttributes);
+    this.registry = registry;
+    this.mirror = new RegistryMirror(filter);
+    registry.addListener(mirror);
+  }
+
+  @Override
+  public void stop() {
+    try {
+      super.stop();
+    } finally {
+      registry.removeListener(mirror);
+    }
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report() {
+    synchronized (this) {
+      report(
+          mirror.gauges(),
+          mirror.counters(),
+          mirror.histograms(),
+          mirror.meters(),
+          mirror.timers());
+    }
+  }
+
+  @SuppressWarnings("rawtypes") // because of signature (for Gauge) in ScheduledReporter#report(..)
+  private static class RegistryMirror implements MetricRegistryListener {
+
+    private final MetricFilter filter;
+    private final ConcurrentSkipListMap<MetricName, Gauge<?>> gauges =
+        new ConcurrentSkipListMap<>();
+    private final ConcurrentSkipListMap<MetricName, Counter> counters =
+        new ConcurrentSkipListMap<>();
+    private final ConcurrentSkipListMap<MetricName, Histogram> histograms =
+        new ConcurrentSkipListMap<>();
+    private final ConcurrentSkipListMap<MetricName, Meter> meters = new ConcurrentSkipListMap<>();
+    private final ConcurrentSkipListMap<MetricName, Timer> timers = new ConcurrentSkipListMap<>();
+
+    RegistryMirror(MetricFilter filter) {
+      this.filter = filter;
+    }
+
+    SortedMap<MetricName, Gauge<?>> gauges() {
+      return gauges;
+    }
+
+    SortedMap<MetricName, Counter> counters() {
+      return counters;
+    }
+
+    SortedMap<MetricName, Histogram> histograms() {
+      return histograms;
+    }
+
+    SortedMap<MetricName, Meter> meters() {
+      return meters;
+    }
+
+    SortedMap<MetricName, Timer> timers() {
+      return timers;
+    }
+
+    @Override
+    public void onGaugeAdded(MetricName name, Gauge<?> gauge) {
+      if (filter.matches(name, gauge)) {
+        gauges.put(name, gauge);
+      }
+    }
+
+    @Override
+    public void onGaugeRemoved(MetricName name) {
+      gauges.remove(name);
+    }
 
-    protected GarbageFreeScheduledReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit,
-                                           TimeUnit durationUnit, ScheduledExecutorService executor,
-                                           boolean shutdownExecutorOnStop,
-                                           Set<MetricAttribute> disabledMetricAttributes) {
-        super(registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop, disabledMetricAttributes);
-        this.registry = registry;
-        this.mirror = new RegistryMirror(filter);
-        registry.addListener(mirror);
+    @Override
+    public void onCounterAdded(MetricName name, Counter counter) {
+      if (filter.matches(name, counter)) {
+        counters.put(name, counter);
+      }
     }
 
     @Override
-    public void stop() {
-        try {
-            super.stop();
-        } finally {
-            registry.removeListener(mirror);
-        }
+    public void onCounterRemoved(MetricName name) {
+      counters.remove(name);
     }
 
     @Override
-    @SuppressWarnings("rawtypes")
-    public void report() {
-        synchronized (this) {
-            report(mirror.gauges(),
-                    mirror.counters(),
-                    mirror.histograms(),
-                    mirror.meters(),
-                    mirror.timers());
-        }
-    }
-
-    @SuppressWarnings("rawtypes") // because of signature (for Gauge) in ScheduledReporter#report(..)
-    private static class RegistryMirror implements MetricRegistryListener {
-
-        private final MetricFilter filter;
-        private final ConcurrentSkipListMap<MetricName, Gauge<?>> gauges = new ConcurrentSkipListMap<>();
-        private final ConcurrentSkipListMap<MetricName, Counter> counters = new ConcurrentSkipListMap<>();
-        private final ConcurrentSkipListMap<MetricName, Histogram> histograms = new ConcurrentSkipListMap<>();
-        private final ConcurrentSkipListMap<MetricName, Meter> meters = new ConcurrentSkipListMap<>();
-        private final ConcurrentSkipListMap<MetricName, Timer> timers = new ConcurrentSkipListMap<>();
-
-        RegistryMirror(MetricFilter filter) {
-            this.filter = filter;
-        }
-
-        SortedMap<MetricName, Gauge<?>> gauges() {
-            return gauges;
-        }
-
-        SortedMap<MetricName, Counter> counters() {
-            return counters;
-        }
-
-        SortedMap<MetricName, Histogram> histograms() {
-            return histograms;
-        }
-
-        SortedMap<MetricName, Meter> meters() {
-            return meters;
-        }
-
-        SortedMap<MetricName, Timer> timers() {
-            return timers;
-        }
-
-
-        @Override
-        public void onGaugeAdded(MetricName name, Gauge<?> gauge) {
-            if (filter.matches(name, gauge)) {
-                gauges.put(name, gauge);
-            }
-        }
-
-        @Override
-        public void onGaugeRemoved(MetricName name) {
-            gauges.remove(name);
-        }
-
-        @Override
-        public void onCounterAdded(MetricName name, Counter counter) {
-            if (filter.matches(name, counter)) {
-                counters.put(name, counter);
-            }
-        }
-
-        @Override
-        public void onCounterRemoved(MetricName name) {
-            counters.remove(name);
-        }
-
-        @Override
-        public void onHistogramAdded(MetricName name, Histogram histogram) {
-            if (filter.matches(name, histogram)) {
-                histograms.put(name, histogram);
-            }
-        }
-
-        @Override
-        public void onHistogramRemoved(MetricName name) {
-            histograms.remove(name);
-        }
-
-        @Override
-        public void onMeterAdded(MetricName name, Meter meter) {
-            if (filter.matches(name, meter)) {
-                meters.put(name, meter);
-            }
-        }
-
-        @Override
-        public void onMeterRemoved(MetricName name) {
-            meters.remove(name);
-        }
-
-        @Override
-        public void onTimerAdded(MetricName name, Timer timer) {
-            if (filter.matches(name, timer)) {
-                timers.put(name, timer);
-            }
-        }
-
-        @Override
-        public void onTimerRemoved(MetricName name) {
-            timers.remove(name);
-        }
+    public void onHistogramAdded(MetricName name, Histogram histogram) {
+      if (filter.matches(name, histogram)) {
+        histograms.put(name, histogram);
+      }
+    }
 
+    @Override
+    public void onHistogramRemoved(MetricName name) {
+      histograms.remove(name);
+    }
+
+    @Override
+    public void onMeterAdded(MetricName name, Meter meter) {
+      if (filter.matches(name, meter)) {
+        meters.put(name, meter);
+      }
     }
 
+    @Override
+    public void onMeterRemoved(MetricName name) {
+      meters.remove(name);
+    }
+
+    @Override
+    public void onTimerAdded(MetricName name, Timer timer) {
+      if (filter.matches(name, timer)) {
+        timers.put(name, timer);
+      }
+    }
+
+    @Override
+    public void onTimerRemoved(MetricName name) {
+      timers.remove(name);
+    }
+  }
 }
--- a/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/InfluxDbLineBuilder.java
+++ b/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/InfluxDbLineBuilder.java
@@ -2,7 +2,6 @@ package io.dropwizard.metrics5.influxdb;
 
 import io.dropwizard.metrics5.MetricAttribute;
 import io.dropwizard.metrics5.MetricName;
-
 import java.util.Map;
 import java.util.Set;
 import java.util.WeakHashMap;
@@ -29,136 +28,135 @@ import java.util.WeakHashMap;
  */
 class InfluxDbLineBuilder {
 
-    private final StringBuilder str = new StringBuilder();
-    private boolean firstField;
-
-    private final Set<MetricAttribute> disabledMetricAttributes;
-    private final MetricName prefix;
-    private final Map<MetricName, String> encodedNameCache = new WeakHashMap<>();
-
-    InfluxDbLineBuilder(Set<MetricAttribute> disabledMetricAttributes, MetricName prefix) {
-        this.disabledMetricAttributes = disabledMetricAttributes;
-        this.prefix = prefix != null ? prefix : MetricName.empty();
-    }
-
-    InfluxDbLineBuilder writeMeasurement(MetricName name) {
-        str.setLength(0);
-        str.append(encodedNameCache.computeIfAbsent(name, this::writeMeasurementNoCache));
-        str.append(' ');
-        firstField = true;
-        return this;
-    }
-
-    private String writeMeasurementNoCache(MetricName name) {
-        StringBuilder sb = new StringBuilder();
-
-        MetricName prefixedName = prefix.append(name);
-        appendName(prefixedName.getKey(), sb);
-        // InfluxDB Performance and Setup Tips:
-        // Sort tags by key before sending them to the database. 
-        // The sort should match the results from the Go bytes.Compare function.
-        // ... tags are already sorted in MetricName
-        for (Map.Entry<String, String> tag : prefixedName.getTags().entrySet()) {
-            sb.append(',');
-            appendName(tag.getKey(), sb);
-            sb.append('=');
-            appendName(tag.getValue(), sb);
-        }
-        return sb.toString();
-    }
-
-    InfluxDbLineBuilder writeField(MetricAttribute key) {
-        if (!firstField) {
-            str.append(',');
-        }
-        str.append(key.getCode()).append('=');
-        firstField = false;
-        return this;
-    }
-
-    InfluxDbLineBuilder writeField(String key) {
-        if (!firstField) {
-            str.append(',');
-        }
-        appendName(key, str);
-        str.append('=');
-        firstField = false;
-        return this;
-    }
-
-    InfluxDbLineBuilder writeFieldValue(double value) {
-        str.append(value);
-        return this;
-    }
-
-    InfluxDbLineBuilder writeFieldValue(long value) {
-        str.append(value).append('i');
-        return this;
-    }
-
-    InfluxDbLineBuilder writeFieldValue(String value) {
-        str.append('"');
-        appendString(value, str);
-        str.append('"');
-        return this;
-    }
-
-    InfluxDbLineBuilder writeFieldValue(boolean value) {
-        str.append(value ? 't' : 'f');
-        return this;
-    }
-
-    InfluxDbLineBuilder writeTimestampMillis(long utcMillis) {
-        str.append(' ').append(utcMillis).append("000000\n");
-        return this;
-    }
-
-    InfluxDbLineBuilder writeFieldIfEnabled(MetricAttribute key, double value) {
-        if (!disabledMetricAttributes.contains(key)) {
-            writeField(key);
-            writeFieldValue(value);
-        }
-        return this;
-    }
-
-    InfluxDbLineBuilder writeFieldIfEnabled(MetricAttribute key, long value) {
-        if (!disabledMetricAttributes.contains(key)) {
-            writeField(key);
-            writeFieldValue(value);
-        }
-        return this;
-    }
-
-    boolean hasValues() {
-        return !firstField;
-    }
-
-    StringBuilder get() {
-        return str;
-    }
-
-    private static void appendName(CharSequence field, StringBuilder dst) {
-        int len = field.length();
-        for (int i = 0; i < len; i++) {
-            char ch = field.charAt(i);
-            if (ch == ',' || ch == '=' || ch == ' ') {
-                // escape
-                dst.append('\\');
-            }
-            dst.append(ch);
-        }
-    }
-
-    private static void appendString(CharSequence field, StringBuilder dst) {
-        int len = field.length();
-        for (int i = 0; i < len; i++) {
-            char ch = field.charAt(i);
-            if (ch == '"') {
-                // escape
-                dst.append('\\');
-            }
-            dst.append(ch);
-        }
-    }
-
+  private final StringBuilder str = new StringBuilder();
+  private boolean firstField;
+
+  private final Set<MetricAttribute> disabledMetricAttributes;
+  private final MetricName prefix;
+  private final Map<MetricName, String> encodedNameCache = new WeakHashMap<>();
+
+  InfluxDbLineBuilder(Set<MetricAttribute> disabledMetricAttributes, MetricName prefix) {
+    this.disabledMetricAttributes = disabledMetricAttributes;
+    this.prefix = prefix != null ? prefix : MetricName.empty();
+  }
+
+  InfluxDbLineBuilder writeMeasurement(MetricName name) {
+    str.setLength(0);
+    str.append(encodedNameCache.computeIfAbsent(name, this::writeMeasurementNoCache));
+    str.append(' ');
+    firstField = true;
+    return this;
+  }
+
+  private String writeMeasurementNoCache(MetricName name) {
+    StringBuilder sb = new StringBuilder();
+
+    MetricName prefixedName = prefix.append(name);
+    appendName(prefixedName.getKey(), sb);
+    // InfluxDB Performance and Setup Tips:
+    // Sort tags by key before sending them to the database.
+    // The sort should match the results from the Go bytes.Compare function.
+    // ... tags are already sorted in MetricName
+    for (Map.Entry<String, String> tag : prefixedName.getTags().entrySet()) {
+      sb.append(',');
+      appendName(tag.getKey(), sb);
+      sb.append('=');
+      appendName(tag.getValue(), sb);
+    }
+    return sb.toString();
+  }
+
+  InfluxDbLineBuilder writeField(MetricAttribute key) {
+    if (!firstField) {
+      str.append(',');
+    }
+    str.append(key.getCode()).append('=');
+    firstField = false;
+    return this;
+  }
+
+  InfluxDbLineBuilder writeField(String key) {
+    if (!firstField) {
+      str.append(',');
+    }
+    appendName(key, str);
+    str.append('=');
+    firstField = false;
+    return this;
+  }
+
+  InfluxDbLineBuilder writeFieldValue(double value) {
+    str.append(value);
+    return this;
+  }
+
+  InfluxDbLineBuilder writeFieldValue(long value) {
+    str.append(value).append('i');
+    return this;
+  }
+
+  InfluxDbLineBuilder writeFieldValue(String value) {
+    str.append('"');
+    appendString(value, str);
+    str.append('"');
+    return this;
+  }
+
+  InfluxDbLineBuilder writeFieldValue(boolean value) {
+    str.append(value ? 't' : 'f');
+    return this;
+  }
+
+  InfluxDbLineBuilder writeTimestampMillis(long utcMillis) {
+    str.append(' ').append(utcMillis).append("000000\n");
+    return this;
+  }
+
+  InfluxDbLineBuilder writeFieldIfEnabled(MetricAttribute key, double value) {
+    if (!disabledMetricAttributes.contains(key)) {
+      writeField(key);
+      writeFieldValue(value);
+    }
+    return this;
+  }
+
+  InfluxDbLineBuilder writeFieldIfEnabled(MetricAttribute key, long value) {
+    if (!disabledMetricAttributes.contains(key)) {
+      writeField(key);
+      writeFieldValue(value);
+    }
+    return this;
+  }
+
+  boolean hasValues() {
+    return !firstField;
+  }
+
+  StringBuilder get() {
+    return str;
+  }
+
+  private static void appendName(CharSequence field, StringBuilder dst) {
+    int len = field.length();
+    for (int i = 0; i < len; i++) {
+      char ch = field.charAt(i);
+      if (ch == ',' || ch == '=' || ch == ' ') {
+        // escape
+        dst.append('\\');
+      }
+      dst.append(ch);
+    }
+  }
+
+  private static void appendString(CharSequence field, StringBuilder dst) {
+    int len = field.length();
+    for (int i = 0; i < len; i++) {
+      char ch = field.charAt(i);
+      if (ch == '"') {
+        // escape
+        dst.append('\\');
+      }
+      dst.append(ch);
+    }
+  }
 }
--- a/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/InfluxDbReporter.java
+++ b/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/InfluxDbReporter.java
@@ -1,5 +1,8 @@
 package io.dropwizard.metrics5.influxdb;
 
+import static io.dropwizard.metrics5.MetricAttribute.*;
+
+import com.google.common.collect.ImmutableSet;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
@@ -7,369 +10,393 @@ import io.dropwizard.metrics5.Histogram;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.Metered;
 import io.dropwizard.metrics5.MetricAttribute;
-import io.dropwizard.metrics5.MetricName;
-
-import java.util.Map;
-
-import static io.dropwizard.metrics5.MetricAttribute.*;
-
 import io.dropwizard.metrics5.MetricFilter;
+import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-
 import java.io.IOException;
-import java.util.Collections;
+import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * A reporter which publishes metric values to InfluxDB.
- * <p>
- * Metrics are reported according to the
- * <a href="https://docs.influxdata.com/influxdb/v1.4/write_protocols/line_protocol_reference/">InfluxDB Line Protocol</a>.
- * Brief line protocol syntax as follows:
+ *
+ * <p>Metrics are reported according to the <a
+ * href="https://docs.influxdata.com/influxdb/v1.4/write_protocols/line_protocol_reference/">InfluxDB
+ * Line Protocol</a>. Brief line protocol syntax as follows:
+ *
  * <pre>
  * measurement(,tag_key=tag_val)* field_key=field_val(,field_key_n=field_value_n)* (nanoseconds-timestamp)?
  * </pre>
+ *
  * <p>
- * <p>
- * This InfluxDB reporter is "garbage free" in steady state.
- * This means objects and buffers are reused and no temporary objects are allocated as much as possible.
+ *
+ * <p>This InfluxDB reporter is "garbage free" in steady state. This means objects and buffers are
+ * reused and no temporary objects are allocated as much as possible.
  */
 public class InfluxDbReporter extends GarbageFreeScheduledReporter {
 
+  /**
+   * Returns a new Builder for {@link InfluxDbReporter}.
+   *
+   * @param registry the registry to report
+   * @return a Builder instance for a {@link InfluxDbReporter}
+   */
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
+
+  /**
+   * A builder for {@link InfluxDbReporter} instances. Defaults to not using a prefix, using the
+   * default clock, converting rates to events/second, converting durations to milliseconds, and not
+   * filtering metrics.
+   */
+  public static class Builder {
+
+    private final MetricRegistry registry;
+    private Clock clock;
+    private MetricName prefix;
+    private TimeUnit rateUnit;
+    private TimeUnit durationUnit;
+    private MetricFilter filter;
+    private ScheduledExecutorService executor;
+    private boolean shutdownExecutorOnStop;
+    private Set<MetricAttribute> disabledMetricAttributes;
+
+    private Builder(MetricRegistry registry) {
+      this.registry = registry;
+      this.clock = Clock.defaultClock();
+      this.prefix = null;
+      this.rateUnit = TimeUnit.SECONDS;
+      this.durationUnit = TimeUnit.MILLISECONDS;
+      this.filter = MetricFilter.ALL;
+      this.executor = null;
+      this.shutdownExecutorOnStop = true;
+      this.disabledMetricAttributes = ImmutableSet.of();
+    }
+
     /**
-     * Returns a new Builder for {@link InfluxDbReporter}.
+     * Specifies whether or not, the executor (used for reporting) will be stopped with same time
+     * with reporter. Default value is true. Setting this parameter to false, has the sense in
+     * combining with providing external managed executor via {@link
+     * #scheduleOn(ScheduledExecutorService)}.
      *
-     * @param registry the registry to report
-     * @return a Builder instance for a {@link InfluxDbReporter}
+     * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+     *     reporter
+     * @return {@code this}
      */
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
+    public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      this.shutdownExecutorOnStop = shutdownExecutorOnStop;
+      return this;
     }
 
     /**
-     * A builder for {@link InfluxDbReporter} instances. Defaults to not using a prefix, using the
-     * default clock, converting rates to events/second, converting durations to milliseconds, and
-     * not filtering metrics.
+     * Specifies the executor to use while scheduling reporting of metrics. Default value is null.
+     * Null value leads to executor will be auto created on start.
+     *
+     * @param executor the executor to use while scheduling reporting of metrics.
+     * @return {@code this}
      */
-    public static class Builder {
-
-        private final MetricRegistry registry;
-        private Clock clock;
-        private MetricName prefix;
-        private TimeUnit rateUnit;
-        private TimeUnit durationUnit;
-        private MetricFilter filter;
-        private ScheduledExecutorService executor;
-        private boolean shutdownExecutorOnStop;
-        private Set<MetricAttribute> disabledMetricAttributes;
-
-        private Builder(MetricRegistry registry) {
-            this.registry = registry;
-            this.clock = Clock.defaultClock();
-            this.prefix = null;
-            this.rateUnit = TimeUnit.SECONDS;
-            this.durationUnit = TimeUnit.MILLISECONDS;
-            this.filter = MetricFilter.ALL;
-            this.executor = null;
-            this.shutdownExecutorOnStop = true;
-            this.disabledMetricAttributes = Collections.emptySet();
-        }
-
-        /**
-         * Specifies whether or not, the executor (used for reporting) will be stopped with same time with reporter.
-         * Default value is true.
-         * Setting this parameter to false, has the sense in combining with providing external managed executor via
-         * {@link #scheduleOn(ScheduledExecutorService)}.
-         *
-         * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this reporter
-         * @return {@code this}
-         */
-        public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            this.shutdownExecutorOnStop = shutdownExecutorOnStop;
-            return this;
-        }
-
-        /**
-         * Specifies the executor to use while scheduling reporting of metrics.
-         * Default value is null.
-         * Null value leads to executor will be auto created on start.
-         *
-         * @param executor the executor to use while scheduling reporting of metrics.
-         * @return {@code this}
-         */
-        public Builder scheduleOn(ScheduledExecutorService executor) {
-            this.executor = executor;
-            return this;
-        }
-
-        /**
-         * Use the given {@link Clock} instance for the time.
-         *
-         * @param clock a {@link Clock} instance
-         * @return {@code this}
-         */
-        public Builder withClock(Clock clock) {
-            this.clock = clock;
-            return this;
-        }
-
-        /**
-         * Prefix all metric names with the given name.
-         *
-         * @param prefix the prefix for all metric names
-         * @return {@code this}
-         */
-        public Builder prefixedWith(MetricName prefix) {
-            this.prefix = prefix;
-            return this;
-        }
-
-        /**
-         * Convert rates to the given time unit.
-         *
-         * @param rateUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertRatesTo(TimeUnit rateUnit) {
-            this.rateUnit = rateUnit;
-            return this;
-        }
-
-        /**
-         * Convert durations to the given time unit.
-         *
-         * @param durationUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertDurationsTo(TimeUnit durationUnit) {
-            this.durationUnit = durationUnit;
-            return this;
-        }
-
-        /**
-         * Only report metrics which match the given filter.
-         *
-         * @param filter a {@link MetricFilter}
-         * @return {@code this}
-         */
-        public Builder filter(MetricFilter filter) {
-            this.filter = filter;
-            return this;
-        }
-
-        /**
-         * Don't report the passed metric attributes for all metrics (e.g. "p999", "stddev" or "m15").
-         *
-         * @param disabledMetricAttributes the disabled metric attributes
-         * @return {@code this}
-         */
-        public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
-            this.disabledMetricAttributes = disabledMetricAttributes;
-            return this;
-        }
-
-        /**
-         * Builds a InfluxDbReporter with the given properties, sending metrics using the
-         * given InfluxDbSender.
-         *
-         * @param sender the InfluxDbSender
-         * @return the InfluxDbReporter
-         */
-        public InfluxDbReporter build(InfluxDbSender sender) {
-            return new InfluxDbReporter(registry, sender, clock, prefix, rateUnit, durationUnit, filter, executor,
-                    shutdownExecutorOnStop, disabledMetricAttributes);
-        }
+    public Builder scheduleOn(ScheduledExecutorService executor) {
+      this.executor = executor;
+      return this;
     }
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(InfluxDbReporter.class);
-    private static final String VALUE = "value";
-
-    private final Clock clock;
-    private final InfluxDbSender sender;
-    private final InfluxDbLineBuilder builder;
-
     /**
-     * Creates a new InfluxDbReporter instance.
+     * Use the given {@link Clock} instance for the time.
      *
-     * @param registry                 the MetricRegistry containing the metrics this reporter will report
-     * @param sender                   the InfluxDbSender which is responsible for sending metrics to a influxdb
-     *                                 server via a transport protocol
-     * @param clock                    the instance of the time. Use {@link Clock#defaultClock()} for the default
-     * @param prefix                   the prefix of all metric names (may be null)
-     * @param rateUnit                 the time unit of in which rates will be converted
-     * @param durationUnit             the time unit of in which durations will be converted
-     * @param filter                   the filter for which metrics to report
-     * @param executor                 the executor to use while scheduling reporting of metrics (may be null).
-     * @param shutdownExecutorOnStop   if true, then executor will be stopped in same time with this reporter
-     * @param disabledMetricAttributes the disable metric attributes
+     * @param clock a {@link Clock} instance
+     * @return {@code this}
      */
-    public InfluxDbReporter(MetricRegistry registry, InfluxDbSender sender, Clock clock, MetricName prefix,
-                            TimeUnit rateUnit, TimeUnit durationUnit, MetricFilter filter, ScheduledExecutorService executor,
-                            boolean shutdownExecutorOnStop, Set<MetricAttribute> disabledMetricAttributes) {
-        super(registry, "influxdb-reporter", filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop,
-                disabledMetricAttributes);
-        this.sender = sender;
-        this.clock = clock;
-        this.builder = new InfluxDbLineBuilder(disabledMetricAttributes, prefix);
+    public Builder withClock(Clock clock) {
+      this.clock = clock;
+      return this;
     }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void report(SortedMap<MetricName, Gauge<?>> gauges,
-                       SortedMap<MetricName, Counter> counters,
-                       SortedMap<MetricName, Histogram> histograms,
-                       SortedMap<MetricName, Meter> meters,
-                       SortedMap<MetricName, Timer> timers) {
-
-        final long timestamp = clock.getTime();
-
-        try {
-            sender.connect();
-
-            for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
-                reportGauge(entry.getKey(), entry.getValue(), timestamp);
-            }
-
-            for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
-                reportCounter(entry.getKey(), entry.getValue(), timestamp);
-            }
-
-            for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
-                reportHistogram(entry.getKey(), entry.getValue(), timestamp);
-            }
-
-            for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
-                reportMetered(entry.getKey(), entry.getValue(), timestamp);
-            }
-
-            for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
-                reportTimer(entry.getKey(), entry.getValue(), timestamp);
-            }
-            sender.flush();
-        } catch (IOException e) {
-            LOGGER.warn("Unable to report to InfluxDb", sender, e);
-        } finally {
-            try {
-                sender.disconnect();
-            } catch (IOException e) {
-                LOGGER.warn("Error disconnecting InfluxDb", sender, e);
-            }
-        }
+    /**
+     * Prefix all metric names with the given name.
+     *
+     * @param prefix the prefix for all metric names
+     * @return {@code this}
+     */
+    public Builder prefixedWith(MetricName prefix) {
+      this.prefix = prefix;
+      return this;
     }
 
-    @Override
-    public void stop() {
-        try {
-            super.stop();
-        } finally {
-            try {
-                sender.close();
-            } catch (IOException e) {
-                LOGGER.debug("Error disconnecting from InfluxDb", e);
-            }
-        }
+    /**
+     * Convert rates to the given time unit.
+     *
+     * @param rateUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertRatesTo(TimeUnit rateUnit) {
+      this.rateUnit = rateUnit;
+      return this;
     }
 
-    private void reportTimer(MetricName name, Timer timer, long timestamp) throws IOException {
-        final Snapshot snapshot = timer.getSnapshot();
-        builder.writeMeasurement(name)
-                .writeFieldIfEnabled(MAX, convertDuration(snapshot.getMax()))
-                .writeFieldIfEnabled(MEAN, convertDuration(snapshot.getMean()))
-                .writeFieldIfEnabled(MIN, convertDuration(snapshot.getMin()))
-                .writeFieldIfEnabled(STDDEV, convertDuration(snapshot.getStdDev()))
-                .writeFieldIfEnabled(P50, convertDuration(snapshot.getMedian()))
-                .writeFieldIfEnabled(P75, convertDuration(snapshot.get75thPercentile()))
-                .writeFieldIfEnabled(P95, convertDuration(snapshot.get95thPercentile()))
-                .writeFieldIfEnabled(P98, convertDuration(snapshot.get98thPercentile()))
-                .writeFieldIfEnabled(P99, convertDuration(snapshot.get99thPercentile()))
-                .writeFieldIfEnabled(P999, convertDuration(snapshot.get999thPercentile()));
-        writeMeteredFieldsIfEnabled(timer)
-                .writeTimestampMillis(timestamp);
-
-        reportLine();
+    /**
+     * Convert durations to the given time unit.
+     *
+     * @param durationUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertDurationsTo(TimeUnit durationUnit) {
+      this.durationUnit = durationUnit;
+      return this;
     }
 
-
-    private void reportHistogram(MetricName name, Histogram histogram, long timestamp) throws IOException {
-        final Snapshot snapshot = histogram.getSnapshot();
-        builder.writeMeasurement(name)
-                .writeFieldIfEnabled(COUNT, histogram.getCount())
-                .writeFieldIfEnabled(SUM, histogram.getSum())
-                .writeFieldIfEnabled(MAX, snapshot.getMax())
-                .writeFieldIfEnabled(MEAN, snapshot.getMean())
-                .writeFieldIfEnabled(MIN, snapshot.getMin())
-                .writeFieldIfEnabled(STDDEV, snapshot.getStdDev())
-                .writeFieldIfEnabled(P50, snapshot.getMedian())
-                .writeFieldIfEnabled(P75, snapshot.get75thPercentile())
-                .writeFieldIfEnabled(P95, snapshot.get95thPercentile())
-                .writeFieldIfEnabled(P98, snapshot.get98thPercentile())
-                .writeFieldIfEnabled(P99, snapshot.get99thPercentile())
-                .writeFieldIfEnabled(P999, snapshot.get999thPercentile())
-                .writeTimestampMillis(timestamp);
-
-        reportLine();
+    /**
+     * Only report metrics which match the given filter.
+     *
+     * @param filter a {@link MetricFilter}
+     * @return {@code this}
+     */
+    public Builder filter(MetricFilter filter) {
+      this.filter = filter;
+      return this;
     }
 
-
-    private void reportMetered(MetricName name, Metered meter, long timestamp) throws IOException {
-        builder.writeMeasurement(name);
-        writeMeteredFieldsIfEnabled(meter)
-                .writeTimestampMillis(timestamp);
-
-        reportLine();
+    /**
+     * Don't report the passed metric attributes for all metrics (e.g. "p999", "stddev" or "m15").
+     *
+     * @param disabledMetricAttributes the disabled metric attributes
+     * @return {@code this}
+     */
+    public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
+      this.disabledMetricAttributes = disabledMetricAttributes;
+      return this;
     }
 
-    private InfluxDbLineBuilder writeMeteredFieldsIfEnabled(Metered meter) {
-        return builder.writeFieldIfEnabled(COUNT, meter.getCount())
-                .writeFieldIfEnabled(SUM, meter.getSum())
-                .writeFieldIfEnabled(M1_RATE, convertRate(meter.getOneMinuteRate()))
-                .writeFieldIfEnabled(M5_RATE, convertRate(meter.getFiveMinuteRate()))
-                .writeFieldIfEnabled(M15_RATE, convertRate(meter.getFifteenMinuteRate()))
-                .writeFieldIfEnabled(MEAN_RATE, convertRate(meter.getMeanRate()));
+    /**
+     * Builds a InfluxDbReporter with the given properties, sending metrics using the given
+     * InfluxDbSender.
+     *
+     * @param sender the InfluxDbSender
+     * @return the InfluxDbReporter
+     */
+    public InfluxDbReporter build(InfluxDbSender sender) {
+      return new InfluxDbReporter(
+          registry,
+          sender,
+          clock,
+          prefix,
+          rateUnit,
+          durationUnit,
+          filter,
+          executor,
+          shutdownExecutorOnStop,
+          disabledMetricAttributes);
     }
-
-    private void reportCounter(MetricName name, Counter counter, long timestamp) throws IOException {
-        builder.writeMeasurement(name)
-                .writeFieldIfEnabled(COUNT, counter.getCount())
-                .writeTimestampMillis(timestamp);
-
-        reportLine();
+  }
+
+  private static final Logger LOG = LoggerFactory.getLogger(InfluxDbReporter.class);
+  private static final String VALUE = "value";
+
+  private final Clock clock;
+  private final InfluxDbSender sender;
+  private final InfluxDbLineBuilder builder;
+
+  /**
+   * Creates a new InfluxDbReporter instance.
+   *
+   * @param registry the MetricRegistry containing the metrics this reporter will report
+   * @param sender the InfluxDbSender which is responsible for sending metrics to a influxdb server
+   *     via a transport protocol
+   * @param clock the instance of the time. Use {@link Clock#defaultClock()} for the default
+   * @param prefix the prefix of all metric names (may be null)
+   * @param rateUnit the time unit of in which rates will be converted
+   * @param durationUnit the time unit of in which durations will be converted
+   * @param filter the filter for which metrics to report
+   * @param executor the executor to use while scheduling reporting of metrics (may be null).
+   * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this
+   *     reporter
+   * @param disabledMetricAttributes the disable metric attributes
+   */
+  public InfluxDbReporter(
+      MetricRegistry registry,
+      InfluxDbSender sender,
+      Clock clock,
+      MetricName prefix,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      MetricFilter filter,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes) {
+    super(
+        registry,
+        "influxdb-reporter",
+        filter,
+        rateUnit,
+        durationUnit,
+        executor,
+        shutdownExecutorOnStop,
+        disabledMetricAttributes);
+    this.sender = sender;
+    this.clock = clock;
+    this.builder = new InfluxDbLineBuilder(disabledMetricAttributes, prefix);
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report(
+      SortedMap<MetricName, Gauge<?>> gauges,
+      SortedMap<MetricName, Counter> counters,
+      SortedMap<MetricName, Histogram> histograms,
+      SortedMap<MetricName, Meter> meters,
+      SortedMap<MetricName, Timer> timers) {
+
+    final long timestamp = clock.getTime();
+
+    try {
+      sender.connect();
+
+      for (Map.Entry<MetricName, Gauge<?>> entry : gauges.entrySet()) {
+        reportGauge(entry.getKey(), entry.getValue(), timestamp);
+      }
+
+      for (Map.Entry<MetricName, Counter> entry : counters.entrySet()) {
+        reportCounter(entry.getKey(), entry.getValue(), timestamp);
+      }
+
+      for (Map.Entry<MetricName, Histogram> entry : histograms.entrySet()) {
+        reportHistogram(entry.getKey(), entry.getValue(), timestamp);
+      }
+
+      for (Map.Entry<MetricName, Meter> entry : meters.entrySet()) {
+        reportMetered(entry.getKey(), entry.getValue(), timestamp);
+      }
+
+      for (Map.Entry<MetricName, Timer> entry : timers.entrySet()) {
+        reportTimer(entry.getKey(), entry.getValue(), timestamp);
+      }
+      sender.flush();
+    } catch (IOException e) {
+      LOG.warn("Unable to report to InfluxDb", sender, e);
+    } finally {
+      try {
+        sender.disconnect();
+      } catch (IOException e) {
+        LOG.warn("Error disconnecting InfluxDb", sender, e);
+      }
     }
-
-    private void reportGauge(MetricName name, Gauge<?> gauge, long timestamp) throws IOException {
-        builder.writeMeasurement(name);
-        final Object value = gauge.getValue();
-        if (value != null) {
-            builder.writeField(VALUE);
-            if (value instanceof Number) {
-                final Number number = (Number) value;
-                if (number instanceof Long || number instanceof Integer || number instanceof Short ||
-                        number instanceof Byte) {
-                    builder.writeFieldValue(number.longValue());
-                } else {
-                    builder.writeFieldValue(number.doubleValue());
-                }
-            } else if (value instanceof Boolean) {
-                builder.writeFieldValue(((Boolean) value));
-            } else {
-                builder.writeFieldValue(value.toString());
-            }
+  }
+
+  @Override
+  public void stop() {
+    try {
+      super.stop();
+    } finally {
+      try {
+        sender.close();
+      } catch (IOException e) {
+        LOG.debug("Error disconnecting from InfluxDb", e);
+      }
+    }
+  }
+
+  private void reportTimer(MetricName name, Timer timer, long timestamp) throws IOException {
+    final Snapshot snapshot = timer.getSnapshot();
+    builder
+        .writeMeasurement(name)
+        .writeFieldIfEnabled(MAX, convertDuration(snapshot.getMax()))
+        .writeFieldIfEnabled(MEAN, convertDuration(snapshot.getMean()))
+        .writeFieldIfEnabled(MIN, convertDuration(snapshot.getMin()))
+        .writeFieldIfEnabled(STDDEV, convertDuration(snapshot.getStdDev()))
+        .writeFieldIfEnabled(P50, convertDuration(snapshot.getMedian()))
+        .writeFieldIfEnabled(P75, convertDuration(snapshot.get75thPercentile()))
+        .writeFieldIfEnabled(P95, convertDuration(snapshot.get95thPercentile()))
+        .writeFieldIfEnabled(P98, convertDuration(snapshot.get98thPercentile()))
+        .writeFieldIfEnabled(P99, convertDuration(snapshot.get99thPercentile()))
+        .writeFieldIfEnabled(P999, convertDuration(snapshot.get999thPercentile()));
+    writeMeteredFieldsIfEnabled(timer).writeTimestampMillis(timestamp);
+
+    reportLine();
+  }
+
+  private void reportHistogram(MetricName name, Histogram histogram, long timestamp)
+      throws IOException {
+    final Snapshot snapshot = histogram.getSnapshot();
+    builder
+        .writeMeasurement(name)
+        .writeFieldIfEnabled(COUNT, histogram.getCount())
+        .writeFieldIfEnabled(SUM, histogram.getSum())
+        .writeFieldIfEnabled(MAX, snapshot.getMax())
+        .writeFieldIfEnabled(MEAN, snapshot.getMean())
+        .writeFieldIfEnabled(MIN, snapshot.getMin())
+        .writeFieldIfEnabled(STDDEV, snapshot.getStdDev())
+        .writeFieldIfEnabled(P50, snapshot.getMedian())
+        .writeFieldIfEnabled(P75, snapshot.get75thPercentile())
+        .writeFieldIfEnabled(P95, snapshot.get95thPercentile())
+        .writeFieldIfEnabled(P98, snapshot.get98thPercentile())
+        .writeFieldIfEnabled(P99, snapshot.get99thPercentile())
+        .writeFieldIfEnabled(P999, snapshot.get999thPercentile())
+        .writeTimestampMillis(timestamp);
+
+    reportLine();
+  }
+
+  private void reportMetered(MetricName name, Metered meter, long timestamp) throws IOException {
+    builder.writeMeasurement(name);
+    writeMeteredFieldsIfEnabled(meter).writeTimestampMillis(timestamp);
+
+    reportLine();
+  }
+
+  private InfluxDbLineBuilder writeMeteredFieldsIfEnabled(Metered meter) {
+    return builder
+        .writeFieldIfEnabled(COUNT, meter.getCount())
+        .writeFieldIfEnabled(SUM, meter.getSum())
+        .writeFieldIfEnabled(M1_RATE, convertRate(meter.getOneMinuteRate()))
+        .writeFieldIfEnabled(M5_RATE, convertRate(meter.getFiveMinuteRate()))
+        .writeFieldIfEnabled(M15_RATE, convertRate(meter.getFifteenMinuteRate()))
+        .writeFieldIfEnabled(MEAN_RATE, convertRate(meter.getMeanRate()));
+  }
+
+  private void reportCounter(MetricName name, Counter counter, long timestamp) throws IOException {
+    builder
+        .writeMeasurement(name)
+        .writeFieldIfEnabled(COUNT, counter.getCount())
+        .writeTimestampMillis(timestamp);
+
+    reportLine();
+  }
+
+  private void reportGauge(MetricName name, Gauge<?> gauge, long timestamp) throws IOException {
+    builder.writeMeasurement(name);
+    final Object value = gauge.getValue();
+    if (value != null) {
+      builder.writeField(VALUE);
+      if (value instanceof Number) {
+        final Number number = (Number) value;
+        if (number instanceof Long
+            || number instanceof Integer
+            || number instanceof Short
+            || number instanceof Byte) {
+          builder.writeFieldValue(number.longValue());
+        } else {
+          builder.writeFieldValue(number.doubleValue());
         }
-        builder.writeTimestampMillis(timestamp);
-        reportLine();
+      } else if (value instanceof Boolean) {
+        builder.writeFieldValue(((Boolean) value));
+      } else {
+        builder.writeFieldValue(value.toString());
+      }
     }
+    builder.writeTimestampMillis(timestamp);
+    reportLine();
+  }
 
-    private void reportLine() throws IOException {
-        if (builder.hasValues()) {
-            sender.send(builder.get());
-        }
+  private void reportLine() throws IOException {
+    if (builder.hasValues()) {
+      sender.send(builder.get());
     }
+  }
 }
--- a/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/InfluxDbSender.java
+++ b/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/InfluxDbSender.java
@@ -5,43 +5,40 @@ import java.io.IOException;
 
 public interface InfluxDbSender extends Closeable {
 
-    /**
-     * Connects to the server.
-     *
-     * @throws IllegalStateException if the client is already connected
-     * @throws IOException           if there is an error connecting
-     */
-    void connect() throws IllegalStateException, IOException;
+  /**
+   * Connects to the server.
+   *
+   * @throws IllegalStateException if the client is already connected
+   * @throws IOException if there is an error connecting
+   */
+  void connect() throws IllegalStateException, IOException;
 
-    /**
-     * Sends the given measurement to the server.
-     * <p>
-     * <b>NOTE:</b> The caller may modify the <code>measurement</code> buffer after this call.
-     * The implementation of this method MUST NOT keep any reference to the buffer after this call.
-     * </p>
-     *
-     * @param measurement a single measurement line,
-     *                    according to the InfluxDb line protocol including a trailing newline.
-     * @throws IOException if there was an error sending the metric
-     */
-    void send(StringBuilder measurement) throws IOException;
+  /**
+   * Sends the given measurement to the server.
+   *
+   * <p><b>NOTE:</b> The caller may modify the <code>measurement</code> buffer after this call. The
+   * implementation of this method MUST NOT keep any reference to the buffer after this call.
+   *
+   * @param measurement a single measurement line, according to the InfluxDb line protocol including
+   *     a trailing newline.
+   * @throws IOException if there was an error sending the metric
+   */
+  void send(StringBuilder measurement) throws IOException;
 
-    /**
-     * Flushes buffer, if applicable
-     *
-     * @throws IOException if there was an error during flushing metrics to the server
-     */
-    void flush() throws IOException;
+  /**
+   * Flushes buffer, if applicable
+   *
+   * @throws IOException if there was an error during flushing metrics to the server
+   */
+  void flush() throws IOException;
 
-    /**
-     * Disconnects from the server.
-     *
-     * @throws IOException if there is an error disconnecting
-     */
-    void disconnect() throws IOException;
+  /**
+   * Disconnects from the server.
+   *
+   * @throws IOException if there is an error disconnecting
+   */
+  void disconnect() throws IOException;
 
-    /**
-     * Returns true if ready to send data
-     */
-    boolean isConnected();
+  /** Returns true if ready to send data */
+  boolean isConnected();
 }
--- a/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/InfluxDbUdpSender.java
+++ b/metrics-influxdb/src/main/java/io/dropwizard/metrics5/influxdb/InfluxDbUdpSender.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.influxdb;
 
+import static java.util.Objects.requireNonNull;
+
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
@@ -9,139 +11,137 @@ import java.nio.charset.Charset;
 import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CoderResult;
 import java.nio.charset.CodingErrorAction;
-import java.util.Objects;
 
 public class InfluxDbUdpSender implements InfluxDbSender {
 
-    private final InetSocketAddress address;
-    private int mtu = 1500;
-
-    private DatagramChannel datagramChannel;
-    private ByteBuffer byteBuf;
-    private CharBuffer charBuf;
-
-    private final CharsetEncoder encoder = Charset.forName("UTF-8")
-            .newEncoder()
-            .onMalformedInput(CodingErrorAction.REPLACE)
-            .onUnmappableCharacter(CodingErrorAction.REPLACE);
-
-    /**
-     * Creates a new client which sends data to given address using UDP
-     *
-     * @param hostname The hostname of the InfluxDb server
-     * @param port     The port of the InfluxDb server
-     */
-    public InfluxDbUdpSender(String hostname, int port) {
-        this(new InetSocketAddress(hostname, port));
+  private final InetSocketAddress address;
+  private int mtu = 1500;
+
+  private DatagramChannel datagramChannel;
+  private ByteBuffer byteBuf;
+  private CharBuffer charBuf;
+
+  private final CharsetEncoder encoder =
+      Charset.forName("UTF-8")
+          .newEncoder()
+          .onMalformedInput(CodingErrorAction.REPLACE)
+          .onUnmappableCharacter(CodingErrorAction.REPLACE);
+
+  /**
+   * Creates a new client which sends data to given address using UDP
+   *
+   * @param hostname The hostname of the InfluxDb server
+   * @param port The port of the InfluxDb server
+   */
+  public InfluxDbUdpSender(String hostname, int port) {
+    this(new InetSocketAddress(hostname, port));
+  }
+
+  /**
+   * Creates a new client which sends data to given address using UDP
+   *
+   * @param address the address of the InfluxDb server
+   */
+  public InfluxDbUdpSender(InetSocketAddress address) {
+    this.address = requireNonNull(address);
+    charBuf = CharBuffer.allocate(mtu * 2);
+    byteBuf = ByteBuffer.allocate(mtu * 2);
+  }
+
+  // for testing
+  void setMTU(int mtu) {
+    this.mtu = mtu;
+  }
+
+  // for testing
+  void setDatagramChannel(DatagramChannel datagramChannel) {
+    this.datagramChannel = datagramChannel;
+  }
+
+  @Override
+  public void connect() throws IllegalStateException, IOException {
+    if (datagramChannel == null) {
+      datagramChannel = DatagramChannel.open();
     }
-
-    /**
-     * Creates a new client which sends data to given address using UDP
-     *
-     * @param address the address of the InfluxDb server
-     */
-    public InfluxDbUdpSender(InetSocketAddress address) {
-        this.address = Objects.requireNonNull(address);
-        charBuf = CharBuffer.allocate(mtu * 2);
-        byteBuf = ByteBuffer.allocate(mtu * 2);
+    byteBuf.clear();
+  }
+
+  @Override
+  public boolean isConnected() {
+    return datagramChannel != null;
+  }
+
+  @Override
+  public void disconnect() throws IOException {
+    // ignore, keep the datagram channel open
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      datagramChannel.close();
+    } finally {
+      datagramChannel = null;
     }
-
-    // for testing
-    void setMTU(int mtu) {
-        this.mtu = mtu;
-    }
-
-    // for testing
-    void setDatagramChannel(DatagramChannel datagramChannel) {
-        this.datagramChannel = datagramChannel;
-    }
-
-    @Override
-    public void connect() throws IllegalStateException, IOException {
-        if (datagramChannel == null) {
-            datagramChannel = DatagramChannel.open();
-        }
+  }
+
+  @Override
+  public void send(StringBuilder str) throws IOException {
+    int len = byteBuf.position();
+    encode(str);
+    int len2 = byteBuf.position();
+    if (len2 >= mtu) {
+      if (len == 0) {
+        // send current buffer (one single measurement exceeds the MTU)
+        sendBuffer();
         byteBuf.clear();
+      } else {
+        // send previous buffer
+        byteBuf.position(len);
+        sendBuffer();
+        byteBuf.limit(len2);
+        byteBuf.compact();
+      }
     }
+  }
 
-    @Override
-    public boolean isConnected() {
-        return datagramChannel != null;
+  @Override
+  public void flush() throws IOException {
+    if (byteBuf.position() > 0) {
+      sendBuffer();
+      byteBuf.clear();
     }
-
-    @Override
-    public void disconnect() throws IOException {
-        // ignore, keep the datagram channel open
+  }
+
+  private void sendBuffer() throws IOException {
+    byteBuf.flip();
+    datagramChannel.send(byteBuf, address);
+  }
+
+  private void encode(StringBuilder str) {
+    // copy chars
+    if (charBuf.capacity() < str.length()) {
+      charBuf = CharBuffer.allocate(str.length());
+    } else {
+      charBuf.clear();
     }
+    str.getChars(0, str.length(), charBuf.array(), charBuf.arrayOffset());
+    charBuf.limit(str.length());
 
-    @Override
-    public void close() throws IOException {
-        try {
-            datagramChannel.close();
-        } finally {
-            datagramChannel = null;
-        }
-    }
+    // encode chars
+    encoder.reset();
 
-    @Override
-    public void send(StringBuilder str) throws IOException {
-        int len = byteBuf.position();
-        encode(str);
-        int len2 = byteBuf.position();
-        if (len2 >= mtu) {
-            if (len == 0) {
-                // send current buffer (one single measurement exceeds the MTU)
-                sendBuffer();
-                byteBuf.clear();
-            } else {
-                // send previous buffer
-                byteBuf.position(len);
-                sendBuffer();
-                byteBuf.limit(len2);
-                byteBuf.compact();
-            }
-        }
-    }
-
-    @Override
-    public void flush() throws IOException {
-        if (byteBuf.position() > 0) {
-            sendBuffer();
-            byteBuf.clear();
-        }
-    }
-
-    private void sendBuffer() throws IOException {
+    for (; ; ) {
+      CoderResult result = encoder.encode(charBuf, byteBuf, true);
+      if (result.isOverflow()) {
+        // grow the buffer
+        ByteBuffer byteBuf2 = ByteBuffer.allocate(byteBuf.capacity() * 2);
         byteBuf.flip();
-        datagramChannel.send(byteBuf, address);
+        byteBuf2.put(byteBuf);
+        byteBuf = byteBuf2;
+      } else { // underflow, i.e. done
+        break;
+      }
     }
-
-    private void encode(StringBuilder str) {
-        // copy chars
-        if (charBuf.capacity() < str.length()) {
-            charBuf = CharBuffer.allocate(str.length());
-        } else {
-            charBuf.clear();
-        }
-        str.getChars(0, str.length(), charBuf.array(), charBuf.arrayOffset());
-        charBuf.limit(str.length());
-
-        // encode chars
-        encoder.reset();
-
-        for (; ; ) {
-            CoderResult result = encoder.encode(charBuf, byteBuf, true);
-            if (result.isOverflow()) {
-                // grow the buffer
-                ByteBuffer byteBuf2 = ByteBuffer.allocate(byteBuf.capacity() * 2);
-                byteBuf.flip();
-                byteBuf2.put(byteBuf);
-                byteBuf = byteBuf2;
-            } else { // underflow, i.e. done
-                break;
-            }
-        }
-    }
-
-
+  }
 }
--- a/metrics-influxdb/src/test/java/io/dropwizard/metrics5/influxdb/InfluxDbLineBuilderAssumptionsTest.java
+++ b/metrics-influxdb/src/test/java/io/dropwizard/metrics5/influxdb/InfluxDbLineBuilderAssumptionsTest.java
@@ -1,17 +1,17 @@
 package io.dropwizard.metrics5.influxdb;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricAttribute;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class InfluxDbLineBuilderAssumptionsTest {
+final class InfluxDbLineBuilderAssumptionsTest {
 
-    @Test
-    void ensureMetricAttributeCodesAreSafeFieldKeys() {
-        for (MetricAttribute ma : MetricAttribute.values()) {
-            String code = ma.getCode();
-            assertThat(code).doesNotContainPattern("[,= ]");
-        }
+  @Test
+  void ensureMetricAttributeCodesAreSafeFieldKeys() {
+    for (MetricAttribute ma : MetricAttribute.values()) {
+      String code = ma.getCode();
+      assertThat(code).doesNotContainPattern("[,= ]");
     }
+  }
 }
--- a/metrics-influxdb/src/test/java/io/dropwizard/metrics5/influxdb/InfluxDbReporterTest.java
+++ b/metrics-influxdb/src/test/java/io/dropwizard/metrics5/influxdb/InfluxDbReporterTest.java
@@ -1,5 +1,17 @@
 package io.dropwizard.metrics5.influxdb;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.ImmutableSet;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
@@ -11,458 +23,397 @@ import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import org.mockito.InOrder;
-
 import java.io.IOException;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
 import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.InOrder;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
-class InfluxDbReporterTest {
-    private static final MetricName GAUGE = MetricName.build("gauge");
-    private static final MetricName METER = MetricName.build("meter");
-    private static final MetricName COUNTER = MetricName.build("counter");
-
-    private final long timestamp = 1000198;
-    private final Clock clock = mock(Clock.class);
-    private final InfluxDbSender sender = mock(InfluxDbSender.class);
-    private final List<String> send = new ArrayList<>();
-    private final MetricRegistry registry = mock(MetricRegistry.class);
-    private final InfluxDbReporter reporter = InfluxDbReporter.forRegistry(registry)
+final class InfluxDbReporterTest {
+  private static final MetricName GAUGE = MetricName.build("gauge");
+  private static final MetricName METER = MetricName.build("meter");
+  private static final MetricName COUNTER = MetricName.build("counter");
+
+  private final long timestamp = 1000198;
+  private final Clock clock = mock();
+  private final InfluxDbSender sender = mock();
+  private final List<String> send = new ArrayList<>();
+  private final MetricRegistry registry = mock();
+  private final InfluxDbReporter reporter =
+      InfluxDbReporter.forRegistry(registry)
+          .withClock(clock)
+          .prefixedWith(new MetricName("prefix", map("foo", "bar")))
+          .convertRatesTo(TimeUnit.SECONDS)
+          .convertDurationsTo(TimeUnit.MILLISECONDS)
+          .filter(MetricFilter.ALL)
+          .disabledMetricAttributes(ImmutableSet.of())
+          .build(sender);
+
+  private final InfluxDbReporter minuteRateReporter =
+      InfluxDbReporter.forRegistry(registry)
+          .withClock(clock)
+          .prefixedWith(new MetricName("prefix", map("foo", "bar")))
+          .convertRatesTo(TimeUnit.MINUTES)
+          .convertDurationsTo(TimeUnit.MILLISECONDS)
+          .filter(MetricFilter.ALL)
+          .disabledMetricAttributes(ImmutableSet.of())
+          .build(sender);
+
+  @BeforeEach
+  void setUp() throws IOException {
+    when(clock.getTime()).thenReturn(timestamp * 1000);
+    send.clear();
+    doAnswer(invocation -> send.add(invocation.getArgument(0).toString()))
+        .when(sender)
+        .send(any(StringBuilder.class));
+  }
+
+  @Test
+  void reportsStringGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge("value")), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=\"value\" 1000198000000000\n");
+  }
+
+  @Test
+  void reportsByteGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge((byte) 1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1i 1000198000000000\n");
+  }
+
+  @Test
+  void reportsShortGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge((short) 1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1i 1000198000000000\n");
+  }
+
+  @Test
+  void reportsIntegerGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1i 1000198000000000\n");
+  }
+
+  @Test
+  void reportsLongGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(1L)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1i 1000198000000000\n");
+  }
+
+  @Test
+  void reportsFloatGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(1.5f)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1.5 1000198000000000\n");
+  }
+
+  @Test
+  void reportsDoubleGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(1.1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1.1 1000198000000000\n");
+  }
+
+  @Test
+  void reportsBooleanGaugeValues() throws Exception {
+    reporter.report(map(GAUGE, gauge(true)), map(), map(), map(), map());
+
+    reporter.report(map(GAUGE, gauge(false)), map(), map(), map(), map());
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+
+    assertThat(send).element(0).isEqualTo("prefix.gauge,foo=bar value=t 1000198000000000\n");
+    assertThat(send).element(1).isEqualTo("prefix.gauge,foo=bar value=f 1000198000000000\n");
+  }
+
+  @Test
+  void reportsCounters() throws Exception {
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(100L);
+
+    reporter.report(map(), map(COUNTER, counter), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send).first().isEqualTo("prefix.counter,foo=bar count=100i 1000198000000000\n");
+  }
+
+  @Test
+  void reportsHistograms() throws Exception {
+    final Histogram histogram = mock();
+    when(histogram.getCount()).thenReturn(1L);
+    when(histogram.getSum()).thenReturn(12L);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(2L);
+    when(snapshot.getMean()).thenReturn(3.0);
+    when(snapshot.getMin()).thenReturn(4L);
+    when(snapshot.getStdDev()).thenReturn(5.0);
+    when(snapshot.getMedian()).thenReturn(6.0);
+    when(snapshot.get75thPercentile()).thenReturn(7.0);
+    when(snapshot.get95thPercentile()).thenReturn(8.0);
+    when(snapshot.get98thPercentile()).thenReturn(9.0);
+    when(snapshot.get99thPercentile()).thenReturn(10.0);
+    when(snapshot.get999thPercentile()).thenReturn(11.0);
+
+    when(histogram.getSnapshot()).thenReturn(snapshot);
+
+    reporter.report(map(), map(), map(MetricName.build("histogram"), histogram), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send)
+        .first()
+        .isEqualTo(
+            "prefix.histogram,foo=bar count=1i,sum=12i,max=2i,mean=3.0,min=4i,stddev=5.0,p50=6.0,p75=7.0,p95=8.0,p98=9.0,p99=10.0,p999=11.0 1000198000000000\n");
+  }
+
+  @Test
+  void reportsMeters() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(6L);
+    when(meter.getOneMinuteRate()).thenReturn(2.0);
+    when(meter.getFiveMinuteRate()).thenReturn(3.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(4.0);
+    when(meter.getMeanRate()).thenReturn(5.0);
+
+    reporter.report(map(), map(), map(), map(METER, meter), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send)
+        .first()
+        .isEqualTo(
+            "prefix.meter,foo=bar count=1i,sum=6i,m1_rate=2.0,m5_rate=3.0,m15_rate=4.0,mean_rate=5.0 1000198000000000\n");
+  }
+
+  @Test
+  void reportsMetersInMinutes() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(6L);
+    when(meter.getOneMinuteRate()).thenReturn(2.0);
+    when(meter.getFiveMinuteRate()).thenReturn(3.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(4.0);
+    when(meter.getMeanRate()).thenReturn(5.0);
+
+    minuteRateReporter.report(
+        this.map(), this.map(), this.map(), this.map(METER, meter), this.map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send)
+        .first()
+        .isEqualTo(
+            "prefix.meter,foo=bar count=1i,sum=6i,m1_rate=120.0,m5_rate=180.0,m15_rate=240.0,mean_rate=300.0 1000198000000000\n");
+  }
+
+  @Test
+  void reportsTimers() throws Exception {
+    final Timer timer = mock();
+    when(timer.getCount()).thenReturn(1L);
+    when(timer.getSum()).thenReturn(6L);
+    when(timer.getMeanRate()).thenReturn(2.0);
+    when(timer.getOneMinuteRate()).thenReturn(3.0);
+    when(timer.getFiveMinuteRate()).thenReturn(4.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(5.0);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
+    when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
+    when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
+    when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
+    when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
+    when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
+    when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
+    when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
+    when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
+    when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
+
+    when(timer.getSnapshot()).thenReturn(snapshot);
+
+    reporter.report(map(), map(), map(), map(), map(MetricName.build("timer"), timer));
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+    assertThat(send)
+        .first()
+        .isEqualTo(
+            "prefix.timer,foo=bar max=100.0,mean=200.0,min=300.0,stddev=400.0,p50=500.0,p75=600.0,p95=700.0,p98=800.0,p99=900.0,p999=1000.0,count=1i,sum=6i,m1_rate=3.0,m5_rate=4.0,m15_rate=5.0,mean_rate=2.0 1000198000000000\n");
+
+    reporter.close();
+  }
+
+  @Test
+  void disconnectsIfSenderIsUnavailable() throws Exception {
+    doThrow(new UnknownHostException("UNKNOWN-HOST")).when(sender).connect();
+    reporter.report(map(GAUGE, gauge(1)), map(), map(), map(), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+  }
+
+  @Test
+  void closesConnectionOnReporterStop() throws Exception {
+    reporter.stop();
+
+    verify(sender).close();
+  }
+
+  @Test
+  void disabledMetricsAttribute() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(6L);
+    when(meter.getOneMinuteRate()).thenReturn(2.0);
+    when(meter.getFiveMinuteRate()).thenReturn(3.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(4.0);
+    when(meter.getMeanRate()).thenReturn(5.0);
+
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(11L);
+
+    Set<MetricAttribute> disabledMetricAttributes =
+        EnumSet.of(MetricAttribute.M15_RATE, MetricAttribute.M5_RATE);
+    InfluxDbReporter reporterWithdisabledMetricAttributes =
+        InfluxDbReporter.forRegistry(registry)
             .withClock(clock)
-            .prefixedWith(new MetricName("prefix", map("foo", "bar")))
+            .prefixedWith(MetricName.build("prefix"))
             .convertRatesTo(TimeUnit.SECONDS)
             .convertDurationsTo(TimeUnit.MILLISECONDS)
             .filter(MetricFilter.ALL)
-            .disabledMetricAttributes(Collections.emptySet())
+            .disabledMetricAttributes(disabledMetricAttributes)
             .build(sender);
-
-    private final InfluxDbReporter minuteRateReporter = InfluxDbReporter
-            .forRegistry(registry)
-            .withClock(clock)
-            .prefixedWith(new MetricName("prefix", map("foo", "bar")))
-            .convertRatesTo(TimeUnit.MINUTES)
-            .convertDurationsTo(TimeUnit.MILLISECONDS)
-            .filter(MetricFilter.ALL)
-            .disabledMetricAttributes(Collections.emptySet())
-            .build(sender);
-
-    @BeforeEach
-    void setUp() throws IOException {
-        when(clock.getTime()).thenReturn(timestamp * 1000);
-        send.clear();
-        doAnswer(invocation -> send.add(invocation.getArgument(0).toString()))
-                .when(sender).send(any(StringBuilder.class));
-    }
-
-    @Test
-    void reportsStringGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge("value")),
-                map(),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=\"value\" 1000198000000000\n");
-    }
-
-    @Test
-    void reportsByteGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge((byte) 1)),
-                map(),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1i 1000198000000000\n");
-    }
-
-    @Test
-    void reportsShortGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge((short) 1)),
-                map(),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1i 1000198000000000\n");
-    }
-
-    @Test
-    void reportsIntegerGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(1)),
-                map(),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1i 1000198000000000\n");
-    }
-
-    @Test
-    void reportsLongGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(1L)),
-                map(),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1i 1000198000000000\n");
-    }
-
-    @Test
-    void reportsFloatGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(1.5f)),
-                map(),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1.5 1000198000000000\n");
-    }
-
-    @Test
-    void reportsDoubleGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(1.1)),
-                map(),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.gauge,foo=bar value=1.1 1000198000000000\n");
-    }
-
-    @Test
-    void reportsBooleanGaugeValues() throws Exception {
-        reporter.report(map(GAUGE, gauge(true)),
-                map(),
-                map(),
-                map(),
-                map());
-
-        reporter.report(map(GAUGE, gauge(false)),
-                map(),
-                map(),
-                map(),
-                map());
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-
-        assertThat(send).element(0).isEqualTo("prefix.gauge,foo=bar value=t 1000198000000000\n");
-        assertThat(send).element(1).isEqualTo("prefix.gauge,foo=bar value=f 1000198000000000\n");
-    }
-
-    @Test
-    void reportsCounters() throws Exception {
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(100L);
-
-        reporter.report(map(),
-                map(COUNTER, counter),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.counter,foo=bar count=100i 1000198000000000\n");
-    }
-
-    @Test
-    void reportsHistograms() throws Exception {
-        final Histogram histogram = mock(Histogram.class);
-        when(histogram.getCount()).thenReturn(1L);
-        when(histogram.getSum()).thenReturn(12L);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(2L);
-        when(snapshot.getMean()).thenReturn(3.0);
-        when(snapshot.getMin()).thenReturn(4L);
-        when(snapshot.getStdDev()).thenReturn(5.0);
-        when(snapshot.getMedian()).thenReturn(6.0);
-        when(snapshot.get75thPercentile()).thenReturn(7.0);
-        when(snapshot.get95thPercentile()).thenReturn(8.0);
-        when(snapshot.get98thPercentile()).thenReturn(9.0);
-        when(snapshot.get99thPercentile()).thenReturn(10.0);
-        when(snapshot.get999thPercentile()).thenReturn(11.0);
-
-        when(histogram.getSnapshot()).thenReturn(snapshot);
-
-        reporter.report(map(),
-                map(),
-                map(MetricName.build("histogram"), histogram),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.histogram,foo=bar count=1i,sum=12i,max=2i,mean=3.0,min=4i,stddev=5.0,p50=6.0,p75=7.0,p95=8.0,p98=9.0,p99=10.0,p999=11.0 1000198000000000\n");
-
-    }
-
-    @Test
-    void reportsMeters() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(6L);
-        when(meter.getOneMinuteRate()).thenReturn(2.0);
-        when(meter.getFiveMinuteRate()).thenReturn(3.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(4.0);
-        when(meter.getMeanRate()).thenReturn(5.0);
-
-        reporter.report(map(),
-                map(),
-                map(),
-                map(METER, meter),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.meter,foo=bar count=1i,sum=6i,m1_rate=2.0,m5_rate=3.0,m15_rate=4.0,mean_rate=5.0 1000198000000000\n");
-    }
-
-    @Test
-    void reportsMetersInMinutes() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(6L);
-        when(meter.getOneMinuteRate()).thenReturn(2.0);
-        when(meter.getFiveMinuteRate()).thenReturn(3.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(4.0);
-        when(meter.getMeanRate()).thenReturn(5.0);
-
-        minuteRateReporter.report(this.map(),
-                this.map(),
-                this.map(),
-                this.map(METER, meter),
-                this.map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.meter,foo=bar count=1i,sum=6i,m1_rate=120.0,m5_rate=180.0,m15_rate=240.0,mean_rate=300.0 1000198000000000\n");
-    }
-
-    @Test
-    void reportsTimers() throws Exception {
-        final Timer timer = mock(Timer.class);
-        when(timer.getCount()).thenReturn(1L);
-        when(timer.getSum()).thenReturn(6L);
-        when(timer.getMeanRate()).thenReturn(2.0);
-        when(timer.getOneMinuteRate()).thenReturn(3.0);
-        when(timer.getFiveMinuteRate()).thenReturn(4.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(5.0);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
-        when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
-        when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
-        when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
-        when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
-        when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
-        when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
-        when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
-        when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
-        when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS
-                .toNanos(1000));
-
-        when(timer.getSnapshot()).thenReturn(snapshot);
-
-        reporter.report(map(),
-                map(),
-                map(),
-                map(),
-                map(MetricName.build("timer"), timer));
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-        assertThat(send).first().isEqualTo("prefix.timer,foo=bar max=100.0,mean=200.0,min=300.0,stddev=400.0,p50=500.0,p75=600.0,p95=700.0,p98=800.0,p99=900.0,p999=1000.0,count=1i,sum=6i,m1_rate=3.0,m5_rate=4.0,m15_rate=5.0,mean_rate=2.0 1000198000000000\n");
-
-        reporter.close();
-    }
-
-    @Test
-    void disconnectsIfSenderIsUnavailable() throws Exception {
-        doThrow(new UnknownHostException("UNKNOWN-HOST")).when(sender).connect();
-        reporter.report(map(GAUGE, gauge(1)),
-                map(),
-                map(),
-                map(),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender).disconnect();
-
-
-        verifyNoMoreInteractions(sender);
-    }
-
-    @Test
-    void closesConnectionOnReporterStop() throws Exception {
-        reporter.stop();
-
-        verify(sender).close();
-    }
-
-    @Test
-    void disabledMetricsAttribute() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(6L);
-        when(meter.getOneMinuteRate()).thenReturn(2.0);
-        when(meter.getFiveMinuteRate()).thenReturn(3.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(4.0);
-        when(meter.getMeanRate()).thenReturn(5.0);
-
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(11L);
-
-        Set<MetricAttribute> disabledMetricAttributes = EnumSet.of(MetricAttribute.M15_RATE, MetricAttribute.M5_RATE);
-        InfluxDbReporter reporterWithdisabledMetricAttributes = InfluxDbReporter.forRegistry(registry)
-                .withClock(clock)
-                .prefixedWith(MetricName.build("prefix"))
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .filter(MetricFilter.ALL)
-                .disabledMetricAttributes(disabledMetricAttributes)
-                .build(sender);
-        reporterWithdisabledMetricAttributes.report(map(),
-                map(COUNTER, counter),
-                map(),
-                map(METER, meter),
-                map());
-
-        final InOrder inOrder = inOrder(sender);
-        inOrder.verify(sender).connect();
-        inOrder.verify(sender, times(2)).send(anySb());
-        inOrder.verify(sender).flush();
-        inOrder.verify(sender).disconnect();
-
-        verifyNoMoreInteractions(sender);
-
-        assertThat(send).element(0).isEqualTo("prefix.counter count=11i 1000198000000000\n");
-        assertThat(send).element(1).isEqualTo("prefix.meter count=1i,sum=6i,m1_rate=2.0,mean_rate=5.0 1000198000000000\n");
-    }
-
-    private <T> SortedMap<MetricName, T> map() {
-        return new TreeMap<>();
-    }
-
-    private <K, V> SortedMap<K, V> map(K key, V value) {
-        final SortedMap<K, V> map = new TreeMap<>();
-        map.put(key, value);
-        return map;
-    }
-
-    private <T> Gauge<T> gauge(T value) {
-        return () -> value;
-    }
-
-    private StringBuilder anySb() {
-        return any(StringBuilder.class);
-    }
+    reporterWithdisabledMetricAttributes.report(
+        map(), map(COUNTER, counter), map(), map(METER, meter), map());
+
+    final InOrder inOrder = inOrder(sender);
+    inOrder.verify(sender).connect();
+    inOrder.verify(sender, times(2)).send(anySb());
+    inOrder.verify(sender).flush();
+    inOrder.verify(sender).disconnect();
+
+    verifyNoMoreInteractions(sender);
+
+    assertThat(send).element(0).isEqualTo("prefix.counter count=11i 1000198000000000\n");
+    assertThat(send)
+        .element(1)
+        .isEqualTo("prefix.meter count=1i,sum=6i,m1_rate=2.0,mean_rate=5.0 1000198000000000\n");
+  }
+
+  private <T> SortedMap<MetricName, T> map() {
+    return new TreeMap<>();
+  }
+
+  private <K, V> SortedMap<K, V> map(K key, V value) {
+    final SortedMap<K, V> map = new TreeMap<>();
+    map.put(key, value);
+    return map;
+  }
+
+  private <T> Gauge<T> gauge(T value) {
+    return () -> value;
+  }
+
+  private StringBuilder anySb() {
+    return any(StringBuilder.class);
+  }
 }
--- a/metrics-influxdb/src/test/java/io/dropwizard/metrics5/influxdb/InfluxDbUdpTest.java
+++ b/metrics-influxdb/src/test/java/io/dropwizard/metrics5/influxdb/InfluxDbUdpTest.java
@@ -1,83 +1,84 @@
 package io.dropwizard.metrics5.influxdb;
 
-import java.io.IOException;
-
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import org.mockito.Mockito;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
+import java.io.IOException;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.DatagramChannel;
 import java.util.ArrayList;
 import java.util.List;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.times;
-
-class InfluxDbUdpTest {
-
-    private final String host = "example.com";
-    private final int port = 1234;
-
-    private InfluxDbUdpSender influxdbUdp;
-    private final DatagramChannel datagramChannel = Mockito.mock(DatagramChannel.class);
-    private final List<byte[]> sent = new ArrayList<>();
-
-    @BeforeEach
-    void setUp() throws IOException {
-        sent.clear();
-        doAnswer(invocation -> {
-            sent.add(toBytes(invocation.getArgument(0)));
-            return 0;
-        }).when(datagramChannel).send(any(ByteBuffer.class), any(SocketAddress.class));
-        influxdbUdp = new InfluxDbUdpSender(host, port);
-        influxdbUdp.setDatagramChannel(datagramChannel);
-    }
-
-    @Test
-    void writesValue() throws Exception {
-        influxdbUdp.send(new StringBuilder("räksmörgås value=123 456000000000\n"));
-        influxdbUdp.flush();
-
-        verify(datagramChannel).send(any(), any());
-
-        assertThat(sent).first().isEqualTo("räksmörgås value=123 456000000000\n".getBytes("UTF-8"));
-    }
-
-    @Test
-    void batchesValues() throws Exception {
-        influxdbUdp.send(new StringBuilder("name1 value=111 456000000000\n"));
-        influxdbUdp.send(new StringBuilder("name2 value=222 456000000000\n"));
-        influxdbUdp.flush();
-
-        verify(datagramChannel).send(any(), any());
-
-        assertThat(sent).first().isEqualTo(
-                "name1 value=111 456000000000\nname2 value=222 456000000000\n".getBytes("UTF-8"));
-    }
-
-    @Test
-    void respectsMTU() throws Exception {
-        influxdbUdp.setMTU(40);
-        influxdbUdp.send(new StringBuilder("name1 value=111 456000000000\n"));
-        influxdbUdp.send(new StringBuilder("name2 value=222 456000000000\n"));
-        influxdbUdp.flush();
-
-        verify(datagramChannel, times(2)).send(any(), any());
-
-        assertThat(sent).element(0).isEqualTo("name1 value=111 456000000000\n".getBytes("UTF-8"));
-        assertThat(sent).element(1).isEqualTo("name2 value=222 456000000000\n".getBytes("UTF-8"));
-    }
-
-    private byte[] toBytes(ByteBuffer buf) {
-        byte[] bytes = new byte[buf.remaining()];
-        buf.get(bytes);
-        return bytes;
-    }
-}
\ No newline at end of file
+final class InfluxDbUdpTest {
+
+  private final String host = "example.com";
+  private final int port = 1234;
+
+  private InfluxDbUdpSender influxdbUdp;
+  private final DatagramChannel datagramChannel = mock();
+  private final List<byte[]> sent = new ArrayList<>();
+
+  @BeforeEach
+  void setUp() throws IOException {
+    sent.clear();
+    doAnswer(
+            invocation -> {
+              sent.add(toBytes(invocation.getArgument(0)));
+              return 0;
+            })
+        .when(datagramChannel)
+        .send(any(ByteBuffer.class), any(SocketAddress.class));
+    influxdbUdp = new InfluxDbUdpSender(host, port);
+    influxdbUdp.setDatagramChannel(datagramChannel);
+  }
+
+  @Test
+  void writesValue() throws Exception {
+    influxdbUdp.send(new StringBuilder("räksmörgås value=123 456000000000\n"));
+    influxdbUdp.flush();
+
+    verify(datagramChannel).send(any(), any());
+
+    assertThat(sent).first().isEqualTo("räksmörgås value=123 456000000000\n".getBytes("UTF-8"));
+  }
+
+  @Test
+  void batchesValues() throws Exception {
+    influxdbUdp.send(new StringBuilder("name1 value=111 456000000000\n"));
+    influxdbUdp.send(new StringBuilder("name2 value=222 456000000000\n"));
+    influxdbUdp.flush();
+
+    verify(datagramChannel).send(any(), any());
+
+    assertThat(sent)
+        .first()
+        .isEqualTo(
+            "name1 value=111 456000000000\nname2 value=222 456000000000\n".getBytes("UTF-8"));
+  }
+
+  @Test
+  void respectsMTU() throws Exception {
+    influxdbUdp.setMTU(40);
+    influxdbUdp.send(new StringBuilder("name1 value=111 456000000000\n"));
+    influxdbUdp.send(new StringBuilder("name2 value=222 456000000000\n"));
+    influxdbUdp.flush();
+
+    verify(datagramChannel, times(2)).send(any(), any());
+
+    assertThat(sent).element(0).isEqualTo("name1 value=111 456000000000\n".getBytes("UTF-8"));
+    assertThat(sent).element(1).isEqualTo("name2 value=222 456000000000\n".getBytes("UTF-8"));
+  }
+
+  private byte[] toBytes(ByteBuffer buf) {
+    byte[] bytes = new byte[buf.remaining()];
+    buf.get(bytes);
+    return bytes;
+  }
+}
--- a/metrics-jakarta-servlet/src/main/java/io/dropwizard/metrics5/servlet/AbstractInstrumentedFilter.java
+++ b/metrics-jakarta-servlet/src/main/java/io/dropwizard/metrics5/servlet/AbstractInstrumentedFilter.java
@@ -1,5 +1,8 @@
 package io.dropwizard.metrics5.servlet;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
+import com.google.common.base.Strings;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
@@ -14,205 +17,197 @@ import jakarta.servlet.ServletRequest;
 import jakarta.servlet.ServletResponse;
 import jakarta.servlet.http.HttpServletResponse;
 import jakarta.servlet.http.HttpServletResponseWrapper;
-
 import java.io.IOException;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 /**
  * {@link Filter} implementation which captures request information and a breakdown of the response
  * codes being returned.
  */
 public abstract class AbstractInstrumentedFilter implements Filter {
-    static final String METRIC_PREFIX = "name-prefix";
-
-    private final String otherMetricName;
-    private final Map<Integer, String> meterNamesByStatusCode;
-    private final String registryAttribute;
-
-    // initialized after call of init method
-    private ConcurrentMap<Integer, Meter> metersByStatusCode;
-    private Meter otherMeter;
-    private Meter timeoutsMeter;
-    private Meter errorsMeter;
-    private Counter activeRequests;
-    private Timer requestTimer;
-
-
-    /**
-     * Creates a new instance of the filter.
-     *
-     * @param registryAttribute      the attribute used to look up the metrics registry in the
-     *                               servlet context
-     * @param meterNamesByStatusCode A map, keyed by status code, of meter names that we are
-     *                               interested in.
-     * @param otherMetricName        The name used for the catch-all meter.
-     */
-    protected AbstractInstrumentedFilter(String registryAttribute,
-                                         Map<Integer, String> meterNamesByStatusCode,
-                                         String otherMetricName) {
-        this.registryAttribute = registryAttribute;
-        this.otherMetricName = otherMetricName;
-        this.meterNamesByStatusCode = meterNamesByStatusCode;
+  static final String METRIC_PREFIX = "name-prefix";
+
+  private final String otherMetricName;
+  private final Map<Integer, String> meterNamesByStatusCode;
+  private final String registryAttribute;
+
+  // initialized after call of init method
+  private ConcurrentMap<Integer, Meter> metersByStatusCode;
+  private Meter otherMeter;
+  private Meter timeoutsMeter;
+  private Meter errorsMeter;
+  private Counter activeRequests;
+  private Timer requestTimer;
+
+  /**
+   * Creates a new instance of the filter.
+   *
+   * @param registryAttribute the attribute used to look up the metrics registry in the servlet
+   *     context
+   * @param meterNamesByStatusCode A map, keyed by status code, of meter names that we are
+   *     interested in.
+   * @param otherMetricName The name used for the catch-all meter.
+   */
+  protected AbstractInstrumentedFilter(
+      String registryAttribute,
+      Map<Integer, String> meterNamesByStatusCode,
+      String otherMetricName) {
+    this.registryAttribute = registryAttribute;
+    this.otherMetricName = otherMetricName;
+    this.meterNamesByStatusCode = meterNamesByStatusCode;
+  }
+
+  @Override
+  public void init(FilterConfig filterConfig) throws ServletException {
+    final MetricRegistry metricsRegistry = getMetricsFactory(filterConfig);
+
+    String metricName = filterConfig.getInitParameter(METRIC_PREFIX);
+    if (Strings.isNullOrEmpty(metricName)) {
+      metricName = getClass().getName();
     }
 
-    @Override
-    public void init(FilterConfig filterConfig) throws ServletException {
-        final MetricRegistry metricsRegistry = getMetricsFactory(filterConfig);
-
-        String metricName = filterConfig.getInitParameter(METRIC_PREFIX);
-        if (metricName == null || metricName.isEmpty()) {
-            metricName = getClass().getName();
-        }
-
-        this.metersByStatusCode = new ConcurrentHashMap<>(meterNamesByStatusCode.size());
-        for (Entry<Integer, String> entry : meterNamesByStatusCode.entrySet()) {
-            metersByStatusCode.put(entry.getKey(),
-                    metricsRegistry.meter(name(metricName, entry.getValue())));
-        }
-        this.otherMeter = metricsRegistry.meter(name(metricName, otherMetricName));
-        this.timeoutsMeter = metricsRegistry.meter(name(metricName, "timeouts"));
-        this.errorsMeter = metricsRegistry.meter(name(metricName, "errors"));
-        this.activeRequests = metricsRegistry.counter(name(metricName, "activeRequests"));
-        this.requestTimer = metricsRegistry.timer(name(metricName, "requests"));
-
+    this.metersByStatusCode = new ConcurrentHashMap<>(meterNamesByStatusCode.size());
+    for (Entry<Integer, String> entry : meterNamesByStatusCode.entrySet()) {
+      metersByStatusCode.put(
+          entry.getKey(), metricsRegistry.meter(name(metricName, entry.getValue())));
     }
-
-    private MetricRegistry getMetricsFactory(FilterConfig filterConfig) {
-        final MetricRegistry metricsRegistry;
-
-        final Object o = filterConfig.getServletContext().getAttribute(this.registryAttribute);
-        if (o instanceof MetricRegistry) {
-            metricsRegistry = (MetricRegistry) o;
+    this.otherMeter = metricsRegistry.meter(name(metricName, otherMetricName));
+    this.timeoutsMeter = metricsRegistry.meter(name(metricName, "timeouts"));
+    this.errorsMeter = metricsRegistry.meter(name(metricName, "errors"));
+    this.activeRequests = metricsRegistry.counter(name(metricName, "activeRequests"));
+    this.requestTimer = metricsRegistry.timer(name(metricName, "requests"));
+  }
+
+  private MetricRegistry getMetricsFactory(FilterConfig filterConfig) {
+    final MetricRegistry metricsRegistry;
+
+    final Object o = filterConfig.getServletContext().getAttribute(this.registryAttribute);
+    if (o instanceof MetricRegistry) {
+      metricsRegistry = (MetricRegistry) o;
+    } else {
+      metricsRegistry = new MetricRegistry();
+    }
+    return metricsRegistry;
+  }
+
+  @Override
+  public void destroy() {}
+
+  @Override
+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
+      throws IOException, ServletException {
+    final StatusExposingServletResponse wrappedResponse =
+        new StatusExposingServletResponse((HttpServletResponse) response);
+    activeRequests.inc();
+    final Timer.Context context = requestTimer.time();
+    boolean error = false;
+    try {
+      chain.doFilter(request, wrappedResponse);
+    } catch (IOException | RuntimeException | ServletException e) {
+      error = true;
+      throw e;
+    } finally {
+      if (!error && request.isAsyncStarted()) {
+        request.getAsyncContext().addListener(new AsyncResultListener(context));
+      } else {
+        context.stop();
+        activeRequests.dec();
+        if (error) {
+          errorsMeter.mark();
         } else {
-            metricsRegistry = new MetricRegistry();
+          markMeterForStatusCode(wrappedResponse.getStatus());
         }
-        return metricsRegistry;
+      }
+    }
+  }
+
+  private void markMeterForStatusCode(int status) {
+    final Meter metric = metersByStatusCode.get(status);
+    if (metric != null) {
+      metric.mark();
+    } else {
+      otherMeter.mark();
     }
+  }
 
-    @Override
-    public void destroy() {
+  private static class StatusExposingServletResponse extends HttpServletResponseWrapper {
+    // The Servlet spec says: calling setStatus is optional, if no status is set, the default is
+    // 200.
+    private int httpStatus = 200;
 
+    public StatusExposingServletResponse(HttpServletResponse response) {
+      super(response);
     }
 
     @Override
-    public void doFilter(ServletRequest request,
-                         ServletResponse response,
-                         FilterChain chain) throws IOException, ServletException {
-        final StatusExposingServletResponse wrappedResponse =
-                new StatusExposingServletResponse((HttpServletResponse) response);
-        activeRequests.inc();
-        final Timer.Context context = requestTimer.time();
-        boolean error = false;
-        try {
-            chain.doFilter(request, wrappedResponse);
-        } catch (IOException | RuntimeException | ServletException e) {
-            error = true;
-            throw e;
-        } finally {
-            if (!error && request.isAsyncStarted()) {
-                request.getAsyncContext().addListener(new AsyncResultListener(context));
-            } else {
-                context.stop();
-                activeRequests.dec();
-                if (error) {
-                    errorsMeter.mark();
-                } else {
-                    markMeterForStatusCode(wrappedResponse.getStatus());
-                }
-            }
-        }
+    public void sendError(int sc) throws IOException {
+      httpStatus = sc;
+      super.sendError(sc);
     }
 
-    private void markMeterForStatusCode(int status) {
-        final Meter metric = metersByStatusCode.get(status);
-        if (metric != null) {
-            metric.mark();
-        } else {
-            otherMeter.mark();
-        }
+    @Override
+    public void sendError(int sc, String msg) throws IOException {
+      httpStatus = sc;
+      super.sendError(sc, msg);
     }
 
-    private static class StatusExposingServletResponse extends HttpServletResponseWrapper {
-        // The Servlet spec says: calling setStatus is optional, if no status is set, the default is 200.
-        private int httpStatus = 200;
-
-        public StatusExposingServletResponse(HttpServletResponse response) {
-            super(response);
-        }
-
-        @Override
-        public void sendError(int sc) throws IOException {
-            httpStatus = sc;
-            super.sendError(sc);
-        }
-
-        @Override
-        public void sendError(int sc, String msg) throws IOException {
-            httpStatus = sc;
-            super.sendError(sc, msg);
-        }
-
-        @Override
-        public void setStatus(int sc) {
-            httpStatus = sc;
-            super.setStatus(sc);
-        }
-
-        @Override
-        @SuppressWarnings("deprecation")
-        public void setStatus(int sc, String sm) {
-            httpStatus = sc;
-            super.setStatus(sc, sm);
-        }
+    @Override
+    public void setStatus(int sc) {
+      httpStatus = sc;
+      super.setStatus(sc);
+    }
 
-        @Override
-        public int getStatus() {
-            return httpStatus;
-        }
+    @Override
+    @SuppressWarnings("deprecation")
+    public void setStatus(int sc, String sm) {
+      httpStatus = sc;
+      super.setStatus(sc, sm);
     }
 
-    private class AsyncResultListener implements AsyncListener {
-        private Timer.Context context;
-        private boolean done = false;
+    @Override
+    public int getStatus() {
+      return httpStatus;
+    }
+  }
 
-        public AsyncResultListener(Timer.Context context) {
-            this.context = context;
-        }
+  private class AsyncResultListener implements AsyncListener {
+    private Timer.Context context;
+    private boolean done = false;
 
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {
-            if (!done) {
-                HttpServletResponse suppliedResponse = (HttpServletResponse) event.getSuppliedResponse();
-                context.stop();
-                activeRequests.dec();
-                markMeterForStatusCode(suppliedResponse.getStatus());
-            }
-        }
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {
-            context.stop();
-            activeRequests.dec();
-            timeoutsMeter.mark();
-            done = true;
-        }
+    public AsyncResultListener(Timer.Context context) {
+      this.context = context;
+    }
 
-        @Override
-        public void onError(AsyncEvent event) throws IOException {
-            context.stop();
-            activeRequests.dec();
-            errorsMeter.mark();
-            done = true;
-        }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {
+      if (!done) {
+        HttpServletResponse suppliedResponse = (HttpServletResponse) event.getSuppliedResponse();
+        context.stop();
+        activeRequests.dec();
+        markMeterForStatusCode(suppliedResponse.getStatus());
+      }
+    }
 
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {
+      context.stop();
+      activeRequests.dec();
+      timeoutsMeter.mark();
+      done = true;
+    }
 
-        }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {
+      context.stop();
+      activeRequests.dec();
+      errorsMeter.mark();
+      done = true;
     }
+
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {}
+  }
 }
--- a/metrics-jakarta-servlet/src/main/java/io/dropwizard/metrics5/servlet/InstrumentedFilter.java
+++ b/metrics-jakarta-servlet/src/main/java/io/dropwizard/metrics5/servlet/InstrumentedFilter.java
@@ -4,8 +4,13 @@ import java.util.HashMap;
 import java.util.Map;
 
 /**
- * Implementation of the {@link AbstractInstrumentedFilter} which provides a default set of response codes
- * to capture information about. <p>Use it in your servlet.xml like this:<p>
+ * Implementation of the {@link AbstractInstrumentedFilter} which provides a default set of response
+ * codes to capture information about.
+ *
+ * <p>Use it in your servlet.xml like this:
+ *
+ * <p>
+ *
  * <pre>{@code
  * <filter>
  *     <filter-name>instrumentedFilter</filter-name>
@@ -18,31 +23,29 @@ import java.util.Map;
  * }</pre>
  */
 public class InstrumentedFilter extends AbstractInstrumentedFilter {
-    public static final String REGISTRY_ATTRIBUTE = InstrumentedFilter.class.getName() + ".registry";
+  public static final String REGISTRY_ATTRIBUTE = InstrumentedFilter.class.getName() + ".registry";
 
-    private static final String NAME_PREFIX = "responseCodes.";
-    private static final int OK = 200;
-    private static final int CREATED = 201;
-    private static final int NO_CONTENT = 204;
-    private static final int BAD_REQUEST = 400;
-    private static final int NOT_FOUND = 404;
-    private static final int SERVER_ERROR = 500;
+  private static final String NAME_PREFIX = "responseCodes.";
+  private static final int OK = 200;
+  private static final int CREATED = 201;
+  private static final int NO_CONTENT = 204;
+  private static final int BAD_REQUEST = 400;
+  private static final int NOT_FOUND = 404;
+  private static final int SERVER_ERROR = 500;
 
-    /**
-     * Creates a new instance of the filter.
-     */
-    public InstrumentedFilter() {
-        super(REGISTRY_ATTRIBUTE, createMeterNamesByStatusCode(), NAME_PREFIX + "other");
-    }
+  /** Creates a new instance of the filter. */
+  public InstrumentedFilter() {
+    super(REGISTRY_ATTRIBUTE, createMeterNamesByStatusCode(), NAME_PREFIX + "other");
+  }
 
-    private static Map<Integer, String> createMeterNamesByStatusCode() {
-        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);
-        meterNamesByStatusCode.put(OK, NAME_PREFIX + "ok");
-        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + "created");
-        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + "noContent");
-        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + "badRequest");
-        meterNamesByStatusCode.put(NOT_FOUND, NAME_PREFIX + "notFound");
-        meterNamesByStatusCode.put(SERVER_ERROR, NAME_PREFIX + "serverError");
-        return meterNamesByStatusCode;
-    }
+  private static Map<Integer, String> createMeterNamesByStatusCode() {
+    final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);
+    meterNamesByStatusCode.put(OK, NAME_PREFIX + "ok");
+    meterNamesByStatusCode.put(CREATED, NAME_PREFIX + "created");
+    meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + "noContent");
+    meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + "badRequest");
+    meterNamesByStatusCode.put(NOT_FOUND, NAME_PREFIX + "notFound");
+    meterNamesByStatusCode.put(SERVER_ERROR, NAME_PREFIX + "serverError");
+    return meterNamesByStatusCode;
+  }
 }
--- a/metrics-jakarta-servlet/src/main/java/io/dropwizard/metrics5/servlet/InstrumentedFilterContextListener.java
+++ b/metrics-jakarta-servlet/src/main/java/io/dropwizard/metrics5/servlet/InstrumentedFilterContextListener.java
@@ -10,17 +10,17 @@ import jakarta.servlet.ServletContextListener;
  * application.
  */
 public abstract class InstrumentedFilterContextListener implements ServletContextListener {
-    /**
-     * @return the {@link MetricRegistry} to inject into the servlet context.
-     */
-    protected abstract MetricRegistry getMetricRegistry();
+  /**
+   * @return the {@link MetricRegistry} to inject into the servlet context.
+   */
+  protected abstract MetricRegistry getMetricRegistry();
 
-    @Override
-    public void contextInitialized(ServletContextEvent sce) {
-        sce.getServletContext().setAttribute(InstrumentedFilter.REGISTRY_ATTRIBUTE, getMetricRegistry());
-    }
+  @Override
+  public void contextInitialized(ServletContextEvent sce) {
+    sce.getServletContext()
+        .setAttribute(InstrumentedFilter.REGISTRY_ATTRIBUTE, getMetricRegistry());
+  }
 
-    @Override
-    public void contextDestroyed(ServletContextEvent sce) {
-    }
+  @Override
+  public void contextDestroyed(ServletContextEvent sce) {}
 }
--- a/metrics-jakarta-servlet/src/test/java/io/dropwizard/metrics5/servlet/InstrumentedFilterContextListenerTest.java
+++ b/metrics-jakarta-servlet/src/test/java/io/dropwizard/metrics5/servlet/InstrumentedFilterContextListenerTest.java
@@ -1,32 +1,34 @@
 package io.dropwizard.metrics5.servlet;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import jakarta.servlet.ServletContext;
 import jakarta.servlet.ServletContextEvent;
 import org.junit.jupiter.api.Test;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-class InstrumentedFilterContextListenerTest {
-    private final MetricRegistry registry = mock(MetricRegistry.class);
-    private final InstrumentedFilterContextListener listener = new InstrumentedFilterContextListener() {
+final class InstrumentedFilterContextListenerTest {
+  private final MetricRegistry registry = mock();
+  private final InstrumentedFilterContextListener listener =
+      new InstrumentedFilterContextListener() {
         @Override
         protected MetricRegistry getMetricRegistry() {
-            return registry;
+          return registry;
         }
-    };
+      };
 
-    @Test
-    void injectsTheMetricRegistryIntoTheServletContext() {
-        final ServletContext context = mock(ServletContext.class);
+  @Test
+  void injectsTheMetricRegistryIntoTheServletContext() {
+    final ServletContext context = mock();
 
-        final ServletContextEvent event = mock(ServletContextEvent.class);
-        when(event.getServletContext()).thenReturn(context);
+    final ServletContextEvent event = mock();
+    when(event.getServletContext()).thenReturn(context);
 
-        listener.contextInitialized(event);
+    listener.contextInitialized(event);
 
-        verify(context).setAttribute("io.dropwizard.metrics5.servlet.InstrumentedFilter.registry", registry);
-    }
+    verify(context)
+        .setAttribute("io.dropwizard.metrics5.servlet.InstrumentedFilter.registry", registry);
+  }
 }
--- a/metrics-jakarta-servlet6/src/main/java/io/dropwizard/metrics5/servlet6/AbstractInstrumentedFilter.java
+++ b/metrics-jakarta-servlet6/src/main/java/io/dropwizard/metrics5/servlet6/AbstractInstrumentedFilter.java
@@ -1,5 +1,8 @@
 package io.dropwizard.metrics5.servlet6;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
+import com.google.common.base.Strings;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
@@ -14,198 +17,190 @@ import jakarta.servlet.ServletRequest;
 import jakarta.servlet.ServletResponse;
 import jakarta.servlet.http.HttpServletResponse;
 import jakarta.servlet.http.HttpServletResponseWrapper;
-
 import java.io.IOException;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 /**
  * {@link Filter} implementation which captures request information and a breakdown of the response
  * codes being returned.
  */
 public abstract class AbstractInstrumentedFilter implements Filter {
-    static final String METRIC_PREFIX = "name-prefix";
-
-    private final String otherMetricName;
-    private final Map<Integer, String> meterNamesByStatusCode;
-    private final String registryAttribute;
-
-    // initialized after call of init method
-    private ConcurrentMap<Integer, Meter> metersByStatusCode;
-    private Meter otherMeter;
-    private Meter timeoutsMeter;
-    private Meter errorsMeter;
-    private Counter activeRequests;
-    private Timer requestTimer;
-
-
-    /**
-     * Creates a new instance of the filter.
-     *
-     * @param registryAttribute      the attribute used to look up the metrics registry in the
-     *                               servlet context
-     * @param meterNamesByStatusCode A map, keyed by status code, of meter names that we are
-     *                               interested in.
-     * @param otherMetricName        The name used for the catch-all meter.
-     */
-    protected AbstractInstrumentedFilter(String registryAttribute,
-                                         Map<Integer, String> meterNamesByStatusCode,
-                                         String otherMetricName) {
-        this.registryAttribute = registryAttribute;
-        this.otherMetricName = otherMetricName;
-        this.meterNamesByStatusCode = meterNamesByStatusCode;
+  static final String METRIC_PREFIX = "name-prefix";
+
+  private final String otherMetricName;
+  private final Map<Integer, String> meterNamesByStatusCode;
+  private final String registryAttribute;
+
+  // initialized after call of init method
+  private ConcurrentMap<Integer, Meter> metersByStatusCode;
+  private Meter otherMeter;
+  private Meter timeoutsMeter;
+  private Meter errorsMeter;
+  private Counter activeRequests;
+  private Timer requestTimer;
+
+  /**
+   * Creates a new instance of the filter.
+   *
+   * @param registryAttribute the attribute used to look up the metrics registry in the servlet
+   *     context
+   * @param meterNamesByStatusCode A map, keyed by status code, of meter names that we are
+   *     interested in.
+   * @param otherMetricName The name used for the catch-all meter.
+   */
+  protected AbstractInstrumentedFilter(
+      String registryAttribute,
+      Map<Integer, String> meterNamesByStatusCode,
+      String otherMetricName) {
+    this.registryAttribute = registryAttribute;
+    this.otherMetricName = otherMetricName;
+    this.meterNamesByStatusCode = meterNamesByStatusCode;
+  }
+
+  @Override
+  public void init(FilterConfig filterConfig) throws ServletException {
+    final MetricRegistry metricsRegistry = getMetricsFactory(filterConfig);
+
+    String metricName = filterConfig.getInitParameter(METRIC_PREFIX);
+    if (Strings.isNullOrEmpty(metricName)) {
+      metricName = getClass().getName();
     }
 
-    @Override
-    public void init(FilterConfig filterConfig) throws ServletException {
-        final MetricRegistry metricsRegistry = getMetricsFactory(filterConfig);
-
-        String metricName = filterConfig.getInitParameter(METRIC_PREFIX);
-        if (metricName == null || metricName.isEmpty()) {
-            metricName = getClass().getName();
-        }
-
-        this.metersByStatusCode = new ConcurrentHashMap<>(meterNamesByStatusCode.size());
-        for (Entry<Integer, String> entry : meterNamesByStatusCode.entrySet()) {
-            metersByStatusCode.put(entry.getKey(),
-                    metricsRegistry.meter(name(metricName, entry.getValue())));
-        }
-        this.otherMeter = metricsRegistry.meter(name(metricName, otherMetricName));
-        this.timeoutsMeter = metricsRegistry.meter(name(metricName, "timeouts"));
-        this.errorsMeter = metricsRegistry.meter(name(metricName, "errors"));
-        this.activeRequests = metricsRegistry.counter(name(metricName, "activeRequests"));
-        this.requestTimer = metricsRegistry.timer(name(metricName, "requests"));
-
+    this.metersByStatusCode = new ConcurrentHashMap<>(meterNamesByStatusCode.size());
+    for (Entry<Integer, String> entry : meterNamesByStatusCode.entrySet()) {
+      metersByStatusCode.put(
+          entry.getKey(), metricsRegistry.meter(name(metricName, entry.getValue())));
     }
-
-    private MetricRegistry getMetricsFactory(FilterConfig filterConfig) {
-        final MetricRegistry metricsRegistry;
-
-        final Object o = filterConfig.getServletContext().getAttribute(this.registryAttribute);
-        if (o instanceof MetricRegistry) {
-            metricsRegistry = (MetricRegistry) o;
+    this.otherMeter = metricsRegistry.meter(name(metricName, otherMetricName));
+    this.timeoutsMeter = metricsRegistry.meter(name(metricName, "timeouts"));
+    this.errorsMeter = metricsRegistry.meter(name(metricName, "errors"));
+    this.activeRequests = metricsRegistry.counter(name(metricName, "activeRequests"));
+    this.requestTimer = metricsRegistry.timer(name(metricName, "requests"));
+  }
+
+  private MetricRegistry getMetricsFactory(FilterConfig filterConfig) {
+    final MetricRegistry metricsRegistry;
+
+    final Object o = filterConfig.getServletContext().getAttribute(this.registryAttribute);
+    if (o instanceof MetricRegistry) {
+      metricsRegistry = (MetricRegistry) o;
+    } else {
+      metricsRegistry = new MetricRegistry();
+    }
+    return metricsRegistry;
+  }
+
+  @Override
+  public void destroy() {}
+
+  @Override
+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
+      throws IOException, ServletException {
+    final StatusExposingServletResponse wrappedResponse =
+        new StatusExposingServletResponse((HttpServletResponse) response);
+    activeRequests.inc();
+    final Timer.Context context = requestTimer.time();
+    boolean error = false;
+    try {
+      chain.doFilter(request, wrappedResponse);
+    } catch (IOException | RuntimeException | ServletException e) {
+      error = true;
+      throw e;
+    } finally {
+      if (!error && request.isAsyncStarted()) {
+        request.getAsyncContext().addListener(new AsyncResultListener(context));
+      } else {
+        context.stop();
+        activeRequests.dec();
+        if (error) {
+          errorsMeter.mark();
         } else {
-            metricsRegistry = new MetricRegistry();
+          markMeterForStatusCode(wrappedResponse.getStatus());
         }
-        return metricsRegistry;
+      }
+    }
+  }
+
+  private void markMeterForStatusCode(int status) {
+    final Meter metric = metersByStatusCode.get(status);
+    if (metric != null) {
+      metric.mark();
+    } else {
+      otherMeter.mark();
     }
+  }
 
-    @Override
-    public void destroy() {
+  private static class StatusExposingServletResponse extends HttpServletResponseWrapper {
+    // The Servlet spec says: calling setStatus is optional, if no status is set, the default is
+    // 200.
+    private int httpStatus = 200;
 
+    public StatusExposingServletResponse(HttpServletResponse response) {
+      super(response);
     }
 
     @Override
-    public void doFilter(ServletRequest request,
-                         ServletResponse response,
-                         FilterChain chain) throws IOException, ServletException {
-        final StatusExposingServletResponse wrappedResponse =
-                new StatusExposingServletResponse((HttpServletResponse) response);
-        activeRequests.inc();
-        final Timer.Context context = requestTimer.time();
-        boolean error = false;
-        try {
-            chain.doFilter(request, wrappedResponse);
-        } catch (IOException | RuntimeException | ServletException e) {
-            error = true;
-            throw e;
-        } finally {
-            if (!error && request.isAsyncStarted()) {
-                request.getAsyncContext().addListener(new AsyncResultListener(context));
-            } else {
-                context.stop();
-                activeRequests.dec();
-                if (error) {
-                    errorsMeter.mark();
-                } else {
-                    markMeterForStatusCode(wrappedResponse.getStatus());
-                }
-            }
-        }
+    public void sendError(int sc) throws IOException {
+      httpStatus = sc;
+      super.sendError(sc);
     }
 
-    private void markMeterForStatusCode(int status) {
-        final Meter metric = metersByStatusCode.get(status);
-        if (metric != null) {
-            metric.mark();
-        } else {
-            otherMeter.mark();
-        }
+    @Override
+    public void sendError(int sc, String msg) throws IOException {
+      httpStatus = sc;
+      super.sendError(sc, msg);
     }
 
-    private static class StatusExposingServletResponse extends HttpServletResponseWrapper {
-        // The Servlet spec says: calling setStatus is optional, if no status is set, the default is 200.
-        private int httpStatus = 200;
-
-        public StatusExposingServletResponse(HttpServletResponse response) {
-            super(response);
-        }
-
-        @Override
-        public void sendError(int sc) throws IOException {
-            httpStatus = sc;
-            super.sendError(sc);
-        }
-
-        @Override
-        public void sendError(int sc, String msg) throws IOException {
-            httpStatus = sc;
-            super.sendError(sc, msg);
-        }
-
-        @Override
-        public void setStatus(int sc) {
-            httpStatus = sc;
-            super.setStatus(sc);
-        }
-
-        @Override
-        public int getStatus() {
-            return httpStatus;
-        }
+    @Override
+    public void setStatus(int sc) {
+      httpStatus = sc;
+      super.setStatus(sc);
     }
 
-    private class AsyncResultListener implements AsyncListener {
-        private final Timer.Context context;
-        private boolean done = false;
-
-        public AsyncResultListener(Timer.Context context) {
-            this.context = context;
-        }
+    @Override
+    public int getStatus() {
+      return httpStatus;
+    }
+  }
 
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {
-            if (!done) {
-                HttpServletResponse suppliedResponse = (HttpServletResponse) event.getSuppliedResponse();
-                context.stop();
-                activeRequests.dec();
-                markMeterForStatusCode(suppliedResponse.getStatus());
-            }
-        }
+  private class AsyncResultListener implements AsyncListener {
+    private final Timer.Context context;
+    private boolean done = false;
 
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {
-            context.stop();
-            activeRequests.dec();
-            timeoutsMeter.mark();
-            done = true;
-        }
+    public AsyncResultListener(Timer.Context context) {
+      this.context = context;
+    }
 
-        @Override
-        public void onError(AsyncEvent event) throws IOException {
-            context.stop();
-            activeRequests.dec();
-            errorsMeter.mark();
-            done = true;
-        }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {
+      if (!done) {
+        HttpServletResponse suppliedResponse = (HttpServletResponse) event.getSuppliedResponse();
+        context.stop();
+        activeRequests.dec();
+        markMeterForStatusCode(suppliedResponse.getStatus());
+      }
+    }
 
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {
+      context.stop();
+      activeRequests.dec();
+      timeoutsMeter.mark();
+      done = true;
+    }
 
-        }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {
+      context.stop();
+      activeRequests.dec();
+      errorsMeter.mark();
+      done = true;
     }
+
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {}
+  }
 }
--- a/metrics-jakarta-servlet6/src/main/java/io/dropwizard/metrics5/servlet6/InstrumentedFilter.java
+++ b/metrics-jakarta-servlet6/src/main/java/io/dropwizard/metrics5/servlet6/InstrumentedFilter.java
@@ -4,8 +4,13 @@ import java.util.HashMap;
 import java.util.Map;
 
 /**
- * Implementation of the {@link AbstractInstrumentedFilter} which provides a default set of response codes
- * to capture information about. <p>Use it in your servlet.xml like this:<p>
+ * Implementation of the {@link AbstractInstrumentedFilter} which provides a default set of response
+ * codes to capture information about.
+ *
+ * <p>Use it in your servlet.xml like this:
+ *
+ * <p>
+ *
  * <pre>{@code
  * <filter>
  *     <filter-name>instrumentedFilter</filter-name>
@@ -18,31 +23,29 @@ import java.util.Map;
  * }</pre>
  */
 public class InstrumentedFilter extends AbstractInstrumentedFilter {
-    public static final String REGISTRY_ATTRIBUTE = InstrumentedFilter.class.getName() + ".registry";
+  public static final String REGISTRY_ATTRIBUTE = InstrumentedFilter.class.getName() + ".registry";
 
-    private static final String NAME_PREFIX = "responseCodes.";
-    private static final int OK = 200;
-    private static final int CREATED = 201;
-    private static final int NO_CONTENT = 204;
-    private static final int BAD_REQUEST = 400;
-    private static final int NOT_FOUND = 404;
-    private static final int SERVER_ERROR = 500;
+  private static final String NAME_PREFIX = "responseCodes.";
+  private static final int OK = 200;
+  private static final int CREATED = 201;
+  private static final int NO_CONTENT = 204;
+  private static final int BAD_REQUEST = 400;
+  private static final int NOT_FOUND = 404;
+  private static final int SERVER_ERROR = 500;
 
-    /**
-     * Creates a new instance of the filter.
-     */
-    public InstrumentedFilter() {
-        super(REGISTRY_ATTRIBUTE, createMeterNamesByStatusCode(), NAME_PREFIX + "other");
-    }
+  /** Creates a new instance of the filter. */
+  public InstrumentedFilter() {
+    super(REGISTRY_ATTRIBUTE, createMeterNamesByStatusCode(), NAME_PREFIX + "other");
+  }
 
-    private static Map<Integer, String> createMeterNamesByStatusCode() {
-        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);
-        meterNamesByStatusCode.put(OK, NAME_PREFIX + "ok");
-        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + "created");
-        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + "noContent");
-        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + "badRequest");
-        meterNamesByStatusCode.put(NOT_FOUND, NAME_PREFIX + "notFound");
-        meterNamesByStatusCode.put(SERVER_ERROR, NAME_PREFIX + "serverError");
-        return meterNamesByStatusCode;
-    }
+  private static Map<Integer, String> createMeterNamesByStatusCode() {
+    final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);
+    meterNamesByStatusCode.put(OK, NAME_PREFIX + "ok");
+    meterNamesByStatusCode.put(CREATED, NAME_PREFIX + "created");
+    meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + "noContent");
+    meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + "badRequest");
+    meterNamesByStatusCode.put(NOT_FOUND, NAME_PREFIX + "notFound");
+    meterNamesByStatusCode.put(SERVER_ERROR, NAME_PREFIX + "serverError");
+    return meterNamesByStatusCode;
+  }
 }
--- a/metrics-jakarta-servlet6/src/main/java/io/dropwizard/metrics5/servlet6/InstrumentedFilterContextListener.java
+++ b/metrics-jakarta-servlet6/src/main/java/io/dropwizard/metrics5/servlet6/InstrumentedFilterContextListener.java
@@ -10,17 +10,17 @@ import jakarta.servlet.ServletContextListener;
  * application.
  */
 public abstract class InstrumentedFilterContextListener implements ServletContextListener {
-    /**
-     * @return the {@link MetricRegistry} to inject into the servlet context.
-     */
-    protected abstract MetricRegistry getMetricRegistry();
+  /**
+   * @return the {@link MetricRegistry} to inject into the servlet context.
+   */
+  protected abstract MetricRegistry getMetricRegistry();
 
-    @Override
-    public void contextInitialized(ServletContextEvent sce) {
-        sce.getServletContext().setAttribute(InstrumentedFilter.REGISTRY_ATTRIBUTE, getMetricRegistry());
-    }
+  @Override
+  public void contextInitialized(ServletContextEvent sce) {
+    sce.getServletContext()
+        .setAttribute(InstrumentedFilter.REGISTRY_ATTRIBUTE, getMetricRegistry());
+  }
 
-    @Override
-    public void contextDestroyed(ServletContextEvent sce) {
-    }
+  @Override
+  public void contextDestroyed(ServletContextEvent sce) {}
 }
--- a/metrics-jakarta-servlet6/src/test/java/io/dropwizard/metrics5/servlet6/InstrumentedFilterContextListenerTest.java
+++ b/metrics-jakarta-servlet6/src/test/java/io/dropwizard/metrics5/servlet6/InstrumentedFilterContextListenerTest.java
@@ -1,32 +1,34 @@
 package io.dropwizard.metrics5.servlet6;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import jakarta.servlet.ServletContext;
 import jakarta.servlet.ServletContextEvent;
 import org.junit.jupiter.api.Test;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-class InstrumentedFilterContextListenerTest {
-    private final MetricRegistry registry = mock(MetricRegistry.class);
-    private final InstrumentedFilterContextListener listener = new InstrumentedFilterContextListener() {
+final class InstrumentedFilterContextListenerTest {
+  private final MetricRegistry registry = mock();
+  private final InstrumentedFilterContextListener listener =
+      new InstrumentedFilterContextListener() {
         @Override
         protected MetricRegistry getMetricRegistry() {
-            return registry;
+          return registry;
         }
-    };
+      };
 
-    @Test
-    void injectsTheMetricRegistryIntoTheServletContext() {
-        final ServletContext context = mock(ServletContext.class);
+  @Test
+  void injectsTheMetricRegistryIntoTheServletContext() {
+    final ServletContext context = mock();
 
-        final ServletContextEvent event = mock(ServletContextEvent.class);
-        when(event.getServletContext()).thenReturn(context);
+    final ServletContextEvent event = mock();
+    when(event.getServletContext()).thenReturn(context);
 
-        listener.contextInitialized(event);
+    listener.contextInitialized(event);
 
-        verify(context).setAttribute("io.dropwizard.metrics5.servlet6.InstrumentedFilter.registry", registry);
-    }
+    verify(context)
+        .setAttribute("io.dropwizard.metrics5.servlet6.InstrumentedFilter.registry", registry);
+  }
 }
--- a/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/AdminServlet.java
+++ b/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/AdminServlet.java
@@ -6,185 +6,205 @@ import jakarta.servlet.ServletException;
 import jakarta.servlet.http.HttpServlet;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
-
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.text.MessageFormat;
 
 public class AdminServlet extends HttpServlet {
-    public static final String DEFAULT_HEALTHCHECK_URI = "/healthcheck";
-    public static final String DEFAULT_METRICS_URI = "/metrics";
-    public static final String DEFAULT_PING_URI = "/ping";
-    public static final String DEFAULT_THREADS_URI = "/threads";
-    public static final String DEFAULT_CPU_PROFILE_URI = "/pprof";
-
-    public static final String METRICS_ENABLED_PARAM_KEY = "metrics-enabled";
-    public static final String METRICS_URI_PARAM_KEY = "metrics-uri";
-    public static final String PING_ENABLED_PARAM_KEY = "ping-enabled";
-    public static final String PING_URI_PARAM_KEY = "ping-uri";
-    public static final String THREADS_ENABLED_PARAM_KEY = "threads-enabled";
-    public static final String THREADS_URI_PARAM_KEY = "threads-uri";
-    public static final String HEALTHCHECK_ENABLED_PARAM_KEY = "healthcheck-enabled";
-    public static final String HEALTHCHECK_URI_PARAM_KEY = "healthcheck-uri";
-    public static final String SERVICE_NAME_PARAM_KEY = "service-name";
-    public static final String CPU_PROFILE_ENABLED_PARAM_KEY = "cpu-profile-enabled";
-    public static final String CPU_PROFILE_URI_PARAM_KEY = "cpu-profile-uri";
-
-    private static final String BASE_TEMPLATE =
-            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n" +
-                    "        \"http://www.w3.org/TR/html4/loose.dtd\">%n" +
-                    "<html>%n" +
-                    "<head>%n" +
-                    "  <title>Metrics{10}</title>%n" +
-                    "</head>%n" +
-                    "<body>%n" +
-                    "  <h1>Operational Menu{10}</h1>%n" +
-                    "  <ul>%n" +
-                    "%s" +
-                    "  </ul>%n" +
-                    "</body>%n" +
-                    "</html>";
-    private static final String METRICS_LINK = "    <li><a href=\"{0}{1}?pretty=true\">Metrics</a></li>%n";
-    private static final String PING_LINK = "    <li><a href=\"{2}{3}\">Ping</a></li>%n" ;
-    private static final String THREADS_LINK = "    <li><a href=\"{4}{5}\">Threads</a></li>%n" ;
-    private static final String HEALTHCHECK_LINK = "    <li><a href=\"{6}{7}?pretty=true\">Healthcheck</a></li>%n" ;
-    private static final String CPU_PROFILE_LINK = "    <li><a href=\"{8}{9}\">CPU Profile</a></li>%n" +
-            "    <li><a href=\"{8}{9}?state=blocked\">CPU Contention</a></li>%n";
-
-
-    private static final String CONTENT_TYPE = "text/html";
-    private static final long serialVersionUID = -2850794040708785318L;
-
-    private transient HealthCheckServlet healthCheckServlet;
-    private transient MetricsServlet metricsServlet;
-    private transient PingServlet pingServlet;
-    private transient ThreadDumpServlet threadDumpServlet;
-    private transient CpuProfileServlet cpuProfileServlet;
-    private transient boolean metricsEnabled;
-    private transient String metricsUri;
-    private transient boolean pingEnabled;
-    private transient String pingUri;
-    private transient boolean threadsEnabled;
-    private transient String threadsUri;
-    private transient boolean healthcheckEnabled;
-    private transient String healthcheckUri;
-    private transient boolean cpuProfileEnabled;
-    private transient String cpuProfileUri;
-    private transient String serviceName;
-    private transient String pageContentTemplate;
-
-    @Override
-    public void init(ServletConfig config) throws ServletException {
-        super.init(config);
-
-        final ServletContext context = config.getServletContext();
-        final StringBuilder servletLinks = new StringBuilder();
-
-        this.metricsEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(METRICS_ENABLED_PARAM_KEY), "true"));
-        if (this.metricsEnabled) {
-            servletLinks.append(METRICS_LINK);
-        }
-        this.metricsServlet = new MetricsServlet();
-        metricsServlet.init(config);
-
-        this.pingEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(PING_ENABLED_PARAM_KEY), "true"));
-        if (this.pingEnabled) {
-            servletLinks.append(PING_LINK);
-        }
-        this.pingServlet = new PingServlet();
-        pingServlet.init(config);
-
-        this.threadsEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(THREADS_ENABLED_PARAM_KEY), "true"));
-        if (this.threadsEnabled) {
-            servletLinks.append(THREADS_LINK);
-        }
-        this.threadDumpServlet = new ThreadDumpServlet();
-        threadDumpServlet.init(config);
-
-        this.healthcheckEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(HEALTHCHECK_ENABLED_PARAM_KEY), "true"));
-        if (this.healthcheckEnabled) {
-            servletLinks.append(HEALTHCHECK_LINK);
-        }
-        this.healthCheckServlet = new HealthCheckServlet();
-        healthCheckServlet.init(config);
-
-        this.cpuProfileEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(CPU_PROFILE_ENABLED_PARAM_KEY), "true"));
-        if (this.cpuProfileEnabled) {
-            servletLinks.append(CPU_PROFILE_LINK);
-        }
-        this.cpuProfileServlet = new CpuProfileServlet();
-        cpuProfileServlet.init(config);
-
-        pageContentTemplate = String.format(BASE_TEMPLATE, String.format(servletLinks.toString()));
-
-        this.metricsUri = getParam(context.getInitParameter(METRICS_URI_PARAM_KEY), DEFAULT_METRICS_URI);
-        this.pingUri = getParam(context.getInitParameter(PING_URI_PARAM_KEY), DEFAULT_PING_URI);
-        this.threadsUri = getParam(context.getInitParameter(THREADS_URI_PARAM_KEY), DEFAULT_THREADS_URI);
-        this.healthcheckUri = getParam(context.getInitParameter(HEALTHCHECK_URI_PARAM_KEY), DEFAULT_HEALTHCHECK_URI);
-        this.cpuProfileUri = getParam(context.getInitParameter(CPU_PROFILE_URI_PARAM_KEY), DEFAULT_CPU_PROFILE_URI);
-        this.serviceName = getParam(context.getInitParameter(SERVICE_NAME_PARAM_KEY), null);
+  public static final String DEFAULT_HEALTHCHECK_URI = "/healthcheck";
+  public static final String DEFAULT_METRICS_URI = "/metrics";
+  public static final String DEFAULT_PING_URI = "/ping";
+  public static final String DEFAULT_THREADS_URI = "/threads";
+  public static final String DEFAULT_CPU_PROFILE_URI = "/pprof";
+
+  public static final String METRICS_ENABLED_PARAM_KEY = "metrics-enabled";
+  public static final String METRICS_URI_PARAM_KEY = "metrics-uri";
+  public static final String PING_ENABLED_PARAM_KEY = "ping-enabled";
+  public static final String PING_URI_PARAM_KEY = "ping-uri";
+  public static final String THREADS_ENABLED_PARAM_KEY = "threads-enabled";
+  public static final String THREADS_URI_PARAM_KEY = "threads-uri";
+  public static final String HEALTHCHECK_ENABLED_PARAM_KEY = "healthcheck-enabled";
+  public static final String HEALTHCHECK_URI_PARAM_KEY = "healthcheck-uri";
+  public static final String SERVICE_NAME_PARAM_KEY = "service-name";
+  public static final String CPU_PROFILE_ENABLED_PARAM_KEY = "cpu-profile-enabled";
+  public static final String CPU_PROFILE_URI_PARAM_KEY = "cpu-profile-uri";
+
+  private static final String BASE_TEMPLATE =
+      "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n"
+          + "        \"http://www.w3.org/TR/html4/loose.dtd\">%n"
+          + "<html>%n"
+          + "<head>%n"
+          + "  <title>Metrics{10}</title>%n"
+          + "</head>%n"
+          + "<body>%n"
+          + "  <h1>Operational Menu{10}</h1>%n"
+          + "  <ul>%n"
+          + "%s"
+          + "  </ul>%n"
+          + "</body>%n"
+          + "</html>";
+  private static final String METRICS_LINK =
+      "    <li><a href=\"{0}{1}?pretty=true\">Metrics</a></li>%n";
+  private static final String PING_LINK = "    <li><a href=\"{2}{3}\">Ping</a></li>%n";
+  private static final String THREADS_LINK = "    <li><a href=\"{4}{5}\">Threads</a></li>%n";
+  private static final String HEALTHCHECK_LINK =
+      "    <li><a href=\"{6}{7}?pretty=true\">Healthcheck</a></li>%n";
+  private static final String CPU_PROFILE_LINK =
+      "    <li><a href=\"{8}{9}\">CPU Profile</a></li>%n"
+          + "    <li><a href=\"{8}{9}?state=blocked\">CPU Contention</a></li>%n";
+
+  private static final String CONTENT_TYPE = "text/html";
+  private static final long serialVersionUID = -2850794040708785318L;
+
+  private transient HealthCheckServlet healthCheckServlet;
+  private transient MetricsServlet metricsServlet;
+  private transient PingServlet pingServlet;
+  private transient ThreadDumpServlet threadDumpServlet;
+  private transient CpuProfileServlet cpuProfileServlet;
+  private transient boolean metricsEnabled;
+  private transient String metricsUri;
+  private transient boolean pingEnabled;
+  private transient String pingUri;
+  private transient boolean threadsEnabled;
+  private transient String threadsUri;
+  private transient boolean healthcheckEnabled;
+  private transient String healthcheckUri;
+  private transient boolean cpuProfileEnabled;
+  private transient String cpuProfileUri;
+  private transient String serviceName;
+  private transient String pageContentTemplate;
+
+  @Override
+  public void init(ServletConfig config) throws ServletException {
+    super.init(config);
+
+    final ServletContext context = config.getServletContext();
+    final StringBuilder servletLinks = new StringBuilder();
+
+    this.metricsEnabled =
+        Boolean.parseBoolean(getParam(context.getInitParameter(METRICS_ENABLED_PARAM_KEY), "true"));
+    if (this.metricsEnabled) {
+      servletLinks.append(METRICS_LINK);
     }
+    this.metricsServlet = new MetricsServlet();
+    metricsServlet.init(config);
 
-    @Override
-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
-        final String path = req.getContextPath() + req.getServletPath();
-
-        resp.setStatus(HttpServletResponse.SC_OK);
-        resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
-        resp.setContentType(CONTENT_TYPE);
-        try (PrintWriter writer = resp.getWriter()) {
-            writer.println(MessageFormat.format(pageContentTemplate, path, metricsUri, path, pingUri, path,
-                    threadsUri, path, healthcheckUri, path, cpuProfileUri,
-                    serviceName == null ? "" : " (" + serviceName + ")"));
-        }
+    this.pingEnabled =
+        Boolean.parseBoolean(getParam(context.getInitParameter(PING_ENABLED_PARAM_KEY), "true"));
+    if (this.pingEnabled) {
+      servletLinks.append(PING_LINK);
     }
+    this.pingServlet = new PingServlet();
+    pingServlet.init(config);
 
-    @Override
-    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
-        final String uri = req.getPathInfo();
-        if (uri == null || uri.equals("/")) {
-            super.service(req, resp);
-        } else if (uri.equals(healthcheckUri)) {
-            if (healthcheckEnabled) {
-                healthCheckServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else if (uri.startsWith(metricsUri)) {
-            if (metricsEnabled) {
-                metricsServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else if (uri.equals(pingUri)) {
-            if (pingEnabled) {
-                pingServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else if (uri.equals(threadsUri)) {
-            if (threadsEnabled) {
-                threadDumpServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else if (uri.equals(cpuProfileUri)) {
-            if (cpuProfileEnabled) {
-                cpuProfileServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else {
-            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-        }
+    this.threadsEnabled =
+        Boolean.parseBoolean(getParam(context.getInitParameter(THREADS_ENABLED_PARAM_KEY), "true"));
+    if (this.threadsEnabled) {
+      servletLinks.append(THREADS_LINK);
     }
-
-    private static String getParam(String initParam, String defaultValue) {
-        return initParam == null ? defaultValue : initParam;
+    this.threadDumpServlet = new ThreadDumpServlet();
+    threadDumpServlet.init(config);
+
+    this.healthcheckEnabled =
+        Boolean.parseBoolean(
+            getParam(context.getInitParameter(HEALTHCHECK_ENABLED_PARAM_KEY), "true"));
+    if (this.healthcheckEnabled) {
+      servletLinks.append(HEALTHCHECK_LINK);
+    }
+    this.healthCheckServlet = new HealthCheckServlet();
+    healthCheckServlet.init(config);
+
+    this.cpuProfileEnabled =
+        Boolean.parseBoolean(
+            getParam(context.getInitParameter(CPU_PROFILE_ENABLED_PARAM_KEY), "true"));
+    if (this.cpuProfileEnabled) {
+      servletLinks.append(CPU_PROFILE_LINK);
     }
+    this.cpuProfileServlet = new CpuProfileServlet();
+    cpuProfileServlet.init(config);
+
+    pageContentTemplate = String.format(BASE_TEMPLATE, String.format(servletLinks.toString()));
+
+    this.metricsUri =
+        getParam(context.getInitParameter(METRICS_URI_PARAM_KEY), DEFAULT_METRICS_URI);
+    this.pingUri = getParam(context.getInitParameter(PING_URI_PARAM_KEY), DEFAULT_PING_URI);
+    this.threadsUri =
+        getParam(context.getInitParameter(THREADS_URI_PARAM_KEY), DEFAULT_THREADS_URI);
+    this.healthcheckUri =
+        getParam(context.getInitParameter(HEALTHCHECK_URI_PARAM_KEY), DEFAULT_HEALTHCHECK_URI);
+    this.cpuProfileUri =
+        getParam(context.getInitParameter(CPU_PROFILE_URI_PARAM_KEY), DEFAULT_CPU_PROFILE_URI);
+    this.serviceName = getParam(context.getInitParameter(SERVICE_NAME_PARAM_KEY), null);
+  }
+
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    final String path = req.getContextPath() + req.getServletPath();
+
+    resp.setStatus(HttpServletResponse.SC_OK);
+    resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
+    resp.setContentType(CONTENT_TYPE);
+    try (PrintWriter writer = resp.getWriter()) {
+      writer.println(
+          MessageFormat.format(
+              pageContentTemplate,
+              path,
+              metricsUri,
+              path,
+              pingUri,
+              path,
+              threadsUri,
+              path,
+              healthcheckUri,
+              path,
+              cpuProfileUri,
+              serviceName == null ? "" : " (" + serviceName + ")"));
+    }
+  }
+
+  @Override
+  protected void service(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    final String uri = req.getPathInfo();
+    if (uri == null || uri.equals("/")) {
+      super.service(req, resp);
+    } else if (uri.equals(healthcheckUri)) {
+      if (healthcheckEnabled) {
+        healthCheckServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else if (uri.startsWith(metricsUri)) {
+      if (metricsEnabled) {
+        metricsServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else if (uri.equals(pingUri)) {
+      if (pingEnabled) {
+        pingServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else if (uri.equals(threadsUri)) {
+      if (threadsEnabled) {
+        threadDumpServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else if (uri.equals(cpuProfileUri)) {
+      if (cpuProfileEnabled) {
+        cpuProfileServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else {
+      resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+    }
+  }
+
+  private static String getParam(String initParam, String defaultValue) {
+    return initParam == null ? defaultValue : initParam;
+  }
 }
--- a/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/CpuProfileServlet.java
+++ b/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/CpuProfileServlet.java
@@ -5,7 +5,6 @@ import jakarta.servlet.ServletException;
 import jakarta.servlet.http.HttpServlet;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
-
 import java.io.IOException;
 import java.io.OutputStream;
 import java.time.Duration;
@@ -13,67 +12,68 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 /**
- * An HTTP servlets which outputs a <a href="https://github.com/gperftools/gperftools">pprof</a> parseable response.
+ * An HTTP servlets which outputs a <a href="https://github.com/gperftools/gperftools">pprof</a>
+ * parseable response.
  */
 public class CpuProfileServlet extends HttpServlet {
-    private static final long serialVersionUID = -668666696530287501L;
-    private static final String CONTENT_TYPE = "pprof/raw";
-    private static final String CACHE_CONTROL = "Cache-Control";
-    private static final String NO_CACHE = "must-revalidate,no-cache,no-store";
-    private final Lock lock = new ReentrantLock();
+  private static final long serialVersionUID = -668666696530287501L;
+  private static final String CONTENT_TYPE = "pprof/raw";
+  private static final String CACHE_CONTROL = "Cache-Control";
+  private static final String NO_CACHE = "must-revalidate,no-cache,no-store";
+  private final Lock lock = new ReentrantLock();
 
-    @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
 
-        int duration = 10;
-        if (req.getParameter("duration") != null) {
-            try {
-                duration = Integer.parseInt(req.getParameter("duration"));
-            } catch (NumberFormatException e) {
-                duration = 10;
-            }
-        }
+    int duration = 10;
+    if (req.getParameter("duration") != null) {
+      try {
+        duration = Integer.parseInt(req.getParameter("duration"));
+      } catch (NumberFormatException e) {
+        duration = 10;
+      }
+    }
 
-        int frequency = 100;
-        if (req.getParameter("frequency") != null) {
-            try {
-                frequency = Integer.parseInt(req.getParameter("frequency"));
-                frequency = Math.min(Math.max(frequency, 1), 1000);
-            } catch (NumberFormatException e) {
-                frequency = 100;
-            }
-        }
+    int frequency = 100;
+    if (req.getParameter("frequency") != null) {
+      try {
+        frequency = Integer.parseInt(req.getParameter("frequency"));
+        frequency = Math.min(Math.max(frequency, 1), 1000);
+      } catch (NumberFormatException e) {
+        frequency = 100;
+      }
+    }
 
-        final Thread.State state;
-        if ("blocked".equalsIgnoreCase(req.getParameter("state"))) {
-            state = Thread.State.BLOCKED;
-        } else {
-            state = Thread.State.RUNNABLE;
-        }
+    final Thread.State state;
+    if ("blocked".equalsIgnoreCase(req.getParameter("state"))) {
+      state = Thread.State.BLOCKED;
+    } else {
+      state = Thread.State.RUNNABLE;
+    }
 
-        resp.setStatus(HttpServletResponse.SC_OK);
-        resp.setHeader(CACHE_CONTROL, NO_CACHE);
-        resp.setContentType(CONTENT_TYPE);
-        try (OutputStream output = resp.getOutputStream()) {
-            doProfile(output, duration, frequency, state);
-        }
+    resp.setStatus(HttpServletResponse.SC_OK);
+    resp.setHeader(CACHE_CONTROL, NO_CACHE);
+    resp.setContentType(CONTENT_TYPE);
+    try (OutputStream output = resp.getOutputStream()) {
+      doProfile(output, duration, frequency, state);
     }
+  }
 
-    protected void doProfile(OutputStream out, int duration, int frequency, Thread.State state) throws IOException {
-        if (lock.tryLock()) {
-            try {
-                CpuProfile profile = CpuProfile.record(Duration.ofSeconds(duration),
-                        frequency, state);
-                if (profile == null) {
-                    throw new RuntimeException("could not create CpuProfile");
-                }
-                profile.writeGoogleProfile(out);
-                return;
-            } finally {
-                lock.unlock();
-            }
+  protected void doProfile(OutputStream out, int duration, int frequency, Thread.State state)
+      throws IOException {
+    if (lock.tryLock()) {
+      try {
+        CpuProfile profile = CpuProfile.record(Duration.ofSeconds(duration), frequency, state);
+        if (profile == null) {
+          throw new RuntimeException("could not create CpuProfile");
         }
-        throw new RuntimeException("Only one profile request may be active at a time");
+        profile.writeGoogleProfile(out);
+        return;
+      } finally {
+        lock.unlock();
+      }
     }
+    throw new RuntimeException("Only one profile request may be active at a time");
+  }
 }
--- a/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/HealthCheckServlet.java
+++ b/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/HealthCheckServlet.java
@@ -1,11 +1,11 @@
 package io.dropwizard.metrics5.servlets;
 
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectWriter;
 import io.dropwizard.metrics5.health.HealthCheck;
 import io.dropwizard.metrics5.health.HealthCheckFilter;
 import io.dropwizard.metrics5.health.HealthCheckRegistry;
 import io.dropwizard.metrics5.json.HealthCheckModule;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.ObjectWriter;
 import jakarta.servlet.ServletConfig;
 import jakarta.servlet.ServletContext;
 import jakarta.servlet.ServletContextEvent;
@@ -14,7 +14,6 @@ import jakarta.servlet.ServletException;
 import jakarta.servlet.http.HttpServlet;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
-
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Map;
@@ -22,175 +21,179 @@ import java.util.SortedMap;
 import java.util.concurrent.ExecutorService;
 
 public class HealthCheckServlet extends HttpServlet {
-    public static abstract class ContextListener implements ServletContextListener {
-        /**
-         * @return the {@link HealthCheckRegistry} to inject into the servlet context.
-         */
-        protected abstract HealthCheckRegistry getHealthCheckRegistry();
-
-        /**
-         * @return the {@link ExecutorService} to inject into the servlet context, or {@code null}
-         * if the health checks should be run in the servlet worker thread.
-         */
-        protected ExecutorService getExecutorService() {
-            // don't use a thread pool by default
-            return null;
-        }
-
-        /**
-         * @return the {@link HealthCheckFilter} that shall be used to filter health checks,
-         * or {@link HealthCheckFilter#ALL} if the default should be used.
-         */
-        protected HealthCheckFilter getHealthCheckFilter() {
-            return HealthCheckFilter.ALL;
-        }
-
-        /**
-         * @return the {@link ObjectMapper} that shall be used to render health checks,
-         * or {@code null} if the default object mapper should be used.
-         */
-        protected ObjectMapper getObjectMapper() {
-            // don't use an object mapper by default
-            return null;
-        }
-
-        @Override
-        public void contextInitialized(ServletContextEvent event) {
-            final ServletContext context = event.getServletContext();
-            context.setAttribute(HEALTH_CHECK_REGISTRY, getHealthCheckRegistry());
-            context.setAttribute(HEALTH_CHECK_EXECUTOR, getExecutorService());
-            context.setAttribute(HEALTH_CHECK_MAPPER, getObjectMapper());
-        }
-
-        @Override
-        public void contextDestroyed(ServletContextEvent event) {
-            // no-op
-        }
-    }
-
-    public static final String HEALTH_CHECK_REGISTRY = HealthCheckServlet.class.getCanonicalName() + ".registry";
-    public static final String HEALTH_CHECK_EXECUTOR = HealthCheckServlet.class.getCanonicalName() + ".executor";
-    public static final String HEALTH_CHECK_FILTER = HealthCheckServlet.class.getCanonicalName() + ".healthCheckFilter";
-    public static final String HEALTH_CHECK_MAPPER = HealthCheckServlet.class.getCanonicalName() + ".mapper";
-    public static final String HEALTH_CHECK_HTTP_STATUS_INDICATOR = HealthCheckServlet.class.getCanonicalName() + ".httpStatusIndicator";
-
-    private static final long serialVersionUID = -8432996484889177321L;
-    private static final String CONTENT_TYPE = "application/json";
-    private static final String HTTP_STATUS_INDICATOR_PARAM = "httpStatusIndicator";
-
-    private transient HealthCheckRegistry registry;
-    private transient ExecutorService executorService;
-    private transient HealthCheckFilter filter;
-    private transient ObjectMapper mapper;
-    private transient boolean httpStatusIndicator;
-
-    public HealthCheckServlet() {
-    }
-
-    public HealthCheckServlet(HealthCheckRegistry registry) {
-        this.registry = registry;
+  public abstract static class ContextListener implements ServletContextListener {
+    /**
+     * @return the {@link HealthCheckRegistry} to inject into the servlet context.
+     */
+    protected abstract HealthCheckRegistry getHealthCheckRegistry();
+
+    /**
+     * @return the {@link ExecutorService} to inject into the servlet context, or {@code null} if
+     *     the health checks should be run in the servlet worker thread.
+     */
+    protected ExecutorService getExecutorService() {
+      // don't use a thread pool by default
+      return null;
     }
 
-    @Override
-    public void init(ServletConfig config) throws ServletException {
-        super.init(config);
-
-        final ServletContext context = config.getServletContext();
-        if (null == registry) {
-            final Object registryAttr = context.getAttribute(HEALTH_CHECK_REGISTRY);
-            if (registryAttr instanceof HealthCheckRegistry) {
-                this.registry = (HealthCheckRegistry) registryAttr;
-            } else {
-                throw new ServletException("Couldn't find a HealthCheckRegistry instance.");
-            }
-        }
-
-        final Object executorAttr = context.getAttribute(HEALTH_CHECK_EXECUTOR);
-        if (executorAttr instanceof ExecutorService) {
-            this.executorService = (ExecutorService) executorAttr;
-        }
-
-
-        final Object filterAttr = context.getAttribute(HEALTH_CHECK_FILTER);
-        if (filterAttr instanceof HealthCheckFilter) {
-            filter = (HealthCheckFilter) filterAttr;
-        }
-        if (filter == null) {
-            filter = HealthCheckFilter.ALL;
-        }
-
-        final Object mapperAttr = context.getAttribute(HEALTH_CHECK_MAPPER);
-        if (mapperAttr instanceof ObjectMapper) {
-            this.mapper = (ObjectMapper) mapperAttr;
-        } else {
-            this.mapper = new ObjectMapper();
-        }
-        this.mapper.registerModule(new HealthCheckModule());
-
-        final Object httpStatusIndicatorAttr = context.getAttribute(HEALTH_CHECK_HTTP_STATUS_INDICATOR);
-        if (httpStatusIndicatorAttr instanceof Boolean) {
-            this.httpStatusIndicator = (Boolean) httpStatusIndicatorAttr;
-        } else {
-            this.httpStatusIndicator = true;
-        }
+    /**
+     * @return the {@link HealthCheckFilter} that shall be used to filter health checks, or {@link
+     *     HealthCheckFilter#ALL} if the default should be used.
+     */
+    protected HealthCheckFilter getHealthCheckFilter() {
+      return HealthCheckFilter.ALL;
+    }
+
+    /**
+     * @return the {@link ObjectMapper} that shall be used to render health checks, or {@code null}
+     *     if the default object mapper should be used.
+     */
+    protected ObjectMapper getObjectMapper() {
+      // don't use an object mapper by default
+      return null;
     }
 
     @Override
-    public void destroy() {
-        super.destroy();
-        registry.shutdown();
+    public void contextInitialized(ServletContextEvent event) {
+      final ServletContext context = event.getServletContext();
+      context.setAttribute(HEALTH_CHECK_REGISTRY, getHealthCheckRegistry());
+      context.setAttribute(HEALTH_CHECK_EXECUTOR, getExecutorService());
+      context.setAttribute(HEALTH_CHECK_MAPPER, getObjectMapper());
     }
 
     @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
-        final SortedMap<String, HealthCheck.Result> results = runHealthChecks();
-        resp.setContentType(CONTENT_TYPE);
-        resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
-        if (results.isEmpty()) {
-            resp.setStatus(HttpServletResponse.SC_NOT_IMPLEMENTED);
-        } else {
-            final String reqParameter = req.getParameter(HTTP_STATUS_INDICATOR_PARAM);
-            final boolean httpStatusIndicatorParam = Boolean.parseBoolean(reqParameter);
-            final boolean useHttpStatusForHealthCheck = reqParameter == null ? httpStatusIndicator : httpStatusIndicatorParam;
-            if (!useHttpStatusForHealthCheck || isAllHealthy(results)) {
-                resp.setStatus(HttpServletResponse.SC_OK);
-            } else {
-                resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
-            }
-        }
-
-        try (OutputStream output = resp.getOutputStream()) {
-            getWriter(req).writeValue(output, results);
-        }
-    }
-
-    private ObjectWriter getWriter(HttpServletRequest request) {
-        final boolean prettyPrint = Boolean.parseBoolean(request.getParameter("pretty"));
-        if (prettyPrint) {
-            return mapper.writerWithDefaultPrettyPrinter();
-        }
-        return mapper.writer();
-    }
-
-    private SortedMap<String, HealthCheck.Result> runHealthChecks() {
-        if (executorService == null) {
-            return registry.runHealthChecks(filter);
-        }
-        return registry.runHealthChecks(executorService, filter);
-    }
-
-    private static boolean isAllHealthy(Map<String, HealthCheck.Result> results) {
-        for (HealthCheck.Result result : results.values()) {
-            if (!result.isHealthy()) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // visible for testing
-    ObjectMapper getMapper() {
-        return mapper;
+    public void contextDestroyed(ServletContextEvent event) {
+      // no-op
+    }
+  }
+
+  public static final String HEALTH_CHECK_REGISTRY =
+      HealthCheckServlet.class.getCanonicalName() + ".registry";
+  public static final String HEALTH_CHECK_EXECUTOR =
+      HealthCheckServlet.class.getCanonicalName() + ".executor";
+  public static final String HEALTH_CHECK_FILTER =
+      HealthCheckServlet.class.getCanonicalName() + ".healthCheckFilter";
+  public static final String HEALTH_CHECK_MAPPER =
+      HealthCheckServlet.class.getCanonicalName() + ".mapper";
+  public static final String HEALTH_CHECK_HTTP_STATUS_INDICATOR =
+      HealthCheckServlet.class.getCanonicalName() + ".httpStatusIndicator";
+
+  private static final long serialVersionUID = -8432996484889177321L;
+  private static final String CONTENT_TYPE = "application/json";
+  private static final String HTTP_STATUS_INDICATOR_PARAM = "httpStatusIndicator";
+
+  private transient HealthCheckRegistry registry;
+  private transient ExecutorService executorService;
+  private transient HealthCheckFilter filter;
+  private transient ObjectMapper mapper;
+  private transient boolean httpStatusIndicator;
+
+  public HealthCheckServlet() {}
+
+  public HealthCheckServlet(HealthCheckRegistry registry) {
+    this.registry = registry;
+  }
+
+  @Override
+  public void init(ServletConfig config) throws ServletException {
+    super.init(config);
+
+    final ServletContext context = config.getServletContext();
+    if (registry == null) {
+      final Object registryAttr = context.getAttribute(HEALTH_CHECK_REGISTRY);
+      if (registryAttr instanceof HealthCheckRegistry) {
+        this.registry = (HealthCheckRegistry) registryAttr;
+      } else {
+        throw new ServletException("Couldn't find a HealthCheckRegistry instance.");
+      }
+    }
+
+    final Object executorAttr = context.getAttribute(HEALTH_CHECK_EXECUTOR);
+    if (executorAttr instanceof ExecutorService) {
+      this.executorService = (ExecutorService) executorAttr;
+    }
+
+    final Object filterAttr = context.getAttribute(HEALTH_CHECK_FILTER);
+    if (filterAttr instanceof HealthCheckFilter) {
+      filter = (HealthCheckFilter) filterAttr;
+    }
+    if (filter == null) {
+      filter = HealthCheckFilter.ALL;
     }
+
+    final Object mapperAttr = context.getAttribute(HEALTH_CHECK_MAPPER);
+    if (mapperAttr instanceof ObjectMapper) {
+      this.mapper = (ObjectMapper) mapperAttr;
+    } else {
+      this.mapper = new ObjectMapper();
+    }
+    this.mapper.registerModule(new HealthCheckModule());
+
+    final Object httpStatusIndicatorAttr = context.getAttribute(HEALTH_CHECK_HTTP_STATUS_INDICATOR);
+    if (httpStatusIndicatorAttr instanceof Boolean) {
+      this.httpStatusIndicator = (Boolean) httpStatusIndicatorAttr;
+    } else {
+      this.httpStatusIndicator = true;
+    }
+  }
+
+  @Override
+  public void destroy() {
+    super.destroy();
+    registry.shutdown();
+  }
+
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    final SortedMap<String, HealthCheck.Result> results = runHealthChecks();
+    resp.setContentType(CONTENT_TYPE);
+    resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
+    if (results.isEmpty()) {
+      resp.setStatus(HttpServletResponse.SC_NOT_IMPLEMENTED);
+    } else {
+      final String reqParameter = req.getParameter(HTTP_STATUS_INDICATOR_PARAM);
+      final boolean httpStatusIndicatorParam = Boolean.parseBoolean(reqParameter);
+      final boolean useHttpStatusForHealthCheck =
+          reqParameter == null ? httpStatusIndicator : httpStatusIndicatorParam;
+      if (!useHttpStatusForHealthCheck || isAllHealthy(results)) {
+        resp.setStatus(HttpServletResponse.SC_OK);
+      } else {
+        resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
+      }
+    }
+
+    try (OutputStream output = resp.getOutputStream()) {
+      getWriter(req).writeValue(output, results);
+    }
+  }
+
+  private ObjectWriter getWriter(HttpServletRequest request) {
+    final boolean prettyPrint = Boolean.parseBoolean(request.getParameter("pretty"));
+    if (prettyPrint) {
+      return mapper.writerWithDefaultPrettyPrinter();
+    }
+    return mapper.writer();
+  }
+
+  private SortedMap<String, HealthCheck.Result> runHealthChecks() {
+    if (executorService == null) {
+      return registry.runHealthChecks(filter);
+    }
+    return registry.runHealthChecks(executorService, filter);
+  }
+
+  private static boolean isAllHealthy(Map<String, HealthCheck.Result> results) {
+    for (HealthCheck.Result result : results.values()) {
+      if (!result.isHealthy()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  // visible for testing
+  ObjectMapper getMapper() {
+    return mapper;
+  }
 }
--- a/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/MetricsServlet.java
+++ b/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/MetricsServlet.java
@@ -1,11 +1,11 @@
 package io.dropwizard.metrics5.servlets;
 
-import io.dropwizard.metrics5.MetricFilter;
-import io.dropwizard.metrics5.MetricRegistry;
-import io.dropwizard.metrics5.json.MetricsModule;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectWriter;
 import com.fasterxml.jackson.databind.util.JSONPObject;
+import io.dropwizard.metrics5.MetricFilter;
+import io.dropwizard.metrics5.MetricRegistry;
+import io.dropwizard.metrics5.json.MetricsModule;
 import jakarta.servlet.ServletConfig;
 import jakarta.servlet.ServletContext;
 import jakarta.servlet.ServletContextEvent;
@@ -14,7 +14,6 @@ import jakarta.servlet.ServletException;
 import jakarta.servlet.http.HttpServlet;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
-
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Locale;
@@ -24,176 +23,177 @@ import java.util.concurrent.TimeUnit;
  * A servlet which returns the metrics in a given registry as an {@code application/json} response.
  */
 public class MetricsServlet extends HttpServlet {
+  /**
+   * An abstract {@link ServletContextListener} which allows you to programmatically inject the
+   * {@link MetricRegistry}, rate and duration units, and allowed origin for {@link MetricsServlet}.
+   */
+  public abstract static class ContextListener implements ServletContextListener {
     /**
-     * An abstract {@link ServletContextListener} which allows you to programmatically inject the
-     * {@link MetricRegistry}, rate and duration units, and allowed origin for
-     * {@link MetricsServlet}.
+     * @return the {@link MetricRegistry} to inject into the servlet context.
      */
-    public static abstract class ContextListener implements ServletContextListener {
-        /**
-         * @return the {@link MetricRegistry} to inject into the servlet context.
-         */
-        protected abstract MetricRegistry getMetricRegistry();
-
-        /**
-         * @return the {@link TimeUnit} to which rates should be converted, or {@code null} if the
-         * default should be used.
-         */
-        protected TimeUnit getRateUnit() {
-            // use the default
-            return null;
-        }
-
-        /**
-         * @return the {@link TimeUnit} to which durations should be converted, or {@code null} if
-         * the default should be used.
-         */
-        protected TimeUnit getDurationUnit() {
-            // use the default
-            return null;
-        }
-
-        /**
-         * @return the {@code Access-Control-Allow-Origin} header value, if any.
-         */
-        protected String getAllowedOrigin() {
-            // use the default
-            return null;
-        }
-
-        /**
-         * Returns the name of the parameter used to specify the jsonp callback, if any.
-         */
-        protected String getJsonpCallbackParameter() {
-            return null;
-        }
-
-        /**
-         * Returns the {@link MetricFilter} that shall be used to filter metrics, or {@link MetricFilter#ALL} if
-         * the default should be used.
-         */
-        protected MetricFilter getMetricFilter() {
-            // use the default
-            return MetricFilter.ALL;
-        }
-
-        @Override
-        public void contextInitialized(ServletContextEvent event) {
-            final ServletContext context = event.getServletContext();
-            context.setAttribute(METRICS_REGISTRY, getMetricRegistry());
-            context.setAttribute(METRIC_FILTER, getMetricFilter());
-            if (getDurationUnit() != null) {
-                context.setInitParameter(MetricsServlet.DURATION_UNIT, getDurationUnit().toString());
-            }
-            if (getRateUnit() != null) {
-                context.setInitParameter(MetricsServlet.RATE_UNIT, getRateUnit().toString());
-            }
-            if (getAllowedOrigin() != null) {
-                context.setInitParameter(MetricsServlet.ALLOWED_ORIGIN, getAllowedOrigin());
-            }
-            if (getJsonpCallbackParameter() != null) {
-                context.setAttribute(CALLBACK_PARAM, getJsonpCallbackParameter());
-            }
-        }
-
-        @Override
-        public void contextDestroyed(ServletContextEvent event) {
-            // no-op
-        }
-    }
-
-    public static final String RATE_UNIT = MetricsServlet.class.getCanonicalName() + ".rateUnit";
-    public static final String DURATION_UNIT = MetricsServlet.class.getCanonicalName() + ".durationUnit";
-    public static final String SHOW_SAMPLES = MetricsServlet.class.getCanonicalName() + ".showSamples";
-    public static final String METRICS_REGISTRY = MetricsServlet.class.getCanonicalName() + ".registry";
-    public static final String ALLOWED_ORIGIN = MetricsServlet.class.getCanonicalName() + ".allowedOrigin";
-    public static final String METRIC_FILTER = MetricsServlet.class.getCanonicalName() + ".metricFilter";
-    public static final String CALLBACK_PARAM = MetricsServlet.class.getCanonicalName() + ".jsonpCallback";
+    protected abstract MetricRegistry getMetricRegistry();
 
-    private static final long serialVersionUID = 1049773947734939602L;
-    private static final String CONTENT_TYPE = "application/json";
+    /**
+     * @return the {@link TimeUnit} to which rates should be converted, or {@code null} if the
+     *     default should be used.
+     */
+    protected TimeUnit getRateUnit() {
+      // use the default
+      return null;
+    }
 
-    protected String allowedOrigin;
-    protected String jsonpParamName;
-    protected transient MetricRegistry registry;
-    protected transient ObjectMapper mapper;
+    /**
+     * @return the {@link TimeUnit} to which durations should be converted, or {@code null} if the
+     *     default should be used.
+     */
+    protected TimeUnit getDurationUnit() {
+      // use the default
+      return null;
+    }
 
-    public MetricsServlet() {
+    /**
+     * @return the {@code Access-Control-Allow-Origin} header value, if any.
+     */
+    protected String getAllowedOrigin() {
+      // use the default
+      return null;
     }
 
-    public MetricsServlet(MetricRegistry registry) {
-        this.registry = registry;
+    /** Returns the name of the parameter used to specify the jsonp callback, if any. */
+    protected String getJsonpCallbackParameter() {
+      return null;
     }
 
-    @Override
-    public void init(ServletConfig config) throws ServletException {
-        super.init(config);
-
-        final ServletContext context = config.getServletContext();
-        if (null == registry) {
-            final Object registryAttr = context.getAttribute(METRICS_REGISTRY);
-            if (registryAttr instanceof MetricRegistry) {
-                this.registry = (MetricRegistry) registryAttr;
-            } else {
-                throw new ServletException("Couldn't find a MetricRegistry instance.");
-            }
-        }
-        this.allowedOrigin = context.getInitParameter(ALLOWED_ORIGIN);
-        this.jsonpParamName = context.getInitParameter(CALLBACK_PARAM);
-
-        setupMetricsModule(context);
+    /**
+     * Returns the {@link MetricFilter} that shall be used to filter metrics, or {@link
+     * MetricFilter#ALL} if the default should be used.
+     */
+    protected MetricFilter getMetricFilter() {
+      // use the default
+      return MetricFilter.ALL;
     }
 
-    protected void setupMetricsModule(ServletContext context) {
-        final TimeUnit rateUnit = parseTimeUnit(context.getInitParameter(RATE_UNIT),
-                TimeUnit.SECONDS);
-        final TimeUnit durationUnit = parseTimeUnit(context.getInitParameter(DURATION_UNIT),
-                TimeUnit.SECONDS);
-        final boolean showSamples = Boolean.parseBoolean(context.getInitParameter(SHOW_SAMPLES));
-        MetricFilter filter = (MetricFilter) context.getAttribute(METRIC_FILTER);
-        if (filter == null) {
-            filter = MetricFilter.ALL;
-        }
-
-        this.mapper = new ObjectMapper().registerModule(new MetricsModule(rateUnit,
-                durationUnit,
-                showSamples,
-                filter));
+    @Override
+    public void contextInitialized(ServletContextEvent event) {
+      final ServletContext context = event.getServletContext();
+      context.setAttribute(METRICS_REGISTRY, getMetricRegistry());
+      context.setAttribute(METRIC_FILTER, getMetricFilter());
+      if (getDurationUnit() != null) {
+        context.setInitParameter(MetricsServlet.DURATION_UNIT, getDurationUnit().toString());
+      }
+      if (getRateUnit() != null) {
+        context.setInitParameter(MetricsServlet.RATE_UNIT, getRateUnit().toString());
+      }
+      if (getAllowedOrigin() != null) {
+        context.setInitParameter(MetricsServlet.ALLOWED_ORIGIN, getAllowedOrigin());
+      }
+      if (getJsonpCallbackParameter() != null) {
+        context.setAttribute(CALLBACK_PARAM, getJsonpCallbackParameter());
+      }
     }
 
     @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
-        resp.setContentType(CONTENT_TYPE);
-        if (allowedOrigin != null) {
-            resp.setHeader("Access-Control-Allow-Origin", allowedOrigin);
-        }
-        resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
-        resp.setStatus(HttpServletResponse.SC_OK);
-
-        try (OutputStream output = resp.getOutputStream()) {
-            if (jsonpParamName != null && req.getParameter(jsonpParamName) != null) {
-                getWriter(req).writeValue(output, new JSONPObject(req.getParameter(jsonpParamName), registry));
-            } else {
-                getWriter(req).writeValue(output, registry);
-            }
-        }
+    public void contextDestroyed(ServletContextEvent event) {
+      // no-op
+    }
+  }
+
+  public static final String RATE_UNIT = MetricsServlet.class.getCanonicalName() + ".rateUnit";
+  public static final String DURATION_UNIT =
+      MetricsServlet.class.getCanonicalName() + ".durationUnit";
+  public static final String SHOW_SAMPLES =
+      MetricsServlet.class.getCanonicalName() + ".showSamples";
+  public static final String METRICS_REGISTRY =
+      MetricsServlet.class.getCanonicalName() + ".registry";
+  public static final String ALLOWED_ORIGIN =
+      MetricsServlet.class.getCanonicalName() + ".allowedOrigin";
+  public static final String METRIC_FILTER =
+      MetricsServlet.class.getCanonicalName() + ".metricFilter";
+  public static final String CALLBACK_PARAM =
+      MetricsServlet.class.getCanonicalName() + ".jsonpCallback";
+
+  private static final long serialVersionUID = 1049773947734939602L;
+  private static final String CONTENT_TYPE = "application/json";
+
+  protected String allowedOrigin;
+  protected String jsonpParamName;
+  protected transient MetricRegistry registry;
+  protected transient ObjectMapper mapper;
+
+  public MetricsServlet() {}
+
+  public MetricsServlet(MetricRegistry registry) {
+    this.registry = registry;
+  }
+
+  @Override
+  public void init(ServletConfig config) throws ServletException {
+    super.init(config);
+
+    final ServletContext context = config.getServletContext();
+    if (registry == null) {
+      final Object registryAttr = context.getAttribute(METRICS_REGISTRY);
+      if (registryAttr instanceof MetricRegistry) {
+        this.registry = (MetricRegistry) registryAttr;
+      } else {
+        throw new ServletException("Couldn't find a MetricRegistry instance.");
+      }
+    }
+    this.allowedOrigin = context.getInitParameter(ALLOWED_ORIGIN);
+    this.jsonpParamName = context.getInitParameter(CALLBACK_PARAM);
+
+    setupMetricsModule(context);
+  }
+
+  protected void setupMetricsModule(ServletContext context) {
+    final TimeUnit rateUnit = parseTimeUnit(context.getInitParameter(RATE_UNIT), TimeUnit.SECONDS);
+    final TimeUnit durationUnit =
+        parseTimeUnit(context.getInitParameter(DURATION_UNIT), TimeUnit.SECONDS);
+    final boolean showSamples = Boolean.parseBoolean(context.getInitParameter(SHOW_SAMPLES));
+    MetricFilter filter = (MetricFilter) context.getAttribute(METRIC_FILTER);
+    if (filter == null) {
+      filter = MetricFilter.ALL;
     }
 
-    protected ObjectWriter getWriter(HttpServletRequest request) {
-        final boolean prettyPrint = Boolean.parseBoolean(request.getParameter("pretty"));
-        if (prettyPrint) {
-            return mapper.writerWithDefaultPrettyPrinter();
-        }
-        return mapper.writer();
+    this.mapper =
+        new ObjectMapper()
+            .registerModule(new MetricsModule(rateUnit, durationUnit, showSamples, filter));
+  }
+
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    resp.setContentType(CONTENT_TYPE);
+    if (allowedOrigin != null) {
+      resp.setHeader("Access-Control-Allow-Origin", allowedOrigin);
+    }
+    resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
+    resp.setStatus(HttpServletResponse.SC_OK);
+
+    try (OutputStream output = resp.getOutputStream()) {
+      if (jsonpParamName != null && req.getParameter(jsonpParamName) != null) {
+        getWriter(req)
+            .writeValue(output, new JSONPObject(req.getParameter(jsonpParamName), registry));
+      } else {
+        getWriter(req).writeValue(output, registry);
+      }
     }
+  }
 
-    @SuppressWarnings("IdentityConversion")
-    protected TimeUnit parseTimeUnit(String value, TimeUnit defaultValue) {
-        try {
-            return TimeUnit.valueOf(String.valueOf(value).toUpperCase(Locale.US));
-        } catch (IllegalArgumentException e) {
-            return defaultValue;
-        }
+  protected ObjectWriter getWriter(HttpServletRequest request) {
+    final boolean prettyPrint = Boolean.parseBoolean(request.getParameter("pretty"));
+    if (prettyPrint) {
+      return mapper.writerWithDefaultPrettyPrinter();
+    }
+    return mapper.writer();
+  }
+
+  @SuppressWarnings("IdentityConversion")
+  protected TimeUnit parseTimeUnit(String value, TimeUnit defaultValue) {
+    try {
+      return TimeUnit.valueOf(String.valueOf(value).toUpperCase(Locale.US));
+    } catch (IllegalArgumentException e) {
+      return defaultValue;
     }
+  }
 }
--- a/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/PingServlet.java
+++ b/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/PingServlet.java
@@ -4,28 +4,25 @@ import jakarta.servlet.ServletException;
 import jakarta.servlet.http.HttpServlet;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
-
 import java.io.IOException;
 import java.io.PrintWriter;
 
-/**
- * An HTTP servlets which outputs a {@code text/plain} {@code "pong"} response.
- */
+/** An HTTP servlets which outputs a {@code text/plain} {@code "pong"} response. */
 public class PingServlet extends HttpServlet {
-    private static final long serialVersionUID = 3772654177231086757L;
-    private static final String CONTENT_TYPE = "text/plain";
-    private static final String CONTENT = "pong";
-    private static final String CACHE_CONTROL = "Cache-Control";
-    private static final String NO_CACHE = "must-revalidate,no-cache,no-store";
+  private static final long serialVersionUID = 3772654177231086757L;
+  private static final String CONTENT_TYPE = "text/plain";
+  private static final String CONTENT = "pong";
+  private static final String CACHE_CONTROL = "Cache-Control";
+  private static final String NO_CACHE = "must-revalidate,no-cache,no-store";
 
-    @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
-        resp.setStatus(HttpServletResponse.SC_OK);
-        resp.setHeader(CACHE_CONTROL, NO_CACHE);
-        resp.setContentType(CONTENT_TYPE);
-        try (PrintWriter writer = resp.getWriter()) {
-            writer.println(CONTENT);
-        }
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    resp.setStatus(HttpServletResponse.SC_OK);
+    resp.setHeader(CACHE_CONTROL, NO_CACHE);
+    resp.setContentType(CONTENT_TYPE);
+    try (PrintWriter writer = resp.getWriter()) {
+      writer.println(CONTENT);
     }
+  }
 }
--- a/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/ThreadDumpServlet.java
+++ b/metrics-jakarta-servlets/src/main/java/io/dropwizard/metrics5/servlets/ThreadDumpServlet.java
@@ -5,51 +5,50 @@ import jakarta.servlet.ServletException;
 import jakarta.servlet.http.HttpServlet;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
-
 import java.io.IOException;
 import java.io.OutputStream;
 import java.lang.management.ManagementFactory;
 
 /**
- * An HTTP servlets which outputs a {@code text/plain} dump of all threads in
- * the VM. Only responds to {@code GET} requests.
+ * An HTTP servlets which outputs a {@code text/plain} dump of all threads in the VM. Only responds
+ * to {@code GET} requests.
  */
 public class ThreadDumpServlet extends HttpServlet {
 
-    private static final long serialVersionUID = -2690343532336103046L;
-    private static final String CONTENT_TYPE = "text/plain";
+  private static final long serialVersionUID = -2690343532336103046L;
+  private static final String CONTENT_TYPE = "text/plain";
 
-    private transient ThreadDump threadDump;
+  private transient ThreadDump threadDump;
 
-    @Override
-    public void init() throws ServletException {
-        try {
-            // Some PaaS like Google App Engine blacklist java.lang.managament
-            this.threadDump = new ThreadDump(ManagementFactory.getThreadMXBean());
-        } catch (NoClassDefFoundError ncdfe) {
-            this.threadDump = null; // we won't be able to provide thread dump
-        }
+  @Override
+  public void init() throws ServletException {
+    try {
+      // Some PaaS like Google App Engine blacklist java.lang.managament
+      this.threadDump = new ThreadDump(ManagementFactory.getThreadMXBean());
+    } catch (NoClassDefFoundError ncdfe) {
+      this.threadDump = null; // we won't be able to provide thread dump
     }
-
-    @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
-        final boolean includeMonitors = getParam(req.getParameter("monitors"), true);
-        final boolean includeSynchronizers = getParam(req.getParameter("synchronizers"), true);
-
-        resp.setStatus(HttpServletResponse.SC_OK);
-        resp.setContentType(CONTENT_TYPE);
-        resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
-        if (threadDump == null) {
-            resp.getWriter().println("Sorry your runtime environment does not allow to dump threads.");
-            return;
-        }
-        try (OutputStream output = resp.getOutputStream()) {
-            threadDump.dump(includeMonitors, includeSynchronizers, output);
-        }
+  }
+
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    final boolean includeMonitors = getParam(req.getParameter("monitors"), true);
+    final boolean includeSynchronizers = getParam(req.getParameter("synchronizers"), true);
+
+    resp.setStatus(HttpServletResponse.SC_OK);
+    resp.setContentType(CONTENT_TYPE);
+    resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
+    if (threadDump == null) {
+      resp.getWriter().println("Sorry your runtime environment does not allow to dump threads.");
+      return;
     }
-
-    private static Boolean getParam(String initParam, boolean defaultValue) {
-        return initParam == null ? defaultValue : Boolean.parseBoolean(initParam);
+    try (OutputStream output = resp.getOutputStream()) {
+      threadDump.dump(includeMonitors, includeSynchronizers, output);
     }
+  }
+
+  private static Boolean getParam(String initParam, boolean defaultValue) {
+    return initParam == null ? defaultValue : Boolean.parseBoolean(initParam);
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/AbstractServletTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/AbstractServletTest.java
@@ -6,24 +6,24 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 
 public abstract class AbstractServletTest {
-    private final ServletTester tester = new ServletTester();
-    protected final HttpTester.Request request = HttpTester.newRequest();
-    protected HttpTester.Response response;
+  private final ServletTester tester = new ServletTester();
+  protected final HttpTester.Request request = HttpTester.newRequest();
+  protected HttpTester.Response response;
 
-    @BeforeEach
-    public void setUpTester() throws Exception {
-        setUp(tester);
-        tester.start();
-    }
+  @BeforeEach
+  public void setUpTester() throws Exception {
+    setUp(tester);
+    tester.start();
+  }
 
-    protected abstract void setUp(ServletTester tester);
+  protected abstract void setUp(ServletTester tester);
 
-    @AfterEach
-    public void tearDownTester() throws Exception {
-        tester.stop();
-    }
+  @AfterEach
+  public void tearDownTester() throws Exception {
+    tester.stop();
+  }
 
-    protected void processRequest() throws Exception {
-        this.response = HttpTester.parseResponse(tester.getResponses(request.generate()));
-    }
+  protected void processRequest() throws Exception {
+    this.response = HttpTester.parseResponse(tester.getResponses(request.generate()));
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletExclusionTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletExclusionTest.java
@@ -1,60 +1,60 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.health.HealthCheckRegistry;
-import static org.assertj.core.api.Assertions.assertThat;
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-class AdminServletExclusionTest extends AbstractServletTest {
-    private final MetricRegistry registry = new MetricRegistry();
-    private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.setContextPath("/context");
-
-        tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
-        tester.setAttribute("io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
-        tester.setInitParameter("threads-enabled", "false");
-        tester.setInitParameter("cpu-profile-enabled", "false");
-        tester.addServlet(AdminServlet.class, "/admin");
-    }
-
-    @BeforeEach
-    void setUp() {
-        request.setMethod("GET");
-        request.setURI("/context/admin");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.getContent())
-                .isEqualTo(String.format(
-                        "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n" +
-                                "        \"http://www.w3.org/TR/html4/loose.dtd\">%n" +
-                                "<html>%n" +
-                                "<head>%n" +
-                                "  <title>Metrics</title>%n" +
-                                "</head>%n" +
-                                "<body>%n" +
-                                "  <h1>Operational Menu</h1>%n" +
-                                "  <ul>%n" +
-                                "    <li><a href=\"/context/admin/metrics?pretty=true\">Metrics</a></li>%n" +
-                                "    <li><a href=\"/context/admin/ping\">Ping</a></li>%n" +
-                                "    <li><a href=\"/context/admin/healthcheck?pretty=true\">Healthcheck</a></li>%n" +
-                                "  </ul>%n" +
-                                "</body>%n" +
-                                "</html>%n"
-                ));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/html;charset=UTF-8");
-    }
+final class AdminServletExclusionTest extends AbstractServletTest {
+  private final MetricRegistry registry = new MetricRegistry();
+  private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.setContextPath("/context");
+
+    tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
+    tester.setAttribute(
+        "io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
+    tester.setInitParameter("threads-enabled", "false");
+    tester.setInitParameter("cpu-profile-enabled", "false");
+    tester.addServlet(AdminServlet.class, "/admin");
+  }
+
+  @BeforeEach
+  void setUp() {
+    request.setMethod("GET");
+    request.setURI("/context/admin");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n"
+                    + "        \"http://www.w3.org/TR/html4/loose.dtd\">%n"
+                    + "<html>%n"
+                    + "<head>%n"
+                    + "  <title>Metrics</title>%n"
+                    + "</head>%n"
+                    + "<body>%n"
+                    + "  <h1>Operational Menu</h1>%n"
+                    + "  <ul>%n"
+                    + "    <li><a href=\"/context/admin/metrics?pretty=true\">Metrics</a></li>%n"
+                    + "    <li><a href=\"/context/admin/ping\">Ping</a></li>%n"
+                    + "    <li><a href=\"/context/admin/healthcheck?pretty=true\">Healthcheck</a></li>%n"
+                    + "  </ul>%n"
+                    + "</body>%n"
+                    + "</html>%n"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/html;charset=UTF-8");
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletTest.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.health.HealthCheckRegistry;
 import org.eclipse.jetty.http.HttpHeader;
@@ -7,56 +9,53 @@ import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class AdminServletTest extends AbstractServletTest {
-    private final MetricRegistry registry = new MetricRegistry();
-    private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.setContextPath("/context");
-
-        tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
-        tester.setAttribute("io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
-        tester.addServlet(AdminServlet.class, "/admin");
-    }
-
-    @BeforeEach
-    void setUp() {
-        request.setMethod("GET");
-        request.setURI("/context/admin");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.getContent())
-                .isEqualTo(String.format(
-                        "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n" +
-                                "        \"http://www.w3.org/TR/html4/loose.dtd\">%n" +
-                                "<html>%n" +
-                                "<head>%n" +
-                                "  <title>Metrics</title>%n" +
-                                "</head>%n" +
-                                "<body>%n" +
-                                "  <h1>Operational Menu</h1>%n" +
-                                "  <ul>%n" +
-                                "    <li><a href=\"/context/admin/metrics?pretty=true\">Metrics</a></li>%n" +
-                                "    <li><a href=\"/context/admin/ping\">Ping</a></li>%n" +
-                                "    <li><a href=\"/context/admin/threads\">Threads</a></li>%n" +
-                                "    <li><a href=\"/context/admin/healthcheck?pretty=true\">Healthcheck</a></li>%n" +
-                                "    <li><a href=\"/context/admin/pprof\">CPU Profile</a></li>%n" +
-                                "    <li><a href=\"/context/admin/pprof?state=blocked\">CPU Contention</a></li>%n" +
-                                "  </ul>%n" +
-                                "</body>%n" +
-                                "</html>%n"
-                ));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/html;charset=UTF-8");
-    }
+final class AdminServletTest extends AbstractServletTest {
+  private final MetricRegistry registry = new MetricRegistry();
+  private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.setContextPath("/context");
+
+    tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
+    tester.setAttribute(
+        "io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
+    tester.addServlet(AdminServlet.class, "/admin");
+  }
+
+  @BeforeEach
+  void setUp() {
+    request.setMethod("GET");
+    request.setURI("/context/admin");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n"
+                    + "        \"http://www.w3.org/TR/html4/loose.dtd\">%n"
+                    + "<html>%n"
+                    + "<head>%n"
+                    + "  <title>Metrics</title>%n"
+                    + "</head>%n"
+                    + "<body>%n"
+                    + "  <h1>Operational Menu</h1>%n"
+                    + "  <ul>%n"
+                    + "    <li><a href=\"/context/admin/metrics?pretty=true\">Metrics</a></li>%n"
+                    + "    <li><a href=\"/context/admin/ping\">Ping</a></li>%n"
+                    + "    <li><a href=\"/context/admin/threads\">Threads</a></li>%n"
+                    + "    <li><a href=\"/context/admin/healthcheck?pretty=true\">Healthcheck</a></li>%n"
+                    + "    <li><a href=\"/context/admin/pprof\">CPU Profile</a></li>%n"
+                    + "    <li><a href=\"/context/admin/pprof?state=blocked\">CPU Contention</a></li>%n"
+                    + "  </ul>%n"
+                    + "</body>%n"
+                    + "</html>%n"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/html;charset=UTF-8");
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletUriTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletUriTest.java
@@ -1,66 +1,66 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.health.HealthCheckRegistry;
-import static org.assertj.core.api.Assertions.assertThat;
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-class AdminServletUriTest extends AbstractServletTest {
-    private final MetricRegistry registry = new MetricRegistry();
-    private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
+final class AdminServletUriTest extends AbstractServletTest {
+  private final MetricRegistry registry = new MetricRegistry();
+  private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
 
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.setContextPath("/context");
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.setContextPath("/context");
 
-        tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
-        tester.setAttribute("io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
-        tester.setInitParameter("metrics-uri", "/metrics-test");
-        tester.setInitParameter("ping-uri", "/ping-test");
-        tester.setInitParameter("threads-uri", "/threads-test");
-        tester.setInitParameter("healthcheck-uri", "/healthcheck-test");
-        tester.setInitParameter("cpu-profile-uri", "/pprof-test");
-        tester.addServlet(AdminServlet.class, "/admin");
-    }
+    tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
+    tester.setAttribute(
+        "io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
+    tester.setInitParameter("metrics-uri", "/metrics-test");
+    tester.setInitParameter("ping-uri", "/ping-test");
+    tester.setInitParameter("threads-uri", "/threads-test");
+    tester.setInitParameter("healthcheck-uri", "/healthcheck-test");
+    tester.setInitParameter("cpu-profile-uri", "/pprof-test");
+    tester.addServlet(AdminServlet.class, "/admin");
+  }
 
-    @BeforeEach
-    void setUp() {
-        request.setMethod("GET");
-        request.setURI("/context/admin");
-        request.setVersion("HTTP/1.0");
-    }
+  @BeforeEach
+  void setUp() {
+    request.setMethod("GET");
+    request.setURI("/context/admin");
+    request.setVersion("HTTP/1.0");
+  }
 
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
 
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.getContent())
-                .isEqualTo(String.format(
-                        "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n" +
-                                "        \"http://www.w3.org/TR/html4/loose.dtd\">%n" +
-                                "<html>%n" +
-                                "<head>%n" +
-                                "  <title>Metrics</title>%n" +
-                                "</head>%n" +
-                                "<body>%n" +
-                                "  <h1>Operational Menu</h1>%n" +
-                                "  <ul>%n" +
-                                "    <li><a href=\"/context/admin/metrics-test?pretty=true\">Metrics</a></li>%n" +
-                                "    <li><a href=\"/context/admin/ping-test\">Ping</a></li>%n" +
-                                "    <li><a href=\"/context/admin/threads-test\">Threads</a></li>%n" +
-                                "    <li><a href=\"/context/admin/healthcheck-test?pretty=true\">Healthcheck</a></li>%n" +
-                                "    <li><a href=\"/context/admin/pprof-test\">CPU Profile</a></li>%n" +
-                                "    <li><a href=\"/context/admin/pprof-test?state=blocked\">CPU Contention</a></li>%n" +
-                                "  </ul>%n" +
-                                "</body>%n" +
-                                "</html>%n"
-                ));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/html;charset=UTF-8");
-    }
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n"
+                    + "        \"http://www.w3.org/TR/html4/loose.dtd\">%n"
+                    + "<html>%n"
+                    + "<head>%n"
+                    + "  <title>Metrics</title>%n"
+                    + "</head>%n"
+                    + "<body>%n"
+                    + "  <h1>Operational Menu</h1>%n"
+                    + "  <ul>%n"
+                    + "    <li><a href=\"/context/admin/metrics-test?pretty=true\">Metrics</a></li>%n"
+                    + "    <li><a href=\"/context/admin/ping-test\">Ping</a></li>%n"
+                    + "    <li><a href=\"/context/admin/threads-test\">Threads</a></li>%n"
+                    + "    <li><a href=\"/context/admin/healthcheck-test?pretty=true\">Healthcheck</a></li>%n"
+                    + "    <li><a href=\"/context/admin/pprof-test\">CPU Profile</a></li>%n"
+                    + "    <li><a href=\"/context/admin/pprof-test?state=blocked\">CPU Contention</a></li>%n"
+                    + "  </ul>%n"
+                    + "</body>%n"
+                    + "</html>%n"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/html;charset=UTF-8");
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/CpuProfileServletTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/CpuProfileServletTest.java
@@ -1,44 +1,41 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class CpuProfileServletTest extends AbstractServletTest {
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.addServlet(CpuProfileServlet.class, "/pprof");
-    }
-
-    @BeforeEach
-    void setUp() throws Exception {
-        request.setMethod("GET");
-        request.setURI("/pprof?duration=1");
-        request.setVersion("HTTP/1.0");
-
-        processRequest();
-    }
-
-    @Test
-    void returns200OK() {
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-    }
-
-    @Test
-    void returnsPprofRaw() {
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("pprof/raw");
-    }
-
-    @Test
-    void returnsUncacheable() {
-        assertThat(response.get(HttpHeader.CACHE_CONTROL))
-                .isEqualTo("must-revalidate,no-cache,no-store");
-
-    }
+final class CpuProfileServletTest extends AbstractServletTest {
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.addServlet(CpuProfileServlet.class, "/pprof");
+  }
+
+  @BeforeEach
+  void setUp() throws Exception {
+    request.setMethod("GET");
+    request.setURI("/pprof?duration=1");
+    request.setVersion("HTTP/1.0");
+
+    processRequest();
+  }
+
+  @Test
+  void returns200OK() {
+    assertThat(response.getStatus()).isEqualTo(200);
+  }
+
+  @Test
+  void returnsPprofRaw() {
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("pprof/raw");
+  }
+
+  @Test
+  void returnsUncacheable() {
+    assertThat(response.get(HttpHeader.CACHE_CONTROL))
+        .isEqualTo("must-revalidate,no-cache,no-store");
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/HealthCheckServletTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/HealthCheckServletTest.java
@@ -1,5 +1,12 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.fasterxml.jackson.databind.ObjectMapper;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.health.HealthCheck;
@@ -8,251 +15,255 @@ import io.dropwizard.metrics5.health.HealthCheckRegistry;
 import jakarta.servlet.ServletConfig;
 import jakarta.servlet.ServletContext;
 import jakarta.servlet.ServletException;
-import org.eclipse.jetty.http.HttpHeader;
-import org.eclipse.jetty.servlet.ServletTester;
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import org.eclipse.jetty.http.HttpHeader;
+import org.eclipse.jetty.servlet.ServletTester;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-class HealthCheckServletTest extends AbstractServletTest {
+final class HealthCheckServletTest extends AbstractServletTest {
 
-    private static final ZonedDateTime FIXED_TIME = ZonedDateTime.now();
+  private static final ZonedDateTime FIXED_TIME = ZonedDateTime.now();
 
-    private static final DateTimeFormatter DATE_TIME_FORMATTER =
-            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
+  private static final DateTimeFormatter DATE_TIME_FORMATTER =
+      DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
 
-    private static final String EXPECTED_TIMESTAMP = DATE_TIME_FORMATTER.format(FIXED_TIME);
+  private static final String EXPECTED_TIMESTAMP = DATE_TIME_FORMATTER.format(FIXED_TIME);
 
-    private static final Clock FIXED_CLOCK = new Clock() {
+  private static final Clock FIXED_CLOCK =
+      new Clock() {
         @Override
         public long getTick() {
-            return 0L;
+          return 0L;
         }
 
         @Override
         public long getTime() {
-            return FIXED_TIME.toInstant().toEpochMilli();
+          return FIXED_TIME.toInstant().toEpochMilli();
         }
-    };
-
-    private final HealthCheckRegistry registry = new HealthCheckRegistry();
-    private final ExecutorService threadPool = Executors.newCachedThreadPool();
-    private final ObjectMapper mapper = new ObjectMapper();
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.addServlet(HealthCheckServlet.class, "/healthchecks");
-        tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".registry", registry);
-        tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".executor", threadPool);
-        tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".mapper", mapper);
-        tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".healthCheckFilter",
-                (HealthCheckFilter) (name, healthCheck) -> !"filtered".equals(name));
-    }
-
-    @BeforeEach
-    void setUp() {
-        request.setMethod("GET");
-        request.setURI("/healthchecks");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @AfterEach
-    void tearDown() {
-        threadPool.shutdown();
-    }
-
-    @Test
-    void returns501IfNoHealthChecksAreRegistered() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(501);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent()).isEqualTo("{}");
-    }
-
-    @Test
-    void returnsA200IfAllHealthChecksAreHealthy() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent())
-                .isEqualTo("{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" +
-                        EXPECTED_TIMESTAMP +
-                        "\"}}");
-    }
-
-    @Test
-    void returnsASubsetOfHealthChecksIfFiltered() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
-        registry.register("filtered", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent())
-                .isEqualTo("{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" +
-                        EXPECTED_TIMESTAMP +
-                        "\"}}");
-    }
-
-    @Test
-    void returnsA500IfAnyHealthChecksAreUnhealthy() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
-        registry.register("notFun", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(500);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent()).contains(
-                "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" + EXPECTED_TIMESTAMP + "\"}",
-                ",\"notFun\":{\"healthy\":false,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" + EXPECTED_TIMESTAMP + "\"}}");
-    }
-
-    @Test
-    void returnsA200IfAnyHealthChecksAreUnhealthyAndHttpStatusIndicatorIsDisabled() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
-        registry.register("notFun", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
-        request.setURI("/healthchecks?httpStatusIndicator=false");
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent()).contains(
-                "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" + EXPECTED_TIMESTAMP + "\"}",
-                ",\"notFun\":{\"healthy\":false,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" + EXPECTED_TIMESTAMP + "\"}}");
-    }
-
-    @Test
-    void optionallyPrettyPrintsTheJson() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("foo bar 123")));
-
-        request.setURI("/healthchecks?pretty=true");
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent())
-                .isEqualTo(String.format("{%n" +
-                        "  \"fun\" : {%n" +
-                        "    \"healthy\" : true,%n" +
-                        "    \"message\" : \"foo bar 123\",%n" +
-                        "    \"duration\" : 0,%n" +
-                        "    \"timestamp\" : \"" + EXPECTED_TIMESTAMP + "\"" +
-                        "%n  }%n}"));
-    }
-
-    private static HealthCheck.Result healthyResultWithMessage(String message) {
-        return HealthCheck.Result.builder()
-                .healthy()
-                .withMessage(message)
-                .usingClock(FIXED_CLOCK)
-                .build();
-    }
-
-    private static HealthCheck.Result unhealthyResultWithMessage(String message) {
-        return HealthCheck.Result.builder()
-                .unhealthy()
-                .withMessage(message)
-                .usingClock(FIXED_CLOCK)
-                .build();
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentIsUsedInPreferenceOverServletConfig() throws Exception {
-        final HealthCheckRegistry healthCheckRegistry = mock(HealthCheckRegistry.class);
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-
-        final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(healthCheckRegistry);
-        healthCheckServlet.init(servletConfig);
-
-        verify(servletConfig, times(1)).getServletContext();
-        verify(servletContext, never()).getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY);
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentUsesServletConfigWhenNull() throws Exception {
-        final HealthCheckRegistry healthCheckRegistry = mock(HealthCheckRegistry.class);
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-        when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
-                .thenReturn(healthCheckRegistry);
-
-        final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
-        healthCheckServlet.init(servletConfig);
-
-        verify(servletConfig, times(1)).getServletContext();
-        verify(servletContext, times(1)).getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY);
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentUsesServletConfigWhenNullButWrongTypeInContext() throws Exception {
-        assertThrows(ServletException.class, () -> {
-            final ServletContext servletContext = mock(ServletContext.class);
-            final ServletConfig servletConfig = mock(ServletConfig.class);
-            when(servletConfig.getServletContext()).thenReturn(servletContext);
-            when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
-                    .thenReturn("IRELLEVANT_STRING");
-
-            final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
-            healthCheckServlet.init(servletConfig);
-        });
+      };
+
+  private final HealthCheckRegistry registry = new HealthCheckRegistry();
+  private final ExecutorService threadPool = Executors.newCachedThreadPool();
+  private final ObjectMapper mapper = new ObjectMapper();
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.addServlet(HealthCheckServlet.class, "/healthchecks");
+    tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".registry", registry);
+    tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".executor", threadPool);
+    tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".mapper", mapper);
+    tester.setAttribute(
+        HealthCheckServlet.class.getCanonicalName() + ".healthCheckFilter",
+        (HealthCheckFilter) (name, healthCheck) -> !"filtered".equals(name));
+  }
+
+  @BeforeEach
+  void setUp() {
+    request.setMethod("GET");
+    request.setURI("/healthchecks");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @AfterEach
+  void tearDown() {
+    threadPool.shutdown();
+  }
+
+  @Test
+  void returns501IfNoHealthChecksAreRegistered() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(501);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent()).isEqualTo("{}");
+  }
+
+  @Test
+  void returnsA200IfAllHealthChecksAreHealthy() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"%s\"}}",
+            EXPECTED_TIMESTAMP);
+  }
+
+  @Test
+  void returnsASubsetOfHealthChecksIfFiltered() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
+    registry.register("filtered", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"%s\"}}",
+            EXPECTED_TIMESTAMP);
+  }
+
+  @Test
+  void returnsA500IfAnyHealthChecksAreUnhealthy() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
+    registry.register("notFun", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(500);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .contains(
+            "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\""
+                + EXPECTED_TIMESTAMP
+                + "\"}",
+            ",\"notFun\":{\"healthy\":false,\"message\":\"whee\",\"duration\":0,\"timestamp\":\""
+                + EXPECTED_TIMESTAMP
+                + "\"}}");
+  }
+
+  @Test
+  void returnsA200IfAnyHealthChecksAreUnhealthyAndHttpStatusIndicatorIsDisabled() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
+    registry.register("notFun", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
+    request.setURI("/healthchecks?httpStatusIndicator=false");
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .contains(
+            "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\""
+                + EXPECTED_TIMESTAMP
+                + "\"}",
+            ",\"notFun\":{\"healthy\":false,\"message\":\"whee\",\"duration\":0,\"timestamp\":\""
+                + EXPECTED_TIMESTAMP
+                + "\"}}");
+  }
+
+  @Test
+  void optionallyPrettyPrintsTheJson() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("foo bar 123")));
+
+    request.setURI("/healthchecks?pretty=true");
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "{%n  \"fun\" : {%n    \"healthy\" : true,%n    \"message\" : \"foo bar 123\",%n    \"duration\" : 0,%n    \"timestamp\" : \"%s\"%n  }%n}",
+                EXPECTED_TIMESTAMP));
+  }
+
+  private static HealthCheck.Result healthyResultWithMessage(String message) {
+    return HealthCheck.Result.builder()
+        .healthy()
+        .withMessage(message)
+        .usingClock(FIXED_CLOCK)
+        .build();
+  }
+
+  private static HealthCheck.Result unhealthyResultWithMessage(String message) {
+    return HealthCheck.Result.builder()
+        .unhealthy()
+        .withMessage(message)
+        .usingClock(FIXED_CLOCK)
+        .build();
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentIsUsedInPreferenceOverServletConfig() throws Exception {
+    final HealthCheckRegistry healthCheckRegistry = mock();
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+
+    final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(healthCheckRegistry);
+    healthCheckServlet.init(servletConfig);
+
+    verify(servletConfig).getServletContext();
+    verify(servletContext, never()).getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY);
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentUsesServletConfigWhenNull() throws Exception {
+    final HealthCheckRegistry healthCheckRegistry = mock();
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+    when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
+        .thenReturn(healthCheckRegistry);
+
+    final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
+    healthCheckServlet.init(servletConfig);
+
+    verify(servletConfig).getServletContext();
+    verify(servletContext).getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY);
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentUsesServletConfigWhenNullButWrongTypeInContext()
+      throws Exception {
+    assertThatThrownBy(
+            () -> {
+              final ServletContext servletContext = mock();
+              final ServletConfig servletConfig = mock();
+              when(servletConfig.getServletContext()).thenReturn(servletContext);
+              when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
+                  .thenReturn("IRELLEVANT_STRING");
+
+              final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
+              healthCheckServlet.init(servletConfig);
+            })
+        .isInstanceOf(ServletException.class);
+  }
+
+  @Test
+  void constructorWithObjectMapperAsArgumentUsesServletConfigWhenNullButWrongTypeInContext()
+      throws Exception {
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+    when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
+        .thenReturn(registry);
+    when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_MAPPER))
+        .thenReturn("IRELLEVANT_STRING");
+
+    final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
+    healthCheckServlet.init(servletConfig);
+
+    assertThat(healthCheckServlet.getMapper()).isNotNull().isInstanceOf(ObjectMapper.class);
+  }
+
+  static class TestHealthCheck implements HealthCheck {
+    private final Callable<Result> check;
+
+    public TestHealthCheck(Callable<Result> check) {
+      this.check = check;
     }
 
-    @Test
-    void constructorWithObjectMapperAsArgumentUsesServletConfigWhenNullButWrongTypeInContext() throws Exception {
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-        when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY)).thenReturn(registry);
-        when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_MAPPER)).thenReturn("IRELLEVANT_STRING");
-
-        final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
-        healthCheckServlet.init(servletConfig);
-
-        assertThat(healthCheckServlet.getMapper())
-                .isNotNull()
-                .isInstanceOf(ObjectMapper.class);
+    @Override
+    public Result check() throws Exception {
+      return check.call();
     }
 
-    static class TestHealthCheck implements HealthCheck {
-        private final Callable<Result> check;
-
-        public TestHealthCheck(Callable<Result> check) {
-            this.check = check;
-        }
-
-        @Override
-        public Result check() throws Exception {
-            return check.call();
-        }
-
-        @Override
-        public Clock clock() {
-            return FIXED_CLOCK;
-        }
+    @Override
+    public Clock clock() {
+      return FIXED_CLOCK;
     }
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/MetricsServletContextListenerTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/MetricsServletContextListenerTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.ExponentiallyDecayingReservoir;
 import io.dropwizard.metrics5.Gauge;
@@ -7,166 +11,163 @@ import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.util.concurrent.TimeUnit;
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-class MetricsServletContextListenerTest extends AbstractServletTest {
-    private final Clock clock = mock(Clock.class);
-    private final MetricRegistry registry = new MetricRegistry();
-    private final String allowedOrigin = "some.other.origin";
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.setAttribute(MetricsServlet.class.getCanonicalName() + ".registry", registry);
-        tester.addServlet(MetricsServlet.class, "/metrics");
-        tester.getContext().addEventListener(new MetricsServlet.ContextListener() {
-            @Override
-            protected MetricRegistry getMetricRegistry() {
+final class MetricsServletContextListenerTest extends AbstractServletTest {
+  private final Clock clock = mock();
+  private final MetricRegistry registry = new MetricRegistry();
+  private final String allowedOrigin = "some.other.origin";
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.setAttribute(MetricsServlet.class.getCanonicalName() + ".registry", registry);
+    tester.addServlet(MetricsServlet.class, "/metrics");
+    tester
+        .getContext()
+        .addEventListener(
+            new MetricsServlet.ContextListener() {
+              @Override
+              protected MetricRegistry getMetricRegistry() {
                 return registry;
-            }
+              }
 
-            @Override
-            protected TimeUnit getDurationUnit() {
+              @Override
+              protected TimeUnit getDurationUnit() {
                 return TimeUnit.MILLISECONDS;
-            }
+              }
 
-            @Override
-            protected TimeUnit getRateUnit() {
+              @Override
+              protected TimeUnit getRateUnit() {
                 return TimeUnit.MINUTES;
-            }
+              }
 
-            @Override
-            protected String getAllowedOrigin() {
+              @Override
+              protected String getAllowedOrigin() {
                 return allowedOrigin;
-            }
-        });
-    }
-
-    @BeforeEach
-    void setUp() {
-        // provide ticks for the setup (calls getTick 6 times). The serialization in the tests themselves
-        // will call getTick again several times and always get the same value (the last specified here)
-        when(clock.getTick()).thenReturn(100L, 100L, 200L, 300L, 300L, 400L);
-
-        registry.register(MetricName.build("g1"), (Gauge<Long>) () -> 100L);
-        registry.counter("c").inc();
-        registry.histogram("h").update(1);
-        registry.register(MetricName.build("m"), new Meter(clock)).mark();
-        registry.register(MetricName.build("t"), new Timer(new ExponentiallyDecayingReservoir(), clock))
-                .update(1, TimeUnit.SECONDS);
-
-        request.setMethod("GET");
-        request.setURI("/metrics");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo(allowedOrigin);
-        assertThat(response.getContent())
-                .isEqualTo("{" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{" +
-                        "\"g1\":{\"value\":100}" +
-                        "}," +
-                        "\"counters\":{" +
-                        "\"c\":{\"count\":1}" +
-                        "}," +
-                        "\"histograms\":{" +
-                        "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}" +
-                        "}," +
-                        "\"meters\":{" +
-                        "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":2.0E8,\"units\":\"events/minute\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1000.0,\"mean\":1000.0,\"min\":1000.0,\"p50\":1000.0,\"p75\":1000.0,\"p95\":1000.0,\"p98\":1000.0,\"p99\":1000.0,\"p999\":1000.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":6.0E8,\"duration_units\":\"milliseconds\",\"rate_units\":\"calls/minute\"}" +
-                        "}" +
-                        "}");
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void optionallyPrettyPrintsTheJson() throws Exception {
-        request.setURI("/metrics?pretty=true");
-
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo(allowedOrigin);
-        assertThat(response.getContent())
-                .isEqualTo(String.format("{%n" +
-                        "  \"version\" : \"5.0.0\",%n" +
-                        "  \"gauges\" : {%n" +
-                        "    \"g1\" : {%n" +
-                        "      \"value\" : 100%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"counters\" : {%n" +
-                        "    \"c\" : {%n" +
-                        "      \"count\" : 1%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"histograms\" : {%n" +
-                        "    \"h\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"max\" : 1,%n" +
-                        "      \"mean\" : 1.0,%n" +
-                        "      \"min\" : 1,%n" +
-                        "      \"p50\" : 1.0,%n" +
-                        "      \"p75\" : 1.0,%n" +
-                        "      \"p95\" : 1.0,%n" +
-                        "      \"p98\" : 1.0,%n" +
-                        "      \"p99\" : 1.0,%n" +
-                        "      \"p999\" : 1.0,%n" +
-                        "      \"stddev\" : 0.0%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"meters\" : {%n" +
-                        "    \"m\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"m15_rate\" : 0.0,%n" +
-                        "      \"m1_rate\" : 0.0,%n" +
-                        "      \"m5_rate\" : 0.0,%n" +
-                        "      \"mean_rate\" : 2.0E8,%n" +
-                        "      \"units\" : \"events/minute\"%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"timers\" : {%n" +
-                        "    \"t\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"max\" : 1000.0,%n" +
-                        "      \"mean\" : 1000.0,%n" +
-                        "      \"min\" : 1000.0,%n" +
-                        "      \"p50\" : 1000.0,%n" +
-                        "      \"p75\" : 1000.0,%n" +
-                        "      \"p95\" : 1000.0,%n" +
-                        "      \"p98\" : 1000.0,%n" +
-                        "      \"p99\" : 1000.0,%n" +
-                        "      \"p999\" : 1000.0,%n" +
-                        "      \"stddev\" : 0.0,%n" +
-                        "      \"m15_rate\" : 0.0,%n" +
-                        "      \"m1_rate\" : 0.0,%n" +
-                        "      \"m5_rate\" : 0.0,%n" +
-                        "      \"mean_rate\" : 6.0E8,%n" +
-                        "      \"duration_units\" : \"milliseconds\",%n" +
-                        "      \"rate_units\" : \"calls/minute\"%n" +
-                        "    }%n" +
-                        "  }%n" +
-                        "}"));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
+              }
+            });
+  }
+
+  @BeforeEach
+  void setUp() {
+    // provide ticks for the setup (calls getTick 6 times). The serialization in the tests
+    // themselves
+    // will call getTick again several times and always get the same value (the last specified here)
+    when(clock.getTick()).thenReturn(100L, 100L, 200L, 300L, 300L, 400L);
+
+    registry.register(MetricName.build("g1"), (Gauge<Long>) () -> 100L);
+    registry.counter("c").inc();
+    registry.histogram("h").update(1);
+    registry.register(MetricName.build("m"), new Meter(clock)).mark();
+    registry
+        .register(MetricName.build("t"), new Timer(new ExponentiallyDecayingReservoir(), clock))
+        .update(1, TimeUnit.SECONDS);
+
+    request.setMethod("GET");
+    request.setURI("/metrics");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo(allowedOrigin);
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{"
+                + "\"version\":\"5.0.0\","
+                + "\"gauges\":{"
+                + "\"g1\":{\"value\":100}"
+                + "},"
+                + "\"counters\":{"
+                + "\"c\":{\"count\":1}"
+                + "},"
+                + "\"histograms\":{"
+                + "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}"
+                + "},"
+                + "\"meters\":{"
+                + "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":2.0E8,\"units\":\"events/minute\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1000.0,\"mean\":1000.0,\"min\":1000.0,\"p50\":1000.0,\"p75\":1000.0,\"p95\":1000.0,\"p98\":1000.0,\"p99\":1000.0,\"p999\":1000.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":6.0E8,\"duration_units\":\"milliseconds\",\"rate_units\":\"calls/minute\"}"
+                + "}"
+                + "}");
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void optionallyPrettyPrintsTheJson() throws Exception {
+    request.setURI("/metrics?pretty=true");
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo(allowedOrigin);
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "{%n"
+                    + "  \"version\" : \"5.0.0\",%n"
+                    + "  \"gauges\" : {%n"
+                    + "    \"g1\" : {%n"
+                    + "      \"value\" : 100%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"counters\" : {%n"
+                    + "    \"c\" : {%n"
+                    + "      \"count\" : 1%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"histograms\" : {%n"
+                    + "    \"h\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"max\" : 1,%n"
+                    + "      \"mean\" : 1.0,%n"
+                    + "      \"min\" : 1,%n"
+                    + "      \"p50\" : 1.0,%n"
+                    + "      \"p75\" : 1.0,%n"
+                    + "      \"p95\" : 1.0,%n"
+                    + "      \"p98\" : 1.0,%n"
+                    + "      \"p99\" : 1.0,%n"
+                    + "      \"p999\" : 1.0,%n"
+                    + "      \"stddev\" : 0.0%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"meters\" : {%n"
+                    + "    \"m\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"m15_rate\" : 0.0,%n"
+                    + "      \"m1_rate\" : 0.0,%n"
+                    + "      \"m5_rate\" : 0.0,%n"
+                    + "      \"mean_rate\" : 2.0E8,%n"
+                    + "      \"units\" : \"events/minute\"%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"timers\" : {%n"
+                    + "    \"t\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"max\" : 1000.0,%n"
+                    + "      \"mean\" : 1000.0,%n"
+                    + "      \"min\" : 1000.0,%n"
+                    + "      \"p50\" : 1000.0,%n"
+                    + "      \"p75\" : 1000.0,%n"
+                    + "      \"p95\" : 1000.0,%n"
+                    + "      \"p98\" : 1000.0,%n"
+                    + "      \"p99\" : 1000.0,%n"
+                    + "      \"p999\" : 1000.0,%n"
+                    + "      \"stddev\" : 0.0,%n"
+                    + "      \"m15_rate\" : 0.0,%n"
+                    + "      \"m1_rate\" : 0.0,%n"
+                    + "      \"m5_rate\" : 0.0,%n"
+                    + "      \"mean_rate\" : 6.0E8,%n"
+                    + "      \"duration_units\" : \"milliseconds\",%n"
+                    + "      \"rate_units\" : \"calls/minute\"%n"
+                    + "    }%n"
+                    + "  }%n"
+                    + "}"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/MetricsServletTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/MetricsServletTest.java
@@ -1,5 +1,12 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.ExponentiallyDecayingReservoir;
 import io.dropwizard.metrics5.Gauge;
@@ -10,258 +17,238 @@ import io.dropwizard.metrics5.Timer;
 import jakarta.servlet.ServletConfig;
 import jakarta.servlet.ServletContext;
 import jakarta.servlet.ServletException;
+import java.util.concurrent.TimeUnit;
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-class MetricsServletTest extends AbstractServletTest {
-    private final Clock clock = mock(Clock.class);
-    private final MetricRegistry registry = new MetricRegistry();
-    private ServletTester tester;
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        this.tester = tester;
-        tester.setAttribute(MetricsServlet.class.getCanonicalName() + ".registry", registry);
-        tester.addServlet(MetricsServlet.class, "/metrics");
-        tester.getContext().setInitParameter(MetricsServlet.class.getCanonicalName() + ".allowedOrigin", "*");
-    }
-
-    @BeforeEach
-    void setUp() {
-        // provide ticks for the setup (calls getTick 6 times). The serialization in the tests themselves
-        // will call getTick again several times and always get the same value (the last specified here)
-        when(clock.getTick()).thenReturn(100L, 100L, 200L, 300L, 300L, 400L);
-
-        registry.register(MetricName.build("g1"), (Gauge<Long>) () -> 100L);
-        registry.counter("c").inc();
-        registry.histogram("h").update(1);
-        registry.register(MetricName.build("m"), new Meter(clock)).mark();
-        registry.register(MetricName.build("t"), new Timer(new ExponentiallyDecayingReservoir(), clock))
-                .update(1, TimeUnit.SECONDS);
-
-        request.setMethod("GET");
-        request.setURI("/metrics");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo("*");
-        assertThat(response.getContent())
-                .isEqualTo("{" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{" +
-                        "\"g1\":{\"value\":100}" +
-                        "}," +
-                        "\"counters\":{" +
-                        "\"c\":{\"count\":1}" +
-                        "}," +
-                        "\"histograms\":{" +
-                        "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}" +
-                        "}," +
-                        "\"meters\":{" +
-                        "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}" +
-                        "}" +
-                        "}");
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void returnsJsonWhenJsonpInitParamNotSet() throws Exception {
-        String callbackParamName = "callbackParam";
-        String callbackParamVal = "callbackParamVal";
-        request.setURI("/metrics?" + callbackParamName + "=" + callbackParamVal);
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo("*");
-        assertThat(response.getContent())
-                .isEqualTo("{" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{" +
-                        "\"g1\":{\"value\":100}" +
-                        "}," +
-                        "\"counters\":{" +
-                        "\"c\":{\"count\":1}" +
-                        "}," +
-                        "\"histograms\":{" +
-                        "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}" +
-                        "}," +
-                        "\"meters\":{" +
-                        "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}" +
-                        "}" +
-                        "}");
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void returnsJsonpWhenInitParamSet() throws Exception {
-        String callbackParamName = "callbackParam";
-        String callbackParamVal = "callbackParamVal";
-        request.setURI("/metrics?" + callbackParamName + "=" + callbackParamVal);
-        tester.getContext().setInitParameter(MetricsServlet.class.getCanonicalName() + ".jsonpCallback", callbackParamName);
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo("*");
-        assertThat(response.getContent())
-                .isEqualTo(callbackParamVal + "({" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{" +
-                        "\"g1\":{\"value\":100}" +
-                        "}," +
-                        "\"counters\":{" +
-                        "\"c\":{\"count\":1}" +
-                        "}," +
-                        "\"histograms\":{" +
-                        "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}" +
-                        "}," +
-                        "\"meters\":{" +
-                        "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}" +
-                        "}" +
-                        "})");
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void optionallyPrettyPrintsTheJson() throws Exception {
-        request.setURI("/metrics?pretty=true");
-
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo("*");
-        assertThat(response.getContent())
-                .isEqualTo(String.format("{%n" +
-                        "  \"version\" : \"5.0.0\",%n" +
-                        "  \"gauges\" : {%n" +
-                        "    \"g1\" : {%n" +
-                        "      \"value\" : 100%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"counters\" : {%n" +
-                        "    \"c\" : {%n" +
-                        "      \"count\" : 1%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"histograms\" : {%n" +
-                        "    \"h\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"max\" : 1,%n" +
-                        "      \"mean\" : 1.0,%n" +
-                        "      \"min\" : 1,%n" +
-                        "      \"p50\" : 1.0,%n" +
-                        "      \"p75\" : 1.0,%n" +
-                        "      \"p95\" : 1.0,%n" +
-                        "      \"p98\" : 1.0,%n" +
-                        "      \"p99\" : 1.0,%n" +
-                        "      \"p999\" : 1.0,%n" +
-                        "      \"stddev\" : 0.0%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"meters\" : {%n" +
-                        "    \"m\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"m15_rate\" : 0.0,%n" +
-                        "      \"m1_rate\" : 0.0,%n" +
-                        "      \"m5_rate\" : 0.0,%n" +
-                        "      \"mean_rate\" : 3333333.3333333335,%n" +
-                        "      \"units\" : \"events/second\"%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"timers\" : {%n" +
-                        "    \"t\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"max\" : 1.0,%n" +
-                        "      \"mean\" : 1.0,%n" +
-                        "      \"min\" : 1.0,%n" +
-                        "      \"p50\" : 1.0,%n" +
-                        "      \"p75\" : 1.0,%n" +
-                        "      \"p95\" : 1.0,%n" +
-                        "      \"p98\" : 1.0,%n" +
-                        "      \"p99\" : 1.0,%n" +
-                        "      \"p999\" : 1.0,%n" +
-                        "      \"stddev\" : 0.0,%n" +
-                        "      \"m15_rate\" : 0.0,%n" +
-                        "      \"m1_rate\" : 0.0,%n" +
-                        "      \"m5_rate\" : 0.0,%n" +
-                        "      \"mean_rate\" : 1.0E7,%n" +
-                        "      \"duration_units\" : \"seconds\",%n" +
-                        "      \"rate_units\" : \"calls/second\"%n" +
-                        "    }%n" +
-                        "  }%n" +
-                        "}"));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentIsUsedInPreferenceOverServletConfig() throws Exception {
-        final MetricRegistry metricRegistry = mock(MetricRegistry.class);
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-
-        final MetricsServlet metricsServlet = new MetricsServlet(metricRegistry);
-        metricsServlet.init(servletConfig);
-
-        verify(servletConfig, times(1)).getServletContext();
-        verify(servletContext, never()).getAttribute(eq(MetricsServlet.METRICS_REGISTRY));
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentUsesServletConfigWhenNull() throws Exception {
-        final MetricRegistry metricRegistry = mock(MetricRegistry.class);
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-        when(servletContext.getAttribute(eq(MetricsServlet.METRICS_REGISTRY)))
-                .thenReturn(metricRegistry);
-
-        final MetricsServlet metricsServlet = new MetricsServlet(null);
-        metricsServlet.init(servletConfig);
-
-        verify(servletConfig, times(1)).getServletContext();
-        verify(servletContext, times(1)).getAttribute(eq(MetricsServlet.METRICS_REGISTRY));
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentUsesServletConfigWhenNullButWrongTypeInContext() throws Exception {
-        assertThrows(ServletException.class, () -> {
-            final ServletContext servletContext = mock(ServletContext.class);
-            final ServletConfig servletConfig = mock(ServletConfig.class);
-            when(servletConfig.getServletContext()).thenReturn(servletContext);
-            when(servletContext.getAttribute(eq(MetricsServlet.METRICS_REGISTRY)))
-                    .thenReturn("IRELLEVANT_STRING");
-
-            final MetricsServlet metricsServlet = new MetricsServlet(null);
-            metricsServlet.init(servletConfig);
-        });
-    }
+final class MetricsServletTest extends AbstractServletTest {
+  private final Clock clock = mock();
+  private final MetricRegistry registry = new MetricRegistry();
+  private ServletTester tester;
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    this.tester = tester;
+    tester.setAttribute(MetricsServlet.class.getCanonicalName() + ".registry", registry);
+    tester.addServlet(MetricsServlet.class, "/metrics");
+    tester
+        .getContext()
+        .setInitParameter(MetricsServlet.class.getCanonicalName() + ".allowedOrigin", "*");
+  }
+
+  @BeforeEach
+  void setUp() {
+    // provide ticks for the setup (calls getTick 6 times). The serialization in the tests
+    // themselves
+    // will call getTick again several times and always get the same value (the last specified here)
+    when(clock.getTick()).thenReturn(100L, 100L, 200L, 300L, 300L, 400L);
+
+    registry.register(MetricName.build("g1"), (Gauge<Long>) () -> 100L);
+    registry.counter("c").inc();
+    registry.histogram("h").update(1);
+    registry.register(MetricName.build("m"), new Meter(clock)).mark();
+    registry
+        .register(MetricName.build("t"), new Timer(new ExponentiallyDecayingReservoir(), clock))
+        .update(1, TimeUnit.SECONDS);
+
+    request.setMethod("GET");
+    request.setURI("/metrics");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo("*");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{"
+                + "\"version\":\"5.0.0\","
+                + "\"gauges\":{"
+                + "\"g1\":{\"value\":100}"
+                + "},"
+                + "\"counters\":{"
+                + "\"c\":{\"count\":1}"
+                + "},"
+                + "\"histograms\":{"
+                + "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}"
+                + "},"
+                + "\"meters\":{"
+                + "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}"
+                + "}"
+                + "}");
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void returnsJsonWhenJsonpInitParamNotSet() throws Exception {
+    String callbackParamName = "callbackParam";
+    String callbackParamVal = "callbackParamVal";
+    request.setURI("/metrics?" + callbackParamName + "=" + callbackParamVal);
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo("*");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{"
+                + "\"version\":\"5.0.0\","
+                + "\"gauges\":{"
+                + "\"g1\":{\"value\":100}"
+                + "},"
+                + "\"counters\":{"
+                + "\"c\":{\"count\":1}"
+                + "},"
+                + "\"histograms\":{"
+                + "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}"
+                + "},"
+                + "\"meters\":{"
+                + "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}"
+                + "}"
+                + "}");
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void returnsJsonpWhenInitParamSet() throws Exception {
+    String callbackParamName = "callbackParam";
+    String callbackParamVal = "callbackParamVal";
+    request.setURI("/metrics?" + callbackParamName + "=" + callbackParamVal);
+    tester
+        .getContext()
+        .setInitParameter(
+            MetricsServlet.class.getCanonicalName() + ".jsonpCallback", callbackParamName);
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo("*");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "%s({\"version\":\"5.0.0\",\"gauges\":{\"g1\":{\"value\":100}},\"counters\":{\"c\":{\"count\":1}},\"histograms\":{\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}},\"meters\":{\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}}})",
+            callbackParamVal);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void optionallyPrettyPrintsTheJson() throws Exception {
+    request.setURI("/metrics?pretty=true");
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo("*");
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "{%n"
+                    + "  \"version\" : \"5.0.0\",%n"
+                    + "  \"gauges\" : {%n"
+                    + "    \"g1\" : {%n"
+                    + "      \"value\" : 100%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"counters\" : {%n"
+                    + "    \"c\" : {%n"
+                    + "      \"count\" : 1%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"histograms\" : {%n"
+                    + "    \"h\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"max\" : 1,%n"
+                    + "      \"mean\" : 1.0,%n"
+                    + "      \"min\" : 1,%n"
+                    + "      \"p50\" : 1.0,%n"
+                    + "      \"p75\" : 1.0,%n"
+                    + "      \"p95\" : 1.0,%n"
+                    + "      \"p98\" : 1.0,%n"
+                    + "      \"p99\" : 1.0,%n"
+                    + "      \"p999\" : 1.0,%n"
+                    + "      \"stddev\" : 0.0%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"meters\" : {%n"
+                    + "    \"m\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"m15_rate\" : 0.0,%n"
+                    + "      \"m1_rate\" : 0.0,%n"
+                    + "      \"m5_rate\" : 0.0,%n"
+                    + "      \"mean_rate\" : 3333333.3333333335,%n"
+                    + "      \"units\" : \"events/second\"%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"timers\" : {%n"
+                    + "    \"t\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"max\" : 1.0,%n"
+                    + "      \"mean\" : 1.0,%n"
+                    + "      \"min\" : 1.0,%n"
+                    + "      \"p50\" : 1.0,%n"
+                    + "      \"p75\" : 1.0,%n"
+                    + "      \"p95\" : 1.0,%n"
+                    + "      \"p98\" : 1.0,%n"
+                    + "      \"p99\" : 1.0,%n"
+                    + "      \"p999\" : 1.0,%n"
+                    + "      \"stddev\" : 0.0,%n"
+                    + "      \"m15_rate\" : 0.0,%n"
+                    + "      \"m1_rate\" : 0.0,%n"
+                    + "      \"m5_rate\" : 0.0,%n"
+                    + "      \"mean_rate\" : 1.0E7,%n"
+                    + "      \"duration_units\" : \"seconds\",%n"
+                    + "      \"rate_units\" : \"calls/second\"%n"
+                    + "    }%n"
+                    + "  }%n"
+                    + "}"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentIsUsedInPreferenceOverServletConfig() throws Exception {
+    final MetricRegistry metricRegistry = mock();
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+
+    final MetricsServlet metricsServlet = new MetricsServlet(metricRegistry);
+    metricsServlet.init(servletConfig);
+
+    verify(servletConfig).getServletContext();
+    verify(servletContext, never()).getAttribute(MetricsServlet.METRICS_REGISTRY);
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentUsesServletConfigWhenNull() throws Exception {
+    final MetricRegistry metricRegistry = mock();
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+    when(servletContext.getAttribute(MetricsServlet.METRICS_REGISTRY)).thenReturn(metricRegistry);
+
+    final MetricsServlet metricsServlet = new MetricsServlet(null);
+    metricsServlet.init(servletConfig);
+
+    verify(servletConfig).getServletContext();
+    verify(servletContext).getAttribute(MetricsServlet.METRICS_REGISTRY);
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentUsesServletConfigWhenNullButWrongTypeInContext()
+      throws Exception {
+    assertThatThrownBy(
+            () -> {
+              final ServletContext servletContext = mock();
+              final ServletConfig servletConfig = mock();
+              when(servletConfig.getServletContext()).thenReturn(servletContext);
+              when(servletContext.getAttribute(MetricsServlet.METRICS_REGISTRY))
+                  .thenReturn("IRELLEVANT_STRING");
+
+              final MetricsServlet metricsServlet = new MetricsServlet(null);
+              metricsServlet.init(servletConfig);
+            })
+        .isInstanceOf(ServletException.class);
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/PingServletTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/PingServletTest.java
@@ -1,49 +1,45 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class PingServletTest extends AbstractServletTest {
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.addServlet(PingServlet.class, "/ping");
-    }
-
-    @BeforeEach
-    void setUp() throws Exception {
-        request.setMethod("GET");
-        request.setURI("/ping");
-        request.setVersion("HTTP/1.0");
-
-        processRequest();
-    }
-
-    @Test
-    void returns200OK() {
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-    }
-
-    @Test
-    void returnsPong() {
-        assertThat(response.getContent())
-                .isEqualTo(String.format("pong%n"));
-    }
-
-    @Test
-    void returnsTextPlain() {
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/plain;charset=ISO-8859-1");
-    }
-
-    @Test
-    void returnsUncacheable() {
-        assertThat(response.get(HttpHeader.CACHE_CONTROL))
-                .isEqualTo("must-revalidate,no-cache,no-store");
-
-    }
+final class PingServletTest extends AbstractServletTest {
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.addServlet(PingServlet.class, "/ping");
+  }
+
+  @BeforeEach
+  void setUp() throws Exception {
+    request.setMethod("GET");
+    request.setURI("/ping");
+    request.setVersion("HTTP/1.0");
+
+    processRequest();
+  }
+
+  @Test
+  void returns200OK() {
+    assertThat(response.getStatus()).isEqualTo(200);
+  }
+
+  @Test
+  void returnsPong() {
+    assertThat(response.getContent()).isEqualTo(String.format("pong%n"));
+  }
+
+  @Test
+  void returnsTextPlain() {
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/plain;charset=ISO-8859-1");
+  }
+
+  @Test
+  void returnsUncacheable() {
+    assertThat(response.get(HttpHeader.CACHE_CONTROL))
+        .isEqualTo("must-revalidate,no-cache,no-store");
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/ThreadDumpServletTest.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/ThreadDumpServletTest.java
@@ -1,49 +1,45 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class ThreadDumpServletTest extends AbstractServletTest {
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.addServlet(ThreadDumpServlet.class, "/threads");
-    }
-
-    @BeforeEach
-    void setUp() throws Exception {
-        request.setMethod("GET");
-        request.setURI("/threads");
-        request.setVersion("HTTP/1.0");
-
-        processRequest();
-    }
-
-    @Test
-    void returns200OK() {
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-    }
-
-    @Test
-    void returnsAThreadDump() {
-        assertThat(response.getContent())
-                .contains("Finalizer");
-    }
-
-    @Test
-    void returnsTextPlain() {
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/plain");
-    }
-
-    @Test
-    void returnsUncacheable() {
-        assertThat(response.get(HttpHeader.CACHE_CONTROL))
-                .isEqualTo("must-revalidate,no-cache,no-store");
-
-    }
+final class ThreadDumpServletTest extends AbstractServletTest {
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.addServlet(ThreadDumpServlet.class, "/threads");
+  }
+
+  @BeforeEach
+  void setUp() throws Exception {
+    request.setMethod("GET");
+    request.setURI("/threads");
+    request.setVersion("HTTP/1.0");
+
+    processRequest();
+  }
+
+  @Test
+  void returns200OK() {
+    assertThat(response.getStatus()).isEqualTo(200);
+  }
+
+  @Test
+  void returnsAThreadDump() {
+    assertThat(response.getContent()).contains("Finalizer");
+  }
+
+  @Test
+  void returnsTextPlain() {
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/plain");
+  }
+
+  @Test
+  void returnsUncacheable() {
+    assertThat(response.get(HttpHeader.CACHE_CONTROL))
+        .isEqualTo("must-revalidate,no-cache,no-store");
+  }
 }
--- a/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/experiments/ExampleServer.java
+++ b/metrics-jakarta-servlets/src/test/java/io/dropwizard/metrics5/servlets/experiments/ExampleServer.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.servlets.experiments;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.MetricRegistry;
@@ -18,43 +20,48 @@ import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
 import org.eclipse.jetty.util.thread.ThreadPool;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 public class ExampleServer {
-    private static final MetricRegistry REGISTRY = new MetricRegistry();
-    private static final Counter COUNTER_1 = REGISTRY.counter(name(ExampleServer.class, "wah", "doody"));
-    private static final Counter COUNTER_2 = REGISTRY.counter(name(ExampleServer.class, "woo"));
+  private static final MetricRegistry REGISTRY = new MetricRegistry();
+  private static final Counter COUNTER_1 =
+      REGISTRY.counter(name(ExampleServer.class, "wah", "doody"));
+  private static final Counter COUNTER_2 = REGISTRY.counter(name(ExampleServer.class, "woo"));
 
-    static {
-        REGISTRY.register(name(ExampleServer.class, "boo"), (Gauge<Integer>) () -> {
-            throw new RuntimeException("asplode!");
-        });
-    }
+  static {
+    REGISTRY.register(
+        name(ExampleServer.class, "boo"),
+        (Gauge<Integer>)
+            () -> {
+              throw new RuntimeException("asplode!");
+            });
+  }
 
-    public static void main(String[] args) throws Exception {
-        COUNTER_1.inc();
-        COUNTER_2.inc();
+  public static void main(String[] args) throws Exception {
+    COUNTER_1.inc();
+    COUNTER_2.inc();
 
-        final ThreadPool threadPool = new InstrumentedQueuedThreadPool(REGISTRY);
-        final Server server = new Server(threadPool);
+    final ThreadPool threadPool = new InstrumentedQueuedThreadPool(REGISTRY);
+    final Server server = new Server(threadPool);
 
-        final Connector connector = new ServerConnector(server, new InstrumentedConnectionFactory(
+    final Connector connector =
+        new ServerConnector(
+            server,
+            new InstrumentedConnectionFactory(
                 new HttpConnectionFactory(), REGISTRY.timer("http.connection")));
-        server.addConnector(connector);
+    server.addConnector(connector);
 
-        final ServletContextHandler context = new ServletContextHandler();
-        context.setContextPath("/initial");
-        context.setAttribute(MetricsServlet.METRICS_REGISTRY, REGISTRY);
-        context.setAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY, new HealthCheckRegistry());
+    final ServletContextHandler context = new ServletContextHandler();
+    context.setContextPath("/initial");
+    context.setAttribute(MetricsServlet.METRICS_REGISTRY, REGISTRY);
+    context.setAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY, new HealthCheckRegistry());
 
-        final ServletHolder holder = new ServletHolder(new AdminServlet());
-        context.addServlet(holder, "/dingo/*");
+    final ServletHolder holder = new ServletHolder(new AdminServlet());
+    context.addServlet(holder, "/dingo/*");
 
-        final InstrumentedHandler handler = new InstrumentedHandler(REGISTRY);
-        handler.setHandler(context);
-        server.setHandler(handler);
+    final InstrumentedHandler handler = new InstrumentedHandler(REGISTRY);
+    handler.setHandler(context);
+    server.setHandler(handler);
 
-        server.start();
-        server.join();
-    }
+    server.start();
+    server.join();
+  }
 }
--- a/metrics-jcache/src/main/java/io/dropwizard/metrics5/jcache/JCacheGaugeSet.java
+++ b/metrics-jcache/src/main/java/io/dropwizard/metrics5/jcache/JCacheGaugeSet.java
@@ -1,27 +1,26 @@
 package io.dropwizard.metrics5.jcache;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static java.util.Collections.unmodifiableMap;
+
 import io.dropwizard.metrics5.Metric;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricSet;
 import io.dropwizard.metrics5.jvm.JmxAttributeGauge;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.cache.management.CacheStatisticsMXBean;
-import javax.management.MalformedObjectNameException;
-import javax.management.ObjectInstance;
-import javax.management.ObjectName;
 import java.lang.management.ManagementFactory;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
+import javax.cache.management.CacheStatisticsMXBean;
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectInstance;
+import javax.management.ObjectName;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Gauge set retrieving JCache JMX attributes
@@ -31,54 +30,55 @@ import static io.dropwizard.metrics5.MetricRegistry.name;
  */
 public class JCacheGaugeSet implements MetricSet {
 
-    private static final String M_BEAN_COORDINATES = "javax.cache:type=CacheStatistics,CacheManager=*,Cache=*";
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(JCacheGaugeSet.class);
+  private static final String M_BEAN_COORDINATES =
+      "javax.cache:type=CacheStatistics,CacheManager=*,Cache=*";
 
-    @Override
-    public Map<MetricName, Metric> getMetrics() {
-        Set<ObjectInstance> cacheBeans = getCacheBeans();
-        List<String> availableStatsNames = retrieveStatsNames();
+  private static final Logger LOG = LoggerFactory.getLogger(JCacheGaugeSet.class);
 
-        Map<MetricName, Metric> gauges = new HashMap<>(cacheBeans.size() * availableStatsNames.size());
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    Set<ObjectInstance> cacheBeans = getCacheBeans();
+    List<String> availableStatsNames = retrieveStatsNames();
 
-        for (ObjectInstance cacheBean : cacheBeans) {
-            ObjectName objectName = cacheBean.getObjectName();
-            String cacheName = objectName.getKeyProperty("Cache");
+    Map<MetricName, Metric> gauges = new HashMap<>(cacheBeans.size() * availableStatsNames.size());
 
-            for (String statsName : availableStatsNames) {
-                JmxAttributeGauge jmxAttributeGauge = new JmxAttributeGauge(objectName, statsName);
-                gauges.put(name(cacheName, toSpinalCase(statsName)), jmxAttributeGauge);
-            }
-        }
+    for (ObjectInstance cacheBean : cacheBeans) {
+      ObjectName objectName = cacheBean.getObjectName();
+      String cacheName = objectName.getKeyProperty("Cache");
 
-        return Collections.unmodifiableMap(gauges);
+      for (String statsName : availableStatsNames) {
+        JmxAttributeGauge jmxAttributeGauge = new JmxAttributeGauge(objectName, statsName);
+        gauges.put(name(cacheName, toSpinalCase(statsName)), jmxAttributeGauge);
+      }
     }
 
-    private Set<ObjectInstance> getCacheBeans() {
-        try {
-            return ManagementFactory.getPlatformMBeanServer().queryMBeans(ObjectName.getInstance(M_BEAN_COORDINATES), null);
-        } catch (MalformedObjectNameException e) {
-            LOGGER.error("Unable to retrieve {}. Are JCache statistics enabled?", M_BEAN_COORDINATES);
-            throw new RuntimeException(e);
-        }
-    }
+    return unmodifiableMap(gauges);
+  }
 
-    private List<String> retrieveStatsNames() {
-        Method[] methods = CacheStatisticsMXBean.class.getDeclaredMethods();
-        List<String> availableStatsNames = new ArrayList<>(methods.length);
-
-        for (Method method : methods) {
-            String methodName = method.getName();
-            if (methodName.startsWith("get")) {
-                availableStatsNames.add(methodName.substring(3));
-            }
-        }
-        return availableStatsNames;
+  private Set<ObjectInstance> getCacheBeans() {
+    try {
+      return ManagementFactory.getPlatformMBeanServer()
+          .queryMBeans(ObjectName.getInstance(M_BEAN_COORDINATES), null);
+    } catch (MalformedObjectNameException e) {
+      LOG.error("Unable to retrieve {}. Are JCache statistics enabled?", M_BEAN_COORDINATES);
+      throw new RuntimeException(e);
     }
+  }
+
+  private List<String> retrieveStatsNames() {
+    Method[] methods = CacheStatisticsMXBean.class.getDeclaredMethods();
+    List<String> availableStatsNames = new ArrayList<>(methods.length);
 
-    private static String toSpinalCase(String camelCase) {
-        return camelCase.replaceAll("(.)(\\p{Upper})", "$1-$2").toLowerCase(Locale.US);
+    for (Method method : methods) {
+      String methodName = method.getName();
+      if (methodName.startsWith("get")) {
+        availableStatsNames.add(methodName.substring(3));
+      }
     }
+    return availableStatsNames;
+  }
 
+  private static String toSpinalCase(String camelCase) {
+    return camelCase.replaceAll("(.)(\\p{Upper})", "$1-$2").toLowerCase(Locale.US);
+  }
 }
--- a/metrics-jcache/src/test/java/JCacheGaugeSetTest.java
+++ b/metrics-jcache/src/test/java/JCacheGaugeSetTest.java
@@ -1,88 +1,83 @@
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jcache.JCacheGaugeSet;
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
 import javax.cache.Cache;
 import javax.cache.CacheManager;
 import javax.cache.Caching;
 import javax.cache.spi.CachingProvider;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class JCacheGaugeSetTest {
+final class JCacheGaugeSetTest {
 
-    private MetricRegistry registry;
-    private Cache<Object, Object> myCache;
-    private Cache<Object, Object> myOtherCache;
-    private CacheManager cacheManager;
+  private MetricRegistry registry;
+  private Cache<Object, Object> myCache;
+  private Cache<Object, Object> myOtherCache;
+  private CacheManager cacheManager;
 
-    @BeforeEach
-    void setUp() throws Exception {
+  @BeforeEach
+  void setUp() throws Exception {
 
-        CachingProvider provider = Caching.getCachingProvider();
-        cacheManager = provider.getCacheManager(
-                getClass().getResource("ehcache.xml").toURI(),
-                getClass().getClassLoader());
+    CachingProvider provider = Caching.getCachingProvider();
+    cacheManager =
+        provider.getCacheManager(
+            getClass().getResource("ehcache.xml").toURI(), getClass().getClassLoader());
 
-        myCache = cacheManager.getCache("myCache");
-        myOtherCache = cacheManager.getCache("myOtherCache");
+    myCache = cacheManager.getCache("myCache");
+    myOtherCache = cacheManager.getCache("myOtherCache");
 
-        registry = new MetricRegistry();
-        registry.register(MetricName.build("jcache.statistics"), new JCacheGaugeSet());
-    }
+    registry = new MetricRegistry();
+    registry.register(MetricName.build("jcache.statistics"), new JCacheGaugeSet());
+  }
 
-    @Test
-    void measuresGauges() throws Exception {
+  @Test
+  void measuresGauges() throws Exception {
 
-        myOtherCache.get("woo");
-        assertThat(registry.getGauges().get(MetricName.build("jcache.statistics.myOtherCache.cache-misses"))
+    myOtherCache.get("woo");
+    assertThat(
+            registry
+                .getGauges()
+                .get(MetricName.build("jcache.statistics.myOtherCache.cache-misses"))
                 .getValue())
-                .isEqualTo(1L);
-
-        myCache.get("woo");
-        MetricName myCache = MetricName.build("jcache.statistics.myCache");
-        assertThat(registry.getGauges().get(myCache.resolve("cache-misses")).getValue())
-                .isEqualTo(1L);
-        assertThat(registry.getGauges().get(myCache.resolve("cache-hits")).getValue())
-                .isEqualTo(0L);
-        assertThat(registry.getGauges().get(myCache.resolve("cache-gets")).getValue())
-                .isEqualTo(1L);
-
-        this.myCache.put("woo", "whee");
-        this.myCache.get("woo");
-        assertThat(registry.getGauges().get(myCache.resolve("cache-puts")).getValue())
-                .isEqualTo(1L);
-        assertThat(registry.getGauges().get(myCache.resolve("cache-hits")).getValue())
-                .isEqualTo(1L);
-        assertThat(registry.getGauges().get(myCache.resolve("cache-hit-percentage")).getValue())
-                .isEqualTo(50.0f);
-        assertThat(registry.getGauges().get(myCache.resolve("cache-miss-percentage")).getValue())
-                .isEqualTo(50.0f);
-        assertThat(registry.getGauges().get(myCache.resolve("cache-gets")).getValue())
-                .isEqualTo(2L);
-
-        // cache size being 1, eviction occurs after this line
-        this.myCache.put("woo2", "whoza");
-        assertThat(registry.getGauges().get(myCache.resolve("cache-evictions")).getValue())
-                .isEqualTo(1L);
-
-        this.myCache.remove("woo2");
-        assertThat((Float) registry.getGauges().get(myCache.resolve("average-get-time")).getValue())
-                .isGreaterThan(0.0f);
-        assertThat((Float) registry.getGauges().get(myCache.resolve("average-put-time")).getValue())
-                .isGreaterThan(0.0f);
-        assertThat((Float) registry.getGauges().get(myCache.resolve("average-remove-time")).getValue())
-                .isGreaterThan(0.0f);
-
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        cacheManager.destroyCache("myCache");
-        cacheManager.destroyCache("myOtherCache");
-        cacheManager.close();
-    }
+        .isEqualTo(1L);
+
+    myCache.get("woo");
+    MetricName myCache = MetricName.build("jcache.statistics.myCache");
+    assertThat(registry.getGauges().get(myCache.resolve("cache-misses")).getValue()).isEqualTo(1L);
+    assertThat(registry.getGauges().get(myCache.resolve("cache-hits")).getValue()).isEqualTo(0L);
+    assertThat(registry.getGauges().get(myCache.resolve("cache-gets")).getValue()).isEqualTo(1L);
+
+    this.myCache.put("woo", "whee");
+    this.myCache.get("woo");
+    assertThat(registry.getGauges().get(myCache.resolve("cache-puts")).getValue()).isEqualTo(1L);
+    assertThat(registry.getGauges().get(myCache.resolve("cache-hits")).getValue()).isEqualTo(1L);
+    assertThat(registry.getGauges().get(myCache.resolve("cache-hit-percentage")).getValue())
+        .isEqualTo(50.0f);
+    assertThat(registry.getGauges().get(myCache.resolve("cache-miss-percentage")).getValue())
+        .isEqualTo(50.0f);
+    assertThat(registry.getGauges().get(myCache.resolve("cache-gets")).getValue()).isEqualTo(2L);
+
+    // cache size being 1, eviction occurs after this line
+    this.myCache.put("woo2", "whoza");
+    assertThat(registry.getGauges().get(myCache.resolve("cache-evictions")).getValue())
+        .isEqualTo(1L);
+
+    this.myCache.remove("woo2");
+    assertThat((Float) registry.getGauges().get(myCache.resolve("average-get-time")).getValue())
+        .isPositive();
+    assertThat((Float) registry.getGauges().get(myCache.resolve("average-put-time")).getValue())
+        .isPositive();
+    assertThat((Float) registry.getGauges().get(myCache.resolve("average-remove-time")).getValue())
+        .isPositive();
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    cacheManager.destroyCache("myCache");
+    cacheManager.destroyCache("myOtherCache");
+    cacheManager.close();
+  }
 }
--- a/metrics-jcstress/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoirTrimReadTest.java
+++ b/metrics-jcstress/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoirTrimReadTest.java
@@ -1,5 +1,8 @@
 package io.dropwizard.metrics5;
 
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
 import org.openjdk.jcstress.annotations.Actor;
 import org.openjdk.jcstress.annotations.Expect;
 import org.openjdk.jcstress.annotations.JCStressTest;
@@ -7,61 +10,59 @@ import org.openjdk.jcstress.annotations.Outcome;
 import org.openjdk.jcstress.annotations.State;
 import org.openjdk.jcstress.infra.results.L_Result;
 
-import java.util.Arrays;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
-
 @JCStressTest
 @Outcome(
     id = "\\[240, 241, 242, 243, 244, 245, 246, 247, 248, 249\\]",
     expect = Expect.ACCEPTABLE,
-    desc = "Actor1 made read before Actor2 even started"
-    )
+    desc = "Actor1 made read before Actor2 even started")
 @Outcome(
     id = "\\[243, 244, 245, 246, 247, 248, 249\\]",
     expect = Expect.ACCEPTABLE,
-    desc = "Actor2 made trim before Actor1 even started"
-    )
+    desc = "Actor2 made trim before Actor1 even started")
 @Outcome(
     id = "\\[244, 245, 246, 247, 248, 249\\]",
     expect = Expect.ACCEPTABLE,
-    desc = "Actor1 made trim, then Actor2 started trim and made startIndex change, " +
-        "before Actor1 concurrent read."
-    )
+    desc =
+        "Actor1 made trim, then Actor2 started trim and made startIndex change, "
+            + "before Actor1 concurrent read.")
 @Outcome(
     id = "\\[243, 244, 245, 246, 247, 248\\]",
     expect = Expect.ACCEPTABLE,
-    desc = "Actor1 made trim, then Actor2 started trim, but not finished startIndex change, before Actor1 concurrent read."
-    )
+    desc =
+        "Actor1 made trim, then Actor2 started trim, but not finished startIndex change, before Actor1 concurrent read.")
 @State
 public class SlidingTimeWindowArrayReservoirTrimReadTest {
-    private final AtomicLong ticks = new AtomicLong(0);
-    private final SlidingTimeWindowArrayReservoir reservoir;
+  private final AtomicLong ticks = new AtomicLong(0);
+  private final SlidingTimeWindowArrayReservoir reservoir;
 
-    public SlidingTimeWindowArrayReservoirTrimReadTest() {
-        reservoir = new SlidingTimeWindowArrayReservoir(10, TimeUnit.NANOSECONDS, new Clock() {
-            @Override
-            public long getTick() {
+  public SlidingTimeWindowArrayReservoirTrimReadTest() {
+    reservoir =
+        new SlidingTimeWindowArrayReservoir(
+            10,
+            TimeUnit.NANOSECONDS,
+            new Clock() {
+              @Override
+              public long getTick() {
                 return ticks.get();
-            }
-        });
+              }
+            });
 
-        for (int i = 0; i < 250; i++) {
-            ticks.set(i);
-            reservoir.update(i);
-        }
+    for (int i = 0; i < 250; i++) {
+      ticks.set(i);
+      reservoir.update(i);
     }
+  }
 
-    @Actor
-    public void actor1(L_Result r) {
-        Snapshot snapshot = reservoir.getSnapshot();
-        String stringValues = Arrays.toString(snapshot.getValues());
-        r.r1 = stringValues;
-    }
+  @Actor
+  public void actor1(L_Result r) {
+    Snapshot snapshot = reservoir.getSnapshot();
+    String stringValues = Arrays.toString(snapshot.getValues());
+    r.r1 = stringValues;
+  }
 
-    @Actor
-    public void actor2() {
-        ticks.set(253);
-        reservoir.trim();
-    }
-}
\ No newline at end of file
+  @Actor
+  public void actor2() {
+    ticks.set(253);
+    reservoir.trim();
+  }
+}
--- a/metrics-jcstress/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoirWriteReadAllocate.java
+++ b/metrics-jcstress/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoirWriteReadAllocate.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5;
 
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
 import org.openjdk.jcstress.annotations.Actor;
 import org.openjdk.jcstress.annotations.Arbiter;
 import org.openjdk.jcstress.annotations.Expect;
@@ -8,38 +10,36 @@ import org.openjdk.jcstress.annotations.Outcome;
 import org.openjdk.jcstress.annotations.State;
 import org.openjdk.jcstress.infra.results.L_Result;
 
-import java.util.Arrays;
-import java.util.concurrent.TimeUnit;
-
 @JCStressTest
 @Outcome(id = "\\[1023, 1029, 1034\\]", expect = Expect.ACCEPTABLE)
 @State
 public class SlidingTimeWindowArrayReservoirWriteReadAllocate {
 
-    private final SlidingTimeWindowArrayReservoir reservoir;
-
-    public SlidingTimeWindowArrayReservoirWriteReadAllocate() {
-        reservoir = new SlidingTimeWindowArrayReservoir(500, TimeUnit.SECONDS);
-        for (int i = 0; i < 1024; i++) {
-            reservoir.update(i);
-        }
-    }
-
-    @Actor
-    public void actor1() {
-        reservoir.update(1029L);
-    }
-
-    @Actor
-    public void actor2() {
-        reservoir.update(1034L);
-    }
+  private final SlidingTimeWindowArrayReservoir reservoir;
 
-    @Arbiter
-    public void arbiter(L_Result r) {
-        Snapshot snapshot = reservoir.getSnapshot();
-        long[] values = snapshot.getValues();
-        String stringValues = Arrays.toString(Arrays.copyOfRange(values, values.length - 3, values.length));
-        r.r1 = stringValues;
+  public SlidingTimeWindowArrayReservoirWriteReadAllocate() {
+    reservoir = new SlidingTimeWindowArrayReservoir(500, TimeUnit.SECONDS);
+    for (int i = 0; i < 1024; i++) {
+      reservoir.update(i);
     }
-}
\ No newline at end of file
+  }
+
+  @Actor
+  public void actor1() {
+    reservoir.update(1029L);
+  }
+
+  @Actor
+  public void actor2() {
+    reservoir.update(1034L);
+  }
+
+  @Arbiter
+  public void arbiter(L_Result r) {
+    Snapshot snapshot = reservoir.getSnapshot();
+    long[] values = snapshot.getValues();
+    String stringValues =
+        Arrays.toString(Arrays.copyOfRange(values, values.length - 3, values.length));
+    r.r1 = stringValues;
+  }
+}
--- a/metrics-jcstress/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoirWriteReadTest.java
+++ b/metrics-jcstress/src/main/java/io/dropwizard/metrics5/SlidingTimeWindowArrayReservoirWriteReadTest.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5;
 
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
 import org.openjdk.jcstress.annotations.Actor;
 import org.openjdk.jcstress.annotations.Expect;
 import org.openjdk.jcstress.annotations.JCStressTest;
@@ -7,9 +9,6 @@ import org.openjdk.jcstress.annotations.Outcome;
 import org.openjdk.jcstress.annotations.State;
 import org.openjdk.jcstress.infra.results.L_Result;
 
-import java.util.Arrays;
-import java.util.concurrent.TimeUnit;
-
 @JCStressTest
 @Outcome(id = "\\[\\]", expect = Expect.ACCEPTABLE)
 @Outcome(id = "\\[31\\]", expect = Expect.ACCEPTABLE)
@@ -19,27 +18,26 @@ import java.util.concurrent.TimeUnit;
 @State
 public class SlidingTimeWindowArrayReservoirWriteReadTest {
 
-    private final SlidingTimeWindowArrayReservoir reservoir;
-
-    public SlidingTimeWindowArrayReservoirWriteReadTest() {
-        reservoir = new SlidingTimeWindowArrayReservoir(1, TimeUnit.SECONDS);
-    }
-
-    @Actor
-    public void actor1() {
-        reservoir.update(31L);
-    }
-
-    @Actor
-    public void actor2() {
-        reservoir.update(15L);
-    }
-
-    @Actor
-    public void actor3(L_Result r) {
-        Snapshot snapshot = reservoir.getSnapshot();
-        String stringValues = Arrays.toString(snapshot.getValues());
-        r.r1 = stringValues;
-    }
-
-}
\ No newline at end of file
+  private final SlidingTimeWindowArrayReservoir reservoir;
+
+  public SlidingTimeWindowArrayReservoirWriteReadTest() {
+    reservoir = new SlidingTimeWindowArrayReservoir(1, TimeUnit.SECONDS);
+  }
+
+  @Actor
+  public void actor1() {
+    reservoir.update(31L);
+  }
+
+  @Actor
+  public void actor2() {
+    reservoir.update(15L);
+  }
+
+  @Actor
+  public void actor3(L_Result r) {
+    Snapshot snapshot = reservoir.getSnapshot();
+    String stringValues = Arrays.toString(snapshot.getValues());
+    r.r1 = stringValues;
+  }
+}
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/InstrumentedSqlLogger.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/InstrumentedSqlLogger.java
@@ -4,45 +4,45 @@ import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jdbi3.strategies.SmartNameStrategy;
 import io.dropwizard.metrics5.jdbi3.strategies.StatementNameStrategy;
-import org.jdbi.v3.core.statement.SqlLogger;
-import org.jdbi.v3.core.statement.StatementContext;
-
 import java.sql.SQLException;
 import java.time.temporal.ChronoUnit;
 import java.util.concurrent.TimeUnit;
+import org.jdbi.v3.core.statement.SqlLogger;
+import org.jdbi.v3.core.statement.StatementContext;
 
 /**
- * A {@link SqlLogger} implementation for JDBI which uses the SQL objects' class names and
- * method names for nanosecond-precision timers.
+ * A {@link SqlLogger} implementation for JDBI which uses the SQL objects' class names and method
+ * names for nanosecond-precision timers.
  */
 public class InstrumentedSqlLogger implements SqlLogger {
-    private final MetricRegistry registry;
-    private final StatementNameStrategy statementNameStrategy;
-
-    public InstrumentedSqlLogger(MetricRegistry registry) {
-        this(registry, new SmartNameStrategy());
-    }
-
-    public InstrumentedSqlLogger(MetricRegistry registry, StatementNameStrategy statementNameStrategy) {
-        this.registry = registry;
-        this.statementNameStrategy = statementNameStrategy;
-    }
-
-    @Override
-    public void logAfterExecution(StatementContext context) {
-        log(context);
-    }
-
-    @Override
-    public void logException(StatementContext context, SQLException ex) {
-        log(context);
-    }
-
-    private void log(StatementContext context) {
-        MetricName statementName = statementNameStrategy.getStatementName(context);
-        if (statementName != null) {
-            final long elapsed = context.getElapsedTime(ChronoUnit.NANOS);
-            registry.timer(statementName).update(elapsed, TimeUnit.NANOSECONDS);
-        }
+  private final MetricRegistry registry;
+  private final StatementNameStrategy statementNameStrategy;
+
+  public InstrumentedSqlLogger(MetricRegistry registry) {
+    this(registry, new SmartNameStrategy());
+  }
+
+  public InstrumentedSqlLogger(
+      MetricRegistry registry, StatementNameStrategy statementNameStrategy) {
+    this.registry = registry;
+    this.statementNameStrategy = statementNameStrategy;
+  }
+
+  @Override
+  public void logAfterExecution(StatementContext context) {
+    log(context);
+  }
+
+  @Override
+  public void logException(StatementContext context, SQLException ex) {
+    log(context);
+  }
+
+  private void log(StatementContext context) {
+    MetricName statementName = statementNameStrategy.getStatementName(context);
+    if (statementName != null) {
+      final long elapsed = context.getElapsedTime(ChronoUnit.NANOS);
+      registry.timer(statementName).update(elapsed, TimeUnit.NANOSECONDS);
     }
+  }
 }
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/InstrumentedTimingCollector.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/InstrumentedTimingCollector.java
@@ -4,39 +4,39 @@ import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jdbi3.strategies.SmartNameStrategy;
 import io.dropwizard.metrics5.jdbi3.strategies.StatementNameStrategy;
+import java.util.concurrent.TimeUnit;
 import org.jdbi.v3.core.statement.SqlLogger;
 import org.jdbi.v3.core.statement.StatementContext;
 import org.jdbi.v3.core.statement.TimingCollector;
 
-import java.util.concurrent.TimeUnit;
-
 /**
  * A {@link TimingCollector} implementation for JDBI which uses the SQL objects' class names and
  * method names for millisecond-precision timers.
  *
- * @deprecated Use {@link InstrumentedSqlLogger} and {@link org.jdbi.v3.core.Jdbi#setSqlLogger(SqlLogger)} instead.
+ * @deprecated Use {@link InstrumentedSqlLogger} and {@link
+ *     org.jdbi.v3.core.Jdbi#setSqlLogger(SqlLogger)} instead.
  */
 @Deprecated
 public class InstrumentedTimingCollector implements TimingCollector {
 
-    private final MetricRegistry registry;
-    private final StatementNameStrategy statementNameStrategy;
+  private final MetricRegistry registry;
+  private final StatementNameStrategy statementNameStrategy;
 
-    public InstrumentedTimingCollector(MetricRegistry registry) {
-        this(registry, new SmartNameStrategy());
-    }
+  public InstrumentedTimingCollector(MetricRegistry registry) {
+    this(registry, new SmartNameStrategy());
+  }
 
-    public InstrumentedTimingCollector(MetricRegistry registry,
-                                       StatementNameStrategy statementNameStrategy) {
-        this.registry = registry;
-        this.statementNameStrategy = statementNameStrategy;
-    }
+  public InstrumentedTimingCollector(
+      MetricRegistry registry, StatementNameStrategy statementNameStrategy) {
+    this.registry = registry;
+    this.statementNameStrategy = statementNameStrategy;
+  }
 
-    @Override
-    public void collect(long elapsedTime, StatementContext ctx) {
-        MetricName statementName = statementNameStrategy.getStatementName(ctx);
-        if (statementName != null) {
-            registry.timer(statementName).update(elapsedTime, TimeUnit.NANOSECONDS);
-        }
+  @Override
+  public void collect(long elapsedTime, StatementContext ctx) {
+    MetricName statementName = statementNameStrategy.getStatementName(ctx);
+    if (statementName != null) {
+      registry.timer(statementName).update(elapsedTime, TimeUnit.NANOSECONDS);
     }
+  }
 }
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/BasicSqlNameStrategy.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/BasicSqlNameStrategy.java
@@ -1,12 +1,9 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
-/**
- * Collects metrics by respective SQLObject methods.
- */
+/** Collects metrics by respective SQLObject methods. */
 public class BasicSqlNameStrategy extends DelegatingStatementNameStrategy {
 
-    public BasicSqlNameStrategy() {
-        super(DefaultNameStrategy.CHECK_EMPTY,
-                DefaultNameStrategy.SQL_OBJECT);
-    }
+  public BasicSqlNameStrategy() {
+    super(DefaultNameStrategy.CHECK_EMPTY, DefaultNameStrategy.SQL_OBJECT);
+  }
 }
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/DefaultNameStrategy.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/DefaultNameStrategy.java
@@ -1,60 +1,52 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
+import com.google.common.base.Strings;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import org.jdbi.v3.core.extension.ExtensionMethod;
 import org.jdbi.v3.core.statement.StatementContext;
 
-/**
- * Default strategies which build a basis of more complex strategies
- */
+/** Default strategies which build a basis of more complex strategies */
 public enum DefaultNameStrategy implements StatementNameStrategy {
 
-    /**
-     * If no SQL in the context, returns `sql.empty`, otherwise falls through
-     */
-    CHECK_EMPTY {
-        @Override
-        public MetricName getStatementName(StatementContext statementContext) {
-            final String rawSql = statementContext.getRawSql();
-            return rawSql == null || rawSql.isEmpty() ? MetricName.build("sql.empty") : null;
-        }
-    },
-
-    /**
-     * If there is an SQL object attached to the context, returns the name package,
-     * the class and the method on which SQL is declared. If not SQL object is attached,
-     * falls through
-     */
-    SQL_OBJECT {
-        @Override
-        public MetricName getStatementName(StatementContext statementContext) {
-            ExtensionMethod extensionMethod = statementContext.getExtensionMethod();
-            if (extensionMethod != null) {
-                return MetricRegistry.name(extensionMethod.getType(), extensionMethod.getMethod().getName());
-            }
-            return null;
-        }
-    },
+  /** If no SQL in the context, returns `sql.empty`, otherwise falls through */
+  CHECK_EMPTY {
+    @Override
+    public MetricName getStatementName(StatementContext statementContext) {
+      final String rawSql = statementContext.getRawSql();
+      return Strings.isNullOrEmpty(rawSql) ? MetricName.build("sql.empty") : null;
+    }
+  },
 
-    /**
-     * Returns a raw SQL in the context (even if it's not exist)
-     */
-    NAIVE_NAME {
-        @Override
-        public MetricName getStatementName(StatementContext statementContext) {
-            return MetricName.build(statementContext.getRawSql());
-        }
-    },
+  /**
+   * If there is an SQL object attached to the context, returns the name package, the class and the
+   * method on which SQL is declared. If not SQL object is attached, falls through
+   */
+  SQL_OBJECT {
+    @Override
+    public MetricName getStatementName(StatementContext statementContext) {
+      ExtensionMethod extensionMethod = statementContext.getExtensionMethod();
+      if (extensionMethod != null) {
+        return MetricRegistry.name(
+            extensionMethod.getType(), extensionMethod.getMethod().getName());
+      }
+      return null;
+    }
+  },
 
-    /**
-     * Returns the `sql.raw` constant
-     */
-    CONSTANT_SQL_RAW {
-        @Override
-        public MetricName getStatementName(StatementContext statementContext) {
-            return MetricName.build("sql.raw");
-        }
+  /** Returns a raw SQL in the context (even if it's not exist) */
+  NAIVE_NAME {
+    @Override
+    public MetricName getStatementName(StatementContext statementContext) {
+      return MetricName.build(statementContext.getRawSql());
     }
+  },
 
+  /** Returns the `sql.raw` constant */
+  CONSTANT_SQL_RAW {
+    @Override
+    public MetricName getStatementName(StatementContext statementContext) {
+      return MetricName.build("sql.raw");
+    }
+  }
 }
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/DelegatingStatementNameStrategy.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/DelegatingStatementNameStrategy.java
@@ -1,33 +1,30 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
 import io.dropwizard.metrics5.MetricName;
-import org.jdbi.v3.core.statement.StatementContext;
-
 import java.util.Arrays;
 import java.util.List;
+import org.jdbi.v3.core.statement.StatementContext;
 
 public abstract class DelegatingStatementNameStrategy implements StatementNameStrategy {
 
-    /**
-     * Unknown SQL.
-     */
-    private static final MetricName UNKNOWN_SQL = MetricName.build("sql.unknown");
+  /** Unknown SQL. */
+  private static final MetricName UNKNOWN_SQL = MetricName.build("sql.unknown");
 
-    private final List<StatementNameStrategy> strategies;
+  private final List<StatementNameStrategy> strategies;
 
-    protected DelegatingStatementNameStrategy(StatementNameStrategy... strategies) {
-        this.strategies = Arrays.asList(strategies);
-    }
-
-    @Override
-    public MetricName getStatementName(StatementContext statementContext) {
-        for (StatementNameStrategy strategy : strategies) {
-            final MetricName statementName = strategy.getStatementName(statementContext);
-            if (statementName != null) {
-                return statementName;
-            }
-        }
+  protected DelegatingStatementNameStrategy(StatementNameStrategy... strategies) {
+    this.strategies = Arrays.asList(strategies);
+  }
 
-        return UNKNOWN_SQL;
+  @Override
+  public MetricName getStatementName(StatementContext statementContext) {
+    for (StatementNameStrategy strategy : strategies) {
+      final MetricName statementName = strategy.getStatementName(statementContext);
+      if (statementName != null) {
+        return statementName;
+      }
     }
+
+    return UNKNOWN_SQL;
+  }
 }
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/NaiveNameStrategy.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/NaiveNameStrategy.java
@@ -1,12 +1,9 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
-/**
- * Very simple strategy, can be used with any JDBI loader to build basic statistics.
- */
+/** Very simple strategy, can be used with any JDBI loader to build basic statistics. */
 public class NaiveNameStrategy extends DelegatingStatementNameStrategy {
 
-    public NaiveNameStrategy() {
-        super(DefaultNameStrategy.CHECK_EMPTY,
-              DefaultNameStrategy.NAIVE_NAME);
-    }
+  public NaiveNameStrategy() {
+    super(DefaultNameStrategy.CHECK_EMPTY, DefaultNameStrategy.NAIVE_NAME);
+  }
 }
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/SmartNameStrategy.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/SmartNameStrategy.java
@@ -5,9 +5,10 @@ package io.dropwizard.metrics5.jdbi3.strategies;
  */
 public class SmartNameStrategy extends DelegatingStatementNameStrategy {
 
-    public SmartNameStrategy() {
-        super(DefaultNameStrategy.CHECK_EMPTY,
-                DefaultNameStrategy.SQL_OBJECT,
-                DefaultNameStrategy.CONSTANT_SQL_RAW);
-    }
+  public SmartNameStrategy() {
+    super(
+        DefaultNameStrategy.CHECK_EMPTY,
+        DefaultNameStrategy.SQL_OBJECT,
+        DefaultNameStrategy.CONSTANT_SQL_RAW);
+  }
 }
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/StatementNameStrategy.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/StatementNameStrategy.java
@@ -3,11 +3,9 @@ package io.dropwizard.metrics5.jdbi3.strategies;
 import io.dropwizard.metrics5.MetricName;
 import org.jdbi.v3.core.statement.StatementContext;
 
-/**
- * Interface for strategies to statement contexts to metric names.
- */
+/** Interface for strategies to statement contexts to metric names. */
 @FunctionalInterface
 public interface StatementNameStrategy {
 
-    MetricName getStatementName(StatementContext statementContext);
+  MetricName getStatementName(StatementContext statementContext);
 }
--- a/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/TimedAnnotationNameStrategy.java
+++ b/metrics-jdbi3/src/main/java/io/dropwizard/metrics5/jdbi3/strategies/TimedAnnotationNameStrategy.java
@@ -3,46 +3,44 @@ package io.dropwizard.metrics5.jdbi3.strategies;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.annotation.Timed;
+import java.lang.reflect.Method;
 import org.jdbi.v3.core.extension.ExtensionMethod;
 import org.jdbi.v3.core.statement.StatementContext;
 
-import java.lang.reflect.Method;
-
-/**
- * Takes into account the {@link Timed} annotation on extension methods
- */
+/** Takes into account the {@link Timed} annotation on extension methods */
 public class TimedAnnotationNameStrategy implements StatementNameStrategy {
 
-    @Override
-    public MetricName getStatementName(StatementContext statementContext) {
-        final ExtensionMethod extensionMethod = statementContext.getExtensionMethod();
-        if (extensionMethod == null) {
-            return null;
-        }
+  @Override
+  public MetricName getStatementName(StatementContext statementContext) {
+    final ExtensionMethod extensionMethod = statementContext.getExtensionMethod();
+    if (extensionMethod == null) {
+      return null;
+    }
 
-        final Class<?> clazz = extensionMethod.getType();
-        final Timed classTimed = clazz.getAnnotation(Timed.class);
-        final Method method = extensionMethod.getMethod();
-        final Timed methodTimed = method.getAnnotation(Timed.class);
+    final Class<?> clazz = extensionMethod.getType();
+    final Timed classTimed = clazz.getAnnotation(Timed.class);
+    final Method method = extensionMethod.getMethod();
+    final Timed methodTimed = method.getAnnotation(Timed.class);
 
-        // If the method is timed, figure out the name
-        if (methodTimed != null) {
-            String methodName = methodTimed.name().isEmpty() ? method.getName() : methodTimed.name();
-            if (methodTimed.absolute()) {
-                return MetricName.build(methodName);
-            } else {
-                // We need to check if the class has a custom timer name
-                return classTimed == null || classTimed.name().isEmpty() ?
-                        MetricRegistry.name(clazz, methodName) :
-                        MetricRegistry.name(classTimed.name(), methodName);
-            }
-        } else if (classTimed != null) {
-            // Maybe the class is timed?
-            return classTimed.name().isEmpty() ? MetricRegistry.name(clazz, method.getName()) :
-                    MetricRegistry.name(classTimed.name(), method.getName());
-        } else {
-            // No timers neither on the method or the class
-            return null;
-        }
+    // If the method is timed, figure out the name
+    if (methodTimed != null) {
+      String methodName = methodTimed.name().isEmpty() ? method.getName() : methodTimed.name();
+      if (methodTimed.absolute()) {
+        return MetricName.build(methodName);
+      } else {
+        // We need to check if the class has a custom timer name
+        return classTimed == null || classTimed.name().isEmpty()
+            ? MetricRegistry.name(clazz, methodName)
+            : MetricRegistry.name(classTimed.name(), methodName);
+      }
+    } else if (classTimed != null) {
+      // Maybe the class is timed?
+      return classTimed.name().isEmpty()
+          ? MetricRegistry.name(clazz, method.getName())
+          : MetricRegistry.name(classTimed.name(), method.getName());
+    } else {
+      // No timers neither on the method or the class
+      return null;
     }
+  }
 }
--- a/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/AbstractStrategyTest.java
+++ b/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/AbstractStrategyTest.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import org.jdbi.v3.core.statement.StatementContext;
@@ -10,22 +12,19 @@ import org.mockito.junit.jupiter.MockitoExtension;
 import org.mockito.junit.jupiter.MockitoSettings;
 import org.mockito.quality.Strictness;
 
-import static org.mockito.Mockito.when;
-
 @ExtendWith(MockitoExtension.class)
 @MockitoSettings(strictness = Strictness.LENIENT)
 class AbstractStrategyTest {
 
-    MetricRegistry registry = new MetricRegistry();
-    @Mock
-    StatementContext ctx;
+  MetricRegistry registry = new MetricRegistry();
+  @Mock StatementContext ctx;
 
-    @BeforeEach
-    void setUp() throws Exception {
-        when(ctx.getRawSql()).thenReturn("SELECT 1");
-    }
+  @BeforeEach
+  void setUp() throws Exception {
+    when(ctx.getRawSql()).thenReturn("SELECT 1");
+  }
 
-    long getTimerMaxValue(MetricName name) {
-        return registry.timer(name).getSnapshot().getMax();
-    }
+  long getTimerMaxValue(MetricName name) {
+    return registry.timer(name).getSnapshot().getMax();
+  }
 }
--- a/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/BasicSqlNameStrategyTest.java
+++ b/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/BasicSqlNameStrategyTest.java
@@ -1,24 +1,24 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
-import io.dropwizard.metrics5.MetricName;
-import org.jdbi.v3.core.extension.ExtensionMethod;
-import org.junit.jupiter.api.Test;
-
 import static io.dropwizard.metrics5.MetricRegistry.name;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.when;
 
-class BasicSqlNameStrategyTest extends AbstractStrategyTest {
+import io.dropwizard.metrics5.MetricName;
+import org.jdbi.v3.core.extension.ExtensionMethod;
+import org.junit.jupiter.api.Test;
+
+final class BasicSqlNameStrategyTest extends AbstractStrategyTest {
 
-    private final BasicSqlNameStrategy basicSqlNameStrategy = new BasicSqlNameStrategy();
+  private final BasicSqlNameStrategy basicSqlNameStrategy = new BasicSqlNameStrategy();
 
-    @Test
-    void producesMethodNameAsMetric() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(new ExtensionMethod(getClass(), getClass().getMethod("someMethod")));
-        MetricName name = basicSqlNameStrategy.getStatementName(ctx);
-        assertThat(name).isEqualTo(name(getClass(), "someMethod"));
-    }
+  @Test
+  void producesMethodNameAsMetric() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(new ExtensionMethod(getClass(), getClass().getMethod("someMethod")));
+    MetricName name = basicSqlNameStrategy.getStatementName(ctx);
+    assertThat(name).isEqualTo(name(getClass(), "someMethod"));
+  }
 
-    public void someMethod() {
-    }
+  public void someMethod() {}
 }
--- a/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/InstrumentedSqlLoggerTest.java
+++ b/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/InstrumentedSqlLoggerTest.java
@@ -1,61 +1,59 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
+import static org.mockito.Mockito.*;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.jdbi3.InstrumentedSqlLogger;
-import io.dropwizard.metrics5.jdbi3.strategies.StatementNameStrategy;
-import org.jdbi.v3.core.statement.StatementContext;
-import org.junit.jupiter.api.Test;
-
 import java.sql.SQLException;
 import java.time.temporal.ChronoUnit;
 import java.util.concurrent.TimeUnit;
+import org.jdbi.v3.core.statement.StatementContext;
+import org.junit.jupiter.api.Test;
 
-import static org.mockito.Mockito.*;
-
-class InstrumentedSqlLoggerTest {
-    @Test
-    void logsExecutionTime() {
-        final MetricRegistry mockRegistry = mock(MetricRegistry.class);
-        final StatementNameStrategy mockNameStrategy = mock(StatementNameStrategy.class);
-        final InstrumentedSqlLogger logger = new InstrumentedSqlLogger(mockRegistry, mockNameStrategy);
+final class InstrumentedSqlLoggerTest {
+  @Test
+  void logsExecutionTime() {
+    final MetricRegistry mockRegistry = mock();
+    final StatementNameStrategy mockNameStrategy = mock();
+    final InstrumentedSqlLogger logger = new InstrumentedSqlLogger(mockRegistry, mockNameStrategy);
 
-        final StatementContext mockContext = mock(StatementContext.class);
-        final Timer mockTimer = mock(Timer.class);
+    final StatementContext mockContext = mock();
+    final Timer mockTimer = mock();
 
-        final MetricName statementName = MetricName.build("my-fake-name");
-        final long fakeElapsed = 1234L;
+    final MetricName statementName = MetricName.build("my-fake-name");
+    final long fakeElapsed = 1234L;
 
-        when(mockNameStrategy.getStatementName(mockContext)).thenReturn(statementName);
-        when(mockRegistry.timer(statementName)).thenReturn(mockTimer);
+    when(mockNameStrategy.getStatementName(mockContext)).thenReturn(statementName);
+    when(mockRegistry.timer(statementName)).thenReturn(mockTimer);
 
-        when(mockContext.getElapsedTime(ChronoUnit.NANOS)).thenReturn(fakeElapsed);
+    when(mockContext.getElapsedTime(ChronoUnit.NANOS)).thenReturn(fakeElapsed);
 
-        logger.logAfterExecution(mockContext);
+    logger.logAfterExecution(mockContext);
 
-        verify(mockTimer).update(fakeElapsed, TimeUnit.NANOSECONDS);
-    }
+    verify(mockTimer).update(fakeElapsed, TimeUnit.NANOSECONDS);
+  }
 
-    @Test
-    void logsExceptionTime() {
-        final MetricRegistry mockRegistry = mock(MetricRegistry.class);
-        final StatementNameStrategy mockNameStrategy = mock(StatementNameStrategy.class);
-        final InstrumentedSqlLogger logger = new InstrumentedSqlLogger(mockRegistry, mockNameStrategy);
+  @Test
+  void logsExceptionTime() {
+    final MetricRegistry mockRegistry = mock();
+    final StatementNameStrategy mockNameStrategy = mock();
+    final InstrumentedSqlLogger logger = new InstrumentedSqlLogger(mockRegistry, mockNameStrategy);
 
-        final StatementContext mockContext = mock(StatementContext.class);
-        final Timer mockTimer = mock(Timer.class);
+    final StatementContext mockContext = mock();
+    final Timer mockTimer = mock();
 
-        final MetricName statementName = MetricName.build("my-fake-name");
-        final long fakeElapsed = 1234L;
+    final MetricName statementName = MetricName.build("my-fake-name");
+    final long fakeElapsed = 1234L;
 
-        when(mockNameStrategy.getStatementName(mockContext)).thenReturn(statementName);
-        when(mockRegistry.timer(statementName)).thenReturn(mockTimer);
+    when(mockNameStrategy.getStatementName(mockContext)).thenReturn(statementName);
+    when(mockRegistry.timer(statementName)).thenReturn(mockTimer);
 
-        when(mockContext.getElapsedTime(ChronoUnit.NANOS)).thenReturn(fakeElapsed);
+    when(mockContext.getElapsedTime(ChronoUnit.NANOS)).thenReturn(fakeElapsed);
 
-        logger.logException(mockContext, new SQLException());
+    logger.logException(mockContext, new SQLException());
 
-        verify(mockTimer).update(fakeElapsed, TimeUnit.NANOSECONDS);
-    }
+    verify(mockTimer).update(fakeElapsed, TimeUnit.NANOSECONDS);
+  }
 }
--- a/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/NaiveNameStrategyTest.java
+++ b/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/NaiveNameStrategyTest.java
@@ -1,18 +1,17 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
-import io.dropwizard.metrics5.MetricName;
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-class NaiveNameStrategyTest extends AbstractStrategyTest {
+import io.dropwizard.metrics5.MetricName;
+import org.junit.jupiter.api.Test;
 
-    private final NaiveNameStrategy naiveNameStrategy = new NaiveNameStrategy();
+final class NaiveNameStrategyTest extends AbstractStrategyTest {
 
-    @Test
-    void producesSqlRawMetrics() throws Exception {
-        MetricName name = naiveNameStrategy.getStatementName(ctx);
-        assertThat(name.getKey()).isEqualToIgnoringCase("SELECT 1");
-    }
+  private final NaiveNameStrategy naiveNameStrategy = new NaiveNameStrategy();
 
+  @Test
+  void producesSqlRawMetrics() throws Exception {
+    MetricName name = naiveNameStrategy.getStatementName(ctx);
+    assertThat(name.getKey()).isEqualToIgnoringCase("SELECT 1");
+  }
 }
--- a/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/SmartNameStrategyTest.java
+++ b/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/SmartNameStrategyTest.java
@@ -1,73 +1,71 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.jdbi3.InstrumentedTimingCollector;
+import java.util.concurrent.TimeUnit;
 import org.jdbi.v3.core.extension.ExtensionMethod;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.when;
-
-class SmartNameStrategyTest extends AbstractStrategyTest {
+final class SmartNameStrategyTest extends AbstractStrategyTest {
 
-    private final StatementNameStrategy smartNameStrategy = new SmartNameStrategy();
-    private InstrumentedTimingCollector collector;
+  private final StatementNameStrategy smartNameStrategy = new SmartNameStrategy();
+  private InstrumentedTimingCollector collector;
 
-    @BeforeEach
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        collector = new InstrumentedTimingCollector(registry, smartNameStrategy);
-    }
+  @BeforeEach
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    collector = new InstrumentedTimingCollector(registry, smartNameStrategy);
+  }
 
-    @Test
-    void updatesTimerForSqlObjects() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(
-                new ExtensionMethod(getClass(), getClass().getMethod("someMethod")));
+  @Test
+  void updatesTimerForSqlObjects() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(new ExtensionMethod(getClass(), getClass().getMethod("someMethod")));
 
-        collector.collect(TimeUnit.SECONDS.toNanos(1), ctx);
+    collector.collect(TimeUnit.SECONDS.toNanos(1), ctx);
 
-        MetricName name = smartNameStrategy.getStatementName(ctx);
-        assertThat(name).isEqualTo(name(getClass(), "someMethod"));
-        assertThat(getTimerMaxValue(name)).isEqualTo(1000000000);
-    }
+    MetricName name = smartNameStrategy.getStatementName(ctx);
+    assertThat(name).isEqualTo(name(getClass(), "someMethod"));
+    assertThat(getTimerMaxValue(name)).isEqualTo(1000000000);
+  }
 
-    @Test
-    void updatesTimerForRawSql() throws Exception {
-        collector.collect(TimeUnit.SECONDS.toNanos(2), ctx);
+  @Test
+  void updatesTimerForRawSql() throws Exception {
+    collector.collect(TimeUnit.SECONDS.toNanos(2), ctx);
 
-        MetricName name = smartNameStrategy.getStatementName(ctx);
-        assertThat(name).isEqualTo(name("sql", "raw"));
-        assertThat(getTimerMaxValue(name)).isEqualTo(2000000000);
-    }
+    MetricName name = smartNameStrategy.getStatementName(ctx);
+    assertThat(name).isEqualTo(name("sql", "raw"));
+    assertThat(getTimerMaxValue(name)).isEqualTo(2000000000);
+  }
 
-    @Test
-    void updatesTimerForNoRawSql() throws Exception {
-        reset(ctx);
+  @Test
+  void updatesTimerForNoRawSql() throws Exception {
+    reset(ctx);
 
-        collector.collect(TimeUnit.SECONDS.toNanos(2), ctx);
+    collector.collect(TimeUnit.SECONDS.toNanos(2), ctx);
 
-        MetricName name = smartNameStrategy.getStatementName(ctx);
-        assertThat(name).isEqualTo(name("sql", "empty"));
-        assertThat(getTimerMaxValue(name)).isEqualTo(2000000000);
-    }
+    MetricName name = smartNameStrategy.getStatementName(ctx);
+    assertThat(name).isEqualTo(name("sql", "empty"));
+    assertThat(getTimerMaxValue(name)).isEqualTo(2000000000);
+  }
 
-    @Test
-    void updatesTimerForContextClass() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(new ExtensionMethod(getClass(),
-                getClass().getMethod("someMethod")));
-        collector.collect(TimeUnit.SECONDS.toNanos(3), ctx);
+  @Test
+  void updatesTimerForContextClass() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(new ExtensionMethod(getClass(), getClass().getMethod("someMethod")));
+    collector.collect(TimeUnit.SECONDS.toNanos(3), ctx);
 
-        MetricName name = smartNameStrategy.getStatementName(ctx);
-        assertThat(name).isEqualTo(name(getClass(), "someMethod"));
-        assertThat(getTimerMaxValue(name)).isEqualTo(3000000000L);
-    }
+    MetricName name = smartNameStrategy.getStatementName(ctx);
+    assertThat(name).isEqualTo(name(getClass(), "someMethod"));
+    assertThat(getTimerMaxValue(name)).isEqualTo(3000000000L);
+  }
 
-    public void someMethod() {
-    }
+  public void someMethod() {}
 }
--- a/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/TimedAnnotationNameStrategyTest.java
+++ b/metrics-jdbi3/src/test/java/io/dropwizard/metrics5/jdbi3/strategies/TimedAnnotationNameStrategyTest.java
@@ -1,89 +1,104 @@
 package io.dropwizard.metrics5.jdbi3.strategies;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.annotation.Timed;
 import org.jdbi.v3.core.extension.ExtensionMethod;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.when;
-
-class TimedAnnotationNameStrategyTest extends AbstractStrategyTest {
-
-    private final TimedAnnotationNameStrategy timedAnnotationNameStrategy = new TimedAnnotationNameStrategy();
-
-    public interface Foo {
-
-        @Timed
-        void update();
-
-        @Timed(name = "custom-update")
-        void customUpdate();
+final class TimedAnnotationNameStrategyTest extends AbstractStrategyTest {
 
-        @Timed(name = "absolute-update", absolute = true)
-        void absoluteUpdate();
-    }
+  private final TimedAnnotationNameStrategy timedAnnotationNameStrategy =
+      new TimedAnnotationNameStrategy();
 
+  public interface Foo {
 
     @Timed
-    public interface Bar {
-
-        void update();
-    }
-
-    @Timed(name = "custom-bar")
-    public interface CustomBar {
-
-        @Timed(name = "find-by-id")
-        int find(String name);
-    }
-
-    public interface Dummy {
-
-        void show();
-    }
-
-    @Test
-    void testAnnotationOnMethod() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(new ExtensionMethod(Foo.class, Foo.class.getMethod("update")));
-        assertThat(timedAnnotationNameStrategy.getStatementName(ctx))
-                .isEqualTo(MetricName.build("io.dropwizard.metrics5.jdbi3.strategies.TimedAnnotationNameStrategyTest$Foo.update"));
-    }
-
-    @Test
-    void testAnnotationOnMethodWithCustomName() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(new ExtensionMethod(Foo.class, Foo.class.getMethod("customUpdate")));
-        assertThat(timedAnnotationNameStrategy.getStatementName(ctx))
-                .isEqualTo(MetricName.build("io.dropwizard.metrics5.jdbi3.strategies.TimedAnnotationNameStrategyTest$Foo.custom-update"));
-    }
-
-    @Test
-    void testAnnotationOnMethodWithCustomAbsoluteName() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(new ExtensionMethod(Foo.class, Foo.class.getMethod("absoluteUpdate")));
-        assertThat(timedAnnotationNameStrategy.getStatementName(ctx)).isEqualTo(MetricName.build("absolute-update"));
-    }
-
-    @Test
-    void testAnnotationOnClass() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(new ExtensionMethod(Bar.class, Bar.class.getMethod("update")));
-        assertThat(timedAnnotationNameStrategy.getStatementName(ctx))
-                .isEqualTo(MetricName.build("io.dropwizard.metrics5.jdbi3.strategies.TimedAnnotationNameStrategyTest$Bar.update"));
-    }
-
-    @Test
-    void testAnnotationOnMethodAndClassWithCustomNames() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(new ExtensionMethod(CustomBar.class, CustomBar.class.getMethod("find", String.class)));
-        assertThat(timedAnnotationNameStrategy.getStatementName(ctx)).isEqualTo(MetricName.build("custom-bar.find-by-id"));
-    }
-
-    @Test
-    void testNoAnnotations() throws Exception {
-        when(ctx.getExtensionMethod()).thenReturn(new ExtensionMethod(Dummy.class, Dummy.class.getMethod("show")));
-        assertThat(timedAnnotationNameStrategy.getStatementName(ctx)).isNull();
-    }
-
-    @Test
-    void testNoMethod() {
-        assertThat(timedAnnotationNameStrategy.getStatementName(ctx)).isNull();
-    }
-}
\ No newline at end of file
+    void update();
+
+    @Timed(name = "custom-update")
+    void customUpdate();
+
+    @Timed(name = "absolute-update", absolute = true)
+    void absoluteUpdate();
+  }
+
+  @Timed
+  public interface Bar {
+
+    void update();
+  }
+
+  @Timed(name = "custom-bar")
+  public interface CustomBar {
+
+    @Timed(name = "find-by-id")
+    int find(String name);
+  }
+
+  public interface Dummy {
+
+    void show();
+  }
+
+  @Test
+  void annotationOnMethod() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(new ExtensionMethod(Foo.class, Foo.class.getMethod("update")));
+    assertThat(timedAnnotationNameStrategy.getStatementName(ctx))
+        .isEqualTo(
+            MetricName.build(
+                "io.dropwizard.metrics5.jdbi3.strategies.TimedAnnotationNameStrategyTest$Foo.update"));
+  }
+
+  @Test
+  void annotationOnMethodWithCustomName() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(new ExtensionMethod(Foo.class, Foo.class.getMethod("customUpdate")));
+    assertThat(timedAnnotationNameStrategy.getStatementName(ctx))
+        .isEqualTo(
+            MetricName.build(
+                "io.dropwizard.metrics5.jdbi3.strategies.TimedAnnotationNameStrategyTest$Foo.custom-update"));
+  }
+
+  @Test
+  void annotationOnMethodWithCustomAbsoluteName() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(new ExtensionMethod(Foo.class, Foo.class.getMethod("absoluteUpdate")));
+    assertThat(timedAnnotationNameStrategy.getStatementName(ctx))
+        .isEqualTo(MetricName.build("absolute-update"));
+  }
+
+  @Test
+  void annotationOnClass() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(new ExtensionMethod(Bar.class, Bar.class.getMethod("update")));
+    assertThat(timedAnnotationNameStrategy.getStatementName(ctx))
+        .isEqualTo(
+            MetricName.build(
+                "io.dropwizard.metrics5.jdbi3.strategies.TimedAnnotationNameStrategyTest$Bar.update"));
+  }
+
+  @Test
+  void annotationOnMethodAndClassWithCustomNames() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(
+            new ExtensionMethod(CustomBar.class, CustomBar.class.getMethod("find", String.class)));
+    assertThat(timedAnnotationNameStrategy.getStatementName(ctx))
+        .isEqualTo(MetricName.build("custom-bar.find-by-id"));
+  }
+
+  @Test
+  void noAnnotations() throws Exception {
+    when(ctx.getExtensionMethod())
+        .thenReturn(new ExtensionMethod(Dummy.class, Dummy.class.getMethod("show")));
+    assertThat(timedAnnotationNameStrategy.getStatementName(ctx)).isNull();
+  }
+
+  @Test
+  void noMethod() {
+    assertThat(timedAnnotationNameStrategy.getStatementName(ctx)).isNull();
+  }
+}
--- a/metrics-jersey2/src/main/java/io/dropwizard/metrics5/jersey2/InstrumentedResourceMethodApplicationListener.java
+++ b/metrics-jersey2/src/main/java/io/dropwizard/metrics5/jersey2/InstrumentedResourceMethodApplicationListener.java
@@ -1,5 +1,13 @@
 package io.dropwizard.metrics5.jersey2;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.util.Collections.unmodifiableList;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.ExponentiallyDecayingReservoir;
 import io.dropwizard.metrics5.Meter;
@@ -12,541 +20,589 @@ import io.dropwizard.metrics5.annotation.Metered;
 import io.dropwizard.metrics5.annotation.ResponseMetered;
 import io.dropwizard.metrics5.annotation.ResponseMeteredLevel;
 import io.dropwizard.metrics5.annotation.Timed;
-import org.glassfish.jersey.server.ContainerResponse;
-import org.glassfish.jersey.server.model.ModelProcessor;
-import org.glassfish.jersey.server.model.Resource;
-import org.glassfish.jersey.server.model.ResourceMethod;
-import org.glassfish.jersey.server.model.ResourceModel;
-import org.glassfish.jersey.server.monitoring.ApplicationEvent;
-import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
-import org.glassfish.jersey.server.monitoring.RequestEvent;
-import org.glassfish.jersey.server.monitoring.RequestEventListener;
-
-import javax.ws.rs.core.Configuration;
-import javax.ws.rs.ext.Provider;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Collections;
+import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.EnumSet;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import javax.ws.rs.core.Configuration;
+import javax.ws.rs.ext.Provider;
+import org.glassfish.jersey.server.ContainerResponse;
+import org.glassfish.jersey.server.model.ModelProcessor;
+import org.glassfish.jersey.server.model.Resource;
+import org.glassfish.jersey.server.model.ResourceMethod;
+import org.glassfish.jersey.server.model.ResourceModel;
+import org.glassfish.jersey.server.monitoring.ApplicationEvent;
+import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
+import org.glassfish.jersey.server.monitoring.RequestEvent;
+import org.glassfish.jersey.server.monitoring.RequestEventListener;
 
 /**
- * An application event listener that listens for Jersey application initialization to
- * be finished, then creates a map of resource method that have metrics annotations.
- * <p>
- * Finally, it listens for method start events, and returns a {@link RequestEventListener}
- * that updates the relevant metric for suitably annotated methods when it gets the
- * request events indicating that the method is about to be invoked, or just got done
- * being invoked.
+ * An application event listener that listens for Jersey application initialization to be finished,
+ * then creates a map of resource method that have metrics annotations.
+ *
+ * <p>Finally, it listens for method start events, and returns a {@link RequestEventListener} that
+ * updates the relevant metric for suitably annotated methods when it gets the request events
+ * indicating that the method is about to be invoked, or just got done being invoked.
  */
 @Provider
-public class InstrumentedResourceMethodApplicationListener implements ApplicationEventListener, ModelProcessor {
-
-    private static final String[] REQUEST_FILTERING = {"request", "filtering"};
-    private static final String[] RESPONSE_FILTERING = {"response", "filtering"};
-    private static final String TOTAL = "total";
-
-    private final MetricRegistry metrics;
-    private final ConcurrentMap<EventTypeAndMethod, Timer> timers = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, Meter> meters = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters = new ConcurrentHashMap<>();
-
-    private final Clock clock;
-    private final boolean trackFilters;
-    private final Supplier<Reservoir> reservoirSupplier;
-
-    /**
-     * Construct an application event listener using the given metrics registry.
-     * <p>
-     * When using this constructor, the {@link InstrumentedResourceMethodApplicationListener}
-     * should be added to a Jersey {@code ResourceConfig} as a singleton.
-     *
-     * @param metrics a {@link MetricRegistry}
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics) {
-        this(metrics, Clock.defaultClock(), false);
-    }
-
-    /**
-     * Constructs a custom application listener.
-     *
-     * @param metrics      the metrics registry where the metrics will be stored
-     * @param clock        the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters whether the processing time for request and response filters should be tracked
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics, final Clock clock,
-                                                         final boolean trackFilters) {
-        this(metrics, clock, trackFilters, ExponentiallyDecayingReservoir::new);
-    }
-
-    /**
-     * Constructs a custom application listener.
-     *
-     * @param metrics           the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics, final Clock clock,
-                                                         final boolean trackFilters,
-                                                         final Supplier<Reservoir> reservoirSupplier) {
-        this.metrics = metrics;
-        this.clock = clock;
-        this.trackFilters = trackFilters;
-        this.reservoirSupplier = reservoirSupplier;
-    }
-
-    /**
-     * A private class to maintain the metric for a method annotated with the
-     * {@link ExceptionMetered} annotation, which needs to maintain both a meter
-     * and a cause for which the meter should be updated.
-     */
-    private static class ExceptionMeterMetric {
-        public final Meter meter;
-        public final Class<? extends Throwable> cause;
-
-        public ExceptionMeterMetric(final MetricRegistry registry,
-                                    final ResourceMethod method,
-                                    final ExceptionMetered exceptionMetered) {
-            final MetricName name = chooseName(exceptionMetered.name(),
-                    exceptionMetered.absolute(), method, ExceptionMetered.DEFAULT_NAME_SUFFIX);
-            this.meter = registry.meter(name);
-            this.cause = exceptionMetered.cause();
-        }
+public class InstrumentedResourceMethodApplicationListener
+    implements ApplicationEventListener, ModelProcessor {
+
+  private static final String[] REQUEST_FILTERING = {"request", "filtering"};
+  private static final String[] RESPONSE_FILTERING = {"response", "filtering"};
+  private static final String TOTAL = "total";
+
+  private final MetricRegistry metrics;
+  private final ConcurrentMap<EventTypeAndMethod, Timer> timers = new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, Meter> meters = new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters =
+      new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters =
+      new ConcurrentHashMap<>();
+
+  private final Clock clock;
+  private final boolean trackFilters;
+  private final Supplier<Reservoir> reservoirSupplier;
+
+  /**
+   * Construct an application event listener using the given metrics registry.
+   *
+   * <p>When using this constructor, the {@link InstrumentedResourceMethodApplicationListener}
+   * should be added to a Jersey {@code ResourceConfig} as a singleton.
+   *
+   * @param metrics a {@link MetricRegistry}
+   */
+  public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics) {
+    this(metrics, Clock.defaultClock(), false);
+  }
+
+  /**
+   * Constructs a custom application listener.
+   *
+   * @param metrics the metrics registry where the metrics will be stored
+   * @param clock the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters whether the processing time for request and response filters should be
+   *     tracked
+   */
+  public InstrumentedResourceMethodApplicationListener(
+      final MetricRegistry metrics, final Clock clock, final boolean trackFilters) {
+    this(metrics, clock, trackFilters, ExponentiallyDecayingReservoir::new);
+  }
+
+  /**
+   * Constructs a custom application listener.
+   *
+   * @param metrics the metrics registry where the metrics will be stored
+   * @param clock the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters whether the processing time for request and response filters should be
+   *     tracked
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public InstrumentedResourceMethodApplicationListener(
+      final MetricRegistry metrics,
+      final Clock clock,
+      final boolean trackFilters,
+      final Supplier<Reservoir> reservoirSupplier) {
+    this.metrics = metrics;
+    this.clock = clock;
+    this.trackFilters = trackFilters;
+    this.reservoirSupplier = reservoirSupplier;
+  }
+
+  /**
+   * A private class to maintain the metric for a method annotated with the {@link ExceptionMetered}
+   * annotation, which needs to maintain both a meter and a cause for which the meter should be
+   * updated.
+   */
+  private static class ExceptionMeterMetric {
+    public final Meter meter;
+    public final Class<? extends Throwable> cause;
+
+    public ExceptionMeterMetric(
+        final MetricRegistry registry,
+        final ResourceMethod method,
+        final ExceptionMetered exceptionMetered) {
+      final MetricName name =
+          chooseName(
+              exceptionMetered.name(),
+              exceptionMetered.absolute(),
+              method,
+              ExceptionMetered.DEFAULT_NAME_SUFFIX);
+      this.meter = registry.meter(name);
+      this.cause = exceptionMetered.cause();
     }
-
-    /**
-     * A private class to maintain the metrics for a method annotated with the
-     * {@link ResponseMetered} annotation, which needs to maintain meters for
-     * different response codes
-     */
-    private static class ResponseMeterMetric {
-        private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
-        private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
-        private final MetricName metricName;
-        private final List<Meter> meters;
-        private final Map<Integer, Meter> responseCodeMeters;
-        private final MetricRegistry metricRegistry;
-        private final ResponseMeteredLevel level;
-
-        public ResponseMeterMetric(final MetricRegistry registry,
-                                   final ResourceMethod method,
-                                   final ResponseMetered responseMetered) {
-            this.metricName = chooseName(responseMetered.name(), responseMetered.absolute(), method);
-            this.level = responseMetered.level();
-            this.meters = COARSE_METER_LEVELS.contains(level) ?
-                    Collections.unmodifiableList(Arrays.asList(
-                    registry.meter(metricName.resolve("1xx-responses")), // 1xx
-                    registry.meter(metricName.resolve("2xx-responses")), // 2xx
-                    registry.meter(metricName.resolve("3xx-responses")), // 3xx
-                    registry.meter(metricName.resolve("4xx-responses")), // 4xx
-                    registry.meter(metricName.resolve("5xx-responses"))  // 5xx
-            )) : Collections.emptyList();
-            this.responseCodeMeters = DETAILED_METER_LEVELS.contains(level) ? new ConcurrentHashMap<>() : Collections.emptyMap();
-            this.metricRegistry = registry;
-        }
-
-        public void mark(int statusCode) {
-            if (DETAILED_METER_LEVELS.contains(level)) {
-                getResponseCodeMeter(statusCode).mark();
-            }
-
-            if (COARSE_METER_LEVELS.contains(level)) {
-                final int responseStatus = statusCode / 100;
-                if (responseStatus >= 1 && responseStatus <= 5) {
-                    meters.get(responseStatus - 1).mark();
-                }
-            }
-        }
-
-        private Meter getResponseCodeMeter(int statusCode) {
-            return responseCodeMeters
-                    .computeIfAbsent(statusCode, sc -> metricRegistry
-                            .meter(metricName.resolve(String.format("%d-responses", sc))));
-        }
+  }
+
+  /**
+   * A private class to maintain the metrics for a method annotated with the {@link ResponseMetered}
+   * annotation, which needs to maintain meters for different response codes
+   */
+  private static class ResponseMeterMetric {
+    private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
+    private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS =
+        EnumSet.of(DETAILED, ALL);
+    private final MetricName metricName;
+    private final List<Meter> meters;
+    private final Map<Integer, Meter> responseCodeMeters;
+    private final MetricRegistry metricRegistry;
+    private final ResponseMeteredLevel level;
+
+    public ResponseMeterMetric(
+        final MetricRegistry registry,
+        final ResourceMethod method,
+        final ResponseMetered responseMetered) {
+      this.metricName = chooseName(responseMetered.name(), responseMetered.absolute(), method);
+      this.level = responseMetered.level();
+      this.meters =
+          COARSE_METER_LEVELS.contains(level)
+              ? unmodifiableList(
+                  Arrays.asList(
+                      registry.meter(metricName.resolve("1xx-responses")), // 1xx
+                      registry.meter(metricName.resolve("2xx-responses")), // 2xx
+                      registry.meter(metricName.resolve("3xx-responses")), // 3xx
+                      registry.meter(metricName.resolve("4xx-responses")), // 4xx
+                      registry.meter(metricName.resolve("5xx-responses")) // 5xx
+                      ))
+              : ImmutableList.of();
+      this.responseCodeMeters =
+          DETAILED_METER_LEVELS.contains(level) ? new ConcurrentHashMap<>() : ImmutableMap.of();
+      this.metricRegistry = registry;
     }
 
-    private static class TimerRequestEventListener implements RequestEventListener {
+    public void mark(int statusCode) {
+      if (DETAILED_METER_LEVELS.contains(level)) {
+        getResponseCodeMeter(statusCode).mark();
+      }
 
-        private final ConcurrentMap<EventTypeAndMethod, Timer> timers;
-        private final Clock clock;
-        private final long start;
-        private Timer.Context resourceMethodStartContext;
-        private Timer.Context requestMatchedContext;
-        private Timer.Context responseFiltersStartContext;
-
-        public TimerRequestEventListener(final ConcurrentMap<EventTypeAndMethod, Timer> timers, final Clock clock) {
-            this.timers = timers;
-            this.clock = clock;
-            start = clock.getTick();
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            switch (event.getType()) {
-                case RESOURCE_METHOD_START:
-                    resourceMethodStartContext = context(event);
-                    break;
-                case REQUEST_MATCHED:
-                    requestMatchedContext = context(event);
-                    break;
-                case RESP_FILTERS_START:
-                    responseFiltersStartContext = context(event);
-                    break;
-                case RESOURCE_METHOD_FINISHED:
-                    if (resourceMethodStartContext != null) {
-                        resourceMethodStartContext.close();
-                    }
-                    break;
-                case REQUEST_FILTERED:
-                    if (requestMatchedContext != null) {
-                        requestMatchedContext.close();
-                    }
-                    break;
-                case RESP_FILTERS_FINISHED:
-                    if (responseFiltersStartContext != null) {
-                        responseFiltersStartContext.close();
-                    }
-                    break;
-                case FINISHED:
-                    if (requestMatchedContext != null && responseFiltersStartContext != null) {
-                        final Timer timer = timer(event);
-                        if (timer != null) {
-                            timer.update(clock.getTick() - start, TimeUnit.NANOSECONDS);
-                        }
-                    }
-                    break;
-                default:
-                    break;
-            }
-        }
-
-        private Timer timer(RequestEvent event) {
-            final ResourceMethod resourceMethod = event.getUriInfo().getMatchedResourceMethod();
-            if (resourceMethod == null) {
-                return null;
-            }
-            return timers.get(new EventTypeAndMethod(event.getType(), resourceMethod.getInvocable().getDefinitionMethod()));
-        }
-
-        private Timer.Context context(RequestEvent event) {
-            final Timer timer = timer(event);
-            return timer != null ? timer.time() : null;
+      if (COARSE_METER_LEVELS.contains(level)) {
+        final int responseStatus = statusCode / 100;
+        if (responseStatus >= 1 && responseStatus <= 5) {
+          meters.get(responseStatus - 1).mark();
         }
+      }
     }
 
-    private static class MeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, Meter> meters;
-
-        public MeterRequestEventListener(final ConcurrentMap<Method, Meter> meters) {
-            this.meters = meters;
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.RESOURCE_METHOD_START) {
-                final Meter meter = this.meters.get(event.getUriInfo().getMatchedResourceMethod().getInvocable().getDefinitionMethod());
-                if (meter != null) {
-                    meter.mark();
-                }
-            }
-        }
+    private Meter getResponseCodeMeter(int statusCode) {
+      return responseCodeMeters.computeIfAbsent(
+          statusCode,
+          sc -> metricRegistry.meter(metricName.resolve(String.format("%d-responses", sc))));
     }
+  }
 
-    private static class ExceptionMeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters;
+  private static class TimerRequestEventListener implements RequestEventListener {
 
-        public ExceptionMeterRequestEventListener(final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters) {
-            this.exceptionMeters = exceptionMeters;
-        }
+    private final ConcurrentMap<EventTypeAndMethod, Timer> timers;
+    private final Clock clock;
+    private final long start;
+    private Timer.Context resourceMethodStartContext;
+    private Timer.Context requestMatchedContext;
+    private Timer.Context responseFiltersStartContext;
+
+    public TimerRequestEventListener(
+        final ConcurrentMap<EventTypeAndMethod, Timer> timers, final Clock clock) {
+      this.timers = timers;
+      this.clock = clock;
+      start = clock.getTick();
+    }
 
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.ON_EXCEPTION) {
-                final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
-                final ExceptionMeterMetric metric = (method != null) ?
-                        this.exceptionMeters.get(method.getInvocable().getDefinitionMethod()) : null;
-
-                if (metric != null) {
-                    if (metric.cause.isAssignableFrom(event.getException().getClass()) ||
-                            (event.getException().getCause() != null &&
-                                    metric.cause.isAssignableFrom(event.getException().getCause().getClass()))) {
-                        metric.meter.mark();
-                    }
-                }
+    @Override
+    public void onEvent(RequestEvent event) {
+      switch (event.getType()) {
+        case RESOURCE_METHOD_START:
+          resourceMethodStartContext = context(event);
+          break;
+        case REQUEST_MATCHED:
+          requestMatchedContext = context(event);
+          break;
+        case RESP_FILTERS_START:
+          responseFiltersStartContext = context(event);
+          break;
+        case RESOURCE_METHOD_FINISHED:
+          if (resourceMethodStartContext != null) {
+            resourceMethodStartContext.close();
+          }
+          break;
+        case REQUEST_FILTERED:
+          if (requestMatchedContext != null) {
+            requestMatchedContext.close();
+          }
+          break;
+        case RESP_FILTERS_FINISHED:
+          if (responseFiltersStartContext != null) {
+            responseFiltersStartContext.close();
+          }
+          break;
+        case FINISHED:
+          if (requestMatchedContext != null && responseFiltersStartContext != null) {
+            final Timer timer = timer(event);
+            if (timer != null) {
+              timer.update(clock.getTick() - start, TimeUnit.NANOSECONDS);
             }
-        }
+          }
+          break;
+        default:
+          break;
+      }
     }
 
-    private static class ResponseMeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters;
-
-        public ResponseMeterRequestEventListener(final ConcurrentMap<Method, ResponseMeterMetric> responseMeters) {
-            this.responseMeters = responseMeters;
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.FINISHED) {
-                final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
-                final ResponseMeterMetric metric = (method != null) ?
-                        this.responseMeters.get(method.getInvocable().getDefinitionMethod()) : null;
-
-                if (metric != null) {
-                    ContainerResponse containerResponse = event.getContainerResponse();
-                    if (containerResponse == null && event.getException() != null) {
-                        metric.mark(500);
-                    } else if (containerResponse != null) {
-                        metric.mark(containerResponse.getStatus());
-                    }
-                }
-            }
-        }
+    private Timer timer(RequestEvent event) {
+      final ResourceMethod resourceMethod = event.getUriInfo().getMatchedResourceMethod();
+      if (resourceMethod == null) {
+        return null;
+      }
+      return timers.get(
+          new EventTypeAndMethod(
+              event.getType(), resourceMethod.getInvocable().getDefinitionMethod()));
     }
 
-    private static class ChainedRequestEventListener implements RequestEventListener {
-        private final RequestEventListener[] listeners;
+    private Timer.Context context(RequestEvent event) {
+      final Timer timer = timer(event);
+      return timer != null ? timer.time() : null;
+    }
+  }
 
-        private ChainedRequestEventListener(final RequestEventListener... listeners) {
-            this.listeners = listeners;
-        }
+  private static class MeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, Meter> meters;
 
-        @Override
-        public void onEvent(final RequestEvent event) {
-            for (RequestEventListener listener : listeners) {
-                listener.onEvent(event);
-            }
-        }
+    public MeterRequestEventListener(final ConcurrentMap<Method, Meter> meters) {
+      this.meters = meters;
     }
 
     @Override
-    public void onEvent(ApplicationEvent event) {
-        if (event.getType() == ApplicationEvent.Type.INITIALIZATION_APP_FINISHED) {
-            registerMetricsForModel(event.getResourceModel());
-        }
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.RESOURCE_METHOD_START) {
+        final Meter meter =
+            this.meters.get(
+                event.getUriInfo().getMatchedResourceMethod().getInvocable().getDefinitionMethod());
+        if (meter != null) {
+          meter.mark();
+        }
+      }
     }
+  }
 
-    @Override
-    public ResourceModel processResourceModel(ResourceModel resourceModel, Configuration configuration) {
-        return resourceModel;
+  private static class ExceptionMeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters;
+
+    public ExceptionMeterRequestEventListener(
+        final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters) {
+      this.exceptionMeters = exceptionMeters;
     }
 
     @Override
-    public ResourceModel processSubResource(ResourceModel subResourceModel, Configuration configuration) {
-        registerMetricsForModel(subResourceModel);
-        return subResourceModel;
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.ON_EXCEPTION) {
+        final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
+        final ExceptionMeterMetric metric =
+            (method != null)
+                ? this.exceptionMeters.get(method.getInvocable().getDefinitionMethod())
+                : null;
+
+        if (metric != null) {
+          if (metric.cause.isInstance(event.getException())
+              || (event.getException().getCause() != null
+                  && metric.cause.isInstance(event.getException().getCause()))) {
+            metric.meter.mark();
+          }
+        }
+      }
     }
+  }
 
-    private void registerMetricsForModel(ResourceModel resourceModel) {
-        for (final Resource resource : resourceModel.getResources()) {
-
-            final Timed classLevelTimed = getClassLevelAnnotation(resource, Timed.class);
-            final Metered classLevelMetered = getClassLevelAnnotation(resource, Metered.class);
-            final ExceptionMetered classLevelExceptionMetered = getClassLevelAnnotation(resource, ExceptionMetered.class);
-            final ResponseMetered classLevelResponseMetered = getClassLevelAnnotation(resource, ResponseMetered.class);
-
-            for (final ResourceMethod method : resource.getAllMethods()) {
-                registerTimedAnnotations(method, classLevelTimed);
-                registerMeteredAnnotations(method, classLevelMetered);
-                registerExceptionMeteredAnnotations(method, classLevelExceptionMetered);
-                registerResponseMeteredAnnotations(method, classLevelResponseMetered);
-            }
-
-            for (final Resource childResource : resource.getChildResources()) {
+  private static class ResponseMeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters;
 
-                final Timed classLevelTimedChild = getClassLevelAnnotation(childResource, Timed.class);
-                final Metered classLevelMeteredChild = getClassLevelAnnotation(childResource, Metered.class);
-                final ExceptionMetered classLevelExceptionMeteredChild = getClassLevelAnnotation(childResource, ExceptionMetered.class);
-                final ResponseMetered classLevelResponseMeteredChild = getClassLevelAnnotation(childResource, ResponseMetered.class);
-
-                for (final ResourceMethod method : childResource.getAllMethods()) {
-                    registerTimedAnnotations(method, classLevelTimedChild);
-                    registerMeteredAnnotations(method, classLevelMeteredChild);
-                    registerExceptionMeteredAnnotations(method, classLevelExceptionMeteredChild);
-                    registerResponseMeteredAnnotations(method, classLevelResponseMeteredChild);
-                }
-            }
-        }
+    public ResponseMeterRequestEventListener(
+        final ConcurrentMap<Method, ResponseMeterMetric> responseMeters) {
+      this.responseMeters = responseMeters;
     }
 
     @Override
-    public RequestEventListener onRequest(final RequestEvent event) {
-        final RequestEventListener listener = new ChainedRequestEventListener(
-                new TimerRequestEventListener(timers, clock),
-                new MeterRequestEventListener(meters),
-                new ExceptionMeterRequestEventListener(exceptionMeters),
-                new ResponseMeterRequestEventListener(responseMeters));
-
-        return listener;
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.FINISHED) {
+        final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
+        final ResponseMeterMetric metric =
+            (method != null)
+                ? this.responseMeters.get(method.getInvocable().getDefinitionMethod())
+                : null;
+
+        if (metric != null) {
+          ContainerResponse containerResponse = event.getContainerResponse();
+          if (containerResponse == null && event.getException() != null) {
+            metric.mark(500);
+          } else if (containerResponse != null) {
+            metric.mark(containerResponse.getStatus());
+          }
+        }
+      }
     }
+  }
 
-    private <T extends Annotation> T getClassLevelAnnotation(final Resource resource, final Class<T> annotationClazz) {
-        T annotation = null;
+  private static class ChainedRequestEventListener implements RequestEventListener {
+    private final RequestEventListener[] listeners;
 
-        for (final Class<?> clazz : resource.getHandlerClasses()) {
-            annotation = clazz.getAnnotation(annotationClazz);
-
-            if (annotation != null) {
-                break;
-            }
-        }
-        return annotation;
+    private ChainedRequestEventListener(final RequestEventListener... listeners) {
+      this.listeners = listeners;
     }
 
-    private void registerTimedAnnotations(final ResourceMethod method, final Timed classLevelTimed) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
-        if (classLevelTimed != null) {
-            registerTimers(method, definitionMethod, classLevelTimed);
-            return;
-        }
-
-        final Timed annotation = definitionMethod.getAnnotation(Timed.class);
-        if (annotation != null) {
-            registerTimers(method, definitionMethod, annotation);
-        }
+    @Override
+    public void onEvent(final RequestEvent event) {
+      for (RequestEventListener listener : listeners) {
+        listener.onEvent(event);
+      }
     }
+  }
 
-    private void registerTimers(ResourceMethod method, Method definitionMethod, Timed annotation) {
-        timers.putIfAbsent(EventTypeAndMethod.requestMethodStart(definitionMethod), timerMetric(metrics, method, annotation));
-        if (trackFilters) {
-            timers.putIfAbsent(EventTypeAndMethod.requestMatched(definitionMethod), timerMetric(metrics, method, annotation, REQUEST_FILTERING));
-            timers.putIfAbsent(EventTypeAndMethod.respFiltersStart(definitionMethod), timerMetric(metrics, method, annotation, RESPONSE_FILTERING));
-            timers.putIfAbsent(EventTypeAndMethod.finished(definitionMethod), timerMetric(metrics, method, annotation, TOTAL));
-        }
+  @Override
+  public void onEvent(ApplicationEvent event) {
+    if (event.getType() == ApplicationEvent.Type.INITIALIZATION_APP_FINISHED) {
+      registerMetricsForModel(event.getResourceModel());
+    }
+  }
+
+  @Override
+  public ResourceModel processResourceModel(
+      ResourceModel resourceModel, Configuration configuration) {
+    return resourceModel;
+  }
+
+  @Override
+  public ResourceModel processSubResource(
+      ResourceModel subResourceModel, Configuration configuration) {
+    registerMetricsForModel(subResourceModel);
+    return subResourceModel;
+  }
+
+  private void registerMetricsForModel(ResourceModel resourceModel) {
+    for (final Resource resource : resourceModel.getResources()) {
+
+      final Timed classLevelTimed = getClassLevelAnnotation(resource, Timed.class);
+      final Metered classLevelMetered = getClassLevelAnnotation(resource, Metered.class);
+      final ExceptionMetered classLevelExceptionMetered =
+          getClassLevelAnnotation(resource, ExceptionMetered.class);
+      final ResponseMetered classLevelResponseMetered =
+          getClassLevelAnnotation(resource, ResponseMetered.class);
+
+      for (final ResourceMethod method : resource.getAllMethods()) {
+        registerTimedAnnotations(method, classLevelTimed);
+        registerMeteredAnnotations(method, classLevelMetered);
+        registerExceptionMeteredAnnotations(method, classLevelExceptionMetered);
+        registerResponseMeteredAnnotations(method, classLevelResponseMetered);
+      }
+
+      for (final Resource childResource : resource.getChildResources()) {
+
+        final Timed classLevelTimedChild = getClassLevelAnnotation(childResource, Timed.class);
+        final Metered classLevelMeteredChild =
+            getClassLevelAnnotation(childResource, Metered.class);
+        final ExceptionMetered classLevelExceptionMeteredChild =
+            getClassLevelAnnotation(childResource, ExceptionMetered.class);
+        final ResponseMetered classLevelResponseMeteredChild =
+            getClassLevelAnnotation(childResource, ResponseMetered.class);
+
+        for (final ResourceMethod method : childResource.getAllMethods()) {
+          registerTimedAnnotations(method, classLevelTimedChild);
+          registerMeteredAnnotations(method, classLevelMeteredChild);
+          registerExceptionMeteredAnnotations(method, classLevelExceptionMeteredChild);
+          registerResponseMeteredAnnotations(method, classLevelResponseMeteredChild);
+        }
+      }
+    }
+  }
+
+  @Override
+  public RequestEventListener onRequest(final RequestEvent event) {
+    return new ChainedRequestEventListener(
+        new TimerRequestEventListener(timers, clock),
+        new MeterRequestEventListener(meters),
+        new ExceptionMeterRequestEventListener(exceptionMeters),
+        new ResponseMeterRequestEventListener(responseMeters));
+  }
+
+  private <T extends Annotation> T getClassLevelAnnotation(
+      final Resource resource, final Class<T> annotationClazz) {
+    T annotation = null;
+
+    for (final Class<?> clazz : resource.getHandlerClasses()) {
+      annotation = clazz.getAnnotation(annotationClazz);
+
+      if (annotation != null) {
+        break;
+      }
+    }
+    return annotation;
+  }
+
+  private void registerTimedAnnotations(final ResourceMethod method, final Timed classLevelTimed) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (classLevelTimed != null) {
+      registerTimers(method, definitionMethod, classLevelTimed);
+      return;
     }
 
-    private void registerMeteredAnnotations(final ResourceMethod method, final Metered classLevelMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    final Timed annotation = definitionMethod.getAnnotation(Timed.class);
+    if (annotation != null) {
+      registerTimers(method, definitionMethod, annotation);
+    }
+  }
+
+  private void registerTimers(ResourceMethod method, Method definitionMethod, Timed annotation) {
+    timers.putIfAbsent(
+        EventTypeAndMethod.requestMethodStart(definitionMethod),
+        timerMetric(metrics, method, annotation));
+    if (trackFilters) {
+      timers.putIfAbsent(
+          EventTypeAndMethod.requestMatched(definitionMethod),
+          timerMetric(metrics, method, annotation, REQUEST_FILTERING));
+      timers.putIfAbsent(
+          EventTypeAndMethod.respFiltersStart(definitionMethod),
+          timerMetric(metrics, method, annotation, RESPONSE_FILTERING));
+      timers.putIfAbsent(
+          EventTypeAndMethod.finished(definitionMethod),
+          timerMetric(metrics, method, annotation, TOTAL));
+    }
+  }
 
-        if (classLevelMetered != null) {
-            meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, classLevelMetered));
-            return;
-        }
-        final Metered annotation = definitionMethod.getAnnotation(Metered.class);
+  private void registerMeteredAnnotations(
+      final ResourceMethod method, final Metered classLevelMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, annotation));
-        }
+    if (classLevelMetered != null) {
+      meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, classLevelMetered));
+      return;
     }
+    final Metered annotation = definitionMethod.getAnnotation(Metered.class);
 
-    private void registerExceptionMeteredAnnotations(final ResourceMethod method, final ExceptionMetered classLevelExceptionMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (annotation != null) {
+      meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, annotation));
+    }
+  }
 
-        if (classLevelExceptionMetered != null) {
-            exceptionMeters.putIfAbsent(definitionMethod, new ExceptionMeterMetric(metrics, method, classLevelExceptionMetered));
-            return;
-        }
-        final ExceptionMetered annotation = definitionMethod.getAnnotation(ExceptionMetered.class);
+  private void registerExceptionMeteredAnnotations(
+      final ResourceMethod method, final ExceptionMetered classLevelExceptionMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            exceptionMeters.putIfAbsent(definitionMethod, new ExceptionMeterMetric(metrics, method, annotation));
-        }
+    if (classLevelExceptionMetered != null) {
+      exceptionMeters.putIfAbsent(
+          definitionMethod, new ExceptionMeterMetric(metrics, method, classLevelExceptionMetered));
+      return;
     }
+    final ExceptionMetered annotation = definitionMethod.getAnnotation(ExceptionMetered.class);
 
-    private void registerResponseMeteredAnnotations(final ResourceMethod method, final ResponseMetered classLevelResponseMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (annotation != null) {
+      exceptionMeters.putIfAbsent(
+          definitionMethod, new ExceptionMeterMetric(metrics, method, annotation));
+    }
+  }
 
-        if (classLevelResponseMetered != null) {
-            responseMeters.putIfAbsent(definitionMethod, new ResponseMeterMetric(metrics, method, classLevelResponseMetered));
-            return;
-        }
-        final ResponseMetered annotation = definitionMethod.getAnnotation(ResponseMetered.class);
+  private void registerResponseMeteredAnnotations(
+      final ResourceMethod method, final ResponseMetered classLevelResponseMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            responseMeters.putIfAbsent(definitionMethod, new ResponseMeterMetric(metrics, method, annotation));
-        }
+    if (classLevelResponseMetered != null) {
+      responseMeters.putIfAbsent(
+          definitionMethod, new ResponseMeterMetric(metrics, method, classLevelResponseMetered));
+      return;
     }
+    final ResponseMetered annotation = definitionMethod.getAnnotation(ResponseMetered.class);
 
-    private Timer timerMetric(final MetricRegistry registry,
-                              final ResourceMethod method,
-                              final Timed timed,
-                              final String... suffixes) {
-        final MetricName name = chooseName(timed.name(), timed.absolute(), method, suffixes);
-        return registry.timer(name, () -> new Timer(reservoirSupplier.get(), clock));
+    if (annotation != null) {
+      responseMeters.putIfAbsent(
+          definitionMethod, new ResponseMeterMetric(metrics, method, annotation));
     }
-
-    private Meter meterMetric(final MetricRegistry registry,
-                              final ResourceMethod method,
-                              final Metered metered) {
-        final MetricName name = chooseName(metered.name(), metered.absolute(), method);
-        return registry.meter(name, () -> new Meter(clock));
+  }
+
+  private Timer timerMetric(
+      final MetricRegistry registry,
+      final ResourceMethod method,
+      final Timed timed,
+      final String... suffixes) {
+    final MetricName name = chooseName(timed.name(), timed.absolute(), method, suffixes);
+    return registry.timer(name, () -> new Timer(reservoirSupplier.get(), clock));
+  }
+
+  private Meter meterMetric(
+      final MetricRegistry registry, final ResourceMethod method, final Metered metered) {
+    final MetricName name = chooseName(metered.name(), metered.absolute(), method);
+    return registry.meter(name, () -> new Meter(clock));
+  }
+
+  protected static MetricName chooseName(
+      final String explicitName,
+      final boolean absolute,
+      final ResourceMethod method,
+      final String... suffixes) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    MetricName metricName;
+    if (!Strings.isNullOrEmpty(explicitName)) {
+      metricName =
+          absolute
+              ? MetricRegistry.name(explicitName)
+              : MetricRegistry.name(definitionMethod.getDeclaringClass(), explicitName);
+    } else {
+      metricName =
+          MetricRegistry.name(definitionMethod.getDeclaringClass(), definitionMethod.getName());
     }
-
-    protected static MetricName chooseName(final String explicitName, final boolean absolute, final ResourceMethod method,
-                                       final String... suffixes) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
-        MetricName metricName;
-        if (explicitName != null && !explicitName.isEmpty()) {
-            metricName = absolute ? MetricRegistry.name(explicitName) : MetricRegistry.name(definitionMethod.getDeclaringClass(), explicitName);
-        } else {
-            metricName = MetricRegistry.name(definitionMethod.getDeclaringClass(), definitionMethod.getName());
-        }
-        for (String suffix : suffixes) {
-            metricName = metricName.resolve(suffix);
-        }
-        return metricName;
+    for (String suffix : suffixes) {
+      metricName = metricName.resolve(suffix);
     }
+    return metricName;
+  }
 
-    private static class EventTypeAndMethod {
+  private static class EventTypeAndMethod {
 
-        private final RequestEvent.Type type;
-        private final Method method;
-
-        private EventTypeAndMethod(RequestEvent.Type type, Method method) {
-            this.type = type;
-            this.method = method;
-        }
-
-        static EventTypeAndMethod requestMethodStart(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.RESOURCE_METHOD_START, method);
-        }
+    private final RequestEvent.Type type;
+    private final Method method;
 
-        static EventTypeAndMethod requestMatched(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.REQUEST_MATCHED, method);
-        }
+    private EventTypeAndMethod(RequestEvent.Type type, Method method) {
+      this.type = type;
+      this.method = method;
+    }
 
-        static EventTypeAndMethod respFiltersStart(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.RESP_FILTERS_START, method);
-        }
+    static EventTypeAndMethod requestMethodStart(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.RESOURCE_METHOD_START, method);
+    }
 
-        static EventTypeAndMethod finished(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.FINISHED, method);
-        }
+    static EventTypeAndMethod requestMatched(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.REQUEST_MATCHED, method);
+    }
 
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
+    static EventTypeAndMethod respFiltersStart(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.RESP_FILTERS_START, method);
+    }
 
-            EventTypeAndMethod that = (EventTypeAndMethod) o;
+    static EventTypeAndMethod finished(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.FINISHED, method);
+    }
 
-            if (type != that.type) {
-                return false;
-            }
-            return method.equals(that.method);
-        }
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+
+      EventTypeAndMethod that = (EventTypeAndMethod) o;
+
+      if (type != that.type) {
+        return false;
+      }
+      return method.equals(that.method);
+    }
 
-        @Override
-        public int hashCode() {
-            int result = type.hashCode();
-            result = 31 * result + method.hashCode();
-            return result;
-        }
+    @Override
+    public int hashCode() {
+      int result = type.hashCode();
+      return 31 * result + method.hashCode();
     }
+  }
 }
--- a/metrics-jersey2/src/main/java/io/dropwizard/metrics5/jersey2/MetricsFeature.java
+++ b/metrics-jersey2/src/main/java/io/dropwizard/metrics5/jersey2/MetricsFeature.java
@@ -5,93 +5,98 @@ import io.dropwizard.metrics5.ExponentiallyDecayingReservoir;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Reservoir;
 import io.dropwizard.metrics5.SharedMetricRegistries;
-
+import java.util.function.Supplier;
 import javax.ws.rs.core.Feature;
 import javax.ws.rs.core.FeatureContext;
-import java.util.function.Supplier;
 
 /**
- * A {@link Feature} which registers a {@link InstrumentedResourceMethodApplicationListener}
- * for recording request events.
+ * A {@link Feature} which registers a {@link InstrumentedResourceMethodApplicationListener} for
+ * recording request events.
  */
 public class MetricsFeature implements Feature {
 
-    private final MetricRegistry registry;
-    private final Clock clock;
-    private final boolean trackFilters;
-    private final Supplier<Reservoir> reservoirSupplier;
+  private final MetricRegistry registry;
+  private final Clock clock;
+  private final boolean trackFilters;
+  private final Supplier<Reservoir> reservoirSupplier;
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     */
-    public MetricsFeature(MetricRegistry registry) {
-        this(registry, Clock.defaultClock());
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   */
+  public MetricsFeature(MetricRegistry registry) {
+    this(registry, Clock.defaultClock());
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public MetricsFeature(MetricRegistry registry, Supplier<Reservoir> reservoirSupplier) {
-        this(registry, Clock.defaultClock(), false, reservoirSupplier);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public MetricsFeature(MetricRegistry registry, Supplier<Reservoir> reservoirSupplier) {
+    this(registry, Clock.defaultClock(), false, reservoirSupplier);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock) {
-        this(registry, clock, false);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   */
+  public MetricsFeature(MetricRegistry registry, Clock clock) {
+    this(registry, clock, false);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters) {
-        this(registry, clock, trackFilters, ExponentiallyDecayingReservoir::new);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters      whether the processing time for request and response filters should be tracked
+   */
+  public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters) {
+    this(registry, clock, trackFilters, ExponentiallyDecayingReservoir::new);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters, Supplier<Reservoir> reservoirSupplier) {
-        this.registry = registry;
-        this.clock = clock;
-        this.trackFilters = trackFilters;
-        this.reservoirSupplier = reservoirSupplier;
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters      whether the processing time for request and response filters should be tracked
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public MetricsFeature(
+      MetricRegistry registry,
+      Clock clock,
+      boolean trackFilters,
+      Supplier<Reservoir> reservoirSupplier) {
+    this.registry = registry;
+    this.clock = clock;
+    this.trackFilters = trackFilters;
+    this.reservoirSupplier = reservoirSupplier;
+  }
 
-    public MetricsFeature(String registryName) {
-        this(SharedMetricRegistries.getOrCreate(registryName));
-    }
+  public MetricsFeature(String registryName) {
+    this(SharedMetricRegistries.getOrCreate(registryName));
+  }
 
-    /**
-     * A call-back method called when the feature is to be enabled in a given
-     * runtime configuration scope.
-     * <p>
-     * The responsibility of the feature is to properly update the supplied runtime configuration context
-     * and return {@code true} if the feature was successfully enabled or {@code false} otherwise.
-     * <p>
-     * Note that under some circumstances the feature may decide not to enable itself, which
-     * is indicated by returning {@code false}. In such case the configuration context does
-     * not add the feature to the collection of enabled features and a subsequent call to
-     * {@link javax.ws.rs.core.Configuration#isEnabled(javax.ws.rs.core.Feature)} or
-     * {@link javax.ws.rs.core.Configuration#isEnabled(Class)} method
-     * would return {@code false}.
-     * <p>
-     *
-     * @param context configurable context in which the feature should be enabled.
-     * @return {@code true} if the feature was successfully enabled, {@code false}
-     * otherwise.
-     */
-    @Override
-    public boolean configure(FeatureContext context) {
-        context.register(new InstrumentedResourceMethodApplicationListener(registry, clock, trackFilters, reservoirSupplier));
-        return true;
-    }
+  /**
+   * A call-back method called when the feature is to be enabled in a given runtime configuration
+   * scope.
+   *
+   * <p>The responsibility of the feature is to properly update the supplied runtime configuration
+   * context and return {@code true} if the feature was successfully enabled or {@code false}
+   * otherwise.
+   *
+   * <p>Note that under some circumstances the feature may decide not to enable itself, which is
+   * indicated by returning {@code false}. In such case the configuration context does not add the
+   * feature to the collection of enabled features and a subsequent call to {@link
+   * javax.ws.rs.core.Configuration#isEnabled(javax.ws.rs.core.Feature)} or {@link
+   * javax.ws.rs.core.Configuration#isEnabled(Class)} method would return {@code false}.
+   *
+   * <p>
+   *
+   * @param context configurable context in which the feature should be enabled.
+   * @return {@code true} if the feature was successfully enabled, {@code false} otherwise.
+   */
+  @Override
+  public boolean configure(FeatureContext context) {
+    context.register(
+        new InstrumentedResourceMethodApplicationListener(
+            registry, clock, trackFilters, reservoirSupplier));
+    return true;
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/CustomReservoirImplementationTest.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/CustomReservoirImplementationTest.java
@@ -1,45 +1,44 @@
 package io.dropwizard.metrics5.jersey2;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.UniformReservoir;
-import io.dropwizard.metrics5.jersey2.MetricsFeature;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedResourceTimedPerClass;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.ws.rs.core.Application;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import javax.ws.rs.core.Application;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
-class CustomReservoirImplementationTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class CustomReservoirImplementationTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        return new ResourceConfig()
+    return new ResourceConfig()
         .register(new MetricsFeature(this.registry, UniformReservoir::new))
         .register(InstrumentedResourceTimedPerClass.class);
-    }
+  }
 
-    @Test
-    void timerHistogramIsUsingCustomReservoirImplementation() {
-        assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
+  @Test
+  void timerHistogramIsUsingCustomReservoirImplementation() {
+    assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Timer timer = registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
-        assertThat(timer)
+    final Timer timer =
+        registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
+    assertThat(timer)
         .extracting("histogram")
         .extracting("reservoir")
         .isInstanceOf(UniformReservoir.class);
-    }
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonFilterMetricsJerseyTest.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonFilterMetricsJerseyTest.java
@@ -1,161 +1,146 @@
 package io.dropwizard.metrics5.jersey2;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedFilteredResource;
 import io.dropwizard.metrics5.jersey2.resources.TestRequestFilter;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.ws.rs.core.Application;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import javax.ws.rs.core.Application;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig} with filter tracking
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig} with filter tracking
  */
-class SingletonFilterMetricsJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    private TestClock testClock;
-
-    @Override
-    protected Application configure() {
-        registry = new MetricRegistry();
-        testClock = new TestClock();
-        ResourceConfig config = new ResourceConfig();
-        config = config.register(new MetricsFeature(this.registry, testClock, true));
-        config = config.register(new TestRequestFilter(testClock));
-        config = config.register(new InstrumentedFilteredResource(testClock));
-        return config;
-    }
-
-    @BeforeEach
-    void resetClock() {
-        testClock.tick = 0;
-    }
-
-    @Test
-    void timedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "timed"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void explicitNamesAreTimed() {
-        assertThat(target("named")
-        .request()
-        .get(String.class))
-        .isEqualTo("fancy");
-
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "fancyName"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void absoluteNamesAreTimed() {
-        assertThat(target("absolute")
-        .request()
-        .get(String.class))
-        .isEqualTo("absolute");
-
-        final Timer timer = registry.timer("absolutelyFancy");
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void requestFiltersOfTimedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "timed", "request", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void responseFiltersOfTimedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "timed", "response", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void totalTimeOfTimedMethodsIsTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "timed", "total"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(5);
-    }
-
-    @Test
-    void requestFiltersOfNamedMethodsAreTimed() {
-        assertThat(target("named")
-        .request()
-        .get(String.class))
-        .isEqualTo("fancy");
-
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "fancyName", "request", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void requestFiltersOfAbsoluteMethodsAreTimed() {
-        assertThat(target("absolute")
-        .request()
-        .get(String.class))
-        .isEqualTo("absolute");
-
-        final Timer timer = registry.timer(MetricRegistry.name("absolutelyFancy", "request", "filtering"));
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void subResourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedFilteredResource.InstrumentedFilteredSubResource.class,
-        "timed"));
-        assertThat(timer.getCount()).isEqualTo(1);
-
-    }
+final class SingletonFilterMetricsJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
+
+  private MetricRegistry registry;
+
+  private TestClock testClock;
+
+  @Override
+  protected Application configure() {
+    registry = new MetricRegistry();
+    testClock = new TestClock();
+    ResourceConfig config = new ResourceConfig();
+    config = config.register(new MetricsFeature(this.registry, testClock, true));
+    config = config.register(new TestRequestFilter(testClock));
+    return config.register(new InstrumentedFilteredResource(testClock));
+  }
+
+  @BeforeEach
+  void resetClock() {
+    testClock.tick = 0;
+  }
+
+  @Test
+  void timedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "timed"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void explicitNamesAreTimed() {
+    assertThat(target("named").request().get(String.class)).isEqualTo("fancy");
+
+    final Timer timer =
+        registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "fancyName"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void absoluteNamesAreTimed() {
+    assertThat(target("absolute").request().get(String.class)).isEqualTo("absolute");
+
+    final Timer timer = registry.timer("absolutelyFancy");
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void requestFiltersOfTimedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(
+            MetricRegistry.name(
+                InstrumentedFilteredResource.class, "timed", "request", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void responseFiltersOfTimedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(
+            MetricRegistry.name(
+                InstrumentedFilteredResource.class, "timed", "response", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void totalTimeOfTimedMethodsIsTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(MetricRegistry.name(InstrumentedFilteredResource.class, "timed", "total"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(5);
+  }
+
+  @Test
+  void requestFiltersOfNamedMethodsAreTimed() {
+    assertThat(target("named").request().get(String.class)).isEqualTo("fancy");
+
+    final Timer timer =
+        registry.timer(
+            MetricRegistry.name(
+                InstrumentedFilteredResource.class, "fancyName", "request", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void requestFiltersOfAbsoluteMethodsAreTimed() {
+    assertThat(target("absolute").request().get(String.class)).isEqualTo("absolute");
+
+    final Timer timer =
+        registry.timer(MetricRegistry.name("absolutelyFancy", "request", "filtering"));
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void subResourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(
+            MetricRegistry.name(
+                InstrumentedFilteredResource.InstrumentedFilteredSubResource.class, "timed"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsExceptionMeteredPerClassJerseyTest.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsExceptionMeteredPerClassJerseyTest.java
@@ -1,97 +1,91 @@
 package io.dropwizard.metrics5.jersey2;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedResourceExceptionMeteredPerClass;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedSubResourceExceptionMeteredPerClass;
-import org.glassfish.jersey.server.ResourceConfig;
-import org.glassfish.jersey.test.JerseyTest;
-import org.junit.jupiter.api.Test;
-
-import javax.ws.rs.ProcessingException;
-import javax.ws.rs.core.Application;
 import java.io.IOException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import javax.ws.rs.ProcessingException;
+import javax.ws.rs.core.Application;
+import org.glassfish.jersey.server.ResourceConfig;
+import org.glassfish.jersey.test.JerseyTest;
+import org.junit.jupiter.api.Test;
 
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsExceptionMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class SingletonMetricsExceptionMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        ResourceConfig config = new ResourceConfig();
+    ResourceConfig config = new ResourceConfig();
 
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceExceptionMeteredPerClass.class);
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceExceptionMeteredPerClass.class);
+  }
 
-        return config;
-    }
-
-    @Test
-    void exceptionMeteredMethodsAreExceptionMetered() {
-        final Meter meter = registry.meter(MetricRegistry.name(InstrumentedResourceExceptionMeteredPerClass.class,
-        "exceptionMetered",
-        "exceptions"));
-
-        assertThat(target("exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
+  @Test
+  void exceptionMeteredMethodsAreExceptionMetered() {
+    final Meter meter =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedResourceExceptionMeteredPerClass.class,
+                "exceptionMetered",
+                "exceptions"));
 
-        assertThat(meter.getCount()).isZero();
+    assertThat(target("exception-metered").request().get(String.class)).isEqualTo("fuh");
 
-        try {
-            target("exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+    assertThat(meter.getCount()).isEqualTo(0);
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
+    try {
+      target("exception-metered").queryParam("splode", true).request().get(String.class);
 
-        assertThat(meter.getCount()).isEqualTo(1);
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        final Meter meter = registry.meter(MetricRegistry.name(InstrumentedSubResourceExceptionMeteredPerClass.class,
-        "exceptionMetered",
-        "exceptions"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
-        assertThat(target("subresource/exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    final Meter meter =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedSubResourceExceptionMeteredPerClass.class,
+                "exceptionMetered",
+                "exceptions"));
 
-        assertThat(meter.getCount()).isZero();
+    assertThat(target("subresource/exception-metered").request().get(String.class))
+        .isEqualTo("fuh");
 
-        try {
-            target("subresource/exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+    assertThat(meter.getCount()).isEqualTo(0);
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
+    try {
+      target("subresource/exception-metered")
+          .queryParam("splode", true)
+          .request()
+          .get(String.class);
 
-        assertThat(meter.getCount()).isEqualTo(1);
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsJerseyTest.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsJerseyTest.java
@@ -1,155 +1,127 @@
 package io.dropwizard.metrics5.jersey2;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedResource;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedSubResource;
-import org.glassfish.jersey.client.ClientResponse;
-import org.glassfish.jersey.server.ResourceConfig;
-import org.glassfish.jersey.test.JerseyTest;
-import org.junit.jupiter.api.Test;
-
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import javax.ws.rs.NotFoundException;
 import javax.ws.rs.ProcessingException;
 import javax.ws.rs.core.Application;
 import javax.ws.rs.core.Response;
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import org.glassfish.jersey.client.ClientResponse;
+import org.glassfish.jersey.server.ResourceConfig;
+import org.glassfish.jersey.test.JerseyTest;
+import org.junit.jupiter.api.Test;
 
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link org.glassfish.jersey.server.ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link org.glassfish.jersey.server.ResourceConfig}
  */
-class SingletonMetricsJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class SingletonMetricsJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        ResourceConfig config = new ResourceConfig();
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResource.class);
+    ResourceConfig config = new ResourceConfig();
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResource.class);
+  }
 
-        return config;
-    }
+  @Test
+  void timedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
 
-    @Test
-    void timedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+    final Timer timer = registry.timer(MetricRegistry.name(InstrumentedResource.class, "timed"));
 
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedResource.class, "timed"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
+  @Test
+  void meteredMethodsAreMetered() {
+    assertThat(target("metered").request().get(String.class)).isEqualTo("woo");
 
-    @Test
-    void meteredMethodsAreMetered() {
-        assertThat(target("metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("woo");
+    final Meter meter = registry.meter(MetricRegistry.name(InstrumentedResource.class, "metered"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
-        final Meter meter = registry.meter(MetricRegistry.name(InstrumentedResource.class, "metered"));
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void exceptionMeteredMethodsAreExceptionMetered() {
-        final Meter meter = registry.meter(MetricRegistry.name(InstrumentedResource.class,
-        "exceptionMetered",
-        "exceptions"));
+  @Test
+  void exceptionMeteredMethodsAreExceptionMetered() {
+    final Meter meter =
+        registry.meter(
+            MetricRegistry.name(InstrumentedResource.class, "exceptionMetered", "exceptions"));
 
-        assertThat(target("exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
+    assertThat(target("exception-metered").request().get(String.class)).isEqualTo("fuh");
 
-        assertThat(meter.getCount()).isZero();
+    assertThat(meter.getCount()).isEqualTo(0);
 
-        try {
-            target("exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+    try {
+      target("exception-metered").queryParam("splode", true).request().get(String.class);
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
-
-        assertThat(meter.getCount()).isEqualTo(1);
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
-    @Test
-    void responseMeteredMethodsAreMetered() {
-        final Meter meter2xx = registry.meter(MetricRegistry.name(InstrumentedResource.class,
-        "response2xxMetered",
-        "2xx-responses"));
-        final Meter meter4xx = registry.meter(MetricRegistry.name(InstrumentedResource.class,
-        "response4xxMetered",
-        "4xx-responses"));
-        final Meter meter5xx = registry.meter(MetricRegistry.name(InstrumentedResource.class,
-        "response5xxMetered",
-        "5xx-responses"));
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(target("response-2xx-metered")
-        .request()
-        .get().getStatus())
-        .isEqualTo(200);
-
-        assertThat(meter4xx.getCount()).isZero();
-        assertThat(target("response-4xx-metered")
-        .request()
-        .get().getStatus())
-        .isEqualTo(400);
-
-        assertThat(meter5xx.getCount()).isZero();
-        assertThat(target("response-5xx-metered")
-        .request()
-        .get().getStatus())
-        .isEqualTo(500);
-
-        assertThat(meter2xx.getCount()).isEqualTo(1);
-        assertThat(meter4xx.getCount()).isEqualTo(1);
-        assertThat(meter5xx.getCount()).isEqualTo(1);
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMethodsAreMetered() {
+    final Meter meter2xx =
+        registry.meter(
+            MetricRegistry.name(InstrumentedResource.class, "response2xxMetered", "2xx-responses"));
+    final Meter meter4xx =
+        registry.meter(
+            MetricRegistry.name(InstrumentedResource.class, "response4xxMetered", "4xx-responses"));
+    final Meter meter5xx =
+        registry.meter(
+            MetricRegistry.name(InstrumentedResource.class, "response5xxMetered", "5xx-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(target("response-2xx-metered").request().get().getStatus()).isEqualTo(200);
+
+    assertThat(meter4xx.getCount()).isEqualTo(0);
+    assertThat(target("response-4xx-metered").request().get().getStatus()).isEqualTo(400);
+
+    assertThat(meter5xx.getCount()).isEqualTo(0);
+    assertThat(target("response-5xx-metered").request().get().getStatus()).isEqualTo(500);
+
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+    assertThat(meter4xx.getCount()).isEqualTo(1);
+    assertThat(meter5xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void resourceNotFound() {
+    final Response response = target().path("not-found").request().get();
+    assertThat(response.getStatus()).isEqualTo(404);
+
+    try {
+      target().path("not-found").request().get(ClientResponse.class);
+      failBecauseExceptionWasNotThrown(NotFoundException.class);
+    } catch (NotFoundException e) {
+      assertThat(e.getMessage()).isEqualTo("HTTP 404 Not Found");
     }
+  }
 
-    @Test
-    void testResourceNotFound() {
-        final Response response = target().path("not-found").request().get();
-        assertThat(response.getStatus()).isEqualTo(404);
-
-        try {
-            target().path("not-found").request().get(ClientResponse.class);
-            failBecauseExceptionWasNotThrown(NotFoundException.class);
-        } catch (NotFoundException e) {
-            assertThat(e.getMessage()).isEqualTo("HTTP 404 Not Found");
-        }
-    }
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timed").request().get(String.class)).isEqualTo("yay");
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedSubResource.class, "timed"));
-        assertThat(timer.getCount()).isEqualTo(1);
-
-    }
+    final Timer timer = registry.timer(MetricRegistry.name(InstrumentedSubResource.class, "timed"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsMeteredPerClassJerseyTest.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsMeteredPerClassJerseyTest.java
@@ -1,65 +1,57 @@
 package io.dropwizard.metrics5.jersey2;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedResourceMeteredPerClass;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedSubResourceMeteredPerClass;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.ws.rs.core.Application;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import javax.ws.rs.core.Application;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-        ResourceConfig config = new ResourceConfig();
-
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceMeteredPerClass.class);
+final class SingletonMetricsMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-        return config;
-    }
+  private MetricRegistry registry;
 
-    @Test
-    void meteredPerClassMethodsAreMetered() {
-        assertThat(target("meteredPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        final Meter meter = registry.meter(MetricRegistry.name(InstrumentedResourceMeteredPerClass.class, "meteredPerClass"));
+    ResourceConfig config = new ResourceConfig();
 
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceMeteredPerClass.class);
+  }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/meteredPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Test
+  void meteredPerClassMethodsAreMetered() {
+    assertThat(target("meteredPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Meter meter = registry.meter(MetricRegistry.name(InstrumentedSubResourceMeteredPerClass.class, "meteredPerClass"));
-        assertThat(meter.getCount()).isEqualTo(1);
+    final Meter meter =
+        registry.meter(
+            MetricRegistry.name(InstrumentedResourceMeteredPerClass.class, "meteredPerClass"));
 
-    }
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/meteredPerClass").request().get(String.class)).isEqualTo("yay");
 
+    final Meter meter =
+        registry.meter(
+            MetricRegistry.name(InstrumentedSubResourceMeteredPerClass.class, "meteredPerClass"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsResponseMeteredPerClassJerseyTest.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsResponseMeteredPerClassJerseyTest.java
@@ -1,138 +1,138 @@
 package io.dropwizard.metrics5.jersey2;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey2.exception.mapper.TestExceptionMapper;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedResourceResponseMeteredPerClass;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedSubResourceResponseMeteredPerClass;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.ws.rs.core.Application;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import javax.ws.rs.core.Application;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.fail;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsResponseMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-
-        ResourceConfig config = new ResourceConfig();
-
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceResponseMeteredPerClass.class);
-        config = config.register(new TestExceptionMapper());
-
-        return config;
-    }
-
-    @Test
-    void responseMetered2xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered2xxPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(200);
-
-        final Meter meter2xx = registry.meter(MetricRegistry.name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered2xxPerClass",
-        "2xx-responses"));
-
-        assertThat(meter2xx.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void responseMetered4xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered4xxPerClass")
-        .request()
-        .get().getStatus())
+final class SingletonMetricsResponseMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
+
+  private MetricRegistry registry;
+
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
+
+    ResourceConfig config = new ResourceConfig();
+
+    config = config.register(new MetricsFeature(this.registry));
+    config = config.register(InstrumentedResourceResponseMeteredPerClass.class);
+    return config.register(new TestExceptionMapper());
+  }
+
+  @Test
+  void responseMetered2xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered2xxPerClass").request().get().getStatus()).isEqualTo(200);
+
+    final Meter meter2xx =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered2xxPerClass",
+                "2xx-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMetered4xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered4xxPerClass").request().get().getStatus()).isEqualTo(400);
+    assertThat(target("responseMeteredBadRequestPerClass").request().get().getStatus())
         .isEqualTo(400);
-        assertThat(target("responseMeteredBadRequestPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(400);
-
-        final Meter meter4xx = registry.meter(MetricRegistry.name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered4xxPerClass",
-        "4xx-responses"));
-        final Meter meterException4xx = registry.meter(MetricRegistry.name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredBadRequestPerClass",
-        "4xx-responses"));
 
-        assertThat(meter4xx.getCount()).isEqualTo(1);
-        assertThat(meterException4xx.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void responseMetered5xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered5xxPerClass")
-        .request()
-        .get().getStatus())
+    final Meter meter4xx =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered4xxPerClass",
+                "4xx-responses"));
+    final Meter meterException4xx =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredBadRequestPerClass",
+                "4xx-responses"));
+
+    assertThat(meter4xx.getCount()).isEqualTo(1);
+    assertThat(meterException4xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMetered5xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered5xxPerClass").request().get().getStatus()).isEqualTo(500);
+
+    final Meter meter5xx =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered5xxPerClass",
+                "5xx-responses"));
+
+    assertThat(meter5xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMappedExceptionPerClassMethodsAreMetered() {
+    assertThat(target("responseMeteredTestExceptionPerClass").request().get().getStatus())
         .isEqualTo(500);
 
-        final Meter meter5xx = registry.meter(MetricRegistry.name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered5xxPerClass",
-        "5xx-responses"));
-
-        assertThat(meter5xx.getCount()).isEqualTo(1);
+    final Meter meterTestException =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredTestExceptionPerClass",
+                "5xx-responses"));
+
+    assertThat(meterTestException.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredUnmappedExceptionPerClassMethodsAreMetered() {
+    try {
+      target("responseMeteredRuntimeExceptionPerClass").request().get();
+      fail("expected RuntimeException");
+    } catch (Exception e) {
+      assertThat(e.getCause()).isInstanceOf(RuntimeException.class);
     }
 
-    @Test
-    void responseMeteredMappedExceptionPerClassMethodsAreMetered() {
-        assertThat(target("responseMeteredTestExceptionPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(500);
+    final Meter meterException5xx =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredRuntimeExceptionPerClass",
+                "5xx-responses"));
 
-        final Meter meterTestException = registry.meter(MetricRegistry.name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredTestExceptionPerClass",
-        "5xx-responses"));
+    assertThat(meterException5xx.getCount()).isEqualTo(1);
+  }
 
-        assertThat(meterTestException.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void responseMeteredUnmappedExceptionPerClassMethodsAreMetered() {
-        try {
-            target("responseMeteredRuntimeExceptionPerClass")
-            .request()
-            .get();
-            fail("expected RuntimeException");
-        } catch (Exception e) {
-            assertThat(e.getCause()).isInstanceOf(RuntimeException.class);
-        }
-
-        final Meter meterException5xx = registry.meter(MetricRegistry.name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredRuntimeExceptionPerClass",
-        "5xx-responses"));
-
-        assertThat(meterException5xx.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/responseMeteredPerClass")
-        .request()
-        .get().getStatus())
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/responseMeteredPerClass").request().get().getStatus())
         .isEqualTo(200);
 
-        final Meter meter = registry.meter(MetricRegistry.name(InstrumentedSubResourceResponseMeteredPerClass.class,
-        "responseMeteredPerClass",
-        "2xx-responses"));
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
+    final Meter meter =
+        registry.meter(
+            MetricRegistry.name(
+                InstrumentedSubResourceResponseMeteredPerClass.class,
+                "responseMeteredPerClass",
+                "2xx-responses"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsTimedPerClassJerseyTest.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/SingletonMetricsTimedPerClassJerseyTest.java
@@ -1,65 +1,57 @@
 package io.dropwizard.metrics5.jersey2;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedResourceTimedPerClass;
 import io.dropwizard.metrics5.jersey2.resources.InstrumentedSubResourceTimedPerClass;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.ws.rs.core.Application;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import javax.ws.rs.core.Application;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsTimedPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-        ResourceConfig config = new ResourceConfig();
-
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceTimedPerClass.class);
+final class SingletonMetricsTimedPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-        return config;
-    }
+  private MetricRegistry registry;
 
-    @Test
-    void timedPerClassMethodsAreTimed() {
-        assertThat(target("timedPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
+    ResourceConfig config = new ResourceConfig();
 
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceTimedPerClass.class);
+  }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timedPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Test
+  void timedPerClassMethodsAreTimed() {
+    assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Timer timer = registry.timer(MetricRegistry.name(InstrumentedSubResourceTimedPerClass.class, "timedPerClass"));
-        assertThat(timer.getCount()).isEqualTo(1);
+    final Timer timer =
+        registry.timer(
+            MetricRegistry.name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
 
-    }
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timedPerClass").request().get(String.class)).isEqualTo("yay");
 
+    final Timer timer =
+        registry.timer(
+            MetricRegistry.name(InstrumentedSubResourceTimedPerClass.class, "timedPerClass"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/TestClock.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/TestClock.java
@@ -4,10 +4,10 @@ import io.dropwizard.metrics5.Clock;
 
 public class TestClock extends Clock {
 
-    public long tick;
+  public long tick;
 
-    @Override
-    public long getTick() {
-        return tick;
-    }
+  @Override
+  public long getTick() {
+    return tick;
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/exception/TestException.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/exception/TestException.java
@@ -1,9 +1,9 @@
 package io.dropwizard.metrics5.jersey2.exception;
 
 public class TestException extends RuntimeException {
-    private static final long serialVersionUID = 1L;
+  private static final long serialVersionUID = 1L;
 
-    public TestException(String message) {
-        super(message);
-    }
+  public TestException(String message) {
+    super(message);
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/exception/mapper/TestExceptionMapper.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/exception/mapper/TestExceptionMapper.java
@@ -1,15 +1,14 @@
 package io.dropwizard.metrics5.jersey2.exception.mapper;
 
 import io.dropwizard.metrics5.jersey2.exception.TestException;
-
 import javax.ws.rs.core.Response;
 import javax.ws.rs.ext.ExceptionMapper;
 import javax.ws.rs.ext.Provider;
 
 @Provider
 public class TestExceptionMapper implements ExceptionMapper<TestException> {
-    @Override
-    public Response toResponse(TestException exception) {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
+  @Override
+  public Response toResponse(TestException exception) {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedFilteredResource.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedFilteredResource.java
@@ -2,7 +2,6 @@ package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.Timed;
 import io.dropwizard.metrics5.jersey2.TestClock;
-
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
@@ -12,51 +11,50 @@ import javax.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedFilteredResource {
 
-    private final TestClock testClock;
-
-    public InstrumentedFilteredResource(TestClock testClock) {
-        this.testClock = testClock;
-    }
+  private final TestClock testClock;
+
+  public InstrumentedFilteredResource(TestClock testClock) {
+    this.testClock = testClock;
+  }
+
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    testClock.tick++;
+    return "yay";
+  }
+
+  @GET
+  @Path("/named")
+  @Timed(name = "fancyName")
+  public String named() {
+    testClock.tick++;
+    return "fancy";
+  }
+
+  @GET
+  @Path("/absolute")
+  @Timed(name = "absolutelyFancy", absolute = true)
+  public String absolute() {
+    testClock.tick++;
+    return "absolute";
+  }
+
+  @Path("/subresource")
+  public InstrumentedFilteredSubResource locateSubResource() {
+    return new InstrumentedFilteredSubResource();
+  }
+
+  @Produces(MediaType.TEXT_PLAIN)
+  public class InstrumentedFilteredSubResource {
 
     @GET
-    @Timed
     @Path("/timed")
+    @Timed
     public String timed() {
-        testClock.tick++;
-        return "yay";
-    }
-
-    @GET
-    @Timed(name = "fancyName")
-    @Path("/named")
-    public String named() {
-        testClock.tick++;
-        return "fancy";
-    }
-
-    @GET
-    @Timed(name = "absolutelyFancy", absolute = true)
-    @Path("/absolute")
-    public String absolute() {
-        testClock.tick++;
-        return "absolute";
-    }
-
-    @Path("/subresource")
-    public InstrumentedFilteredSubResource locateSubResource() {
-        return new InstrumentedFilteredSubResource();
-    }
-
-    @Produces(MediaType.TEXT_PLAIN)
-    public class InstrumentedFilteredSubResource {
-
-        @GET
-        @Timed
-        @Path("/timed")
-        public String timed() {
-            testClock.tick += 2;
-            return "yay";
-        }
-
+      testClock.tick += 2;
+      return "yay";
     }
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResource.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResource.java
@@ -1,10 +1,14 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+
 import io.dropwizard.metrics5.annotation.ExceptionMetered;
 import io.dropwizard.metrics5.annotation.Metered;
 import io.dropwizard.metrics5.annotation.ResponseMetered;
 import io.dropwizard.metrics5.annotation.Timed;
-
+import java.io.IOException;
 import javax.ws.rs.DefaultValue;
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
@@ -12,83 +16,82 @@ import javax.ws.rs.Produces;
 import javax.ws.rs.QueryParam;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response;
-import java.io.IOException;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
 
 @Path("/")
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResource {
-    @GET
-    @Timed
-    @Path("/timed")
-    public String timed() {
-        return "yay";
-    }
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    return "yay";
+  }
 
-    @GET
-    @Metered
-    @Path("/metered")
-    public String metered() {
-        return "woo";
-    }
+  @GET
+  @Metered
+  @Path("/metered")
+  public String metered() {
+    return "woo";
+  }
 
-    @GET
-    @ExceptionMetered(cause = IOException.class)
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
+  @ExceptionMetered(cause = IOException.class)
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 
-    @GET
-    @ResponseMetered(level = DETAILED)
-    @Path("/response-metered-detailed")
-    public Response responseMeteredDetailed(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-detailed")
+  @ResponseMetered(level = DETAILED)
+  public Response responseMeteredDetailed(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered(level = COARSE)
-    @Path("/response-metered-coarse")
-    public Response responseMeteredCoarse(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-coarse")
+  @ResponseMetered(level = COARSE)
+  public Response responseMeteredCoarse(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered(level = ALL)
-    @Path("/response-metered-all")
-    public Response responseMeteredAll(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-all")
+  @ResponseMetered(level = ALL)
+  public Response responseMeteredAll(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-2xx-metered")
-    public Response response2xxMetered() {
-        return Response.ok().build();
-    }
+  @GET
+  @Path("/response-2xx-metered")
+  @ResponseMetered
+  public Response response2xxMetered() {
+    return Response.ok().build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-4xx-metered")
-    public Response response4xxMetered() {
-        return Response.status(Response.Status.BAD_REQUEST).build();
-    }
+  @GET
+  @Path("/response-4xx-metered")
+  @ResponseMetered
+  public Response response4xxMetered() {
+    return Response.status(Response.Status.BAD_REQUEST).build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-5xx-metered")
-    public Response response5xxMetered() {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
+  @GET
+  @Path("/response-5xx-metered")
+  @ResponseMetered
+  public Response response5xxMetered() {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
 
-    @Path("/subresource")
-    public InstrumentedSubResource locateSubResource() {
-        return new InstrumentedSubResource();
-    }
+  @Path("/subresource")
+  public InstrumentedSubResource locateSubResource() {
+    return new InstrumentedSubResource();
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResourceExceptionMeteredPerClass.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResourceExceptionMeteredPerClass.java
@@ -1,32 +1,31 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.ExceptionMetered;
-
+import java.io.IOException;
 import javax.ws.rs.DefaultValue;
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
 import javax.ws.rs.QueryParam;
 import javax.ws.rs.core.MediaType;
-import java.io.IOException;
 
 @ExceptionMetered(cause = IOException.class)
 @Path("/")
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceExceptionMeteredPerClass {
 
-    @GET
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceExceptionMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceExceptionMeteredPerClass();
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceExceptionMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceExceptionMeteredPerClass();
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResourceMeteredPerClass.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResourceMeteredPerClass.java
@@ -1,7 +1,6 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.Metered;
-
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
@@ -12,15 +11,14 @@ import javax.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceMeteredPerClass {
 
-    @GET
-    @Path("/meteredPerClass")
-    public String meteredPerClass() {
-        return "yay";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceMeteredPerClass();
-    }
+  @GET
+  @Path("/meteredPerClass")
+  public String meteredPerClass() {
+    return "yay";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceMeteredPerClass();
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResourceResponseMeteredPerClass.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResourceResponseMeteredPerClass.java
@@ -2,7 +2,6 @@ package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.ResponseMetered;
 import io.dropwizard.metrics5.jersey2.exception.TestException;
-
 import javax.ws.rs.BadRequestException;
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
@@ -15,45 +14,44 @@ import javax.ws.rs.core.Response;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceResponseMeteredPerClass {
 
-    @GET
-    @Path("/responseMetered2xxPerClass")
-    public Response responseMetered2xxPerClass() {
-        return Response.ok().build();
-    }
-
-    @GET
-    @Path("/responseMetered4xxPerClass")
-    public Response responseMetered4xxPerClass() {
-        return Response.status(Response.Status.BAD_REQUEST).build();
-    }
-
-    @GET
-    @Path("/responseMetered5xxPerClass")
-    public Response responseMetered5xxPerClass() {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
-
-    @GET
-    @Path("/responseMeteredBadRequestPerClass")
-    public String responseMeteredBadRequestPerClass() {
-        throw new BadRequestException();
-    }
-
-    @GET
-    @Path("/responseMeteredRuntimeExceptionPerClass")
-    public String responseMeteredRuntimeExceptionPerClass() {
-        throw new RuntimeException();
-    }
-
-    @GET
-    @Path("/responseMeteredTestExceptionPerClass")
-    public String responseMeteredTestExceptionPerClass() {
-        throw new TestException("test");
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceResponseMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceResponseMeteredPerClass();
-    }
-
+  @GET
+  @Path("/responseMetered2xxPerClass")
+  public Response responseMetered2xxPerClass() {
+    return Response.ok().build();
+  }
+
+  @GET
+  @Path("/responseMetered4xxPerClass")
+  public Response responseMetered4xxPerClass() {
+    return Response.status(Response.Status.BAD_REQUEST).build();
+  }
+
+  @GET
+  @Path("/responseMetered5xxPerClass")
+  public Response responseMetered5xxPerClass() {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
+
+  @GET
+  @Path("/responseMeteredBadRequestPerClass")
+  public String responseMeteredBadRequestPerClass() {
+    throw new BadRequestException();
+  }
+
+  @GET
+  @Path("/responseMeteredRuntimeExceptionPerClass")
+  public String responseMeteredRuntimeExceptionPerClass() {
+    throw new RuntimeException();
+  }
+
+  @GET
+  @Path("/responseMeteredTestExceptionPerClass")
+  public String responseMeteredTestExceptionPerClass() {
+    throw new TestException("test");
+  }
+
+  @Path("/subresource")
+  public InstrumentedSubResourceResponseMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceResponseMeteredPerClass();
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResourceTimedPerClass.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedResourceTimedPerClass.java
@@ -1,7 +1,6 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.Timed;
-
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
@@ -12,15 +11,14 @@ import javax.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceTimedPerClass {
 
-    @GET
-    @Path("/timedPerClass")
-    public String timedPerClass() {
-        return "yay";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceTimedPerClass locateSubResource() {
-        return new InstrumentedSubResourceTimedPerClass();
-    }
+  @GET
+  @Path("/timedPerClass")
+  public String timedPerClass() {
+    return "yay";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceTimedPerClass locateSubResource() {
+    return new InstrumentedSubResourceTimedPerClass();
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResource.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResource.java
@@ -1,7 +1,6 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.Timed;
-
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
@@ -10,11 +9,10 @@ import javax.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResource {
 
-    @GET
-    @Timed
-    @Path("/timed")
-    public String timed() {
-        return "yay";
-    }
-
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    return "yay";
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResourceExceptionMeteredPerClass.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResourceExceptionMeteredPerClass.java
@@ -1,24 +1,24 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.ExceptionMetered;
-
+import java.io.IOException;
 import javax.ws.rs.DefaultValue;
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
 import javax.ws.rs.QueryParam;
 import javax.ws.rs.core.MediaType;
-import java.io.IOException;
 
 @ExceptionMetered(cause = IOException.class)
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceExceptionMeteredPerClass {
-    @GET
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResourceMeteredPerClass.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResourceMeteredPerClass.java
@@ -1,7 +1,6 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.Metered;
-
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
@@ -10,9 +9,9 @@ import javax.ws.rs.core.MediaType;
 @Metered
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceMeteredPerClass {
-    @GET
-    @Path("/meteredPerClass")
-    public String meteredPerClass() {
-        return "yay";
-    }
+  @GET
+  @Path("/meteredPerClass")
+  public String meteredPerClass() {
+    return "yay";
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResourceResponseMeteredPerClass.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResourceResponseMeteredPerClass.java
@@ -1,21 +1,20 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
-import io.dropwizard.metrics5.annotation.ResponseMetered;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
 
+import io.dropwizard.metrics5.annotation.ResponseMetered;
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response;
 
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-
 @ResponseMetered(level = ALL)
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceResponseMeteredPerClass {
-    @GET
-    @Path("/responseMeteredPerClass")
-    public Response responseMeteredPerClass() {
-        return Response.status(Response.Status.OK).build();
-    }
+  @GET
+  @Path("/responseMeteredPerClass")
+  public Response responseMeteredPerClass() {
+    return Response.status(Response.Status.OK).build();
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResourceTimedPerClass.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/InstrumentedSubResourceTimedPerClass.java
@@ -1,7 +1,6 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.annotation.Timed;
-
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;
@@ -10,9 +9,9 @@ import javax.ws.rs.core.MediaType;
 @Timed
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceTimedPerClass {
-    @GET
-    @Path("/timedPerClass")
-    public String timedPerClass() {
-        return "yay";
-    }
+  @GET
+  @Path("/timedPerClass")
+  public String timedPerClass() {
+    return "yay";
+  }
 }
--- a/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/TestRequestFilter.java
+++ b/metrics-jersey2/src/test/java/io/dropwizard/metrics5/jersey2/resources/TestRequestFilter.java
@@ -1,21 +1,20 @@
 package io.dropwizard.metrics5.jersey2.resources;
 
 import io.dropwizard.metrics5.jersey2.TestClock;
-
+import java.io.IOException;
 import javax.ws.rs.container.ContainerRequestContext;
 import javax.ws.rs.container.ContainerRequestFilter;
-import java.io.IOException;
 
 public class TestRequestFilter implements ContainerRequestFilter {
 
-    private final TestClock testClock;
+  private final TestClock testClock;
 
-    public TestRequestFilter(TestClock testClock) {
-        this.testClock = testClock;
-    }
+  public TestRequestFilter(TestClock testClock) {
+    this.testClock = testClock;
+  }
 
-    @Override
-    public void filter(ContainerRequestContext containerRequestContext) throws IOException {
-        testClock.tick += 4;
-    }
+  @Override
+  public void filter(ContainerRequestContext containerRequestContext) throws IOException {
+    testClock.tick += 4;
+  }
 }
--- a/metrics-jersey3/src/main/java/io/dropwizard/metrics5/jersey3/InstrumentedResourceMethodApplicationListener.java
+++ b/metrics-jersey3/src/main/java/io/dropwizard/metrics5/jersey3/InstrumentedResourceMethodApplicationListener.java
@@ -1,5 +1,14 @@
 package io.dropwizard.metrics5.jersey3;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.util.Collections.unmodifiableList;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.ExponentiallyDecayingReservoir;
 import io.dropwizard.metrics5.Meter;
@@ -14,20 +23,9 @@ import io.dropwizard.metrics5.annotation.ResponseMeteredLevel;
 import io.dropwizard.metrics5.annotation.Timed;
 import jakarta.ws.rs.core.Configuration;
 import jakarta.ws.rs.ext.Provider;
-import org.glassfish.jersey.server.ContainerResponse;
-import org.glassfish.jersey.server.model.ModelProcessor;
-import org.glassfish.jersey.server.model.Resource;
-import org.glassfish.jersey.server.model.ResourceMethod;
-import org.glassfish.jersey.server.model.ResourceModel;
-import org.glassfish.jersey.server.monitoring.ApplicationEvent;
-import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
-import org.glassfish.jersey.server.monitoring.RequestEvent;
-import org.glassfish.jersey.server.monitoring.RequestEventListener;
-
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
@@ -36,518 +34,573 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import org.glassfish.jersey.server.ContainerResponse;
+import org.glassfish.jersey.server.model.ModelProcessor;
+import org.glassfish.jersey.server.model.Resource;
+import org.glassfish.jersey.server.model.ResourceMethod;
+import org.glassfish.jersey.server.model.ResourceModel;
+import org.glassfish.jersey.server.monitoring.ApplicationEvent;
+import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
+import org.glassfish.jersey.server.monitoring.RequestEvent;
+import org.glassfish.jersey.server.monitoring.RequestEventListener;
 
 /**
- * An application event listener that listens for Jersey application initialization to
- * be finished, then creates a map of resource method that have metrics annotations.
- * <p>
- * Finally, it listens for method start events, and returns a {@link RequestEventListener}
- * that updates the relevant metric for suitably annotated methods when it gets the
- * request events indicating that the method is about to be invoked, or just got done
- * being invoked.
+ * An application event listener that listens for Jersey application initialization to be finished,
+ * then creates a map of resource method that have metrics annotations.
+ *
+ * <p>Finally, it listens for method start events, and returns a {@link RequestEventListener} that
+ * updates the relevant metric for suitably annotated methods when it gets the request events
+ * indicating that the method is about to be invoked, or just got done being invoked.
  */
 @Provider
-public class InstrumentedResourceMethodApplicationListener implements ApplicationEventListener, ModelProcessor {
-
-    private static final String[] REQUEST_FILTERING = {"request", "filtering"};
-    private static final String[] RESPONSE_FILTERING = {"response", "filtering"};
-    private static final String TOTAL = "total";
-
-    private final MetricRegistry metrics;
-    private final ConcurrentMap<EventTypeAndMethod, Timer> timers = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, Meter> meters = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters = new ConcurrentHashMap<>();
-
-    private final Clock clock;
-    private final boolean trackFilters;
-    private final Supplier<Reservoir> reservoirSupplier;
-
-    /**
-     * Construct an application event listener using the given metrics registry.
-     * <p>
-     * When using this constructor, the {@link InstrumentedResourceMethodApplicationListener}
-     * should be added to a Jersey {@code ResourceConfig} as a singleton.
-     *
-     * @param metrics a {@link MetricRegistry}
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics) {
-        this(metrics, Clock.defaultClock(), false);
-    }
-
-    /**
-     * Constructs a custom application listener.
-     *
-     * @param metrics      the metrics registry where the metrics will be stored
-     * @param clock        the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters whether the processing time for request and response filters should be tracked
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics, final Clock clock,
-                                                         final boolean trackFilters) {
-        this(metrics, clock, trackFilters, ExponentiallyDecayingReservoir::new);
-    }
-
-    /**
-     * Constructs a custom application listener.
-     *
-     * @param metrics           the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics, final Clock clock,
-                                                         final boolean trackFilters,
-                                                         final Supplier<Reservoir> reservoirSupplier) {
-        this.metrics = metrics;
-        this.clock = clock;
-        this.trackFilters = trackFilters;
-        this.reservoirSupplier = reservoirSupplier;
-    }
-
-    /**
-     * A private class to maintain the metric for a method annotated with the
-     * {@link ExceptionMetered} annotation, which needs to maintain both a meter
-     * and a cause for which the meter should be updated.
-     */
-    private static class ExceptionMeterMetric {
-        public final Meter meter;
-        public final Class<? extends Throwable> cause;
-
-        public ExceptionMeterMetric(final MetricRegistry registry,
-                                    final ResourceMethod method,
-                                    final ExceptionMetered exceptionMetered) {
-            final MetricName name = chooseName(exceptionMetered.name(),
-                    exceptionMetered.absolute(), method, ExceptionMetered.DEFAULT_NAME_SUFFIX);
-            this.meter = registry.meter(name);
-            this.cause = exceptionMetered.cause();
-        }
+public class InstrumentedResourceMethodApplicationListener
+    implements ApplicationEventListener, ModelProcessor {
+
+  private static final String[] REQUEST_FILTERING = {"request", "filtering"};
+  private static final String[] RESPONSE_FILTERING = {"response", "filtering"};
+  private static final String TOTAL = "total";
+
+  private final MetricRegistry metrics;
+  private final ConcurrentMap<EventTypeAndMethod, Timer> timers = new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, Meter> meters = new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters =
+      new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters =
+      new ConcurrentHashMap<>();
+
+  private final Clock clock;
+  private final boolean trackFilters;
+  private final Supplier<Reservoir> reservoirSupplier;
+
+  /**
+   * Construct an application event listener using the given metrics registry.
+   *
+   * <p>When using this constructor, the {@link InstrumentedResourceMethodApplicationListener}
+   * should be added to a Jersey {@code ResourceConfig} as a singleton.
+   *
+   * @param metrics a {@link MetricRegistry}
+   */
+  public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics) {
+    this(metrics, Clock.defaultClock(), false);
+  }
+
+  /**
+   * Constructs a custom application listener.
+   *
+   * @param metrics the metrics registry where the metrics will be stored
+   * @param clock the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters whether the processing time for request and response filters should be
+   *     tracked
+   */
+  public InstrumentedResourceMethodApplicationListener(
+      final MetricRegistry metrics, final Clock clock, final boolean trackFilters) {
+    this(metrics, clock, trackFilters, ExponentiallyDecayingReservoir::new);
+  }
+
+  /**
+   * Constructs a custom application listener.
+   *
+   * @param metrics the metrics registry where the metrics will be stored
+   * @param clock the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters whether the processing time for request and response filters should be
+   *     tracked
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public InstrumentedResourceMethodApplicationListener(
+      final MetricRegistry metrics,
+      final Clock clock,
+      final boolean trackFilters,
+      final Supplier<Reservoir> reservoirSupplier) {
+    this.metrics = metrics;
+    this.clock = clock;
+    this.trackFilters = trackFilters;
+    this.reservoirSupplier = reservoirSupplier;
+  }
+
+  /**
+   * A private class to maintain the metric for a method annotated with the {@link ExceptionMetered}
+   * annotation, which needs to maintain both a meter and a cause for which the meter should be
+   * updated.
+   */
+  private static class ExceptionMeterMetric {
+    public final Meter meter;
+    public final Class<? extends Throwable> cause;
+
+    public ExceptionMeterMetric(
+        final MetricRegistry registry,
+        final ResourceMethod method,
+        final ExceptionMetered exceptionMetered) {
+      final MetricName name =
+          chooseName(
+              exceptionMetered.name(),
+              exceptionMetered.absolute(),
+              method,
+              ExceptionMetered.DEFAULT_NAME_SUFFIX);
+      this.meter = registry.meter(name);
+      this.cause = exceptionMetered.cause();
     }
-
-    /**
-     * A private class to maintain the metrics for a method annotated with the
-     * {@link ResponseMetered} annotation, which needs to maintain meters for
-     * different response codes
-     */
-    private static class ResponseMeterMetric {
-        private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
-        private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
-        private final List<Meter> meters;
-        private final Map<Integer, Meter> responseCodeMeters;
-        private final MetricRegistry metricRegistry;
-        private final MetricName metricName;
-        private final ResponseMeteredLevel level;
-
-        public ResponseMeterMetric(final MetricRegistry registry,
-                                   final ResourceMethod method,
-                                   final ResponseMetered responseMetered) {
-            this.metricName = chooseName(responseMetered.name(), responseMetered.absolute(), method);
-            this.level = responseMetered.level();
-            this.meters = COARSE_METER_LEVELS.contains(level) ?
-                    Collections.unmodifiableList(Arrays.asList(
-                            registry.meter(metricName.resolve("1xx-responses")), // 1xx
-                            registry.meter(metricName.resolve("2xx-responses")), // 2xx
-                            registry.meter(metricName.resolve("3xx-responses")), // 3xx
-                            registry.meter(metricName.resolve("4xx-responses")), // 4xx
-                            registry.meter(metricName.resolve("5xx-responses"))  // 5xx
-                    )) : Collections.emptyList();
-            this.responseCodeMeters = DETAILED_METER_LEVELS.contains(level) ? new ConcurrentHashMap<>() : Collections.emptyMap();
-            this.metricRegistry = registry;
-        }
-
-        public void mark(int statusCode) {
-            if (DETAILED_METER_LEVELS.contains(level)) {
-                getResponseCodeMeter(statusCode).mark();
-            }
-
-            if (COARSE_METER_LEVELS.contains(level)) {
-                final int responseStatus = statusCode / 100;
-                if (responseStatus >= 1 && responseStatus <= 5) {
-                    meters.get(responseStatus - 1).mark();
-                }
-            }
-        }
-
-        private Meter getResponseCodeMeter(int statusCode) {
-            return responseCodeMeters
-                    .computeIfAbsent(statusCode, sc -> metricRegistry
-                            .meter(metricName.resolve(String.format("%d-responses", sc))));
-        }
+  }
+
+  /**
+   * A private class to maintain the metrics for a method annotated with the {@link ResponseMetered}
+   * annotation, which needs to maintain meters for different response codes
+   */
+  private static class ResponseMeterMetric {
+    private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
+    private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS =
+        EnumSet.of(DETAILED, ALL);
+    private final List<Meter> meters;
+    private final Map<Integer, Meter> responseCodeMeters;
+    private final MetricRegistry metricRegistry;
+    private final MetricName metricName;
+    private final ResponseMeteredLevel level;
+
+    public ResponseMeterMetric(
+        final MetricRegistry registry,
+        final ResourceMethod method,
+        final ResponseMetered responseMetered) {
+      this.metricName = chooseName(responseMetered.name(), responseMetered.absolute(), method);
+      this.level = responseMetered.level();
+      this.meters =
+          COARSE_METER_LEVELS.contains(level)
+              ? unmodifiableList(
+                  Arrays.asList(
+                      registry.meter(metricName.resolve("1xx-responses")), // 1xx
+                      registry.meter(metricName.resolve("2xx-responses")), // 2xx
+                      registry.meter(metricName.resolve("3xx-responses")), // 3xx
+                      registry.meter(metricName.resolve("4xx-responses")), // 4xx
+                      registry.meter(metricName.resolve("5xx-responses")) // 5xx
+                      ))
+              : ImmutableList.of();
+      this.responseCodeMeters =
+          DETAILED_METER_LEVELS.contains(level) ? new ConcurrentHashMap<>() : ImmutableMap.of();
+      this.metricRegistry = registry;
     }
 
-    private static class TimerRequestEventListener implements RequestEventListener {
-
-        private final ConcurrentMap<EventTypeAndMethod, Timer> timers;
-        private final Clock clock;
-        private final long start;
-        private Timer.Context resourceMethodStartContext;
-        private Timer.Context requestMatchedContext;
-        private Timer.Context responseFiltersStartContext;
-
-        public TimerRequestEventListener(final ConcurrentMap<EventTypeAndMethod, Timer> timers, final Clock clock) {
-            this.timers = timers;
-            this.clock = clock;
-            start = clock.getTick();
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            switch (event.getType()) {
-                case RESOURCE_METHOD_START:
-                    resourceMethodStartContext = context(event);
-                    break;
-                case REQUEST_MATCHED:
-                    requestMatchedContext = context(event);
-                    break;
-                case RESP_FILTERS_START:
-                    responseFiltersStartContext = context(event);
-                    break;
-                case RESOURCE_METHOD_FINISHED:
-                    if (resourceMethodStartContext != null) {
-                        resourceMethodStartContext.close();
-                    }
-                    break;
-                case REQUEST_FILTERED:
-                    if (requestMatchedContext != null) {
-                        requestMatchedContext.close();
-                    }
-                    break;
-                case RESP_FILTERS_FINISHED:
-                    if (responseFiltersStartContext != null) {
-                        responseFiltersStartContext.close();
-                    }
-                    break;
-                case FINISHED:
-                    if (requestMatchedContext != null && responseFiltersStartContext != null) {
-                        final Timer timer = timer(event);
-                        if (timer != null) {
-                            timer.update(clock.getTick() - start, TimeUnit.NANOSECONDS);
-                        }
-                    }
-                    break;
-                default:
-                    break;
-            }
-        }
-
-        private Timer timer(RequestEvent event) {
-            final ResourceMethod resourceMethod = event.getUriInfo().getMatchedResourceMethod();
-            if (resourceMethod == null) {
-                return null;
-            }
-            return timers.get(new EventTypeAndMethod(event.getType(), resourceMethod.getInvocable().getDefinitionMethod()));
-        }
+    public void mark(int statusCode) {
+      if (DETAILED_METER_LEVELS.contains(level)) {
+        getResponseCodeMeter(statusCode).mark();
+      }
 
-        private Timer.Context context(RequestEvent event) {
-            final Timer timer = timer(event);
-            return timer != null ? timer.time() : null;
+      if (COARSE_METER_LEVELS.contains(level)) {
+        final int responseStatus = statusCode / 100;
+        if (responseStatus >= 1 && responseStatus <= 5) {
+          meters.get(responseStatus - 1).mark();
         }
+      }
     }
 
-    private static class MeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, Meter> meters;
-
-        public MeterRequestEventListener(final ConcurrentMap<Method, Meter> meters) {
-            this.meters = meters;
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.RESOURCE_METHOD_START) {
-                final Meter meter = this.meters.get(event.getUriInfo().getMatchedResourceMethod().getInvocable().getDefinitionMethod());
-                if (meter != null) {
-                    meter.mark();
-                }
-            }
-        }
+    private Meter getResponseCodeMeter(int statusCode) {
+      return responseCodeMeters.computeIfAbsent(
+          statusCode,
+          sc -> metricRegistry.meter(metricName.resolve(String.format("%d-responses", sc))));
     }
+  }
 
-    private static class ExceptionMeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters;
+  private static class TimerRequestEventListener implements RequestEventListener {
 
-        public ExceptionMeterRequestEventListener(final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters) {
-            this.exceptionMeters = exceptionMeters;
-        }
+    private final ConcurrentMap<EventTypeAndMethod, Timer> timers;
+    private final Clock clock;
+    private final long start;
+    private Timer.Context resourceMethodStartContext;
+    private Timer.Context requestMatchedContext;
+    private Timer.Context responseFiltersStartContext;
+
+    public TimerRequestEventListener(
+        final ConcurrentMap<EventTypeAndMethod, Timer> timers, final Clock clock) {
+      this.timers = timers;
+      this.clock = clock;
+      start = clock.getTick();
+    }
 
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.ON_EXCEPTION) {
-                final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
-                final ExceptionMeterMetric metric = (method != null) ?
-                        this.exceptionMeters.get(method.getInvocable().getDefinitionMethod()) : null;
-
-                if (metric != null) {
-                    if (metric.cause.isAssignableFrom(event.getException().getClass()) ||
-                            (event.getException().getCause() != null &&
-                                    metric.cause.isAssignableFrom(event.getException().getCause().getClass()))) {
-                        metric.meter.mark();
-                    }
-                }
+    @Override
+    public void onEvent(RequestEvent event) {
+      switch (event.getType()) {
+        case RESOURCE_METHOD_START:
+          resourceMethodStartContext = context(event);
+          break;
+        case REQUEST_MATCHED:
+          requestMatchedContext = context(event);
+          break;
+        case RESP_FILTERS_START:
+          responseFiltersStartContext = context(event);
+          break;
+        case RESOURCE_METHOD_FINISHED:
+          if (resourceMethodStartContext != null) {
+            resourceMethodStartContext.close();
+          }
+          break;
+        case REQUEST_FILTERED:
+          if (requestMatchedContext != null) {
+            requestMatchedContext.close();
+          }
+          break;
+        case RESP_FILTERS_FINISHED:
+          if (responseFiltersStartContext != null) {
+            responseFiltersStartContext.close();
+          }
+          break;
+        case FINISHED:
+          if (requestMatchedContext != null && responseFiltersStartContext != null) {
+            final Timer timer = timer(event);
+            if (timer != null) {
+              timer.update(clock.getTick() - start, TimeUnit.NANOSECONDS);
             }
-        }
+          }
+          break;
+        default:
+          break;
+      }
     }
 
-    private static class ResponseMeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters;
-
-        public ResponseMeterRequestEventListener(final ConcurrentMap<Method, ResponseMeterMetric> responseMeters) {
-            this.responseMeters = responseMeters;
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.FINISHED) {
-                final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
-                final ResponseMeterMetric metric = (method != null) ?
-                        this.responseMeters.get(method.getInvocable().getDefinitionMethod()) : null;
-
-                if (metric != null) {
-                    ContainerResponse containerResponse = event.getContainerResponse();
-                    if (containerResponse == null && event.getException() != null) {
-                        metric.mark(500);
-                    } else if (containerResponse != null) {
-                        metric.mark(containerResponse.getStatus());
-                    }
-                }
-            }
-        }
+    private Timer timer(RequestEvent event) {
+      final ResourceMethod resourceMethod = event.getUriInfo().getMatchedResourceMethod();
+      if (resourceMethod == null) {
+        return null;
+      }
+      return timers.get(
+          new EventTypeAndMethod(
+              event.getType(), resourceMethod.getInvocable().getDefinitionMethod()));
     }
 
-    private static class ChainedRequestEventListener implements RequestEventListener {
-        private final RequestEventListener[] listeners;
+    private Timer.Context context(RequestEvent event) {
+      final Timer timer = timer(event);
+      return timer != null ? timer.time() : null;
+    }
+  }
 
-        private ChainedRequestEventListener(final RequestEventListener... listeners) {
-            this.listeners = listeners;
-        }
+  private static class MeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, Meter> meters;
 
-        @Override
-        public void onEvent(final RequestEvent event) {
-            for (RequestEventListener listener : listeners) {
-                listener.onEvent(event);
-            }
-        }
+    public MeterRequestEventListener(final ConcurrentMap<Method, Meter> meters) {
+      this.meters = meters;
     }
 
     @Override
-    public void onEvent(ApplicationEvent event) {
-        if (event.getType() == ApplicationEvent.Type.INITIALIZATION_APP_FINISHED) {
-            registerMetricsForModel(event.getResourceModel());
-        }
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.RESOURCE_METHOD_START) {
+        final Meter meter =
+            this.meters.get(
+                event.getUriInfo().getMatchedResourceMethod().getInvocable().getDefinitionMethod());
+        if (meter != null) {
+          meter.mark();
+        }
+      }
     }
+  }
 
-    @Override
-    public ResourceModel processResourceModel(ResourceModel resourceModel, Configuration configuration) {
-        return resourceModel;
+  private static class ExceptionMeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters;
+
+    public ExceptionMeterRequestEventListener(
+        final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters) {
+      this.exceptionMeters = exceptionMeters;
     }
 
     @Override
-    public ResourceModel processSubResource(ResourceModel subResourceModel, Configuration configuration) {
-        registerMetricsForModel(subResourceModel);
-        return subResourceModel;
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.ON_EXCEPTION) {
+        final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
+        final ExceptionMeterMetric metric =
+            (method != null)
+                ? this.exceptionMeters.get(method.getInvocable().getDefinitionMethod())
+                : null;
+
+        if (metric != null) {
+          if (metric.cause.isInstance(event.getException())
+              || (event.getException().getCause() != null
+                  && metric.cause.isInstance(event.getException().getCause()))) {
+            metric.meter.mark();
+          }
+        }
+      }
     }
+  }
 
-    private void registerMetricsForModel(ResourceModel resourceModel) {
-        for (final Resource resource : resourceModel.getResources()) {
-
-            final Timed classLevelTimed = getClassLevelAnnotation(resource, Timed.class);
-            final Metered classLevelMetered = getClassLevelAnnotation(resource, Metered.class);
-            final ExceptionMetered classLevelExceptionMetered = getClassLevelAnnotation(resource, ExceptionMetered.class);
-            final ResponseMetered classLevelResponseMetered = getClassLevelAnnotation(resource, ResponseMetered.class);
-
-            for (final ResourceMethod method : resource.getAllMethods()) {
-                registerTimedAnnotations(method, classLevelTimed);
-                registerMeteredAnnotations(method, classLevelMetered);
-                registerExceptionMeteredAnnotations(method, classLevelExceptionMetered);
-                registerResponseMeteredAnnotations(method, classLevelResponseMetered);
-            }
-
-            for (final Resource childResource : resource.getChildResources()) {
-
-                final Timed classLevelTimedChild = getClassLevelAnnotation(childResource, Timed.class);
-                final Metered classLevelMeteredChild = getClassLevelAnnotation(childResource, Metered.class);
-                final ExceptionMetered classLevelExceptionMeteredChild = getClassLevelAnnotation(childResource, ExceptionMetered.class);
-                final ResponseMetered classLevelResponseMeteredChild = getClassLevelAnnotation(childResource, ResponseMetered.class);
+  private static class ResponseMeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters;
 
-                for (final ResourceMethod method : childResource.getAllMethods()) {
-                    registerTimedAnnotations(method, classLevelTimedChild);
-                    registerMeteredAnnotations(method, classLevelMeteredChild);
-                    registerExceptionMeteredAnnotations(method, classLevelExceptionMeteredChild);
-                    registerResponseMeteredAnnotations(method, classLevelResponseMeteredChild);
-                }
-            }
-        }
+    public ResponseMeterRequestEventListener(
+        final ConcurrentMap<Method, ResponseMeterMetric> responseMeters) {
+      this.responseMeters = responseMeters;
     }
 
     @Override
-    public RequestEventListener onRequest(final RequestEvent event) {
-        final RequestEventListener listener = new ChainedRequestEventListener(
-                new TimerRequestEventListener(timers, clock),
-                new MeterRequestEventListener(meters),
-                new ExceptionMeterRequestEventListener(exceptionMeters),
-                new ResponseMeterRequestEventListener(responseMeters));
-
-        return listener;
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.FINISHED) {
+        final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
+        final ResponseMeterMetric metric =
+            (method != null)
+                ? this.responseMeters.get(method.getInvocable().getDefinitionMethod())
+                : null;
+
+        if (metric != null) {
+          ContainerResponse containerResponse = event.getContainerResponse();
+          if (containerResponse == null && event.getException() != null) {
+            metric.mark(500);
+          } else if (containerResponse != null) {
+            metric.mark(containerResponse.getStatus());
+          }
+        }
+      }
     }
+  }
 
-    private <T extends Annotation> T getClassLevelAnnotation(final Resource resource, final Class<T> annotationClazz) {
-        T annotation = null;
-
-        for (final Class<?> clazz : resource.getHandlerClasses()) {
-            annotation = clazz.getAnnotation(annotationClazz);
+  private static class ChainedRequestEventListener implements RequestEventListener {
+    private final RequestEventListener[] listeners;
 
-            if (annotation != null) {
-                break;
-            }
-        }
-        return annotation;
+    private ChainedRequestEventListener(final RequestEventListener... listeners) {
+      this.listeners = listeners;
     }
 
-    private void registerTimedAnnotations(final ResourceMethod method, final Timed classLevelTimed) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
-        if (classLevelTimed != null) {
-            registerTimers(method, definitionMethod, classLevelTimed);
-            return;
-        }
-
-        final Timed annotation = definitionMethod.getAnnotation(Timed.class);
-        if (annotation != null) {
-            registerTimers(method, definitionMethod, annotation);
-        }
+    @Override
+    public void onEvent(final RequestEvent event) {
+      for (RequestEventListener listener : listeners) {
+        listener.onEvent(event);
+      }
     }
+  }
 
-    private void registerTimers(ResourceMethod method, Method definitionMethod, Timed annotation) {
-        timers.putIfAbsent(EventTypeAndMethod.requestMethodStart(definitionMethod), timerMetric(metrics, method, annotation));
-        if (trackFilters) {
-            timers.putIfAbsent(EventTypeAndMethod.requestMatched(definitionMethod), timerMetric(metrics, method, annotation, REQUEST_FILTERING));
-            timers.putIfAbsent(EventTypeAndMethod.respFiltersStart(definitionMethod), timerMetric(metrics, method, annotation, RESPONSE_FILTERING));
-            timers.putIfAbsent(EventTypeAndMethod.finished(definitionMethod), timerMetric(metrics, method, annotation, TOTAL));
-        }
+  @Override
+  public void onEvent(ApplicationEvent event) {
+    if (event.getType() == ApplicationEvent.Type.INITIALIZATION_APP_FINISHED) {
+      registerMetricsForModel(event.getResourceModel());
+    }
+  }
+
+  @Override
+  public ResourceModel processResourceModel(
+      ResourceModel resourceModel, Configuration configuration) {
+    return resourceModel;
+  }
+
+  @Override
+  public ResourceModel processSubResource(
+      ResourceModel subResourceModel, Configuration configuration) {
+    registerMetricsForModel(subResourceModel);
+    return subResourceModel;
+  }
+
+  private void registerMetricsForModel(ResourceModel resourceModel) {
+    for (final Resource resource : resourceModel.getResources()) {
+
+      final Timed classLevelTimed = getClassLevelAnnotation(resource, Timed.class);
+      final Metered classLevelMetered = getClassLevelAnnotation(resource, Metered.class);
+      final ExceptionMetered classLevelExceptionMetered =
+          getClassLevelAnnotation(resource, ExceptionMetered.class);
+      final ResponseMetered classLevelResponseMetered =
+          getClassLevelAnnotation(resource, ResponseMetered.class);
+
+      for (final ResourceMethod method : resource.getAllMethods()) {
+        registerTimedAnnotations(method, classLevelTimed);
+        registerMeteredAnnotations(method, classLevelMetered);
+        registerExceptionMeteredAnnotations(method, classLevelExceptionMetered);
+        registerResponseMeteredAnnotations(method, classLevelResponseMetered);
+      }
+
+      for (final Resource childResource : resource.getChildResources()) {
+
+        final Timed classLevelTimedChild = getClassLevelAnnotation(childResource, Timed.class);
+        final Metered classLevelMeteredChild =
+            getClassLevelAnnotation(childResource, Metered.class);
+        final ExceptionMetered classLevelExceptionMeteredChild =
+            getClassLevelAnnotation(childResource, ExceptionMetered.class);
+        final ResponseMetered classLevelResponseMeteredChild =
+            getClassLevelAnnotation(childResource, ResponseMetered.class);
+
+        for (final ResourceMethod method : childResource.getAllMethods()) {
+          registerTimedAnnotations(method, classLevelTimedChild);
+          registerMeteredAnnotations(method, classLevelMeteredChild);
+          registerExceptionMeteredAnnotations(method, classLevelExceptionMeteredChild);
+          registerResponseMeteredAnnotations(method, classLevelResponseMeteredChild);
+        }
+      }
+    }
+  }
+
+  @Override
+  public RequestEventListener onRequest(final RequestEvent event) {
+    return new ChainedRequestEventListener(
+        new TimerRequestEventListener(timers, clock),
+        new MeterRequestEventListener(meters),
+        new ExceptionMeterRequestEventListener(exceptionMeters),
+        new ResponseMeterRequestEventListener(responseMeters));
+  }
+
+  private <T extends Annotation> T getClassLevelAnnotation(
+      final Resource resource, final Class<T> annotationClazz) {
+    T annotation = null;
+
+    for (final Class<?> clazz : resource.getHandlerClasses()) {
+      annotation = clazz.getAnnotation(annotationClazz);
+
+      if (annotation != null) {
+        break;
+      }
+    }
+    return annotation;
+  }
+
+  private void registerTimedAnnotations(final ResourceMethod method, final Timed classLevelTimed) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (classLevelTimed != null) {
+      registerTimers(method, definitionMethod, classLevelTimed);
+      return;
     }
 
-    private void registerMeteredAnnotations(final ResourceMethod method, final Metered classLevelMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    final Timed annotation = definitionMethod.getAnnotation(Timed.class);
+    if (annotation != null) {
+      registerTimers(method, definitionMethod, annotation);
+    }
+  }
+
+  private void registerTimers(ResourceMethod method, Method definitionMethod, Timed annotation) {
+    timers.putIfAbsent(
+        EventTypeAndMethod.requestMethodStart(definitionMethod),
+        timerMetric(metrics, method, annotation));
+    if (trackFilters) {
+      timers.putIfAbsent(
+          EventTypeAndMethod.requestMatched(definitionMethod),
+          timerMetric(metrics, method, annotation, REQUEST_FILTERING));
+      timers.putIfAbsent(
+          EventTypeAndMethod.respFiltersStart(definitionMethod),
+          timerMetric(metrics, method, annotation, RESPONSE_FILTERING));
+      timers.putIfAbsent(
+          EventTypeAndMethod.finished(definitionMethod),
+          timerMetric(metrics, method, annotation, TOTAL));
+    }
+  }
 
-        if (classLevelMetered != null) {
-            meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, classLevelMetered));
-            return;
-        }
-        final Metered annotation = definitionMethod.getAnnotation(Metered.class);
+  private void registerMeteredAnnotations(
+      final ResourceMethod method, final Metered classLevelMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, annotation));
-        }
+    if (classLevelMetered != null) {
+      meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, classLevelMetered));
+      return;
     }
+    final Metered annotation = definitionMethod.getAnnotation(Metered.class);
 
-    private void registerExceptionMeteredAnnotations(final ResourceMethod method, final ExceptionMetered classLevelExceptionMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (annotation != null) {
+      meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, annotation));
+    }
+  }
 
-        if (classLevelExceptionMetered != null) {
-            exceptionMeters.putIfAbsent(definitionMethod, new ExceptionMeterMetric(metrics, method, classLevelExceptionMetered));
-            return;
-        }
-        final ExceptionMetered annotation = definitionMethod.getAnnotation(ExceptionMetered.class);
+  private void registerExceptionMeteredAnnotations(
+      final ResourceMethod method, final ExceptionMetered classLevelExceptionMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            exceptionMeters.putIfAbsent(definitionMethod, new ExceptionMeterMetric(metrics, method, annotation));
-        }
+    if (classLevelExceptionMetered != null) {
+      exceptionMeters.putIfAbsent(
+          definitionMethod, new ExceptionMeterMetric(metrics, method, classLevelExceptionMetered));
+      return;
     }
+    final ExceptionMetered annotation = definitionMethod.getAnnotation(ExceptionMetered.class);
 
-    private void registerResponseMeteredAnnotations(final ResourceMethod method, final ResponseMetered classLevelResponseMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (annotation != null) {
+      exceptionMeters.putIfAbsent(
+          definitionMethod, new ExceptionMeterMetric(metrics, method, annotation));
+    }
+  }
 
-        if (classLevelResponseMetered != null) {
-            responseMeters.putIfAbsent(definitionMethod, new ResponseMeterMetric(metrics, method, classLevelResponseMetered));
-            return;
-        }
-        final ResponseMetered annotation = definitionMethod.getAnnotation(ResponseMetered.class);
+  private void registerResponseMeteredAnnotations(
+      final ResourceMethod method, final ResponseMetered classLevelResponseMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            responseMeters.putIfAbsent(definitionMethod, new ResponseMeterMetric(metrics, method, annotation));
-        }
+    if (classLevelResponseMetered != null) {
+      responseMeters.putIfAbsent(
+          definitionMethod, new ResponseMeterMetric(metrics, method, classLevelResponseMetered));
+      return;
     }
+    final ResponseMetered annotation = definitionMethod.getAnnotation(ResponseMetered.class);
 
-    private Timer timerMetric(final MetricRegistry registry,
-                              final ResourceMethod method,
-                              final Timed timed,
-                              final String... suffixes) {
-        final MetricName name = chooseName(timed.name(), timed.absolute(), method, suffixes);
-        return registry.timer(name, () -> new Timer(reservoirSupplier.get(), clock));
+    if (annotation != null) {
+      responseMeters.putIfAbsent(
+          definitionMethod, new ResponseMeterMetric(metrics, method, annotation));
     }
-
-    private Meter meterMetric(final MetricRegistry registry,
-                              final ResourceMethod method,
-                              final Metered metered) {
-        final MetricName name = chooseName(metered.name(), metered.absolute(), method);
-        return registry.meter(name, () -> new Meter(clock));
+  }
+
+  private Timer timerMetric(
+      final MetricRegistry registry,
+      final ResourceMethod method,
+      final Timed timed,
+      final String... suffixes) {
+    final MetricName name = chooseName(timed.name(), timed.absolute(), method, suffixes);
+    return registry.timer(name, () -> new Timer(reservoirSupplier.get(), clock));
+  }
+
+  private Meter meterMetric(
+      final MetricRegistry registry, final ResourceMethod method, final Metered metered) {
+    final MetricName name = chooseName(metered.name(), metered.absolute(), method);
+    return registry.meter(name, () -> new Meter(clock));
+  }
+
+  protected static MetricName chooseName(
+      final String explicitName,
+      final boolean absolute,
+      final ResourceMethod method,
+      final String... suffixes) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    MetricName metricName;
+    if (!Strings.isNullOrEmpty(explicitName)) {
+      metricName =
+          absolute ? name(explicitName) : name(definitionMethod.getDeclaringClass(), explicitName);
+    } else {
+      metricName = name(definitionMethod.getDeclaringClass(), definitionMethod.getName());
     }
-
-    protected static MetricName chooseName(final String explicitName, final boolean absolute, final ResourceMethod method,
-                                           final String... suffixes) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
-        MetricName metricName;
-        if (explicitName != null && !explicitName.isEmpty()) {
-            metricName = absolute ? name(explicitName) : name(definitionMethod.getDeclaringClass(), explicitName);
-        } else {
-            metricName = name(definitionMethod.getDeclaringClass(), definitionMethod.getName());
-        }
-        for (String suffix : suffixes) {
-            metricName = metricName.resolve(suffix);
-        }
-        return metricName;
+    for (String suffix : suffixes) {
+      metricName = metricName.resolve(suffix);
     }
+    return metricName;
+  }
 
-    private static class EventTypeAndMethod {
+  private static class EventTypeAndMethod {
 
-        private final RequestEvent.Type type;
-        private final Method method;
-
-        private EventTypeAndMethod(RequestEvent.Type type, Method method) {
-            this.type = type;
-            this.method = method;
-        }
-
-        static EventTypeAndMethod requestMethodStart(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.RESOURCE_METHOD_START, method);
-        }
+    private final RequestEvent.Type type;
+    private final Method method;
 
-        static EventTypeAndMethod requestMatched(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.REQUEST_MATCHED, method);
-        }
+    private EventTypeAndMethod(RequestEvent.Type type, Method method) {
+      this.type = type;
+      this.method = method;
+    }
 
-        static EventTypeAndMethod respFiltersStart(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.RESP_FILTERS_START, method);
-        }
+    static EventTypeAndMethod requestMethodStart(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.RESOURCE_METHOD_START, method);
+    }
 
-        static EventTypeAndMethod finished(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.FINISHED, method);
-        }
+    static EventTypeAndMethod requestMatched(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.REQUEST_MATCHED, method);
+    }
 
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
+    static EventTypeAndMethod respFiltersStart(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.RESP_FILTERS_START, method);
+    }
 
-            EventTypeAndMethod that = (EventTypeAndMethod) o;
+    static EventTypeAndMethod finished(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.FINISHED, method);
+    }
 
-            if (type != that.type) {
-                return false;
-            }
-            return method.equals(that.method);
-        }
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+
+      EventTypeAndMethod that = (EventTypeAndMethod) o;
+
+      if (type != that.type) {
+        return false;
+      }
+      return method.equals(that.method);
+    }
 
-        @Override
-        public int hashCode() {
-            int result = type.hashCode();
-            result = 31 * result + method.hashCode();
-            return result;
-        }
+    @Override
+    public int hashCode() {
+      int result = type.hashCode();
+      return 31 * result + method.hashCode();
     }
+  }
 }
--- a/metrics-jersey3/src/main/java/io/dropwizard/metrics5/jersey3/MetricsFeature.java
+++ b/metrics-jersey3/src/main/java/io/dropwizard/metrics5/jersey3/MetricsFeature.java
@@ -7,91 +7,96 @@ import io.dropwizard.metrics5.Reservoir;
 import io.dropwizard.metrics5.SharedMetricRegistries;
 import jakarta.ws.rs.core.Feature;
 import jakarta.ws.rs.core.FeatureContext;
-
 import java.util.function.Supplier;
 
 /**
- * A {@link Feature} which registers a {@link InstrumentedResourceMethodApplicationListener}
- * for recording request events.
+ * A {@link Feature} which registers a {@link InstrumentedResourceMethodApplicationListener} for
+ * recording request events.
  */
 public class MetricsFeature implements Feature {
 
-    private final MetricRegistry registry;
-    private final Clock clock;
-    private final boolean trackFilters;
-    private final Supplier<Reservoir> reservoirSupplier;
+  private final MetricRegistry registry;
+  private final Clock clock;
+  private final boolean trackFilters;
+  private final Supplier<Reservoir> reservoirSupplier;
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     */
-    public MetricsFeature(MetricRegistry registry) {
-        this(registry, Clock.defaultClock());
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   */
+  public MetricsFeature(MetricRegistry registry) {
+    this(registry, Clock.defaultClock());
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public MetricsFeature(MetricRegistry registry, Supplier<Reservoir> reservoirSupplier) {
-        this(registry, Clock.defaultClock(), false, reservoirSupplier);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public MetricsFeature(MetricRegistry registry, Supplier<Reservoir> reservoirSupplier) {
+    this(registry, Clock.defaultClock(), false, reservoirSupplier);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock) {
-        this(registry, clock, false);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   */
+  public MetricsFeature(MetricRegistry registry, Clock clock) {
+    this(registry, clock, false);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters) {
-        this(registry, clock, trackFilters, ExponentiallyDecayingReservoir::new);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters      whether the processing time for request and response filters should be tracked
+   */
+  public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters) {
+    this(registry, clock, trackFilters, ExponentiallyDecayingReservoir::new);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters, Supplier<Reservoir> reservoirSupplier) {
-        this.registry = registry;
-        this.clock = clock;
-        this.trackFilters = trackFilters;
-        this.reservoirSupplier = reservoirSupplier;
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters      whether the processing time for request and response filters should be tracked
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public MetricsFeature(
+      MetricRegistry registry,
+      Clock clock,
+      boolean trackFilters,
+      Supplier<Reservoir> reservoirSupplier) {
+    this.registry = registry;
+    this.clock = clock;
+    this.trackFilters = trackFilters;
+    this.reservoirSupplier = reservoirSupplier;
+  }
 
-    public MetricsFeature(String registryName) {
-        this(SharedMetricRegistries.getOrCreate(registryName));
-    }
+  public MetricsFeature(String registryName) {
+    this(SharedMetricRegistries.getOrCreate(registryName));
+  }
 
-    /**
-     * A call-back method called when the feature is to be enabled in a given
-     * runtime configuration scope.
-     * <p>
-     * The responsibility of the feature is to properly update the supplied runtime configuration context
-     * and return {@code true} if the feature was successfully enabled or {@code false} otherwise.
-     * <p>
-     * Note that under some circumstances the feature may decide not to enable itself, which
-     * is indicated by returning {@code false}. In such case the configuration context does
-     * not add the feature to the collection of enabled features and a subsequent call to
-     * {@link jakarta.ws.rs.core.Configuration#isEnabled(jakarta.ws.rs.core.Feature)} or
-     * {@link jakarta.ws.rs.core.Configuration#isEnabled(Class)} method
-     * would return {@code false}.
-     * <p>
-     *
-     * @param context configurable context in which the feature should be enabled.
-     * @return {@code true} if the feature was successfully enabled, {@code false}
-     * otherwise.
-     */
-    @Override
-    public boolean configure(FeatureContext context) {
-        context.register(new InstrumentedResourceMethodApplicationListener(registry, clock, trackFilters, reservoirSupplier));
-        return true;
-    }
+  /**
+   * A call-back method called when the feature is to be enabled in a given runtime configuration
+   * scope.
+   *
+   * <p>The responsibility of the feature is to properly update the supplied runtime configuration
+   * context and return {@code true} if the feature was successfully enabled or {@code false}
+   * otherwise.
+   *
+   * <p>Note that under some circumstances the feature may decide not to enable itself, which is
+   * indicated by returning {@code false}. In such case the configuration context does not add the
+   * feature to the collection of enabled features and a subsequent call to {@link
+   * jakarta.ws.rs.core.Configuration#isEnabled(jakarta.ws.rs.core.Feature)} or {@link
+   * jakarta.ws.rs.core.Configuration#isEnabled(Class)} method would return {@code false}.
+   *
+   * <p>
+   *
+   * @param context configurable context in which the feature should be enabled.
+   * @return {@code true} if the feature was successfully enabled, {@code false} otherwise.
+   */
+  @Override
+  public boolean configure(FeatureContext context) {
+    context.register(
+        new InstrumentedResourceMethodApplicationListener(
+            registry, clock, trackFilters, reservoirSupplier));
+    return true;
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/CustomReservoirImplementationTest.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/CustomReservoirImplementationTest.java
@@ -1,44 +1,44 @@
 package io.dropwizard.metrics5.jersey3;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.UniformReservoir;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedResourceTimedPerClass;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
-class CustomReservoirImplementationTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class CustomReservoirImplementationTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        return new ResourceConfig()
+    return new ResourceConfig()
         .register(new MetricsFeature(this.registry, UniformReservoir::new))
         .register(InstrumentedResourceTimedPerClass.class);
-    }
+  }
 
-    @Test
-    void timerHistogramIsUsingCustomReservoirImplementation() {
-        assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
+  @Test
+  void timerHistogramIsUsingCustomReservoirImplementation() {
+    assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Timer timer = registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
-        assertThat(timer)
+    final Timer timer =
+        registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
+    assertThat(timer)
         .extracting("histogram")
         .extracting("reservoir")
         .isInstanceOf(UniformReservoir.class);
-    }
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonFilterMetricsJerseyTest.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonFilterMetricsJerseyTest.java
@@ -1,162 +1,137 @@
 package io.dropwizard.metrics5.jersey3;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedFilteredResource;
 import io.dropwizard.metrics5.jersey3.resources.TestRequestFilter;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig} with filter tracking
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig} with filter tracking
  */
-class SingletonFilterMetricsJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    private TestClock testClock;
-
-    @Override
-    protected Application configure() {
-        registry = new MetricRegistry();
-        testClock = new TestClock();
-        ResourceConfig config = new ResourceConfig();
-        config = config.register(new MetricsFeature(this.registry, testClock, true));
-        config = config.register(new TestRequestFilter(testClock));
-        config = config.register(new InstrumentedFilteredResource(testClock));
-        return config;
-    }
-
-    @BeforeEach
-    void resetClock() {
-        testClock.tick = 0;
-    }
-
-    @Test
-    void timedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void explicitNamesAreTimed() {
-        assertThat(target("named")
-        .request()
-        .get(String.class))
-        .isEqualTo("fancy");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "fancyName"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void absoluteNamesAreTimed() {
-        assertThat(target("absolute")
-        .request()
-        .get(String.class))
-        .isEqualTo("absolute");
-
-        final Timer timer = registry.timer("absolutelyFancy");
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void requestFiltersOfTimedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed", "request", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void responseFiltersOfTimedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed", "response", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void totalTimeOfTimedMethodsIsTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed", "total"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(5);
-    }
-
-    @Test
-    void requestFiltersOfNamedMethodsAreTimed() {
-        assertThat(target("named")
-        .request()
-        .get(String.class))
-        .isEqualTo("fancy");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "fancyName", "request", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void requestFiltersOfAbsoluteMethodsAreTimed() {
-        assertThat(target("absolute")
-        .request()
-        .get(String.class))
-        .isEqualTo("absolute");
-
-        final Timer timer = registry.timer(name("absolutelyFancy", "request", "filtering"));
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void subResourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.InstrumentedFilteredSubResource.class,
-        "timed"));
-        assertThat(timer.getCount()).isEqualTo(1);
-
-    }
+final class SingletonFilterMetricsJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
+
+  private MetricRegistry registry;
+
+  private TestClock testClock;
+
+  @Override
+  protected Application configure() {
+    registry = new MetricRegistry();
+    testClock = new TestClock();
+    ResourceConfig config = new ResourceConfig();
+    config = config.register(new MetricsFeature(this.registry, testClock, true));
+    config = config.register(new TestRequestFilter(testClock));
+    return config.register(new InstrumentedFilteredResource(testClock));
+  }
+
+  @BeforeEach
+  void resetClock() {
+    testClock.tick = 0;
+  }
+
+  @Test
+  void timedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void explicitNamesAreTimed() {
+    assertThat(target("named").request().get(String.class)).isEqualTo("fancy");
+
+    final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "fancyName"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void absoluteNamesAreTimed() {
+    assertThat(target("absolute").request().get(String.class)).isEqualTo("absolute");
+
+    final Timer timer = registry.timer("absolutelyFancy");
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void requestFiltersOfTimedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(name(InstrumentedFilteredResource.class, "timed", "request", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void responseFiltersOfTimedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(name(InstrumentedFilteredResource.class, "timed", "response", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void totalTimeOfTimedMethodsIsTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed", "total"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(5);
+  }
+
+  @Test
+  void requestFiltersOfNamedMethodsAreTimed() {
+    assertThat(target("named").request().get(String.class)).isEqualTo("fancy");
+
+    final Timer timer =
+        registry.timer(
+            name(InstrumentedFilteredResource.class, "fancyName", "request", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void requestFiltersOfAbsoluteMethodsAreTimed() {
+    assertThat(target("absolute").request().get(String.class)).isEqualTo("absolute");
+
+    final Timer timer = registry.timer(name("absolutelyFancy", "request", "filtering"));
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void subResourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(
+            name(InstrumentedFilteredResource.InstrumentedFilteredSubResource.class, "timed"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsExceptionMeteredPerClassJerseyTest.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsExceptionMeteredPerClassJerseyTest.java
@@ -1,98 +1,92 @@
 package io.dropwizard.metrics5.jersey3;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedResourceExceptionMeteredPerClass;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedSubResourceExceptionMeteredPerClass;
 import jakarta.ws.rs.ProcessingException;
 import jakarta.ws.rs.core.Application;
-import org.glassfish.jersey.server.ResourceConfig;
-import org.glassfish.jersey.test.JerseyTest;
-import org.junit.jupiter.api.Test;
-
 import java.io.IOException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import org.glassfish.jersey.server.ResourceConfig;
+import org.glassfish.jersey.test.JerseyTest;
+import org.junit.jupiter.api.Test;
 
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsExceptionMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class SingletonMetricsExceptionMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        ResourceConfig config = new ResourceConfig();
+    ResourceConfig config = new ResourceConfig();
 
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceExceptionMeteredPerClass.class);
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceExceptionMeteredPerClass.class);
+  }
 
-        return config;
-    }
+  @Test
+  void exceptionMeteredMethodsAreExceptionMetered() {
+    final Meter meter =
+        registry.meter(
+            name(
+                InstrumentedResourceExceptionMeteredPerClass.class,
+                "exceptionMetered",
+                "exceptions"));
 
-    @Test
-    void exceptionMeteredMethodsAreExceptionMetered() {
-        final Meter meter = registry.meter(name(InstrumentedResourceExceptionMeteredPerClass.class,
-        "exceptionMetered",
-        "exceptions"));
+    assertThat(target("exception-metered").request().get(String.class)).isEqualTo("fuh");
 
-        assertThat(target("exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
-
-        assertThat(meter.getCount()).isZero();
-
-        try {
-            target("exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+    assertThat(meter.getCount()).isEqualTo(0);
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
+    try {
+      target("exception-metered").queryParam("splode", true).request().get(String.class);
 
-        assertThat(meter.getCount()).isEqualTo(1);
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        final Meter meter = registry.meter(name(InstrumentedSubResourceExceptionMeteredPerClass.class,
-        "exceptionMetered",
-        "exceptions"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
-        assertThat(target("subresource/exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    final Meter meter =
+        registry.meter(
+            name(
+                InstrumentedSubResourceExceptionMeteredPerClass.class,
+                "exceptionMetered",
+                "exceptions"));
 
-        assertThat(meter.getCount()).isZero();
+    assertThat(target("subresource/exception-metered").request().get(String.class))
+        .isEqualTo("fuh");
 
-        try {
-            target("subresource/exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+    assertThat(meter.getCount()).isEqualTo(0);
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
+    try {
+      target("subresource/exception-metered")
+          .queryParam("splode", true)
+          .request()
+          .get(String.class);
 
-        assertThat(meter.getCount()).isEqualTo(1);
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsJerseyTest.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsJerseyTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.jersey3;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
@@ -9,197 +13,156 @@ import jakarta.ws.rs.NotFoundException;
 import jakarta.ws.rs.ProcessingException;
 import jakarta.ws.rs.core.Application;
 import jakarta.ws.rs.core.Response;
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.client.ClientResponse;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link org.glassfish.jersey.server.ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link org.glassfish.jersey.server.ResourceConfig}
  */
-class SingletonMetricsJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-        ResourceConfig config = new ResourceConfig();
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResource.class);
+final class SingletonMetricsJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-        return config;
-    }
-
-    @Test
-    void timedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedResource.class, "timed"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
+  private MetricRegistry registry;
 
-    @Test
-    void meteredMethodsAreMetered() {
-        assertThat(target("metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("woo");
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        final Meter meter = registry.meter(name(InstrumentedResource.class, "metered"));
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
+    ResourceConfig config = new ResourceConfig();
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResource.class);
+  }
 
-    @Test
-    void exceptionMeteredMethodsAreExceptionMetered() {
-        final Meter meter = registry.meter(name(InstrumentedResource.class,
-        "exceptionMetered",
-        "exceptions"));
+  @Test
+  void timedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
 
-        assertThat(target("exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
+    final Timer timer = registry.timer(name(InstrumentedResource.class, "timed"));
 
-        assertThat(meter.getCount()).isZero();
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
-        try {
-            target("exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+  @Test
+  void meteredMethodsAreMetered() {
+    assertThat(target("metered").request().get(String.class)).isEqualTo("woo");
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
+    final Meter meter = registry.meter(name(InstrumentedResource.class, "metered"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
+  @Test
+  void exceptionMeteredMethodsAreExceptionMetered() {
+    final Meter meter =
+        registry.meter(name(InstrumentedResource.class, "exceptionMetered", "exceptions"));
 
-    @Test
-    void responseMeteredMethodsAreMetered() {
-        final Meter meter2xx = registry.meter(name(InstrumentedResource.class,
-                "response2xxMetered",
-                "2xx-responses"));
-        final Meter meter4xx = registry.meter(name(InstrumentedResource.class,
-                "response4xxMetered",
-                "4xx-responses"));
-        final Meter meter5xx = registry.meter(name(InstrumentedResource.class,
-                "response5xxMetered",
-                "5xx-responses"));
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(target("response-2xx-metered")
-                .request()
-                .get().getStatus())
-                .isEqualTo(200);
+    assertThat(target("exception-metered").request().get(String.class)).isEqualTo("fuh");
 
-        assertThat(meter4xx.getCount()).isZero();
-        assertThat(target("response-4xx-metered")
-                .request()
-                .get().getStatus())
-                .isEqualTo(400);
+    assertThat(meter.getCount()).isEqualTo(0);
 
-        assertThat(meter5xx.getCount()).isZero();
-        assertThat(target("response-5xx-metered")
-                .request()
-                .get().getStatus())
-                .isEqualTo(500);
+    try {
+      target("exception-metered").queryParam("splode", true).request().get(String.class);
 
-        assertThat(meter2xx.getCount()).isEqualTo(1);
-        assertThat(meter4xx.getCount()).isEqualTo(1);
-        assertThat(meter5xx.getCount()).isEqualTo(1);
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
-    @Test
-    void responseMeteredMethodsAreMeteredWithDetailedLevel() {
-        final Meter meter2xx = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredDetailed",
-                "2xx-responses"));
-        final Meter meter200 = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredDetailed",
-                "200-responses"));
-        final Meter meter201 = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredDetailed",
-                "201-responses"));
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isZero();
-        assertThat(meter201.getCount()).isZero();
-        assertThat(target("response-metered-detailed")
-                .request()
-                .get().getStatus())
-                .isEqualTo(200);
-        assertThat(target("response-metered-detailed")
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMethodsAreMetered() {
+    final Meter meter2xx =
+        registry.meter(name(InstrumentedResource.class, "response2xxMetered", "2xx-responses"));
+    final Meter meter4xx =
+        registry.meter(name(InstrumentedResource.class, "response4xxMetered", "4xx-responses"));
+    final Meter meter5xx =
+        registry.meter(name(InstrumentedResource.class, "response5xxMetered", "5xx-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(target("response-2xx-metered").request().get().getStatus()).isEqualTo(200);
+
+    assertThat(meter4xx.getCount()).isEqualTo(0);
+    assertThat(target("response-4xx-metered").request().get().getStatus()).isEqualTo(400);
+
+    assertThat(meter5xx.getCount()).isEqualTo(0);
+    assertThat(target("response-5xx-metered").request().get().getStatus()).isEqualTo(500);
+
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+    assertThat(meter4xx.getCount()).isEqualTo(1);
+    assertThat(meter5xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMethodsAreMeteredWithDetailedLevel() {
+    final Meter meter2xx =
+        registry.meter(
+            name(InstrumentedResource.class, "responseMeteredDetailed", "2xx-responses"));
+    final Meter meter200 =
+        registry.meter(
+            name(InstrumentedResource.class, "responseMeteredDetailed", "200-responses"));
+    final Meter meter201 =
+        registry.meter(
+            name(InstrumentedResource.class, "responseMeteredDetailed", "201-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(0);
+    assertThat(meter201.getCount()).isEqualTo(0);
+    assertThat(target("response-metered-detailed").request().get().getStatus()).isEqualTo(200);
+    assertThat(
+            target("response-metered-detailed")
                 .queryParam("status_code", 201)
                 .request()
-                .get().getStatus())
-                .isEqualTo(201);
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isOne();
-        assertThat(meter201.getCount()).isOne();
+                .get()
+                .getStatus())
+        .isEqualTo(201);
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(1);
+    assertThat(meter201.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMethodsAreMeteredWithAllLevel() {
+    final Meter meter2xx =
+        registry.meter(name(InstrumentedResource.class, "responseMeteredAll", "2xx-responses"));
+    final Meter meter200 =
+        registry.meter(name(InstrumentedResource.class, "responseMeteredAll", "200-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(0);
+    assertThat(target("response-metered-all").request().get().getStatus()).isEqualTo(200);
+
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+    assertThat(meter200.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void resourceNotFound() {
+    final Response response = target().path("not-found").request().get();
+    assertThat(response.getStatus()).isEqualTo(404);
+
+    try {
+      target().path("not-found").request().get(ClientResponse.class);
+      failBecauseExceptionWasNotThrown(NotFoundException.class);
+    } catch (NotFoundException e) {
+      assertThat(e.getMessage()).isEqualTo("HTTP 404 Not Found");
     }
+  }
 
-    @Test
-    public void responseMeteredMethodsAreMeteredWithAllLevel() {
-        final Meter meter2xx = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredAll",
-                "2xx-responses"));
-        final Meter meter200 = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredAll",
-                "200-responses"));
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isZero();
-        assertThat(target("response-metered-all")
-                .request()
-                .get().getStatus())
-                .isEqualTo(200);
-
-        assertThat(meter2xx.getCount()).isOne();
-        assertThat(meter200.getCount()).isOne();
-    }
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timed").request().get(String.class)).isEqualTo("yay");
 
-    @Test
-    void testResourceNotFound() {
-        final Response response = target().path("not-found").request().get();
-        assertThat(response.getStatus()).isEqualTo(404);
-
-        try {
-            target().path("not-found").request().get(ClientResponse.class);
-            failBecauseExceptionWasNotThrown(NotFoundException.class);
-        } catch (NotFoundException e) {
-            assertThat(e.getMessage()).isEqualTo("HTTP 404 Not Found");
-        }
-    }
-
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedSubResource.class, "timed"));
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
+    final Timer timer = registry.timer(name(InstrumentedSubResource.class, "timed"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsMeteredPerClassJerseyTest.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsMeteredPerClassJerseyTest.java
@@ -1,66 +1,56 @@
 package io.dropwizard.metrics5.jersey3;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedResourceMeteredPerClass;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedSubResourceMeteredPerClass;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-        ResourceConfig config = new ResourceConfig();
-
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceMeteredPerClass.class);
+final class SingletonMetricsMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-        return config;
-    }
+  private MetricRegistry registry;
 
-    @Test
-    void meteredPerClassMethodsAreMetered() {
-        assertThat(target("meteredPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        final Meter meter = registry.meter(name(InstrumentedResourceMeteredPerClass.class, "meteredPerClass"));
+    ResourceConfig config = new ResourceConfig();
 
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceMeteredPerClass.class);
+  }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/meteredPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Test
+  void meteredPerClassMethodsAreMetered() {
+    assertThat(target("meteredPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Meter meter = registry.meter(name(InstrumentedSubResourceMeteredPerClass.class, "meteredPerClass"));
-        assertThat(meter.getCount()).isEqualTo(1);
+    final Meter meter =
+        registry.meter(name(InstrumentedResourceMeteredPerClass.class, "meteredPerClass"));
 
-    }
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/meteredPerClass").request().get(String.class)).isEqualTo("yay");
 
+    final Meter meter =
+        registry.meter(name(InstrumentedSubResourceMeteredPerClass.class, "meteredPerClass"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsResponseMeteredPerClassJerseyTest.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsResponseMeteredPerClassJerseyTest.java
@@ -1,152 +1,158 @@
 package io.dropwizard.metrics5.jersey3;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey3.exception.mapper.TestExceptionMapper;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedResourceResponseMeteredPerClass;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedSubResourceResponseMeteredPerClass;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.fail;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsResponseMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class SingletonMetricsResponseMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
+    ResourceConfig config = new ResourceConfig();
 
-        ResourceConfig config = new ResourceConfig();
+    config = config.register(new MetricsFeature(this.registry));
+    config = config.register(InstrumentedResourceResponseMeteredPerClass.class);
+    return config.register(new TestExceptionMapper());
+  }
 
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceResponseMeteredPerClass.class);
-        config = config.register(new TestExceptionMapper());
-
-        return config;
-    }
+  @Test
+  void responseMetered2xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered2xxPerClass").request().get().getStatus()).isEqualTo(200);
 
-    @Test
-    void responseMetered2xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered2xxPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(200);
-
-        final Meter meter2xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered2xxPerClass",
-        "2xx-responses"));
+    final Meter meter2xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered2xxPerClass",
+                "2xx-responses"));
 
-        assertThat(meter2xx.getCount()).isEqualTo(1);
-    }
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void responseMetered4xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered4xxPerClass")
-        .request()
-        .get().getStatus())
+  @Test
+  void responseMetered4xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered4xxPerClass").request().get().getStatus()).isEqualTo(400);
+    assertThat(target("responseMeteredBadRequestPerClass").request().get().getStatus())
         .isEqualTo(400);
-        assertThat(target("responseMeteredBadRequestPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(400);
-
-        final Meter meter4xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered4xxPerClass",
-        "4xx-responses"));
-        final Meter meterException4xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredBadRequestPerClass",
-        "4xx-responses"));
 
-        assertThat(meter4xx.getCount()).isEqualTo(1);
-        assertThat(meterException4xx.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void responseMetered5xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered5xxPerClass")
-        .request()
-        .get().getStatus())
+    final Meter meter4xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered4xxPerClass",
+                "4xx-responses"));
+    final Meter meterException4xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredBadRequestPerClass",
+                "4xx-responses"));
+
+    assertThat(meter4xx.getCount()).isEqualTo(1);
+    assertThat(meterException4xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMetered5xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered5xxPerClass").request().get().getStatus()).isEqualTo(500);
+
+    final Meter meter5xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered5xxPerClass",
+                "5xx-responses"));
+
+    assertThat(meter5xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMappedExceptionPerClassMethodsAreMetered() {
+    assertThat(target("responseMeteredTestExceptionPerClass").request().get().getStatus())
         .isEqualTo(500);
 
-        final Meter meter5xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered5xxPerClass",
-        "5xx-responses"));
-
-        assertThat(meter5xx.getCount()).isEqualTo(1);
+    final Meter meterTestException =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredTestExceptionPerClass",
+                "5xx-responses"));
+
+    assertThat(meterTestException.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredUnmappedExceptionPerClassMethodsAreMetered() {
+    try {
+      target("responseMeteredRuntimeExceptionPerClass").request().get();
+      fail("expected RuntimeException");
+    } catch (Exception e) {
+      assertThat(e.getCause()).isInstanceOf(RuntimeException.class);
     }
 
-    @Test
-    void responseMeteredMappedExceptionPerClassMethodsAreMetered() {
-        assertThat(target("responseMeteredTestExceptionPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(500);
-
-        final Meter meterTestException = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredTestExceptionPerClass",
-        "5xx-responses"));
-
-        assertThat(meterTestException.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void responseMeteredUnmappedExceptionPerClassMethodsAreMetered() {
-        try {
-            target("responseMeteredRuntimeExceptionPerClass")
-            .request()
-            .get();
-            fail("expected RuntimeException");
-        } catch (Exception e) {
-            assertThat(e.getCause()).isInstanceOf(RuntimeException.class);
-        }
-
-        final Meter meterException5xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredRuntimeExceptionPerClass",
-        "5xx-responses"));
-
-        assertThat(meterException5xx.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        final Meter meter2xx = registry.meter(name(InstrumentedSubResourceResponseMeteredPerClass.class,
+    final Meter meterException5xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredRuntimeExceptionPerClass",
+                "5xx-responses"));
+
+    assertThat(meterException5xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    final Meter meter2xx =
+        registry.meter(
+            name(
+                InstrumentedSubResourceResponseMeteredPerClass.class,
                 "responseMeteredPerClass",
                 "2xx-responses"));
-        final Meter meter200 = registry.meter(name(InstrumentedSubResourceResponseMeteredPerClass.class,
+    final Meter meter200 =
+        registry.meter(
+            name(
+                InstrumentedSubResourceResponseMeteredPerClass.class,
                 "responseMeteredPerClass",
                 "200-responses"));
 
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isZero();
-
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(0);
 
-        assertThat(target("subresource/responseMeteredPerClass")
-                .request()
-                .get().getStatus())
-                .isEqualTo(200);
+    assertThat(target("subresource/responseMeteredPerClass").request().get().getStatus())
+        .isEqualTo(200);
 
-        final Meter meter = registry.meter(name(InstrumentedSubResourceResponseMeteredPerClass.class,
-        "responseMeteredPerClass", "2xx-responses"));
-        assertThat(meter.getCount()).isEqualTo(1);
+    final Meter meter =
+        registry.meter(
+            name(
+                InstrumentedSubResourceResponseMeteredPerClass.class,
+                "responseMeteredPerClass",
+                "2xx-responses"));
+    assertThat(meter.getCount()).isEqualTo(1);
 
-        assertThat(meter2xx.getCount()).isOne();
-        assertThat(meter200.getCount()).isOne();
-    }
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+    assertThat(meter200.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsTimedPerClassJerseyTest.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/SingletonMetricsTimedPerClassJerseyTest.java
@@ -1,66 +1,56 @@
 package io.dropwizard.metrics5.jersey3;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedResourceTimedPerClass;
 import io.dropwizard.metrics5.jersey3.resources.InstrumentedSubResourceTimedPerClass;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsTimedPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-        ResourceConfig config = new ResourceConfig();
-
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceTimedPerClass.class);
+final class SingletonMetricsTimedPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-        return config;
-    }
+  private MetricRegistry registry;
 
-    @Test
-    void timedPerClassMethodsAreTimed() {
-        assertThat(target("timedPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        final Timer timer = registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
+    ResourceConfig config = new ResourceConfig();
 
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceTimedPerClass.class);
+  }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timedPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Test
+  void timedPerClassMethodsAreTimed() {
+    assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Timer timer = registry.timer(name(InstrumentedSubResourceTimedPerClass.class, "timedPerClass"));
-        assertThat(timer.getCount()).isEqualTo(1);
+    final Timer timer =
+        registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
 
-    }
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timedPerClass").request().get(String.class)).isEqualTo("yay");
 
+    final Timer timer =
+        registry.timer(name(InstrumentedSubResourceTimedPerClass.class, "timedPerClass"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/TestClock.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/TestClock.java
@@ -4,10 +4,10 @@ import io.dropwizard.metrics5.Clock;
 
 public class TestClock extends Clock {
 
-    public long tick;
+  public long tick;
 
-    @Override
-    public long getTick() {
-        return tick;
-    }
+  @Override
+  public long getTick() {
+    return tick;
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/exception/TestException.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/exception/TestException.java
@@ -1,9 +1,9 @@
 package io.dropwizard.metrics5.jersey3.exception;
 
 public class TestException extends RuntimeException {
-    private static final long serialVersionUID = 1L;
+  private static final long serialVersionUID = 1L;
 
-    public TestException(String message) {
-        super(message);
-    }
+  public TestException(String message) {
+    super(message);
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/exception/mapper/TestExceptionMapper.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/exception/mapper/TestExceptionMapper.java
@@ -7,8 +7,8 @@ import jakarta.ws.rs.ext.Provider;
 
 @Provider
 public class TestExceptionMapper implements ExceptionMapper<TestException> {
-    @Override
-    public Response toResponse(TestException exception) {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
+  @Override
+  public Response toResponse(TestException exception) {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedFilteredResource.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedFilteredResource.java
@@ -11,51 +11,50 @@ import jakarta.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedFilteredResource {
 
-    private final TestClock testClock;
-
-    public InstrumentedFilteredResource(TestClock testClock) {
-        this.testClock = testClock;
-    }
+  private final TestClock testClock;
+
+  public InstrumentedFilteredResource(TestClock testClock) {
+    this.testClock = testClock;
+  }
+
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    testClock.tick++;
+    return "yay";
+  }
+
+  @GET
+  @Path("/named")
+  @Timed(name = "fancyName")
+  public String named() {
+    testClock.tick++;
+    return "fancy";
+  }
+
+  @GET
+  @Path("/absolute")
+  @Timed(name = "absolutelyFancy", absolute = true)
+  public String absolute() {
+    testClock.tick++;
+    return "absolute";
+  }
+
+  @Path("/subresource")
+  public InstrumentedFilteredSubResource locateSubResource() {
+    return new InstrumentedFilteredSubResource();
+  }
+
+  @Produces(MediaType.TEXT_PLAIN)
+  public class InstrumentedFilteredSubResource {
 
     @GET
-    @Timed
     @Path("/timed")
+    @Timed
     public String timed() {
-        testClock.tick++;
-        return "yay";
-    }
-
-    @GET
-    @Timed(name = "fancyName")
-    @Path("/named")
-    public String named() {
-        testClock.tick++;
-        return "fancy";
-    }
-
-    @GET
-    @Timed(name = "absolutelyFancy", absolute = true)
-    @Path("/absolute")
-    public String absolute() {
-        testClock.tick++;
-        return "absolute";
-    }
-
-    @Path("/subresource")
-    public InstrumentedFilteredSubResource locateSubResource() {
-        return new InstrumentedFilteredSubResource();
-    }
-
-    @Produces(MediaType.TEXT_PLAIN)
-    public class InstrumentedFilteredSubResource {
-
-        @GET
-        @Timed
-        @Path("/timed")
-        public String timed() {
-            testClock.tick += 2;
-            return "yay";
-        }
-
+      testClock.tick += 2;
+      return "yay";
     }
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResource.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResource.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.jersey3.resources;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+
 import io.dropwizard.metrics5.annotation.ExceptionMetered;
 import io.dropwizard.metrics5.annotation.Metered;
 import io.dropwizard.metrics5.annotation.ResponseMetered;
@@ -13,81 +17,81 @@ import jakarta.ws.rs.core.MediaType;
 import jakarta.ws.rs.core.Response;
 import java.io.IOException;
 
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
-
 @Path("/")
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResource {
-    @GET
-    @Timed
-    @Path("/timed")
-    public String timed() {
-        return "yay";
-    }
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    return "yay";
+  }
 
-    @GET
-    @Metered
-    @Path("/metered")
-    public String metered() {
-        return "woo";
-    }
+  @GET
+  @Metered
+  @Path("/metered")
+  public String metered() {
+    return "woo";
+  }
 
-    @GET
-    @ExceptionMetered(cause = IOException.class)
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
+  @ExceptionMetered(cause = IOException.class)
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 
-    @GET
-    @ResponseMetered(level = DETAILED)
-    @Path("/response-metered-detailed")
-    public Response responseMeteredDetailed(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-detailed")
+  @ResponseMetered(level = DETAILED)
+  public Response responseMeteredDetailed(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered(level = COARSE)
-    @Path("/response-metered-coarse")
-    public Response responseMeteredCoarse(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-coarse")
+  @ResponseMetered(level = COARSE)
+  public Response responseMeteredCoarse(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered(level = ALL)
-    @Path("/response-metered-all")
-    public Response responseMeteredAll(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-all")
+  @ResponseMetered(level = ALL)
+  public Response responseMeteredAll(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-2xx-metered")
-    public Response response2xxMetered() {
-        return Response.ok().build();
-    }
+  @GET
+  @Path("/response-2xx-metered")
+  @ResponseMetered
+  public Response response2xxMetered() {
+    return Response.ok().build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-4xx-metered")
-    public Response response4xxMetered() {
-        return Response.status(Response.Status.BAD_REQUEST).build();
-    }
+  @GET
+  @Path("/response-4xx-metered")
+  @ResponseMetered
+  public Response response4xxMetered() {
+    return Response.status(Response.Status.BAD_REQUEST).build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-5xx-metered")
-    public Response response5xxMetered() {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
+  @GET
+  @Path("/response-5xx-metered")
+  @ResponseMetered
+  public Response response5xxMetered() {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
 
-    @Path("/subresource")
-    public InstrumentedSubResource locateSubResource() {
-        return new InstrumentedSubResource();
-    }
+  @Path("/subresource")
+  public InstrumentedSubResource locateSubResource() {
+    return new InstrumentedSubResource();
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResourceExceptionMeteredPerClass.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResourceExceptionMeteredPerClass.java
@@ -7,7 +7,6 @@ import jakarta.ws.rs.Path;
 import jakarta.ws.rs.Produces;
 import jakarta.ws.rs.QueryParam;
 import jakarta.ws.rs.core.MediaType;
-
 import java.io.IOException;
 
 @ExceptionMetered(cause = IOException.class)
@@ -15,18 +14,18 @@ import java.io.IOException;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceExceptionMeteredPerClass {
 
-    @GET
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceExceptionMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceExceptionMeteredPerClass();
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceExceptionMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceExceptionMeteredPerClass();
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResourceMeteredPerClass.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResourceMeteredPerClass.java
@@ -11,15 +11,14 @@ import jakarta.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceMeteredPerClass {
 
-    @GET
-    @Path("/meteredPerClass")
-    public String meteredPerClass() {
-        return "yay";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceMeteredPerClass();
-    }
+  @GET
+  @Path("/meteredPerClass")
+  public String meteredPerClass() {
+    return "yay";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceMeteredPerClass();
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResourceResponseMeteredPerClass.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResourceResponseMeteredPerClass.java
@@ -14,45 +14,44 @@ import jakarta.ws.rs.core.Response;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceResponseMeteredPerClass {
 
-    @GET
-    @Path("/responseMetered2xxPerClass")
-    public Response responseMetered2xxPerClass() {
-        return Response.ok().build();
-    }
-
-    @GET
-    @Path("/responseMetered4xxPerClass")
-    public Response responseMetered4xxPerClass() {
-        return Response.status(Response.Status.BAD_REQUEST).build();
-    }
-
-    @GET
-    @Path("/responseMetered5xxPerClass")
-    public Response responseMetered5xxPerClass() {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
-
-    @GET
-    @Path("/responseMeteredBadRequestPerClass")
-    public String responseMeteredBadRequestPerClass() {
-        throw new BadRequestException();
-    }
-
-    @GET
-    @Path("/responseMeteredRuntimeExceptionPerClass")
-    public String responseMeteredRuntimeExceptionPerClass() {
-        throw new RuntimeException();
-    }
-
-    @GET
-    @Path("/responseMeteredTestExceptionPerClass")
-    public String responseMeteredTestExceptionPerClass() {
-        throw new TestException("test");
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceResponseMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceResponseMeteredPerClass();
-    }
-
+  @GET
+  @Path("/responseMetered2xxPerClass")
+  public Response responseMetered2xxPerClass() {
+    return Response.ok().build();
+  }
+
+  @GET
+  @Path("/responseMetered4xxPerClass")
+  public Response responseMetered4xxPerClass() {
+    return Response.status(Response.Status.BAD_REQUEST).build();
+  }
+
+  @GET
+  @Path("/responseMetered5xxPerClass")
+  public Response responseMetered5xxPerClass() {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
+
+  @GET
+  @Path("/responseMeteredBadRequestPerClass")
+  public String responseMeteredBadRequestPerClass() {
+    throw new BadRequestException();
+  }
+
+  @GET
+  @Path("/responseMeteredRuntimeExceptionPerClass")
+  public String responseMeteredRuntimeExceptionPerClass() {
+    throw new RuntimeException();
+  }
+
+  @GET
+  @Path("/responseMeteredTestExceptionPerClass")
+  public String responseMeteredTestExceptionPerClass() {
+    throw new TestException("test");
+  }
+
+  @Path("/subresource")
+  public InstrumentedSubResourceResponseMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceResponseMeteredPerClass();
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResourceTimedPerClass.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedResourceTimedPerClass.java
@@ -11,15 +11,14 @@ import jakarta.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceTimedPerClass {
 
-    @GET
-    @Path("/timedPerClass")
-    public String timedPerClass() {
-        return "yay";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceTimedPerClass locateSubResource() {
-        return new InstrumentedSubResourceTimedPerClass();
-    }
+  @GET
+  @Path("/timedPerClass")
+  public String timedPerClass() {
+    return "yay";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceTimedPerClass locateSubResource() {
+    return new InstrumentedSubResourceTimedPerClass();
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResource.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResource.java
@@ -9,11 +9,10 @@ import jakarta.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResource {
 
-    @GET
-    @Timed
-    @Path("/timed")
-    public String timed() {
-        return "yay";
-    }
-
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    return "yay";
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResourceExceptionMeteredPerClass.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResourceExceptionMeteredPerClass.java
@@ -7,18 +7,18 @@ import jakarta.ws.rs.Path;
 import jakarta.ws.rs.Produces;
 import jakarta.ws.rs.QueryParam;
 import jakarta.ws.rs.core.MediaType;
-
 import java.io.IOException;
 
 @ExceptionMetered(cause = IOException.class)
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceExceptionMeteredPerClass {
-    @GET
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResourceMeteredPerClass.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResourceMeteredPerClass.java
@@ -9,9 +9,9 @@ import jakarta.ws.rs.core.MediaType;
 @Metered
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceMeteredPerClass {
-    @GET
-    @Path("/meteredPerClass")
-    public String meteredPerClass() {
-        return "yay";
-    }
+  @GET
+  @Path("/meteredPerClass")
+  public String meteredPerClass() {
+    return "yay";
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResourceResponseMeteredPerClass.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResourceResponseMeteredPerClass.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.jersey3.resources;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+
 import io.dropwizard.metrics5.annotation.ResponseMetered;
 import jakarta.ws.rs.GET;
 import jakarta.ws.rs.Path;
@@ -7,14 +9,12 @@ import jakarta.ws.rs.Produces;
 import jakarta.ws.rs.core.MediaType;
 import jakarta.ws.rs.core.Response;
 
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-
 @ResponseMetered(level = ALL)
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceResponseMeteredPerClass {
-    @GET
-    @Path("/responseMeteredPerClass")
-    public Response responseMeteredPerClass() {
-        return Response.status(Response.Status.OK).build();
-    }
+  @GET
+  @Path("/responseMeteredPerClass")
+  public Response responseMeteredPerClass() {
+    return Response.status(Response.Status.OK).build();
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResourceTimedPerClass.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/InstrumentedSubResourceTimedPerClass.java
@@ -9,9 +9,9 @@ import jakarta.ws.rs.core.MediaType;
 @Timed
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceTimedPerClass {
-    @GET
-    @Path("/timedPerClass")
-    public String timedPerClass() {
-        return "yay";
-    }
+  @GET
+  @Path("/timedPerClass")
+  public String timedPerClass() {
+    return "yay";
+  }
 }
--- a/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/TestRequestFilter.java
+++ b/metrics-jersey3/src/test/java/io/dropwizard/metrics5/jersey3/resources/TestRequestFilter.java
@@ -3,19 +3,18 @@ package io.dropwizard.metrics5.jersey3.resources;
 import io.dropwizard.metrics5.jersey3.TestClock;
 import jakarta.ws.rs.container.ContainerRequestContext;
 import jakarta.ws.rs.container.ContainerRequestFilter;
-
 import java.io.IOException;
 
 public class TestRequestFilter implements ContainerRequestFilter {
 
-    private final TestClock testClock;
+  private final TestClock testClock;
 
-    public TestRequestFilter(TestClock testClock) {
-        this.testClock = testClock;
-    }
+  public TestRequestFilter(TestClock testClock) {
+    this.testClock = testClock;
+  }
 
-    @Override
-    public void filter(ContainerRequestContext containerRequestContext) throws IOException {
-        testClock.tick += 4;
-    }
+  @Override
+  public void filter(ContainerRequestContext containerRequestContext) throws IOException {
+    testClock.tick += 4;
+  }
 }
--- a/metrics-jersey31/src/main/java/io/dropwizard/metrics5/jersey31/InstrumentedResourceMethodApplicationListener.java
+++ b/metrics-jersey31/src/main/java/io/dropwizard/metrics5/jersey31/InstrumentedResourceMethodApplicationListener.java
@@ -1,5 +1,14 @@
 package io.dropwizard.metrics5.jersey31;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.util.Collections.unmodifiableList;
+
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.ExponentiallyDecayingReservoir;
 import io.dropwizard.metrics5.Meter;
@@ -14,20 +23,9 @@ import io.dropwizard.metrics5.annotation.ResponseMeteredLevel;
 import io.dropwizard.metrics5.annotation.Timed;
 import jakarta.ws.rs.core.Configuration;
 import jakarta.ws.rs.ext.Provider;
-import org.glassfish.jersey.server.ContainerResponse;
-import org.glassfish.jersey.server.model.ModelProcessor;
-import org.glassfish.jersey.server.model.Resource;
-import org.glassfish.jersey.server.model.ResourceMethod;
-import org.glassfish.jersey.server.model.ResourceModel;
-import org.glassfish.jersey.server.monitoring.ApplicationEvent;
-import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
-import org.glassfish.jersey.server.monitoring.RequestEvent;
-import org.glassfish.jersey.server.monitoring.RequestEventListener;
-
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
@@ -36,518 +34,573 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import org.glassfish.jersey.server.ContainerResponse;
+import org.glassfish.jersey.server.model.ModelProcessor;
+import org.glassfish.jersey.server.model.Resource;
+import org.glassfish.jersey.server.model.ResourceMethod;
+import org.glassfish.jersey.server.model.ResourceModel;
+import org.glassfish.jersey.server.monitoring.ApplicationEvent;
+import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
+import org.glassfish.jersey.server.monitoring.RequestEvent;
+import org.glassfish.jersey.server.monitoring.RequestEventListener;
 
 /**
- * An application event listener that listens for Jersey application initialization to
- * be finished, then creates a map of resource method that have metrics annotations.
- * <p>
- * Finally, it listens for method start events, and returns a {@link RequestEventListener}
- * that updates the relevant metric for suitably annotated methods when it gets the
- * request events indicating that the method is about to be invoked, or just got done
- * being invoked.
+ * An application event listener that listens for Jersey application initialization to be finished,
+ * then creates a map of resource method that have metrics annotations.
+ *
+ * <p>Finally, it listens for method start events, and returns a {@link RequestEventListener} that
+ * updates the relevant metric for suitably annotated methods when it gets the request events
+ * indicating that the method is about to be invoked, or just got done being invoked.
  */
 @Provider
-public class InstrumentedResourceMethodApplicationListener implements ApplicationEventListener, ModelProcessor {
-
-    private static final String[] REQUEST_FILTERING = {"request", "filtering"};
-    private static final String[] RESPONSE_FILTERING = {"response", "filtering"};
-    private static final String TOTAL = "total";
-
-    private final MetricRegistry metrics;
-    private final ConcurrentMap<EventTypeAndMethod, Timer> timers = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, Meter> meters = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters = new ConcurrentHashMap<>();
-    private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters = new ConcurrentHashMap<>();
-
-    private final Clock clock;
-    private final boolean trackFilters;
-    private final Supplier<Reservoir> reservoirSupplier;
-
-    /**
-     * Construct an application event listener using the given metrics registry.
-     * <p>
-     * When using this constructor, the {@link InstrumentedResourceMethodApplicationListener}
-     * should be added to a Jersey {@code ResourceConfig} as a singleton.
-     *
-     * @param metrics a {@link MetricRegistry}
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics) {
-        this(metrics, Clock.defaultClock(), false);
-    }
-
-    /**
-     * Constructs a custom application listener.
-     *
-     * @param metrics      the metrics registry where the metrics will be stored
-     * @param clock        the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters whether the processing time for request and response filters should be tracked
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics, final Clock clock,
-                                                         final boolean trackFilters) {
-        this(metrics, clock, trackFilters, ExponentiallyDecayingReservoir::new);
-    }
-
-    /**
-     * Constructs a custom application listener.
-     *
-     * @param metrics           the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics, final Clock clock,
-                                                         final boolean trackFilters,
-                                                         final Supplier<Reservoir> reservoirSupplier) {
-        this.metrics = metrics;
-        this.clock = clock;
-        this.trackFilters = trackFilters;
-        this.reservoirSupplier = reservoirSupplier;
-    }
-
-    /**
-     * A private class to maintain the metric for a method annotated with the
-     * {@link ExceptionMetered} annotation, which needs to maintain both a meter
-     * and a cause for which the meter should be updated.
-     */
-    private static class ExceptionMeterMetric {
-        public final Meter meter;
-        public final Class<? extends Throwable> cause;
-
-        public ExceptionMeterMetric(final MetricRegistry registry,
-                                    final ResourceMethod method,
-                                    final ExceptionMetered exceptionMetered) {
-            final MetricName name = chooseName(exceptionMetered.name(),
-                    exceptionMetered.absolute(), method, ExceptionMetered.DEFAULT_NAME_SUFFIX);
-            this.meter = registry.meter(name);
-            this.cause = exceptionMetered.cause();
-        }
+public class InstrumentedResourceMethodApplicationListener
+    implements ApplicationEventListener, ModelProcessor {
+
+  private static final String[] REQUEST_FILTERING = {"request", "filtering"};
+  private static final String[] RESPONSE_FILTERING = {"response", "filtering"};
+  private static final String TOTAL = "total";
+
+  private final MetricRegistry metrics;
+  private final ConcurrentMap<EventTypeAndMethod, Timer> timers = new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, Meter> meters = new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters =
+      new ConcurrentHashMap<>();
+  private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters =
+      new ConcurrentHashMap<>();
+
+  private final Clock clock;
+  private final boolean trackFilters;
+  private final Supplier<Reservoir> reservoirSupplier;
+
+  /**
+   * Construct an application event listener using the given metrics registry.
+   *
+   * <p>When using this constructor, the {@link InstrumentedResourceMethodApplicationListener}
+   * should be added to a Jersey {@code ResourceConfig} as a singleton.
+   *
+   * @param metrics a {@link MetricRegistry}
+   */
+  public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics) {
+    this(metrics, Clock.defaultClock(), false);
+  }
+
+  /**
+   * Constructs a custom application listener.
+   *
+   * @param metrics the metrics registry where the metrics will be stored
+   * @param clock the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters whether the processing time for request and response filters should be
+   *     tracked
+   */
+  public InstrumentedResourceMethodApplicationListener(
+      final MetricRegistry metrics, final Clock clock, final boolean trackFilters) {
+    this(metrics, clock, trackFilters, ExponentiallyDecayingReservoir::new);
+  }
+
+  /**
+   * Constructs a custom application listener.
+   *
+   * @param metrics the metrics registry where the metrics will be stored
+   * @param clock the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters whether the processing time for request and response filters should be
+   *     tracked
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public InstrumentedResourceMethodApplicationListener(
+      final MetricRegistry metrics,
+      final Clock clock,
+      final boolean trackFilters,
+      final Supplier<Reservoir> reservoirSupplier) {
+    this.metrics = metrics;
+    this.clock = clock;
+    this.trackFilters = trackFilters;
+    this.reservoirSupplier = reservoirSupplier;
+  }
+
+  /**
+   * A private class to maintain the metric for a method annotated with the {@link ExceptionMetered}
+   * annotation, which needs to maintain both a meter and a cause for which the meter should be
+   * updated.
+   */
+  private static class ExceptionMeterMetric {
+    public final Meter meter;
+    public final Class<? extends Throwable> cause;
+
+    public ExceptionMeterMetric(
+        final MetricRegistry registry,
+        final ResourceMethod method,
+        final ExceptionMetered exceptionMetered) {
+      final MetricName name =
+          chooseName(
+              exceptionMetered.name(),
+              exceptionMetered.absolute(),
+              method,
+              ExceptionMetered.DEFAULT_NAME_SUFFIX);
+      this.meter = registry.meter(name);
+      this.cause = exceptionMetered.cause();
     }
-
-    /**
-     * A private class to maintain the metrics for a method annotated with the
-     * {@link ResponseMetered} annotation, which needs to maintain meters for
-     * different response codes
-     */
-    private static class ResponseMeterMetric {
-        private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
-        private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
-        private final List<Meter> meters;
-        private final Map<Integer, Meter> responseCodeMeters;
-        private final MetricRegistry metricRegistry;
-        private final MetricName metricName;
-        private final ResponseMeteredLevel level;
-
-        public ResponseMeterMetric(final MetricRegistry registry,
-                                   final ResourceMethod method,
-                                   final ResponseMetered responseMetered) {
-            this.metricName = chooseName(responseMetered.name(), responseMetered.absolute(), method);
-            this.level = responseMetered.level();
-            this.meters = COARSE_METER_LEVELS.contains(level) ?
-                    Collections.unmodifiableList(Arrays.asList(
-                            registry.meter(metricName.resolve("1xx-responses")), // 1xx
-                            registry.meter(metricName.resolve("2xx-responses")), // 2xx
-                            registry.meter(metricName.resolve("3xx-responses")), // 3xx
-                            registry.meter(metricName.resolve("4xx-responses")), // 4xx
-                            registry.meter(metricName.resolve("5xx-responses"))  // 5xx
-                    )) : Collections.emptyList();
-            this.responseCodeMeters = DETAILED_METER_LEVELS.contains(level) ? new ConcurrentHashMap<>() : Collections.emptyMap();
-            this.metricRegistry = registry;
-        }
-
-        public void mark(int statusCode) {
-            if (DETAILED_METER_LEVELS.contains(level)) {
-                getResponseCodeMeter(statusCode).mark();
-            }
-
-            if (COARSE_METER_LEVELS.contains(level)) {
-                final int responseStatus = statusCode / 100;
-                if (responseStatus >= 1 && responseStatus <= 5) {
-                    meters.get(responseStatus - 1).mark();
-                }
-            }
-        }
-
-        private Meter getResponseCodeMeter(int statusCode) {
-            return responseCodeMeters
-                    .computeIfAbsent(statusCode, sc -> metricRegistry
-                            .meter(metricName.resolve(String.format("%d-responses", sc))));
-        }
+  }
+
+  /**
+   * A private class to maintain the metrics for a method annotated with the {@link ResponseMetered}
+   * annotation, which needs to maintain meters for different response codes
+   */
+  private static class ResponseMeterMetric {
+    private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
+    private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS =
+        EnumSet.of(DETAILED, ALL);
+    private final List<Meter> meters;
+    private final Map<Integer, Meter> responseCodeMeters;
+    private final MetricRegistry metricRegistry;
+    private final MetricName metricName;
+    private final ResponseMeteredLevel level;
+
+    public ResponseMeterMetric(
+        final MetricRegistry registry,
+        final ResourceMethod method,
+        final ResponseMetered responseMetered) {
+      this.metricName = chooseName(responseMetered.name(), responseMetered.absolute(), method);
+      this.level = responseMetered.level();
+      this.meters =
+          COARSE_METER_LEVELS.contains(level)
+              ? unmodifiableList(
+                  Arrays.asList(
+                      registry.meter(metricName.resolve("1xx-responses")), // 1xx
+                      registry.meter(metricName.resolve("2xx-responses")), // 2xx
+                      registry.meter(metricName.resolve("3xx-responses")), // 3xx
+                      registry.meter(metricName.resolve("4xx-responses")), // 4xx
+                      registry.meter(metricName.resolve("5xx-responses")) // 5xx
+                      ))
+              : ImmutableList.of();
+      this.responseCodeMeters =
+          DETAILED_METER_LEVELS.contains(level) ? new ConcurrentHashMap<>() : ImmutableMap.of();
+      this.metricRegistry = registry;
     }
 
-    private static class TimerRequestEventListener implements RequestEventListener {
-
-        private final ConcurrentMap<EventTypeAndMethod, Timer> timers;
-        private final Clock clock;
-        private final long start;
-        private Timer.Context resourceMethodStartContext;
-        private Timer.Context requestMatchedContext;
-        private Timer.Context responseFiltersStartContext;
-
-        public TimerRequestEventListener(final ConcurrentMap<EventTypeAndMethod, Timer> timers, final Clock clock) {
-            this.timers = timers;
-            this.clock = clock;
-            start = clock.getTick();
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            switch (event.getType()) {
-                case RESOURCE_METHOD_START:
-                    resourceMethodStartContext = context(event);
-                    break;
-                case REQUEST_MATCHED:
-                    requestMatchedContext = context(event);
-                    break;
-                case RESP_FILTERS_START:
-                    responseFiltersStartContext = context(event);
-                    break;
-                case RESOURCE_METHOD_FINISHED:
-                    if (resourceMethodStartContext != null) {
-                        resourceMethodStartContext.close();
-                    }
-                    break;
-                case REQUEST_FILTERED:
-                    if (requestMatchedContext != null) {
-                        requestMatchedContext.close();
-                    }
-                    break;
-                case RESP_FILTERS_FINISHED:
-                    if (responseFiltersStartContext != null) {
-                        responseFiltersStartContext.close();
-                    }
-                    break;
-                case FINISHED:
-                    if (requestMatchedContext != null && responseFiltersStartContext != null) {
-                        final Timer timer = timer(event);
-                        if (timer != null) {
-                            timer.update(clock.getTick() - start, TimeUnit.NANOSECONDS);
-                        }
-                    }
-                    break;
-                default:
-                    break;
-            }
-        }
-
-        private Timer timer(RequestEvent event) {
-            final ResourceMethod resourceMethod = event.getUriInfo().getMatchedResourceMethod();
-            if (resourceMethod == null) {
-                return null;
-            }
-            return timers.get(new EventTypeAndMethod(event.getType(), resourceMethod.getInvocable().getDefinitionMethod()));
-        }
+    public void mark(int statusCode) {
+      if (DETAILED_METER_LEVELS.contains(level)) {
+        getResponseCodeMeter(statusCode).mark();
+      }
 
-        private Timer.Context context(RequestEvent event) {
-            final Timer timer = timer(event);
-            return timer != null ? timer.time() : null;
+      if (COARSE_METER_LEVELS.contains(level)) {
+        final int responseStatus = statusCode / 100;
+        if (responseStatus >= 1 && responseStatus <= 5) {
+          meters.get(responseStatus - 1).mark();
         }
+      }
     }
 
-    private static class MeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, Meter> meters;
-
-        public MeterRequestEventListener(final ConcurrentMap<Method, Meter> meters) {
-            this.meters = meters;
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.RESOURCE_METHOD_START) {
-                final Meter meter = this.meters.get(event.getUriInfo().getMatchedResourceMethod().getInvocable().getDefinitionMethod());
-                if (meter != null) {
-                    meter.mark();
-                }
-            }
-        }
+    private Meter getResponseCodeMeter(int statusCode) {
+      return responseCodeMeters.computeIfAbsent(
+          statusCode,
+          sc -> metricRegistry.meter(metricName.resolve(String.format("%d-responses", sc))));
     }
+  }
 
-    private static class ExceptionMeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters;
+  private static class TimerRequestEventListener implements RequestEventListener {
 
-        public ExceptionMeterRequestEventListener(final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters) {
-            this.exceptionMeters = exceptionMeters;
-        }
+    private final ConcurrentMap<EventTypeAndMethod, Timer> timers;
+    private final Clock clock;
+    private final long start;
+    private Timer.Context resourceMethodStartContext;
+    private Timer.Context requestMatchedContext;
+    private Timer.Context responseFiltersStartContext;
+
+    public TimerRequestEventListener(
+        final ConcurrentMap<EventTypeAndMethod, Timer> timers, final Clock clock) {
+      this.timers = timers;
+      this.clock = clock;
+      start = clock.getTick();
+    }
 
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.ON_EXCEPTION) {
-                final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
-                final ExceptionMeterMetric metric = (method != null) ?
-                        this.exceptionMeters.get(method.getInvocable().getDefinitionMethod()) : null;
-
-                if (metric != null) {
-                    if (metric.cause.isAssignableFrom(event.getException().getClass()) ||
-                            (event.getException().getCause() != null &&
-                                    metric.cause.isAssignableFrom(event.getException().getCause().getClass()))) {
-                        metric.meter.mark();
-                    }
-                }
+    @Override
+    public void onEvent(RequestEvent event) {
+      switch (event.getType()) {
+        case RESOURCE_METHOD_START:
+          resourceMethodStartContext = context(event);
+          break;
+        case REQUEST_MATCHED:
+          requestMatchedContext = context(event);
+          break;
+        case RESP_FILTERS_START:
+          responseFiltersStartContext = context(event);
+          break;
+        case RESOURCE_METHOD_FINISHED:
+          if (resourceMethodStartContext != null) {
+            resourceMethodStartContext.close();
+          }
+          break;
+        case REQUEST_FILTERED:
+          if (requestMatchedContext != null) {
+            requestMatchedContext.close();
+          }
+          break;
+        case RESP_FILTERS_FINISHED:
+          if (responseFiltersStartContext != null) {
+            responseFiltersStartContext.close();
+          }
+          break;
+        case FINISHED:
+          if (requestMatchedContext != null && responseFiltersStartContext != null) {
+            final Timer timer = timer(event);
+            if (timer != null) {
+              timer.update(clock.getTick() - start, TimeUnit.NANOSECONDS);
             }
-        }
+          }
+          break;
+        default:
+          break;
+      }
     }
 
-    private static class ResponseMeterRequestEventListener implements RequestEventListener {
-        private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters;
-
-        public ResponseMeterRequestEventListener(final ConcurrentMap<Method, ResponseMeterMetric> responseMeters) {
-            this.responseMeters = responseMeters;
-        }
-
-        @Override
-        public void onEvent(RequestEvent event) {
-            if (event.getType() == RequestEvent.Type.FINISHED) {
-                final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
-                final ResponseMeterMetric metric = (method != null) ?
-                        this.responseMeters.get(method.getInvocable().getDefinitionMethod()) : null;
-
-                if (metric != null) {
-                    ContainerResponse containerResponse = event.getContainerResponse();
-                    if (containerResponse == null && event.getException() != null) {
-                        metric.mark(500);
-                    } else if (containerResponse != null) {
-                        metric.mark(containerResponse.getStatus());
-                    }
-                }
-            }
-        }
+    private Timer timer(RequestEvent event) {
+      final ResourceMethod resourceMethod = event.getUriInfo().getMatchedResourceMethod();
+      if (resourceMethod == null) {
+        return null;
+      }
+      return timers.get(
+          new EventTypeAndMethod(
+              event.getType(), resourceMethod.getInvocable().getDefinitionMethod()));
     }
 
-    private static class ChainedRequestEventListener implements RequestEventListener {
-        private final RequestEventListener[] listeners;
+    private Timer.Context context(RequestEvent event) {
+      final Timer timer = timer(event);
+      return timer != null ? timer.time() : null;
+    }
+  }
 
-        private ChainedRequestEventListener(final RequestEventListener... listeners) {
-            this.listeners = listeners;
-        }
+  private static class MeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, Meter> meters;
 
-        @Override
-        public void onEvent(final RequestEvent event) {
-            for (RequestEventListener listener : listeners) {
-                listener.onEvent(event);
-            }
-        }
+    public MeterRequestEventListener(final ConcurrentMap<Method, Meter> meters) {
+      this.meters = meters;
     }
 
     @Override
-    public void onEvent(ApplicationEvent event) {
-        if (event.getType() == ApplicationEvent.Type.INITIALIZATION_APP_FINISHED) {
-            registerMetricsForModel(event.getResourceModel());
-        }
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.RESOURCE_METHOD_START) {
+        final Meter meter =
+            this.meters.get(
+                event.getUriInfo().getMatchedResourceMethod().getInvocable().getDefinitionMethod());
+        if (meter != null) {
+          meter.mark();
+        }
+      }
     }
+  }
 
-    @Override
-    public ResourceModel processResourceModel(ResourceModel resourceModel, Configuration configuration) {
-        return resourceModel;
+  private static class ExceptionMeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters;
+
+    public ExceptionMeterRequestEventListener(
+        final ConcurrentMap<Method, ExceptionMeterMetric> exceptionMeters) {
+      this.exceptionMeters = exceptionMeters;
     }
 
     @Override
-    public ResourceModel processSubResource(ResourceModel subResourceModel, Configuration configuration) {
-        registerMetricsForModel(subResourceModel);
-        return subResourceModel;
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.ON_EXCEPTION) {
+        final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
+        final ExceptionMeterMetric metric =
+            (method != null)
+                ? this.exceptionMeters.get(method.getInvocable().getDefinitionMethod())
+                : null;
+
+        if (metric != null) {
+          if (metric.cause.isInstance(event.getException())
+              || (event.getException().getCause() != null
+                  && metric.cause.isInstance(event.getException().getCause()))) {
+            metric.meter.mark();
+          }
+        }
+      }
     }
+  }
 
-    private void registerMetricsForModel(ResourceModel resourceModel) {
-        for (final Resource resource : resourceModel.getResources()) {
-
-            final Timed classLevelTimed = getClassLevelAnnotation(resource, Timed.class);
-            final Metered classLevelMetered = getClassLevelAnnotation(resource, Metered.class);
-            final ExceptionMetered classLevelExceptionMetered = getClassLevelAnnotation(resource, ExceptionMetered.class);
-            final ResponseMetered classLevelResponseMetered = getClassLevelAnnotation(resource, ResponseMetered.class);
-
-            for (final ResourceMethod method : resource.getAllMethods()) {
-                registerTimedAnnotations(method, classLevelTimed);
-                registerMeteredAnnotations(method, classLevelMetered);
-                registerExceptionMeteredAnnotations(method, classLevelExceptionMetered);
-                registerResponseMeteredAnnotations(method, classLevelResponseMetered);
-            }
-
-            for (final Resource childResource : resource.getChildResources()) {
-
-                final Timed classLevelTimedChild = getClassLevelAnnotation(childResource, Timed.class);
-                final Metered classLevelMeteredChild = getClassLevelAnnotation(childResource, Metered.class);
-                final ExceptionMetered classLevelExceptionMeteredChild = getClassLevelAnnotation(childResource, ExceptionMetered.class);
-                final ResponseMetered classLevelResponseMeteredChild = getClassLevelAnnotation(childResource, ResponseMetered.class);
+  private static class ResponseMeterRequestEventListener implements RequestEventListener {
+    private final ConcurrentMap<Method, ResponseMeterMetric> responseMeters;
 
-                for (final ResourceMethod method : childResource.getAllMethods()) {
-                    registerTimedAnnotations(method, classLevelTimedChild);
-                    registerMeteredAnnotations(method, classLevelMeteredChild);
-                    registerExceptionMeteredAnnotations(method, classLevelExceptionMeteredChild);
-                    registerResponseMeteredAnnotations(method, classLevelResponseMeteredChild);
-                }
-            }
-        }
+    public ResponseMeterRequestEventListener(
+        final ConcurrentMap<Method, ResponseMeterMetric> responseMeters) {
+      this.responseMeters = responseMeters;
     }
 
     @Override
-    public RequestEventListener onRequest(final RequestEvent event) {
-        final RequestEventListener listener = new ChainedRequestEventListener(
-                new TimerRequestEventListener(timers, clock),
-                new MeterRequestEventListener(meters),
-                new ExceptionMeterRequestEventListener(exceptionMeters),
-                new ResponseMeterRequestEventListener(responseMeters));
-
-        return listener;
+    public void onEvent(RequestEvent event) {
+      if (event.getType() == RequestEvent.Type.FINISHED) {
+        final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();
+        final ResponseMeterMetric metric =
+            (method != null)
+                ? this.responseMeters.get(method.getInvocable().getDefinitionMethod())
+                : null;
+
+        if (metric != null) {
+          ContainerResponse containerResponse = event.getContainerResponse();
+          if (containerResponse == null && event.getException() != null) {
+            metric.mark(500);
+          } else if (containerResponse != null) {
+            metric.mark(containerResponse.getStatus());
+          }
+        }
+      }
     }
+  }
 
-    private <T extends Annotation> T getClassLevelAnnotation(final Resource resource, final Class<T> annotationClazz) {
-        T annotation = null;
-
-        for (final Class<?> clazz : resource.getHandlerClasses()) {
-            annotation = clazz.getAnnotation(annotationClazz);
+  private static class ChainedRequestEventListener implements RequestEventListener {
+    private final RequestEventListener[] listeners;
 
-            if (annotation != null) {
-                break;
-            }
-        }
-        return annotation;
+    private ChainedRequestEventListener(final RequestEventListener... listeners) {
+      this.listeners = listeners;
     }
 
-    private void registerTimedAnnotations(final ResourceMethod method, final Timed classLevelTimed) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
-        if (classLevelTimed != null) {
-            registerTimers(method, definitionMethod, classLevelTimed);
-            return;
-        }
-
-        final Timed annotation = definitionMethod.getAnnotation(Timed.class);
-        if (annotation != null) {
-            registerTimers(method, definitionMethod, annotation);
-        }
+    @Override
+    public void onEvent(final RequestEvent event) {
+      for (RequestEventListener listener : listeners) {
+        listener.onEvent(event);
+      }
     }
+  }
 
-    private void registerTimers(ResourceMethod method, Method definitionMethod, Timed annotation) {
-        timers.putIfAbsent(EventTypeAndMethod.requestMethodStart(definitionMethod), timerMetric(metrics, method, annotation));
-        if (trackFilters) {
-            timers.putIfAbsent(EventTypeAndMethod.requestMatched(definitionMethod), timerMetric(metrics, method, annotation, REQUEST_FILTERING));
-            timers.putIfAbsent(EventTypeAndMethod.respFiltersStart(definitionMethod), timerMetric(metrics, method, annotation, RESPONSE_FILTERING));
-            timers.putIfAbsent(EventTypeAndMethod.finished(definitionMethod), timerMetric(metrics, method, annotation, TOTAL));
-        }
+  @Override
+  public void onEvent(ApplicationEvent event) {
+    if (event.getType() == ApplicationEvent.Type.INITIALIZATION_APP_FINISHED) {
+      registerMetricsForModel(event.getResourceModel());
+    }
+  }
+
+  @Override
+  public ResourceModel processResourceModel(
+      ResourceModel resourceModel, Configuration configuration) {
+    return resourceModel;
+  }
+
+  @Override
+  public ResourceModel processSubResource(
+      ResourceModel subResourceModel, Configuration configuration) {
+    registerMetricsForModel(subResourceModel);
+    return subResourceModel;
+  }
+
+  private void registerMetricsForModel(ResourceModel resourceModel) {
+    for (final Resource resource : resourceModel.getResources()) {
+
+      final Timed classLevelTimed = getClassLevelAnnotation(resource, Timed.class);
+      final Metered classLevelMetered = getClassLevelAnnotation(resource, Metered.class);
+      final ExceptionMetered classLevelExceptionMetered =
+          getClassLevelAnnotation(resource, ExceptionMetered.class);
+      final ResponseMetered classLevelResponseMetered =
+          getClassLevelAnnotation(resource, ResponseMetered.class);
+
+      for (final ResourceMethod method : resource.getAllMethods()) {
+        registerTimedAnnotations(method, classLevelTimed);
+        registerMeteredAnnotations(method, classLevelMetered);
+        registerExceptionMeteredAnnotations(method, classLevelExceptionMetered);
+        registerResponseMeteredAnnotations(method, classLevelResponseMetered);
+      }
+
+      for (final Resource childResource : resource.getChildResources()) {
+
+        final Timed classLevelTimedChild = getClassLevelAnnotation(childResource, Timed.class);
+        final Metered classLevelMeteredChild =
+            getClassLevelAnnotation(childResource, Metered.class);
+        final ExceptionMetered classLevelExceptionMeteredChild =
+            getClassLevelAnnotation(childResource, ExceptionMetered.class);
+        final ResponseMetered classLevelResponseMeteredChild =
+            getClassLevelAnnotation(childResource, ResponseMetered.class);
+
+        for (final ResourceMethod method : childResource.getAllMethods()) {
+          registerTimedAnnotations(method, classLevelTimedChild);
+          registerMeteredAnnotations(method, classLevelMeteredChild);
+          registerExceptionMeteredAnnotations(method, classLevelExceptionMeteredChild);
+          registerResponseMeteredAnnotations(method, classLevelResponseMeteredChild);
+        }
+      }
+    }
+  }
+
+  @Override
+  public RequestEventListener onRequest(final RequestEvent event) {
+    return new ChainedRequestEventListener(
+        new TimerRequestEventListener(timers, clock),
+        new MeterRequestEventListener(meters),
+        new ExceptionMeterRequestEventListener(exceptionMeters),
+        new ResponseMeterRequestEventListener(responseMeters));
+  }
+
+  private <T extends Annotation> T getClassLevelAnnotation(
+      final Resource resource, final Class<T> annotationClazz) {
+    T annotation = null;
+
+    for (final Class<?> clazz : resource.getHandlerClasses()) {
+      annotation = clazz.getAnnotation(annotationClazz);
+
+      if (annotation != null) {
+        break;
+      }
+    }
+    return annotation;
+  }
+
+  private void registerTimedAnnotations(final ResourceMethod method, final Timed classLevelTimed) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (classLevelTimed != null) {
+      registerTimers(method, definitionMethod, classLevelTimed);
+      return;
     }
 
-    private void registerMeteredAnnotations(final ResourceMethod method, final Metered classLevelMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    final Timed annotation = definitionMethod.getAnnotation(Timed.class);
+    if (annotation != null) {
+      registerTimers(method, definitionMethod, annotation);
+    }
+  }
+
+  private void registerTimers(ResourceMethod method, Method definitionMethod, Timed annotation) {
+    timers.putIfAbsent(
+        EventTypeAndMethod.requestMethodStart(definitionMethod),
+        timerMetric(metrics, method, annotation));
+    if (trackFilters) {
+      timers.putIfAbsent(
+          EventTypeAndMethod.requestMatched(definitionMethod),
+          timerMetric(metrics, method, annotation, REQUEST_FILTERING));
+      timers.putIfAbsent(
+          EventTypeAndMethod.respFiltersStart(definitionMethod),
+          timerMetric(metrics, method, annotation, RESPONSE_FILTERING));
+      timers.putIfAbsent(
+          EventTypeAndMethod.finished(definitionMethod),
+          timerMetric(metrics, method, annotation, TOTAL));
+    }
+  }
 
-        if (classLevelMetered != null) {
-            meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, classLevelMetered));
-            return;
-        }
-        final Metered annotation = definitionMethod.getAnnotation(Metered.class);
+  private void registerMeteredAnnotations(
+      final ResourceMethod method, final Metered classLevelMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, annotation));
-        }
+    if (classLevelMetered != null) {
+      meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, classLevelMetered));
+      return;
     }
+    final Metered annotation = definitionMethod.getAnnotation(Metered.class);
 
-    private void registerExceptionMeteredAnnotations(final ResourceMethod method, final ExceptionMetered classLevelExceptionMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (annotation != null) {
+      meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, annotation));
+    }
+  }
 
-        if (classLevelExceptionMetered != null) {
-            exceptionMeters.putIfAbsent(definitionMethod, new ExceptionMeterMetric(metrics, method, classLevelExceptionMetered));
-            return;
-        }
-        final ExceptionMetered annotation = definitionMethod.getAnnotation(ExceptionMetered.class);
+  private void registerExceptionMeteredAnnotations(
+      final ResourceMethod method, final ExceptionMetered classLevelExceptionMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            exceptionMeters.putIfAbsent(definitionMethod, new ExceptionMeterMetric(metrics, method, annotation));
-        }
+    if (classLevelExceptionMetered != null) {
+      exceptionMeters.putIfAbsent(
+          definitionMethod, new ExceptionMeterMetric(metrics, method, classLevelExceptionMetered));
+      return;
     }
+    final ExceptionMetered annotation = definitionMethod.getAnnotation(ExceptionMetered.class);
 
-    private void registerResponseMeteredAnnotations(final ResourceMethod method, final ResponseMetered classLevelResponseMetered) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    if (annotation != null) {
+      exceptionMeters.putIfAbsent(
+          definitionMethod, new ExceptionMeterMetric(metrics, method, annotation));
+    }
+  }
 
-        if (classLevelResponseMetered != null) {
-            responseMeters.putIfAbsent(definitionMethod, new ResponseMeterMetric(metrics, method, classLevelResponseMetered));
-            return;
-        }
-        final ResponseMetered annotation = definitionMethod.getAnnotation(ResponseMetered.class);
+  private void registerResponseMeteredAnnotations(
+      final ResourceMethod method, final ResponseMetered classLevelResponseMetered) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
 
-        if (annotation != null) {
-            responseMeters.putIfAbsent(definitionMethod, new ResponseMeterMetric(metrics, method, annotation));
-        }
+    if (classLevelResponseMetered != null) {
+      responseMeters.putIfAbsent(
+          definitionMethod, new ResponseMeterMetric(metrics, method, classLevelResponseMetered));
+      return;
     }
+    final ResponseMetered annotation = definitionMethod.getAnnotation(ResponseMetered.class);
 
-    private Timer timerMetric(final MetricRegistry registry,
-                              final ResourceMethod method,
-                              final Timed timed,
-                              final String... suffixes) {
-        final MetricName name = chooseName(timed.name(), timed.absolute(), method, suffixes);
-        return registry.timer(name, () -> new Timer(reservoirSupplier.get(), clock));
+    if (annotation != null) {
+      responseMeters.putIfAbsent(
+          definitionMethod, new ResponseMeterMetric(metrics, method, annotation));
     }
-
-    private Meter meterMetric(final MetricRegistry registry,
-                              final ResourceMethod method,
-                              final Metered metered) {
-        final MetricName name = chooseName(metered.name(), metered.absolute(), method);
-        return registry.meter(name, () -> new Meter(clock));
+  }
+
+  private Timer timerMetric(
+      final MetricRegistry registry,
+      final ResourceMethod method,
+      final Timed timed,
+      final String... suffixes) {
+    final MetricName name = chooseName(timed.name(), timed.absolute(), method, suffixes);
+    return registry.timer(name, () -> new Timer(reservoirSupplier.get(), clock));
+  }
+
+  private Meter meterMetric(
+      final MetricRegistry registry, final ResourceMethod method, final Metered metered) {
+    final MetricName name = chooseName(metered.name(), metered.absolute(), method);
+    return registry.meter(name, () -> new Meter(clock));
+  }
+
+  protected static MetricName chooseName(
+      final String explicitName,
+      final boolean absolute,
+      final ResourceMethod method,
+      final String... suffixes) {
+    final Method definitionMethod = method.getInvocable().getDefinitionMethod();
+    MetricName metricName;
+    if (!Strings.isNullOrEmpty(explicitName)) {
+      metricName =
+          absolute ? name(explicitName) : name(definitionMethod.getDeclaringClass(), explicitName);
+    } else {
+      metricName = name(definitionMethod.getDeclaringClass(), definitionMethod.getName());
     }
-
-    protected static MetricName chooseName(final String explicitName, final boolean absolute, final ResourceMethod method,
-                                           final String... suffixes) {
-        final Method definitionMethod = method.getInvocable().getDefinitionMethod();
-        MetricName metricName;
-        if (explicitName != null && !explicitName.isEmpty()) {
-            metricName = absolute ? name(explicitName) : name(definitionMethod.getDeclaringClass(), explicitName);
-        } else {
-            metricName = name(definitionMethod.getDeclaringClass(), definitionMethod.getName());
-        }
-        for (String suffix : suffixes) {
-            metricName = metricName.resolve(suffix);
-        }
-        return metricName;
+    for (String suffix : suffixes) {
+      metricName = metricName.resolve(suffix);
     }
+    return metricName;
+  }
 
-    private static class EventTypeAndMethod {
+  private static class EventTypeAndMethod {
 
-        private final RequestEvent.Type type;
-        private final Method method;
-
-        private EventTypeAndMethod(RequestEvent.Type type, Method method) {
-            this.type = type;
-            this.method = method;
-        }
-
-        static EventTypeAndMethod requestMethodStart(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.RESOURCE_METHOD_START, method);
-        }
+    private final RequestEvent.Type type;
+    private final Method method;
 
-        static EventTypeAndMethod requestMatched(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.REQUEST_MATCHED, method);
-        }
+    private EventTypeAndMethod(RequestEvent.Type type, Method method) {
+      this.type = type;
+      this.method = method;
+    }
 
-        static EventTypeAndMethod respFiltersStart(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.RESP_FILTERS_START, method);
-        }
+    static EventTypeAndMethod requestMethodStart(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.RESOURCE_METHOD_START, method);
+    }
 
-        static EventTypeAndMethod finished(Method method) {
-            return new EventTypeAndMethod(RequestEvent.Type.FINISHED, method);
-        }
+    static EventTypeAndMethod requestMatched(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.REQUEST_MATCHED, method);
+    }
 
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
+    static EventTypeAndMethod respFiltersStart(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.RESP_FILTERS_START, method);
+    }
 
-            EventTypeAndMethod that = (EventTypeAndMethod) o;
+    static EventTypeAndMethod finished(Method method) {
+      return new EventTypeAndMethod(RequestEvent.Type.FINISHED, method);
+    }
 
-            if (type != that.type) {
-                return false;
-            }
-            return method.equals(that.method);
-        }
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+
+      EventTypeAndMethod that = (EventTypeAndMethod) o;
+
+      if (type != that.type) {
+        return false;
+      }
+      return method.equals(that.method);
+    }
 
-        @Override
-        public int hashCode() {
-            int result = type.hashCode();
-            result = 31 * result + method.hashCode();
-            return result;
-        }
+    @Override
+    public int hashCode() {
+      int result = type.hashCode();
+      return 31 * result + method.hashCode();
     }
+  }
 }
--- a/metrics-jersey31/src/main/java/io/dropwizard/metrics5/jersey31/MetricsFeature.java
+++ b/metrics-jersey31/src/main/java/io/dropwizard/metrics5/jersey31/MetricsFeature.java
@@ -7,91 +7,96 @@ import io.dropwizard.metrics5.Reservoir;
 import io.dropwizard.metrics5.SharedMetricRegistries;
 import jakarta.ws.rs.core.Feature;
 import jakarta.ws.rs.core.FeatureContext;
-
 import java.util.function.Supplier;
 
 /**
- * A {@link Feature} which registers a {@link InstrumentedResourceMethodApplicationListener}
- * for recording request events.
+ * A {@link Feature} which registers a {@link InstrumentedResourceMethodApplicationListener} for
+ * recording request events.
  */
 public class MetricsFeature implements Feature {
 
-    private final MetricRegistry registry;
-    private final Clock clock;
-    private final boolean trackFilters;
-    private final Supplier<Reservoir> reservoirSupplier;
+  private final MetricRegistry registry;
+  private final Clock clock;
+  private final boolean trackFilters;
+  private final Supplier<Reservoir> reservoirSupplier;
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     */
-    public MetricsFeature(MetricRegistry registry) {
-        this(registry, Clock.defaultClock());
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   */
+  public MetricsFeature(MetricRegistry registry) {
+    this(registry, Clock.defaultClock());
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public MetricsFeature(MetricRegistry registry, Supplier<Reservoir> reservoirSupplier) {
-        this(registry, Clock.defaultClock(), false, reservoirSupplier);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public MetricsFeature(MetricRegistry registry, Supplier<Reservoir> reservoirSupplier) {
+    this(registry, Clock.defaultClock(), false, reservoirSupplier);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock) {
-        this(registry, clock, false);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   */
+  public MetricsFeature(MetricRegistry registry, Clock clock) {
+    this(registry, clock, false);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters) {
-        this(registry, clock, trackFilters, ExponentiallyDecayingReservoir::new);
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters      whether the processing time for request and response filters should be tracked
+   */
+  public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters) {
+    this(registry, clock, trackFilters, ExponentiallyDecayingReservoir::new);
+  }
 
-    /*
-     * @param registry          the metrics registry where the metrics will be stored
-     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
-     * @param trackFilters      whether the processing time for request and response filters should be tracked
-     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
-     */
-    public MetricsFeature(MetricRegistry registry, Clock clock, boolean trackFilters, Supplier<Reservoir> reservoirSupplier) {
-        this.registry = registry;
-        this.clock = clock;
-        this.trackFilters = trackFilters;
-        this.reservoirSupplier = reservoirSupplier;
-    }
+  /*
+   * @param registry          the metrics registry where the metrics will be stored
+   * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
+   * @param trackFilters      whether the processing time for request and response filters should be tracked
+   * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
+   */
+  public MetricsFeature(
+      MetricRegistry registry,
+      Clock clock,
+      boolean trackFilters,
+      Supplier<Reservoir> reservoirSupplier) {
+    this.registry = registry;
+    this.clock = clock;
+    this.trackFilters = trackFilters;
+    this.reservoirSupplier = reservoirSupplier;
+  }
 
-    public MetricsFeature(String registryName) {
-        this(SharedMetricRegistries.getOrCreate(registryName));
-    }
+  public MetricsFeature(String registryName) {
+    this(SharedMetricRegistries.getOrCreate(registryName));
+  }
 
-    /**
-     * A call-back method called when the feature is to be enabled in a given
-     * runtime configuration scope.
-     * <p>
-     * The responsibility of the feature is to properly update the supplied runtime configuration context
-     * and return {@code true} if the feature was successfully enabled or {@code false} otherwise.
-     * <p>
-     * Note that under some circumstances the feature may decide not to enable itself, which
-     * is indicated by returning {@code false}. In such case the configuration context does
-     * not add the feature to the collection of enabled features and a subsequent call to
-     * {@link jakarta.ws.rs.core.Configuration#isEnabled(Feature)} or
-     * {@link jakarta.ws.rs.core.Configuration#isEnabled(Class)} method
-     * would return {@code false}.
-     * <p>
-     *
-     * @param context configurable context in which the feature should be enabled.
-     * @return {@code true} if the feature was successfully enabled, {@code false}
-     * otherwise.
-     */
-    @Override
-    public boolean configure(FeatureContext context) {
-        context.register(new InstrumentedResourceMethodApplicationListener(registry, clock, trackFilters, reservoirSupplier));
-        return true;
-    }
+  /**
+   * A call-back method called when the feature is to be enabled in a given runtime configuration
+   * scope.
+   *
+   * <p>The responsibility of the feature is to properly update the supplied runtime configuration
+   * context and return {@code true} if the feature was successfully enabled or {@code false}
+   * otherwise.
+   *
+   * <p>Note that under some circumstances the feature may decide not to enable itself, which is
+   * indicated by returning {@code false}. In such case the configuration context does not add the
+   * feature to the collection of enabled features and a subsequent call to {@link
+   * jakarta.ws.rs.core.Configuration#isEnabled(Feature)} or {@link
+   * jakarta.ws.rs.core.Configuration#isEnabled(Class)} method would return {@code false}.
+   *
+   * <p>
+   *
+   * @param context configurable context in which the feature should be enabled.
+   * @return {@code true} if the feature was successfully enabled, {@code false} otherwise.
+   */
+  @Override
+  public boolean configure(FeatureContext context) {
+    context.register(
+        new InstrumentedResourceMethodApplicationListener(
+            registry, clock, trackFilters, reservoirSupplier));
+    return true;
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/CustomReservoirImplementationTest.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/CustomReservoirImplementationTest.java
@@ -1,44 +1,44 @@
 package io.dropwizard.metrics5.jersey31;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.UniformReservoir;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedResourceTimedPerClass;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
-class CustomReservoirImplementationTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class CustomReservoirImplementationTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        return new ResourceConfig()
+    return new ResourceConfig()
         .register(new MetricsFeature(this.registry, UniformReservoir::new))
         .register(InstrumentedResourceTimedPerClass.class);
-    }
+  }
 
-    @Test
-    void timerHistogramIsUsingCustomReservoirImplementation() {
-        assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
+  @Test
+  void timerHistogramIsUsingCustomReservoirImplementation() {
+    assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Timer timer = registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
-        assertThat(timer)
+    final Timer timer =
+        registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
+    assertThat(timer)
         .extracting("histogram")
         .extracting("reservoir")
         .isInstanceOf(UniformReservoir.class);
-    }
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonFilterMetricsJerseyTest.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonFilterMetricsJerseyTest.java
@@ -1,162 +1,137 @@
 package io.dropwizard.metrics5.jersey31;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedFilteredResource;
 import io.dropwizard.metrics5.jersey31.resources.TestRequestFilter;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig} with filter tracking
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig} with filter tracking
  */
-class SingletonFilterMetricsJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    private TestClock testClock;
-
-    @Override
-    protected Application configure() {
-        registry = new MetricRegistry();
-        testClock = new TestClock();
-        ResourceConfig config = new ResourceConfig();
-        config = config.register(new MetricsFeature(this.registry, testClock, true));
-        config = config.register(new TestRequestFilter(testClock));
-        config = config.register(new InstrumentedFilteredResource(testClock));
-        return config;
-    }
-
-    @BeforeEach
-    void resetClock() {
-        testClock.tick = 0;
-    }
-
-    @Test
-    void timedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void explicitNamesAreTimed() {
-        assertThat(target("named")
-        .request()
-        .get(String.class))
-        .isEqualTo("fancy");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "fancyName"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void absoluteNamesAreTimed() {
-        assertThat(target("absolute")
-        .request()
-        .get(String.class))
-        .isEqualTo("absolute");
-
-        final Timer timer = registry.timer("absolutelyFancy");
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
-    }
-
-    @Test
-    void requestFiltersOfTimedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed", "request", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void responseFiltersOfTimedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed", "response", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void totalTimeOfTimedMethodsIsTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed", "total"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(5);
-    }
-
-    @Test
-    void requestFiltersOfNamedMethodsAreTimed() {
-        assertThat(target("named")
-        .request()
-        .get(String.class))
-        .isEqualTo("fancy");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "fancyName", "request", "filtering"));
-
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void requestFiltersOfAbsoluteMethodsAreTimed() {
-        assertThat(target("absolute")
-        .request()
-        .get(String.class))
-        .isEqualTo("absolute");
-
-        final Timer timer = registry.timer(name("absolutelyFancy", "request", "filtering"));
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
-    }
-
-    @Test
-    void subResourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
-
-        final Timer timer = registry.timer(name(InstrumentedFilteredResource.InstrumentedFilteredSubResource.class,
-        "timed"));
-        assertThat(timer.getCount()).isEqualTo(1);
-
-    }
+final class SingletonFilterMetricsJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
+
+  private MetricRegistry registry;
+
+  private TestClock testClock;
+
+  @Override
+  protected Application configure() {
+    registry = new MetricRegistry();
+    testClock = new TestClock();
+    ResourceConfig config = new ResourceConfig();
+    config = config.register(new MetricsFeature(this.registry, testClock, true));
+    config = config.register(new TestRequestFilter(testClock));
+    return config.register(new InstrumentedFilteredResource(testClock));
+  }
+
+  @BeforeEach
+  void resetClock() {
+    testClock.tick = 0;
+  }
+
+  @Test
+  void timedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void explicitNamesAreTimed() {
+    assertThat(target("named").request().get(String.class)).isEqualTo("fancy");
+
+    final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "fancyName"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void absoluteNamesAreTimed() {
+    assertThat(target("absolute").request().get(String.class)).isEqualTo("absolute");
+
+    final Timer timer = registry.timer("absolutelyFancy");
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(1);
+  }
+
+  @Test
+  void requestFiltersOfTimedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(name(InstrumentedFilteredResource.class, "timed", "request", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void responseFiltersOfTimedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(name(InstrumentedFilteredResource.class, "timed", "response", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void totalTimeOfTimedMethodsIsTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer = registry.timer(name(InstrumentedFilteredResource.class, "timed", "total"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(5);
+  }
+
+  @Test
+  void requestFiltersOfNamedMethodsAreTimed() {
+    assertThat(target("named").request().get(String.class)).isEqualTo("fancy");
+
+    final Timer timer =
+        registry.timer(
+            name(InstrumentedFilteredResource.class, "fancyName", "request", "filtering"));
+
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void requestFiltersOfAbsoluteMethodsAreTimed() {
+    assertThat(target("absolute").request().get(String.class)).isEqualTo("absolute");
+
+    final Timer timer = registry.timer(name("absolutelyFancy", "request", "filtering"));
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()[0]).isEqualTo(4);
+  }
+
+  @Test
+  void subResourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timed").request().get(String.class)).isEqualTo("yay");
+
+    final Timer timer =
+        registry.timer(
+            name(InstrumentedFilteredResource.InstrumentedFilteredSubResource.class, "timed"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsExceptionMeteredPerClassJerseyTest.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsExceptionMeteredPerClassJerseyTest.java
@@ -1,98 +1,92 @@
 package io.dropwizard.metrics5.jersey31;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedResourceExceptionMeteredPerClass;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedSubResourceExceptionMeteredPerClass;
 import jakarta.ws.rs.ProcessingException;
 import jakarta.ws.rs.core.Application;
-import org.glassfish.jersey.server.ResourceConfig;
-import org.glassfish.jersey.test.JerseyTest;
-import org.junit.jupiter.api.Test;
-
 import java.io.IOException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import org.glassfish.jersey.server.ResourceConfig;
+import org.glassfish.jersey.test.JerseyTest;
+import org.junit.jupiter.api.Test;
 
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsExceptionMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class SingletonMetricsExceptionMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        ResourceConfig config = new ResourceConfig();
+    ResourceConfig config = new ResourceConfig();
 
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceExceptionMeteredPerClass.class);
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceExceptionMeteredPerClass.class);
+  }
 
-        return config;
-    }
+  @Test
+  void exceptionMeteredMethodsAreExceptionMetered() {
+    final Meter meter =
+        registry.meter(
+            name(
+                InstrumentedResourceExceptionMeteredPerClass.class,
+                "exceptionMetered",
+                "exceptions"));
 
-    @Test
-    void exceptionMeteredMethodsAreExceptionMetered() {
-        final Meter meter = registry.meter(name(InstrumentedResourceExceptionMeteredPerClass.class,
-        "exceptionMetered",
-        "exceptions"));
+    assertThat(target("exception-metered").request().get(String.class)).isEqualTo("fuh");
 
-        assertThat(target("exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
-
-        assertThat(meter.getCount()).isZero();
-
-        try {
-            target("exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+    assertThat(meter.getCount()).isEqualTo(0);
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
+    try {
+      target("exception-metered").queryParam("splode", true).request().get(String.class);
 
-        assertThat(meter.getCount()).isEqualTo(1);
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        final Meter meter = registry.meter(name(InstrumentedSubResourceExceptionMeteredPerClass.class,
-        "exceptionMetered",
-        "exceptions"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
-        assertThat(target("subresource/exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    final Meter meter =
+        registry.meter(
+            name(
+                InstrumentedSubResourceExceptionMeteredPerClass.class,
+                "exceptionMetered",
+                "exceptions"));
 
-        assertThat(meter.getCount()).isZero();
+    assertThat(target("subresource/exception-metered").request().get(String.class))
+        .isEqualTo("fuh");
 
-        try {
-            target("subresource/exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+    assertThat(meter.getCount()).isEqualTo(0);
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
+    try {
+      target("subresource/exception-metered")
+          .queryParam("splode", true)
+          .request()
+          .get(String.class);
 
-        assertThat(meter.getCount()).isEqualTo(1);
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsJerseyTest.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsJerseyTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.jersey31;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
@@ -9,214 +13,167 @@ import jakarta.ws.rs.NotFoundException;
 import jakarta.ws.rs.ProcessingException;
 import jakarta.ws.rs.core.Application;
 import jakarta.ws.rs.core.Response;
+import java.io.IOException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.client.ClientResponse;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.io.IOException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-        ResourceConfig config = new ResourceConfig();
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResource.class);
-
-        return config;
-    }
+final class SingletonMetricsJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    @Test
-    void timedMethodsAreTimed() {
-        assertThat(target("timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  private MetricRegistry registry;
 
-        final Timer timer = registry.timer(name(InstrumentedResource.class, "timed"));
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void meteredMethodsAreMetered() {
-        assertThat(target("metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("woo");
+    ResourceConfig config = new ResourceConfig();
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResource.class);
+  }
 
-        final Meter meter = registry.meter(name(InstrumentedResource.class, "metered"));
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
+  @Test
+  void timedMethodsAreTimed() {
+    assertThat(target("timed").request().get(String.class)).isEqualTo("yay");
 
-    @Test
-    void exceptionMeteredMethodsAreExceptionMetered() {
-        final Meter meter = registry.meter(name(InstrumentedResource.class,
-        "exceptionMetered",
-        "exceptions"));
+    final Timer timer = registry.timer(name(InstrumentedResource.class, "timed"));
 
-        assertThat(target("exception-metered")
-        .request()
-        .get(String.class))
-        .isEqualTo("fuh");
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
-        assertThat(meter.getCount()).isZero();
+  @Test
+  void meteredMethodsAreMetered() {
+    assertThat(target("metered").request().get(String.class)).isEqualTo("woo");
 
-        try {
-            target("exception-metered")
-            .queryParam("splode", true)
-            .request()
-            .get(String.class);
+    final Meter meter = registry.meter(name(InstrumentedResource.class, "metered"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
-            failBecauseExceptionWasNotThrown(ProcessingException.class);
-        } catch (ProcessingException e) {
-            assertThat(e.getCause()).isInstanceOf(IOException.class);
-        }
+  @Test
+  void exceptionMeteredMethodsAreExceptionMetered() {
+    final Meter meter =
+        registry.meter(name(InstrumentedResource.class, "exceptionMetered", "exceptions"));
 
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
+    assertThat(target("exception-metered").request().get(String.class)).isEqualTo("fuh");
 
-    @Test
-    void responseMeteredMethodsAreMetered() {
-        final Meter meter2xx = registry.meter(name(InstrumentedResource.class,
-                "response2xxMetered",
-                "2xx-responses"));
-        final Meter meter4xx = registry.meter(name(InstrumentedResource.class,
-                "response4xxMetered",
-                "4xx-responses"));
-        final Meter meter5xx = registry.meter(name(InstrumentedResource.class,
-                "response5xxMetered",
-                "5xx-responses"));
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(target("response-2xx-metered")
-                .request()
-                .get().getStatus())
-                .isEqualTo(200);
+    assertThat(meter.getCount()).isEqualTo(0);
 
-        assertThat(meter4xx.getCount()).isZero();
-        assertThat(target("response-4xx-metered")
-                .request()
-                .get().getStatus())
-                .isEqualTo(400);
-
-        assertThat(meter5xx.getCount()).isZero();
-        assertThat(target("response-5xx-metered")
-                .request()
-                .get().getStatus())
-                .isEqualTo(500);
-    }
-
-    @Test
-    public void responseMeteredMethodsAreMeteredWithCoarseLevel() {
-        final Meter meter2xx = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredCoarse",
-                "2xx-responses"));
-        final Meter meter200 = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredCoarse",
-                "200-responses"));
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isZero();
-        assertThat(target("response-metered-coarse")
-                .request()
-                .get().getStatus())
-                .isEqualTo(200);
+    try {
+      target("exception-metered").queryParam("splode", true).request().get(String.class);
 
-        assertThat(meter2xx.getCount()).isOne();
-        assertThat(meter200.getCount()).isZero();
+      failBecauseExceptionWasNotThrown(ProcessingException.class);
+    } catch (ProcessingException e) {
+      assertThat(e.getCause()).isInstanceOf(IOException.class);
     }
 
-    @Test
-    public void responseMeteredMethodsAreMeteredWithDetailedLevel() {
-        final Meter meter2xx = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredDetailed",
-                "2xx-responses"));
-        final Meter meter200 = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredDetailed",
-                "200-responses"));
-        final Meter meter201 = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredDetailed",
-                "201-responses"));
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isZero();
-        assertThat(meter201.getCount()).isZero();
-        assertThat(target("response-metered-detailed")
-                .request()
-                .get().getStatus())
-                .isEqualTo(200);
-        assertThat(target("response-metered-detailed")
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMethodsAreMetered() {
+    final Meter meter2xx =
+        registry.meter(name(InstrumentedResource.class, "response2xxMetered", "2xx-responses"));
+    final Meter meter4xx =
+        registry.meter(name(InstrumentedResource.class, "response4xxMetered", "4xx-responses"));
+    final Meter meter5xx =
+        registry.meter(name(InstrumentedResource.class, "response5xxMetered", "5xx-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(target("response-2xx-metered").request().get().getStatus()).isEqualTo(200);
+
+    assertThat(meter4xx.getCount()).isEqualTo(0);
+    assertThat(target("response-4xx-metered").request().get().getStatus()).isEqualTo(400);
+
+    assertThat(meter5xx.getCount()).isEqualTo(0);
+    assertThat(target("response-5xx-metered").request().get().getStatus()).isEqualTo(500);
+  }
+
+  @Test
+  void responseMeteredMethodsAreMeteredWithCoarseLevel() {
+    final Meter meter2xx =
+        registry.meter(name(InstrumentedResource.class, "responseMeteredCoarse", "2xx-responses"));
+    final Meter meter200 =
+        registry.meter(name(InstrumentedResource.class, "responseMeteredCoarse", "200-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(0);
+    assertThat(target("response-metered-coarse").request().get().getStatus()).isEqualTo(200);
+
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+    assertThat(meter200.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void responseMeteredMethodsAreMeteredWithDetailedLevel() {
+    final Meter meter2xx =
+        registry.meter(
+            name(InstrumentedResource.class, "responseMeteredDetailed", "2xx-responses"));
+    final Meter meter200 =
+        registry.meter(
+            name(InstrumentedResource.class, "responseMeteredDetailed", "200-responses"));
+    final Meter meter201 =
+        registry.meter(
+            name(InstrumentedResource.class, "responseMeteredDetailed", "201-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(0);
+    assertThat(meter201.getCount()).isEqualTo(0);
+    assertThat(target("response-metered-detailed").request().get().getStatus()).isEqualTo(200);
+    assertThat(
+            target("response-metered-detailed")
                 .queryParam("status_code", 201)
                 .request()
-                .get().getStatus())
-                .isEqualTo(201);
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isOne();
-        assertThat(meter201.getCount()).isOne();
-    }
-
-    @Test
-    public void responseMeteredMethodsAreMeteredWithAllLevel() {
-        final Meter meter2xx = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredAll",
-                "2xx-responses"));
-        final Meter meter200 = registry.meter(name(InstrumentedResource.class,
-                "responseMeteredAll",
-                "200-responses"));
-
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isZero();
-        assertThat(target("response-metered-all")
-                .request()
-                .get().getStatus())
-                .isEqualTo(200);
-
-        assertThat(meter2xx.getCount()).isOne();
-        assertThat(meter200.getCount()).isOne();
-    }
-
-    @Test
-    void testResourceNotFound() {
-        final Response response = target().path("not-found").request().get();
-        assertThat(response.getStatus()).isEqualTo(404);
-
-        try {
-            target().path("not-found").request().get(ClientResponse.class);
-            failBecauseExceptionWasNotThrown(NotFoundException.class);
-        } catch (NotFoundException e) {
-            assertThat(e.getMessage()).isEqualTo("HTTP 404 Not Found");
-        }
+                .get()
+                .getStatus())
+        .isEqualTo(201);
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(1);
+    assertThat(meter201.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMethodsAreMeteredWithAllLevel() {
+    final Meter meter2xx =
+        registry.meter(name(InstrumentedResource.class, "responseMeteredAll", "2xx-responses"));
+    final Meter meter200 =
+        registry.meter(name(InstrumentedResource.class, "responseMeteredAll", "200-responses"));
+
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(0);
+    assertThat(target("response-metered-all").request().get().getStatus()).isEqualTo(200);
+
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+    assertThat(meter200.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void resourceNotFound() {
+    final Response response = target().path("not-found").request().get();
+    assertThat(response.getStatus()).isEqualTo(404);
+
+    try {
+      target().path("not-found").request().get(ClientResponse.class);
+      failBecauseExceptionWasNotThrown(NotFoundException.class);
+    } catch (NotFoundException e) {
+      assertThat(e.getMessage()).isEqualTo("HTTP 404 Not Found");
     }
+  }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timed")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timed").request().get(String.class)).isEqualTo("yay");
 
-        final Timer timer = registry.timer(name(InstrumentedSubResource.class, "timed"));
-        assertThat(timer.getCount()).isEqualTo(1);
-
-    }
+    final Timer timer = registry.timer(name(InstrumentedSubResource.class, "timed"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsMeteredPerClassJerseyTest.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsMeteredPerClassJerseyTest.java
@@ -1,66 +1,56 @@
 package io.dropwizard.metrics5.jersey31;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedResourceMeteredPerClass;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedSubResourceMeteredPerClass;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-        ResourceConfig config = new ResourceConfig();
-
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceMeteredPerClass.class);
+final class SingletonMetricsMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-        return config;
-    }
+  private MetricRegistry registry;
 
-    @Test
-    void meteredPerClassMethodsAreMetered() {
-        assertThat(target("meteredPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        final Meter meter = registry.meter(name(InstrumentedResourceMeteredPerClass.class, "meteredPerClass"));
+    ResourceConfig config = new ResourceConfig();
 
-        assertThat(meter.getCount()).isEqualTo(1);
-    }
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceMeteredPerClass.class);
+  }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/meteredPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Test
+  void meteredPerClassMethodsAreMetered() {
+    assertThat(target("meteredPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Meter meter = registry.meter(name(InstrumentedSubResourceMeteredPerClass.class, "meteredPerClass"));
-        assertThat(meter.getCount()).isEqualTo(1);
+    final Meter meter =
+        registry.meter(name(InstrumentedResourceMeteredPerClass.class, "meteredPerClass"));
 
-    }
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/meteredPerClass").request().get(String.class)).isEqualTo("yay");
 
+    final Meter meter =
+        registry.meter(name(InstrumentedSubResourceMeteredPerClass.class, "meteredPerClass"));
+    assertThat(meter.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsResponseMeteredPerClassJerseyTest.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsResponseMeteredPerClassJerseyTest.java
@@ -1,147 +1,150 @@
 package io.dropwizard.metrics5.jersey31;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.jersey31.exception.mapper.TestExceptionMapper;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedResourceResponseMeteredPerClass;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedSubResourceResponseMeteredPerClass;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.fail;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsResponseMeteredPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
+final class SingletonMetricsResponseMeteredPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-    private MetricRegistry registry;
+  private MetricRegistry registry;
 
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
+    ResourceConfig config = new ResourceConfig();
 
-        ResourceConfig config = new ResourceConfig();
+    config = config.register(new MetricsFeature(this.registry));
+    config = config.register(InstrumentedResourceResponseMeteredPerClass.class);
+    return config.register(new TestExceptionMapper());
+  }
 
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceResponseMeteredPerClass.class);
-        config = config.register(new TestExceptionMapper());
-
-        return config;
-    }
-
-    @Test
-    void responseMetered2xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered2xxPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(200);
+  @Test
+  void responseMetered2xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered2xxPerClass").request().get().getStatus()).isEqualTo(200);
 
-        final Meter meter2xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered2xxPerClass",
-        "2xx-responses"));
+    final Meter meter2xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered2xxPerClass",
+                "2xx-responses"));
 
-        assertThat(meter2xx.getCount()).isEqualTo(1);
-    }
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void responseMetered4xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered4xxPerClass")
-        .request()
-        .get().getStatus())
+  @Test
+  void responseMetered4xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered4xxPerClass").request().get().getStatus()).isEqualTo(400);
+    assertThat(target("responseMeteredBadRequestPerClass").request().get().getStatus())
         .isEqualTo(400);
-        assertThat(target("responseMeteredBadRequestPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(400);
-
-        final Meter meter4xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered4xxPerClass",
-        "4xx-responses"));
-        final Meter meterException4xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredBadRequestPerClass",
-        "4xx-responses"));
 
-        assertThat(meter4xx.getCount()).isEqualTo(1);
-        assertThat(meterException4xx.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void responseMetered5xxPerClassMethodsAreMetered() {
-        assertThat(target("responseMetered5xxPerClass")
-        .request()
-        .get().getStatus())
+    final Meter meter4xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered4xxPerClass",
+                "4xx-responses"));
+    final Meter meterException4xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredBadRequestPerClass",
+                "4xx-responses"));
+
+    assertThat(meter4xx.getCount()).isEqualTo(1);
+    assertThat(meterException4xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMetered5xxPerClassMethodsAreMetered() {
+    assertThat(target("responseMetered5xxPerClass").request().get().getStatus()).isEqualTo(500);
+
+    final Meter meter5xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMetered5xxPerClass",
+                "5xx-responses"));
+
+    assertThat(meter5xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredMappedExceptionPerClassMethodsAreMetered() {
+    assertThat(target("responseMeteredTestExceptionPerClass").request().get().getStatus())
         .isEqualTo(500);
 
-        final Meter meter5xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMetered5xxPerClass",
-        "5xx-responses"));
-
-        assertThat(meter5xx.getCount()).isEqualTo(1);
+    final Meter meterTestException =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredTestExceptionPerClass",
+                "5xx-responses"));
+
+    assertThat(meterTestException.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void responseMeteredUnmappedExceptionPerClassMethodsAreMetered() {
+    try {
+      target("responseMeteredRuntimeExceptionPerClass").request().get();
+      fail("expected RuntimeException");
+    } catch (Exception e) {
+      assertThat(e.getCause()).isInstanceOf(RuntimeException.class);
     }
 
-    @Test
-    void responseMeteredMappedExceptionPerClassMethodsAreMetered() {
-        assertThat(target("responseMeteredTestExceptionPerClass")
-        .request()
-        .get().getStatus())
-        .isEqualTo(500);
-
-        final Meter meterTestException = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredTestExceptionPerClass",
-        "5xx-responses"));
-
-        assertThat(meterTestException.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void responseMeteredUnmappedExceptionPerClassMethodsAreMetered() {
-        try {
-            target("responseMeteredRuntimeExceptionPerClass")
-            .request()
-            .get();
-            fail("expected RuntimeException");
-        } catch (Exception e) {
-            assertThat(e.getCause()).isInstanceOf(RuntimeException.class);
-        }
-
-        final Meter meterException5xx = registry.meter(name(InstrumentedResourceResponseMeteredPerClass.class,
-        "responseMeteredRuntimeExceptionPerClass",
-        "5xx-responses"));
-
-        assertThat(meterException5xx.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        final Meter meter2xx = registry.meter(name(InstrumentedSubResourceResponseMeteredPerClass.class,
+    final Meter meterException5xx =
+        registry.meter(
+            name(
+                InstrumentedResourceResponseMeteredPerClass.class,
+                "responseMeteredRuntimeExceptionPerClass",
+                "5xx-responses"));
+
+    assertThat(meterException5xx.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    final Meter meter2xx =
+        registry.meter(
+            name(
+                InstrumentedSubResourceResponseMeteredPerClass.class,
                 "responseMeteredPerClass",
                 "2xx-responses"));
-        final Meter meter200 = registry.meter(name(InstrumentedSubResourceResponseMeteredPerClass.class,
+    final Meter meter200 =
+        registry.meter(
+            name(
+                InstrumentedSubResourceResponseMeteredPerClass.class,
                 "responseMeteredPerClass",
                 "200-responses"));
 
-        assertThat(meter2xx.getCount()).isZero();
-        assertThat(meter200.getCount()).isZero();
+    assertThat(meter2xx.getCount()).isEqualTo(0);
+    assertThat(meter200.getCount()).isEqualTo(0);
 
-        assertThat(target("subresource/responseMeteredPerClass")
-        .request()
-        .get().getStatus())
+    assertThat(target("subresource/responseMeteredPerClass").request().get().getStatus())
         .isEqualTo(200);
 
-        assertThat(meter2xx.getCount()).isOne();
-        assertThat(meter200.getCount()).isOne();
-    }
+    assertThat(meter2xx.getCount()).isEqualTo(1);
+    assertThat(meter200.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsTimedPerClassJerseyTest.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/SingletonMetricsTimedPerClassJerseyTest.java
@@ -1,66 +1,56 @@
 package io.dropwizard.metrics5.jersey31;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedResourceTimedPerClass;
 import io.dropwizard.metrics5.jersey31.resources.InstrumentedSubResourceTimedPerClass;
 import jakarta.ws.rs.core.Application;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import org.glassfish.jersey.server.ResourceConfig;
 import org.glassfish.jersey.test.JerseyTest;
 import org.junit.jupiter.api.Test;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static org.assertj.core.api.Assertions.assertThat;
-
 /**
- * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton
- * in a Jersey {@link ResourceConfig}
+ * Tests registering {@link InstrumentedResourceMethodApplicationListener} as a singleton in a
+ * Jersey {@link ResourceConfig}
  */
-class SingletonMetricsTimedPerClassJerseyTest extends JerseyTest {
-    static {
-        Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
-    }
-
-    private MetricRegistry registry;
-
-    @Override
-    protected Application configure() {
-        this.registry = new MetricRegistry();
-
-        ResourceConfig config = new ResourceConfig();
-
-        config = config.register(new MetricsFeature(this.registry));
-        config = config.register(InstrumentedResourceTimedPerClass.class);
+final class SingletonMetricsTimedPerClassJerseyTest extends JerseyTest {
+  static {
+    Logger.getLogger("org.glassfish.jersey").setLevel(Level.OFF);
+  }
 
-        return config;
-    }
+  private MetricRegistry registry;
 
-    @Test
-    void timedPerClassMethodsAreTimed() {
-        assertThat(target("timedPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Override
+  protected Application configure() {
+    this.registry = new MetricRegistry();
 
-        final Timer timer = registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
+    ResourceConfig config = new ResourceConfig();
 
-        assertThat(timer.getCount()).isEqualTo(1);
-    }
+    config = config.register(new MetricsFeature(this.registry));
+    return config.register(InstrumentedResourceTimedPerClass.class);
+  }
 
-    @Test
-    void subresourcesFromLocatorsRegisterMetrics() {
-        assertThat(target("subresource/timedPerClass")
-        .request()
-        .get(String.class))
-        .isEqualTo("yay");
+  @Test
+  void timedPerClassMethodsAreTimed() {
+    assertThat(target("timedPerClass").request().get(String.class)).isEqualTo("yay");
 
-        final Timer timer = registry.timer(name(InstrumentedSubResourceTimedPerClass.class, "timedPerClass"));
-        assertThat(timer.getCount()).isEqualTo(1);
+    final Timer timer =
+        registry.timer(name(InstrumentedResourceTimedPerClass.class, "timedPerClass"));
 
-    }
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
+  @Test
+  void subresourcesFromLocatorsRegisterMetrics() {
+    assertThat(target("subresource/timedPerClass").request().get(String.class)).isEqualTo("yay");
 
+    final Timer timer =
+        registry.timer(name(InstrumentedSubResourceTimedPerClass.class, "timedPerClass"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/TestClock.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/TestClock.java
@@ -4,10 +4,10 @@ import io.dropwizard.metrics5.Clock;
 
 public class TestClock extends Clock {
 
-    public long tick;
+  public long tick;
 
-    @Override
-    public long getTick() {
-        return tick;
-    }
+  @Override
+  public long getTick() {
+    return tick;
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/exception/TestException.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/exception/TestException.java
@@ -1,9 +1,9 @@
 package io.dropwizard.metrics5.jersey31.exception;
 
 public class TestException extends RuntimeException {
-    private static final long serialVersionUID = 1L;
+  private static final long serialVersionUID = 1L;
 
-    public TestException(String message) {
-        super(message);
-    }
+  public TestException(String message) {
+    super(message);
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/exception/mapper/TestExceptionMapper.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/exception/mapper/TestExceptionMapper.java
@@ -7,8 +7,8 @@ import jakarta.ws.rs.ext.Provider;
 
 @Provider
 public class TestExceptionMapper implements ExceptionMapper<TestException> {
-    @Override
-    public Response toResponse(TestException exception) {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
+  @Override
+  public Response toResponse(TestException exception) {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedFilteredResource.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedFilteredResource.java
@@ -11,51 +11,50 @@ import jakarta.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedFilteredResource {
 
-    private final TestClock testClock;
-
-    public InstrumentedFilteredResource(TestClock testClock) {
-        this.testClock = testClock;
-    }
+  private final TestClock testClock;
+
+  public InstrumentedFilteredResource(TestClock testClock) {
+    this.testClock = testClock;
+  }
+
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    testClock.tick++;
+    return "yay";
+  }
+
+  @GET
+  @Path("/named")
+  @Timed(name = "fancyName")
+  public String named() {
+    testClock.tick++;
+    return "fancy";
+  }
+
+  @GET
+  @Path("/absolute")
+  @Timed(name = "absolutelyFancy", absolute = true)
+  public String absolute() {
+    testClock.tick++;
+    return "absolute";
+  }
+
+  @Path("/subresource")
+  public InstrumentedFilteredSubResource locateSubResource() {
+    return new InstrumentedFilteredSubResource();
+  }
+
+  @Produces(MediaType.TEXT_PLAIN)
+  public class InstrumentedFilteredSubResource {
 
     @GET
-    @Timed
     @Path("/timed")
+    @Timed
     public String timed() {
-        testClock.tick++;
-        return "yay";
-    }
-
-    @GET
-    @Timed(name = "fancyName")
-    @Path("/named")
-    public String named() {
-        testClock.tick++;
-        return "fancy";
-    }
-
-    @GET
-    @Timed(name = "absolutelyFancy", absolute = true)
-    @Path("/absolute")
-    public String absolute() {
-        testClock.tick++;
-        return "absolute";
-    }
-
-    @Path("/subresource")
-    public InstrumentedFilteredSubResource locateSubResource() {
-        return new InstrumentedFilteredSubResource();
-    }
-
-    @Produces(MediaType.TEXT_PLAIN)
-    public class InstrumentedFilteredSubResource {
-
-        @GET
-        @Timed
-        @Path("/timed")
-        public String timed() {
-            testClock.tick += 2;
-            return "yay";
-        }
-
+      testClock.tick += 2;
+      return "yay";
     }
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResource.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResource.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.jersey31.resources;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+
 import io.dropwizard.metrics5.annotation.ExceptionMetered;
 import io.dropwizard.metrics5.annotation.Metered;
 import io.dropwizard.metrics5.annotation.ResponseMetered;
@@ -11,84 +15,83 @@ import jakarta.ws.rs.Produces;
 import jakarta.ws.rs.QueryParam;
 import jakarta.ws.rs.core.MediaType;
 import jakarta.ws.rs.core.Response;
-
 import java.io.IOException;
 
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
-
 @Path("/")
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResource {
-    @GET
-    @Timed
-    @Path("/timed")
-    public String timed() {
-        return "yay";
-    }
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    return "yay";
+  }
 
-    @GET
-    @Metered
-    @Path("/metered")
-    public String metered() {
-        return "woo";
-    }
+  @GET
+  @Metered
+  @Path("/metered")
+  public String metered() {
+    return "woo";
+  }
 
-    @GET
-    @ExceptionMetered(cause = IOException.class)
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
+  @ExceptionMetered(cause = IOException.class)
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 
-    @GET
-    @ResponseMetered(level = DETAILED)
-    @Path("/response-metered-detailed")
-    public Response responseMeteredDetailed(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-detailed")
+  @ResponseMetered(level = DETAILED)
+  public Response responseMeteredDetailed(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered(level = COARSE)
-    @Path("/response-metered-coarse")
-    public Response responseMeteredCoarse(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-coarse")
+  @ResponseMetered(level = COARSE)
+  public Response responseMeteredCoarse(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered(level = ALL)
-    @Path("/response-metered-all")
-    public Response responseMeteredAll(@QueryParam("status_code") @DefaultValue("200") int statusCode) {
-        return Response.status(Response.Status.fromStatusCode(statusCode)).build();
-    }
+  @GET
+  @Path("/response-metered-all")
+  @ResponseMetered(level = ALL)
+  public Response responseMeteredAll(
+      @QueryParam("status_code") @DefaultValue("200") int statusCode) {
+    return Response.status(Response.Status.fromStatusCode(statusCode)).build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-2xx-metered")
-    public Response response2xxMetered() {
-        return Response.ok().build();
-    }
+  @GET
+  @Path("/response-2xx-metered")
+  @ResponseMetered
+  public Response response2xxMetered() {
+    return Response.ok().build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-4xx-metered")
-    public Response response4xxMetered() {
-        return Response.status(Response.Status.BAD_REQUEST).build();
-    }
+  @GET
+  @Path("/response-4xx-metered")
+  @ResponseMetered
+  public Response response4xxMetered() {
+    return Response.status(Response.Status.BAD_REQUEST).build();
+  }
 
-    @GET
-    @ResponseMetered
-    @Path("/response-5xx-metered")
-    public Response response5xxMetered() {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
+  @GET
+  @Path("/response-5xx-metered")
+  @ResponseMetered
+  public Response response5xxMetered() {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
 
-    @Path("/subresource")
-    public InstrumentedSubResource locateSubResource() {
-        return new InstrumentedSubResource();
-    }
+  @Path("/subresource")
+  public InstrumentedSubResource locateSubResource() {
+    return new InstrumentedSubResource();
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResourceExceptionMeteredPerClass.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResourceExceptionMeteredPerClass.java
@@ -7,7 +7,6 @@ import jakarta.ws.rs.Path;
 import jakarta.ws.rs.Produces;
 import jakarta.ws.rs.QueryParam;
 import jakarta.ws.rs.core.MediaType;
-
 import java.io.IOException;
 
 @ExceptionMetered(cause = IOException.class)
@@ -15,18 +14,18 @@ import java.io.IOException;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceExceptionMeteredPerClass {
 
-    @GET
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceExceptionMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceExceptionMeteredPerClass();
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceExceptionMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceExceptionMeteredPerClass();
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResourceMeteredPerClass.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResourceMeteredPerClass.java
@@ -11,15 +11,14 @@ import jakarta.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceMeteredPerClass {
 
-    @GET
-    @Path("/meteredPerClass")
-    public String meteredPerClass() {
-        return "yay";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceMeteredPerClass();
-    }
+  @GET
+  @Path("/meteredPerClass")
+  public String meteredPerClass() {
+    return "yay";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceMeteredPerClass();
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResourceResponseMeteredPerClass.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResourceResponseMeteredPerClass.java
@@ -14,45 +14,44 @@ import jakarta.ws.rs.core.Response;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceResponseMeteredPerClass {
 
-    @GET
-    @Path("/responseMetered2xxPerClass")
-    public Response responseMetered2xxPerClass() {
-        return Response.ok().build();
-    }
-
-    @GET
-    @Path("/responseMetered4xxPerClass")
-    public Response responseMetered4xxPerClass() {
-        return Response.status(Response.Status.BAD_REQUEST).build();
-    }
-
-    @GET
-    @Path("/responseMetered5xxPerClass")
-    public Response responseMetered5xxPerClass() {
-        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
-    }
-
-    @GET
-    @Path("/responseMeteredBadRequestPerClass")
-    public String responseMeteredBadRequestPerClass() {
-        throw new BadRequestException();
-    }
-
-    @GET
-    @Path("/responseMeteredRuntimeExceptionPerClass")
-    public String responseMeteredRuntimeExceptionPerClass() {
-        throw new RuntimeException();
-    }
-
-    @GET
-    @Path("/responseMeteredTestExceptionPerClass")
-    public String responseMeteredTestExceptionPerClass() {
-        throw new TestException("test");
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceResponseMeteredPerClass locateSubResource() {
-        return new InstrumentedSubResourceResponseMeteredPerClass();
-    }
-
+  @GET
+  @Path("/responseMetered2xxPerClass")
+  public Response responseMetered2xxPerClass() {
+    return Response.ok().build();
+  }
+
+  @GET
+  @Path("/responseMetered4xxPerClass")
+  public Response responseMetered4xxPerClass() {
+    return Response.status(Response.Status.BAD_REQUEST).build();
+  }
+
+  @GET
+  @Path("/responseMetered5xxPerClass")
+  public Response responseMetered5xxPerClass() {
+    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
+  }
+
+  @GET
+  @Path("/responseMeteredBadRequestPerClass")
+  public String responseMeteredBadRequestPerClass() {
+    throw new BadRequestException();
+  }
+
+  @GET
+  @Path("/responseMeteredRuntimeExceptionPerClass")
+  public String responseMeteredRuntimeExceptionPerClass() {
+    throw new RuntimeException();
+  }
+
+  @GET
+  @Path("/responseMeteredTestExceptionPerClass")
+  public String responseMeteredTestExceptionPerClass() {
+    throw new TestException("test");
+  }
+
+  @Path("/subresource")
+  public InstrumentedSubResourceResponseMeteredPerClass locateSubResource() {
+    return new InstrumentedSubResourceResponseMeteredPerClass();
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResourceTimedPerClass.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedResourceTimedPerClass.java
@@ -11,15 +11,14 @@ import jakarta.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedResourceTimedPerClass {
 
-    @GET
-    @Path("/timedPerClass")
-    public String timedPerClass() {
-        return "yay";
-    }
-
-    @Path("/subresource")
-    public InstrumentedSubResourceTimedPerClass locateSubResource() {
-        return new InstrumentedSubResourceTimedPerClass();
-    }
+  @GET
+  @Path("/timedPerClass")
+  public String timedPerClass() {
+    return "yay";
+  }
 
+  @Path("/subresource")
+  public InstrumentedSubResourceTimedPerClass locateSubResource() {
+    return new InstrumentedSubResourceTimedPerClass();
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResource.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResource.java
@@ -9,11 +9,10 @@ import jakarta.ws.rs.core.MediaType;
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResource {
 
-    @GET
-    @Timed
-    @Path("/timed")
-    public String timed() {
-        return "yay";
-    }
-
+  @GET
+  @Path("/timed")
+  @Timed
+  public String timed() {
+    return "yay";
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResourceExceptionMeteredPerClass.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResourceExceptionMeteredPerClass.java
@@ -7,18 +7,18 @@ import jakarta.ws.rs.Path;
 import jakarta.ws.rs.Produces;
 import jakarta.ws.rs.QueryParam;
 import jakarta.ws.rs.core.MediaType;
-
 import java.io.IOException;
 
 @ExceptionMetered(cause = IOException.class)
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceExceptionMeteredPerClass {
-    @GET
-    @Path("/exception-metered")
-    public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode) throws IOException {
-        if (splode) {
-            throw new IOException("AUGH");
-        }
-        return "fuh";
+  @GET
+  @Path("/exception-metered")
+  public String exceptionMetered(@QueryParam("splode") @DefaultValue("false") boolean splode)
+      throws IOException {
+    if (splode) {
+      throw new IOException("AUGH");
     }
+    return "fuh";
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResourceMeteredPerClass.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResourceMeteredPerClass.java
@@ -9,9 +9,9 @@ import jakarta.ws.rs.core.MediaType;
 @Metered
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceMeteredPerClass {
-    @GET
-    @Path("/meteredPerClass")
-    public String meteredPerClass() {
-        return "yay";
-    }
+  @GET
+  @Path("/meteredPerClass")
+  public String meteredPerClass() {
+    return "yay";
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResourceResponseMeteredPerClass.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResourceResponseMeteredPerClass.java
@@ -11,9 +11,9 @@ import jakarta.ws.rs.core.Response;
 @ResponseMetered(level = ResponseMeteredLevel.ALL)
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceResponseMeteredPerClass {
-    @GET
-    @Path("/responseMeteredPerClass")
-    public Response responseMeteredPerClass() {
-        return Response.status(Response.Status.OK).build();
-    }
+  @GET
+  @Path("/responseMeteredPerClass")
+  public Response responseMeteredPerClass() {
+    return Response.status(Response.Status.OK).build();
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResourceTimedPerClass.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/InstrumentedSubResourceTimedPerClass.java
@@ -9,9 +9,9 @@ import jakarta.ws.rs.core.MediaType;
 @Timed
 @Produces(MediaType.TEXT_PLAIN)
 public class InstrumentedSubResourceTimedPerClass {
-    @GET
-    @Path("/timedPerClass")
-    public String timedPerClass() {
-        return "yay";
-    }
+  @GET
+  @Path("/timedPerClass")
+  public String timedPerClass() {
+    return "yay";
+  }
 }
--- a/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/TestRequestFilter.java
+++ b/metrics-jersey31/src/test/java/io/dropwizard/metrics5/jersey31/resources/TestRequestFilter.java
@@ -3,19 +3,18 @@ package io.dropwizard.metrics5.jersey31.resources;
 import io.dropwizard.metrics5.jersey31.TestClock;
 import jakarta.ws.rs.container.ContainerRequestContext;
 import jakarta.ws.rs.container.ContainerRequestFilter;
-
 import java.io.IOException;
 
 public class TestRequestFilter implements ContainerRequestFilter {
 
-    private final TestClock testClock;
+  private final TestClock testClock;
 
-    public TestRequestFilter(TestClock testClock) {
-        this.testClock = testClock;
-    }
+  public TestRequestFilter(TestClock testClock) {
+    this.testClock = testClock;
+  }
 
-    @Override
-    public void filter(ContainerRequestContext containerRequestContext) throws IOException {
-        testClock.tick += 4;
-    }
+  @Override
+  public void filter(ContainerRequestContext containerRequestContext) throws IOException {
+    testClock.tick += 4;
+  }
 }
--- a/metrics-jetty10/src/main/java/io/dropwizard/metrics5/jetty10/InstrumentedConnectionFactory.java
+++ b/metrics-jetty10/src/main/java/io/dropwizard/metrics5/jetty10/InstrumentedConnectionFactory.java
@@ -2,62 +2,63 @@ package io.dropwizard.metrics5.jetty10;
 
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Timer;
+import java.util.List;
 import org.eclipse.jetty.io.Connection;
 import org.eclipse.jetty.io.EndPoint;
 import org.eclipse.jetty.server.ConnectionFactory;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.util.component.ContainerLifeCycle;
 
-import java.util.List;
-
 public class InstrumentedConnectionFactory extends ContainerLifeCycle implements ConnectionFactory {
-    private final ConnectionFactory connectionFactory;
-    private final Timer timer;
-    private final Counter counter;
-
-    public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer) {
-        this(connectionFactory, timer, null);
-    }
-
-    public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer, Counter counter) {
-        this.connectionFactory = connectionFactory;
-        this.timer = timer;
-        this.counter = counter;
-        addBean(connectionFactory);
-    }
-
-    @Override
-    public String getProtocol() {
-        return connectionFactory.getProtocol();
-    }
-
-    @Override
-    public List<String> getProtocols() {
-        return connectionFactory.getProtocols();
-    }
-
-    @Override
-    public Connection newConnection(Connector connector, EndPoint endPoint) {
-        final Connection connection = connectionFactory.newConnection(connector, endPoint);
-        connection.addEventListener(new Connection.Listener() {
-            private Timer.Context context;
-
-            @Override
-            public void onOpened(Connection connection) {
-                this.context = timer.time();
-                if (counter != null) {
-                    counter.inc();
-                }
+  private final ConnectionFactory connectionFactory;
+  private final Timer timer;
+  private final Counter counter;
+
+  public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer) {
+    this(connectionFactory, timer, null);
+  }
+
+  public InstrumentedConnectionFactory(
+      ConnectionFactory connectionFactory, Timer timer, Counter counter) {
+    this.connectionFactory = connectionFactory;
+    this.timer = timer;
+    this.counter = counter;
+    addBean(connectionFactory);
+  }
+
+  @Override
+  public String getProtocol() {
+    return connectionFactory.getProtocol();
+  }
+
+  @Override
+  public List<String> getProtocols() {
+    return connectionFactory.getProtocols();
+  }
+
+  @Override
+  public Connection newConnection(Connector connector, EndPoint endPoint) {
+    final Connection connection = connectionFactory.newConnection(connector, endPoint);
+    connection.addEventListener(
+        new Connection.Listener() {
+          private Timer.Context context;
+
+          @Override
+          public void onOpened(Connection connection) {
+            this.context = timer.time();
+            if (counter != null) {
+              counter.inc();
             }
+          }
 
-            @Override
-            public void onClosed(Connection connection) {
-                context.stop();
-                if (counter != null) {
-                    counter.dec();
-                }
+          @Override
+          public void onClosed(Connection connection) {
+            context.stop();
+            if (counter != null) {
+              counter.dec();
             }
+          }
         });
-        return connection;
-    }
+    return connection;
+  }
 }
--- a/metrics-jetty10/src/main/java/io/dropwizard/metrics5/jetty10/InstrumentedHandler.java
+++ b/metrics-jetty10/src/main/java/io/dropwizard/metrics5/jetty10/InstrumentedHandler.java
@@ -1,5 +1,13 @@
 package io.dropwizard.metrics5.jetty10;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.util.Collections.unmodifiableList;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricName;
@@ -7,439 +15,450 @@ import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.RatioGauge;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.annotation.ResponseMeteredLevel;
-import org.eclipse.jetty.http.HttpMethod;
-import org.eclipse.jetty.server.AsyncContextState;
-import org.eclipse.jetty.server.Handler;
-import org.eclipse.jetty.server.HttpChannelState;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.HandlerWrapper;
-
-import javax.servlet.AsyncEvent;
-import javax.servlet.AsyncListener;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import org.eclipse.jetty.http.HttpMethod;
+import org.eclipse.jetty.server.AsyncContextState;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.HttpChannelState;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.HandlerWrapper;
 
 /**
  * A Jetty {@link Handler} which records various metrics about an underlying {@link Handler}
  * instance.
  */
 public class InstrumentedHandler extends HandlerWrapper {
-    private static final String NAME_REQUESTS = "requests";
-    private static final String NAME_DISPATCHES = "dispatches";
-    private static final String NAME_ACTIVE_REQUESTS = "active-requests";
-    private static final String NAME_ACTIVE_DISPATCHES = "active-dispatches";
-    private static final String NAME_ACTIVE_SUSPENDED = "active-suspended";
-    private static final String NAME_ASYNC_DISPATCHES = "async-dispatches";
-    private static final String NAME_ASYNC_TIMEOUTS = "async-timeouts";
-    private static final String NAME_1XX_RESPONSES = "1xx-responses";
-    private static final String NAME_2XX_RESPONSES = "2xx-responses";
-    private static final String NAME_3XX_RESPONSES = "3xx-responses";
-    private static final String NAME_4XX_RESPONSES = "4xx-responses";
-    private static final String NAME_5XX_RESPONSES = "5xx-responses";
-    private static final String NAME_GET_REQUESTS = "get-requests";
-    private static final String NAME_POST_REQUESTS = "post-requests";
-    private static final String NAME_HEAD_REQUESTS = "head-requests";
-    private static final String NAME_PUT_REQUESTS = "put-requests";
-    private static final String NAME_DELETE_REQUESTS = "delete-requests";
-    private static final String NAME_OPTIONS_REQUESTS = "options-requests";
-    private static final String NAME_TRACE_REQUESTS = "trace-requests";
-    private static final String NAME_CONNECT_REQUESTS = "connect-requests";
-    private static final String NAME_MOVE_REQUESTS = "move-requests";
-    private static final String NAME_OTHER_REQUESTS = "other-requests";
-    private static final String NAME_PERCENT_4XX_1M = "percent-4xx-1m";
-    private static final String NAME_PERCENT_4XX_5M = "percent-4xx-5m";
-    private static final String NAME_PERCENT_4XX_15M = "percent-4xx-15m";
-    private static final String NAME_PERCENT_5XX_1M = "percent-5xx-1m";
-    private static final String NAME_PERCENT_5XX_5M = "percent-5xx-5m";
-    private static final String NAME_PERCENT_5XX_15M = "percent-5xx-15m";
-    private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
-    private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
-
-    private final MetricRegistry metricRegistry;
-
-    private String name;
-    private final String prefix;
-
-    // the requests handled by this handler, excluding active
-    private Timer requests;
-
-    // the number of dispatches seen by this handler, excluding active
-    private Timer dispatches;
-
-    // the number of active requests
-    private Counter activeRequests;
-
-    // the number of active dispatches
-    private Counter activeDispatches;
-
-    // the number of requests currently suspended.
-    private Counter activeSuspended;
-
-    // the number of requests that have been asynchronously dispatched
-    private Meter asyncDispatches;
-
-    // the number of requests that expired while suspended
-    private Meter asyncTimeouts;
-
-    private final ResponseMeteredLevel responseMeteredLevel;
-    private List<Meter> responses;
-    private Map<Integer, Meter> responseCodeMeters;
-
-    private Timer getRequests;
-    private Timer postRequests;
-    private Timer headRequests;
-    private Timer putRequests;
-    private Timer deleteRequests;
-    private Timer optionsRequests;
-    private Timer traceRequests;
-    private Timer connectRequests;
-    private Timer moveRequests;
-    private Timer otherRequests;
-
-    private AsyncListener listener;
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     */
-    public InstrumentedHandler(MetricRegistry registry) {
-        this(registry, null);
+  private static final String NAME_REQUESTS = "requests";
+  private static final String NAME_DISPATCHES = "dispatches";
+  private static final String NAME_ACTIVE_REQUESTS = "active-requests";
+  private static final String NAME_ACTIVE_DISPATCHES = "active-dispatches";
+  private static final String NAME_ACTIVE_SUSPENDED = "active-suspended";
+  private static final String NAME_ASYNC_DISPATCHES = "async-dispatches";
+  private static final String NAME_ASYNC_TIMEOUTS = "async-timeouts";
+  private static final String NAME_1XX_RESPONSES = "1xx-responses";
+  private static final String NAME_2XX_RESPONSES = "2xx-responses";
+  private static final String NAME_3XX_RESPONSES = "3xx-responses";
+  private static final String NAME_4XX_RESPONSES = "4xx-responses";
+  private static final String NAME_5XX_RESPONSES = "5xx-responses";
+  private static final String NAME_GET_REQUESTS = "get-requests";
+  private static final String NAME_POST_REQUESTS = "post-requests";
+  private static final String NAME_HEAD_REQUESTS = "head-requests";
+  private static final String NAME_PUT_REQUESTS = "put-requests";
+  private static final String NAME_DELETE_REQUESTS = "delete-requests";
+  private static final String NAME_OPTIONS_REQUESTS = "options-requests";
+  private static final String NAME_TRACE_REQUESTS = "trace-requests";
+  private static final String NAME_CONNECT_REQUESTS = "connect-requests";
+  private static final String NAME_MOVE_REQUESTS = "move-requests";
+  private static final String NAME_OTHER_REQUESTS = "other-requests";
+  private static final String NAME_PERCENT_4XX_1M = "percent-4xx-1m";
+  private static final String NAME_PERCENT_4XX_5M = "percent-4xx-5m";
+  private static final String NAME_PERCENT_4XX_15M = "percent-4xx-15m";
+  private static final String NAME_PERCENT_5XX_1M = "percent-5xx-1m";
+  private static final String NAME_PERCENT_5XX_5M = "percent-5xx-5m";
+  private static final String NAME_PERCENT_5XX_15M = "percent-5xx-15m";
+  private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
+  private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
+
+  private final MetricRegistry metricRegistry;
+
+  private String name;
+  private final String prefix;
+
+  // the requests handled by this handler, excluding active
+  private Timer requests;
+
+  // the number of dispatches seen by this handler, excluding active
+  private Timer dispatches;
+
+  // the number of active requests
+  private Counter activeRequests;
+
+  // the number of active dispatches
+  private Counter activeDispatches;
+
+  // the number of requests currently suspended.
+  private Counter activeSuspended;
+
+  // the number of requests that have been asynchronously dispatched
+  private Meter asyncDispatches;
+
+  // the number of requests that expired while suspended
+  private Meter asyncTimeouts;
+
+  private final ResponseMeteredLevel responseMeteredLevel;
+  private List<Meter> responses;
+  private Map<Integer, Meter> responseCodeMeters;
+
+  private Timer getRequests;
+  private Timer postRequests;
+  private Timer headRequests;
+  private Timer putRequests;
+  private Timer deleteRequests;
+  private Timer optionsRequests;
+  private Timer traceRequests;
+  private Timer connectRequests;
+  private Timer moveRequests;
+  private Timer otherRequests;
+
+  private AsyncListener listener;
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   */
+  public InstrumentedHandler(MetricRegistry registry) {
+    this(registry, null);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param prefix the prefix to use for the metrics names
+   */
+  public InstrumentedHandler(MetricRegistry registry, String prefix) {
+    this(registry, prefix, COARSE);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param prefix the prefix to use for the metrics names
+   * @param responseMeteredLevel the level to determine individual/aggregate response codes that are
+   *     instrumented
+   */
+  public InstrumentedHandler(
+      MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
+    this.metricRegistry = registry;
+    this.prefix = prefix;
+    this.responseMeteredLevel = responseMeteredLevel;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  @Override
+  protected void doStart() throws Exception {
+    super.doStart();
+
+    final MetricName prefix = getMetricPrefix();
+
+    this.requests = metricRegistry.timer(prefix.resolve(NAME_REQUESTS));
+    this.dispatches = metricRegistry.timer(prefix.resolve(NAME_DISPATCHES));
+
+    this.activeRequests = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_REQUESTS));
+    this.activeDispatches = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_DISPATCHES));
+    this.activeSuspended = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_SUSPENDED));
+
+    this.asyncDispatches = metricRegistry.meter(prefix.resolve(NAME_ASYNC_DISPATCHES));
+    this.asyncTimeouts = metricRegistry.meter(prefix.resolve(NAME_ASYNC_TIMEOUTS));
+
+    this.responseCodeMeters =
+        DETAILED_METER_LEVELS.contains(responseMeteredLevel)
+            ? new ConcurrentHashMap<>()
+            : ImmutableMap.of();
+
+    this.getRequests = metricRegistry.timer(prefix.resolve(NAME_GET_REQUESTS));
+    this.postRequests = metricRegistry.timer(prefix.resolve(NAME_POST_REQUESTS));
+    this.headRequests = metricRegistry.timer(prefix.resolve(NAME_HEAD_REQUESTS));
+    this.putRequests = metricRegistry.timer(prefix.resolve(NAME_PUT_REQUESTS));
+    this.deleteRequests = metricRegistry.timer(prefix.resolve(NAME_DELETE_REQUESTS));
+    this.optionsRequests = metricRegistry.timer(prefix.resolve(NAME_OPTIONS_REQUESTS));
+    this.traceRequests = metricRegistry.timer(prefix.resolve(NAME_TRACE_REQUESTS));
+    this.connectRequests = metricRegistry.timer(prefix.resolve(NAME_CONNECT_REQUESTS));
+    this.moveRequests = metricRegistry.timer(prefix.resolve(NAME_MOVE_REQUESTS));
+    this.otherRequests = metricRegistry.timer(prefix.resolve(NAME_OTHER_REQUESTS));
+
+    if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
+      this.responses =
+          unmodifiableList(
+              Arrays.asList(
+                  metricRegistry.meter(prefix.resolve(NAME_1XX_RESPONSES)), // 1xx
+                  metricRegistry.meter(prefix.resolve(NAME_2XX_RESPONSES)), // 2xx
+                  metricRegistry.meter(prefix.resolve(NAME_3XX_RESPONSES)), // 3xx
+                  metricRegistry.meter(prefix.resolve(NAME_4XX_RESPONSES)), // 4xx
+                  metricRegistry.meter(prefix.resolve(NAME_5XX_RESPONSES)) // 5xx
+                  ));
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_1M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(3).getOneMinuteRate(), requests.getOneMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_5M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(3).getFiveMinuteRate(), requests.getFiveMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_15M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(
+                  responses.get(3).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_1M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(4).getOneMinuteRate(), requests.getOneMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_5M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(4).getFiveMinuteRate(), requests.getFiveMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_15M),
+          new RatioGauge() {
+            @Override
+            public Ratio getRatio() {
+              return Ratio.of(
+                  responses.get(4).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+            }
+          });
+    } else {
+      this.responses = ImmutableList.of();
     }
 
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param prefix   the prefix to use for the metrics names
-     */
-    public InstrumentedHandler(MetricRegistry registry, String prefix) {
-        this(registry, prefix, COARSE);
+    this.listener = new AsyncAttachingListener();
+  }
+
+  @Override
+  protected void doStop() throws Exception {
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.remove(prefix.resolve(NAME_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_SUSPENDED));
+    metricRegistry.remove(prefix.resolve(NAME_ASYNC_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ASYNC_TIMEOUTS));
+    metricRegistry.remove(prefix.resolve(NAME_1XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_2XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_3XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_4XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_5XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_GET_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_POST_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_HEAD_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_PUT_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_DELETE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_OPTIONS_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_TRACE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_CONNECT_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_MOVE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_OTHER_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_1M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_5M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_15M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_1M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_5M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_15M));
+
+    if (responseCodeMeters != null) {
+      responseCodeMeters.keySet().stream()
+          .map(sc -> getMetricPrefix().resolve(String.format("%d-responses", sc)))
+          .forEach(metricRegistry::remove);
     }
 
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param prefix   the prefix to use for the metrics names
-     * @param responseMeteredLevel the level to determine individual/aggregate response codes that are instrumented
-     */
-    public InstrumentedHandler(MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
-        this.metricRegistry = registry;
-        this.prefix = prefix;
-        this.responseMeteredLevel = responseMeteredLevel;
+    super.doStop();
+  }
+
+  @Override
+  public void handle(
+      String path,
+      Request request,
+      HttpServletRequest httpRequest,
+      HttpServletResponse httpResponse)
+      throws IOException, ServletException {
+
+    activeDispatches.inc();
+
+    final long start;
+    final HttpChannelState state = request.getHttpChannelState();
+    if (state.isInitial()) {
+      // new request
+      activeRequests.inc();
+      start = request.getTimeStamp();
+      state.addListener(listener);
+    } else {
+      // resumed request
+      start = System.currentTimeMillis();
+      activeSuspended.dec();
+      if (state.getState() == HttpChannelState.State.HANDLING) {
+        asyncDispatches.mark();
+      }
     }
 
-    public String getName() {
-        return name;
+    try {
+      super.handle(path, request, httpRequest, httpResponse);
+    } finally {
+      final long now = System.currentTimeMillis();
+      final long dispatched = now - start;
+
+      activeDispatches.dec();
+      dispatches.update(dispatched, TimeUnit.MILLISECONDS);
+
+      if (state.isSuspended()) {
+        activeSuspended.inc();
+      } else if (state.isInitial()) {
+        updateResponses(httpRequest, httpResponse, start, request.isHandled());
+      }
+      // else onCompletion will handle it.
     }
-
-    public void setName(String name) {
-        this.name = name;
+  }
+
+  private Timer requestTimer(String method) {
+    final HttpMethod m = HttpMethod.fromString(method);
+    if (m == null) {
+      return otherRequests;
+    } else {
+      switch (m) {
+        case GET:
+          return getRequests;
+        case POST:
+          return postRequests;
+        case PUT:
+          return putRequests;
+        case HEAD:
+          return headRequests;
+        case DELETE:
+          return deleteRequests;
+        case OPTIONS:
+          return optionsRequests;
+        case TRACE:
+          return traceRequests;
+        case CONNECT:
+          return connectRequests;
+        case MOVE:
+          return moveRequests;
+        default:
+          return otherRequests;
+      }
     }
-
-    @Override
-    protected void doStart() throws Exception {
-        super.doStart();
-
-        final MetricName prefix = getMetricPrefix();
-
-        this.requests = metricRegistry.timer(prefix.resolve(NAME_REQUESTS));
-        this.dispatches = metricRegistry.timer(prefix.resolve(NAME_DISPATCHES));
-
-        this.activeRequests = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_REQUESTS));
-        this.activeDispatches = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_DISPATCHES));
-        this.activeSuspended = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_SUSPENDED));
-
-        this.asyncDispatches = metricRegistry.meter(prefix.resolve(NAME_ASYNC_DISPATCHES));
-        this.asyncTimeouts = metricRegistry.meter(prefix.resolve(NAME_ASYNC_TIMEOUTS));
-
-        this.responseCodeMeters = DETAILED_METER_LEVELS.contains(responseMeteredLevel) ? new ConcurrentHashMap<>() : Collections.emptyMap();
-
-        this.getRequests = metricRegistry.timer(prefix.resolve(NAME_GET_REQUESTS));
-        this.postRequests = metricRegistry.timer(prefix.resolve(NAME_POST_REQUESTS));
-        this.headRequests = metricRegistry.timer(prefix.resolve(NAME_HEAD_REQUESTS));
-        this.putRequests = metricRegistry.timer(prefix.resolve(NAME_PUT_REQUESTS));
-        this.deleteRequests = metricRegistry.timer(prefix.resolve(NAME_DELETE_REQUESTS));
-        this.optionsRequests = metricRegistry.timer(prefix.resolve(NAME_OPTIONS_REQUESTS));
-        this.traceRequests = metricRegistry.timer(prefix.resolve(NAME_TRACE_REQUESTS));
-        this.connectRequests = metricRegistry.timer(prefix.resolve(NAME_CONNECT_REQUESTS));
-        this.moveRequests = metricRegistry.timer(prefix.resolve(NAME_MOVE_REQUESTS));
-        this.otherRequests = metricRegistry.timer(prefix.resolve(NAME_OTHER_REQUESTS));
-
-        if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
-            this.responses = Collections.unmodifiableList(Arrays.asList(
-                    metricRegistry.meter(prefix.resolve(NAME_1XX_RESPONSES)), // 1xx
-                    metricRegistry.meter(prefix.resolve(NAME_2XX_RESPONSES)), // 2xx
-                    metricRegistry.meter(prefix.resolve(NAME_3XX_RESPONSES)), // 3xx
-                    metricRegistry.meter(prefix.resolve(NAME_4XX_RESPONSES)), // 4xx
-                    metricRegistry.meter(prefix.resolve(NAME_5XX_RESPONSES))  // 5xx
-            ));
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_1M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getOneMinuteRate(),
-                            requests.getOneMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_5M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getFiveMinuteRate(),
-                            requests.getFiveMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_15M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getFifteenMinuteRate(),
-                            requests.getFifteenMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_1M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getOneMinuteRate(),
-                            requests.getOneMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_5M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getFiveMinuteRate(),
-                            requests.getFiveMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_15M), new RatioGauge() {
-                @Override
-                public Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getFifteenMinuteRate(),
-                            requests.getFifteenMinuteRate());
-                }
-            });
-        } else {
-            this.responses = Collections.emptyList();
-        }
-
-        this.listener = new AsyncAttachingListener();
+  }
+
+  private void updateResponses(
+      HttpServletRequest request, HttpServletResponse response, long start, boolean isHandled) {
+    if (isHandled) {
+      mark(response.getStatus());
+    } else {
+      mark(404);
+      ; // will end up with a 404 response sent by HttpChannel.handle
+    }
+    activeRequests.dec();
+    final long elapsedTime = System.currentTimeMillis() - start;
+    requests.update(elapsedTime, TimeUnit.MILLISECONDS);
+    requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
+  }
+
+  private void mark(int statusCode) {
+    if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
+      getResponseCodeMeter(statusCode).mark();
     }
 
-    @Override
-    protected void doStop() throws Exception {
-        final MetricName prefix = getMetricPrefix();
-        
-        metricRegistry.remove(prefix.resolve(NAME_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_SUSPENDED));
-        metricRegistry.remove(prefix.resolve(NAME_ASYNC_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ASYNC_TIMEOUTS));
-        metricRegistry.remove(prefix.resolve(NAME_1XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_2XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_3XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_4XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_5XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_GET_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_POST_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_HEAD_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_PUT_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_DELETE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_OPTIONS_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_TRACE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_CONNECT_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_MOVE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_OTHER_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_1M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_5M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_15M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_1M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_5M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_15M));
-
-        if (responseCodeMeters != null) {
-            responseCodeMeters.keySet().stream()
-                    .map(sc -> getMetricPrefix().resolve(String.format("%d-responses", sc)))
-                    .forEach(metricRegistry::remove);
-        }
-
-        super.doStop();
+    if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
+      final int responseStatus = statusCode / 100;
+      if (responseStatus >= 1 && responseStatus <= 5) {
+        responses.get(responseStatus - 1).mark();
+      }
     }
+  }
 
-    @Override
-    public void handle(String path,
-                       Request request,
-                       HttpServletRequest httpRequest,
-                       HttpServletResponse httpResponse) throws IOException, ServletException {
-
-        activeDispatches.inc();
-
-        final long start;
-        final HttpChannelState state = request.getHttpChannelState();
-        if (state.isInitial()) {
-            // new request
-            activeRequests.inc();
-            start = request.getTimeStamp();
-            state.addListener(listener);
-        } else {
-            // resumed request
-            start = System.currentTimeMillis();
-            activeSuspended.dec();
-            if (state.getState() == HttpChannelState.State.HANDLING) {
-                asyncDispatches.mark();
-            }
-        }
+  private Meter getResponseCodeMeter(int statusCode) {
+    return responseCodeMeters.computeIfAbsent(
+        statusCode,
+        sc -> metricRegistry.meter(getMetricPrefix().resolve(String.format("%d-responses", sc))));
+  }
 
-        try {
-            super.handle(path, request, httpRequest, httpResponse);
-        } finally {
-            final long now = System.currentTimeMillis();
-            final long dispatched = now - start;
+  private MetricName getMetricPrefix() {
+    return this.prefix == null ? name(getHandler().getClass(), name) : name(this.prefix, name);
+  }
 
-            activeDispatches.dec();
-            dispatches.update(dispatched, TimeUnit.MILLISECONDS);
+  private class AsyncAttachingListener implements AsyncListener {
 
-            if (state.isSuspended()) {
-                activeSuspended.inc();
-            } else if (state.isInitial()) {
-                updateResponses(httpRequest, httpResponse, start, request.isHandled());
-            }
-            // else onCompletion will handle it.
-        }
-    }
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {}
 
-    private Timer requestTimer(String method) {
-        final HttpMethod m = HttpMethod.fromString(method);
-        if (m == null) {
-            return otherRequests;
-        } else {
-            switch (m) {
-                case GET:
-                    return getRequests;
-                case POST:
-                    return postRequests;
-                case PUT:
-                    return putRequests;
-                case HEAD:
-                    return headRequests;
-                case DELETE:
-                    return deleteRequests;
-                case OPTIONS:
-                    return optionsRequests;
-                case TRACE:
-                    return traceRequests;
-                case CONNECT:
-                    return connectRequests;
-                case MOVE:
-                    return moveRequests;
-                default:
-                    return otherRequests;
-            }
-        }
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {
+      event.getAsyncContext().addListener(new InstrumentedAsyncListener());
     }
 
-    private void updateResponses(HttpServletRequest request, HttpServletResponse response, long start, boolean isHandled) {
-        if (isHandled) {
-            mark(response.getStatus());
-        } else {
-            mark(404);; // will end up with a 404 response sent by HttpChannel.handle
-        }
-        activeRequests.dec();
-        final long elapsedTime = System.currentTimeMillis() - start;
-        requests.update(elapsedTime, TimeUnit.MILLISECONDS);
-        requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
-    }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {}
 
-    private void mark(int statusCode) {
-        if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
-            getResponseCodeMeter(statusCode).mark();
-        }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {}
+  }
+  ;
 
-        if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
-            final int responseStatus = statusCode / 100;
-            if (responseStatus >= 1 && responseStatus <= 5) {
-                responses.get(responseStatus - 1).mark();
-            }
-        }
-    }
+  private class InstrumentedAsyncListener implements AsyncListener {
+    private final long startTime;
 
-    private Meter getResponseCodeMeter(int statusCode) {
-        return responseCodeMeters
-                .computeIfAbsent(statusCode, sc -> metricRegistry
-                        .meter(getMetricPrefix().resolve(String.format("%d-responses", sc))));
+    InstrumentedAsyncListener() {
+      this.startTime = System.currentTimeMillis();
     }
 
-    private MetricName getMetricPrefix() {
-        return this.prefix == null ? name(getHandler().getClass(), name) : name(this.prefix, name);
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {
+      asyncTimeouts.mark();
     }
 
-    private class AsyncAttachingListener implements AsyncListener {
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {}
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-            event.getAsyncContext().addListener(new InstrumentedAsyncListener());
-        }
-
-        @Override
-        public void onError(AsyncEvent event) throws IOException {}
-
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {}
-    };
-
-    private class InstrumentedAsyncListener implements AsyncListener {
-        private final long startTime;
-
-        InstrumentedAsyncListener() {
-            this.startTime = System.currentTimeMillis();
-        }
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {
-            asyncTimeouts.mark();
-        }
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-        }
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {}
 
-        @Override
-        public void onError(AsyncEvent event) throws IOException {
-        }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {}
 
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {
-            final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
-            final HttpServletRequest request = (HttpServletRequest) state.getRequest();
-            final HttpServletResponse response = (HttpServletResponse) state.getResponse();
-            updateResponses(request, response, startTime, true);
-            if (!state.getHttpChannelState().isSuspended()) {
-                activeSuspended.dec();
-            }
-        }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {
+      final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
+      final HttpServletRequest request = (HttpServletRequest) state.getRequest();
+      final HttpServletResponse response = (HttpServletResponse) state.getResponse();
+      updateResponses(request, response, startTime, true);
+      if (!state.getHttpChannelState().isSuspended()) {
+        activeSuspended.dec();
+      }
     }
+  }
 }
--- a/metrics-jetty10/src/main/java/io/dropwizard/metrics5/jetty10/InstrumentedHttpChannelListener.java
+++ b/metrics-jetty10/src/main/java/io/dropwizard/metrics5/jetty10/InstrumentedHttpChannelListener.java
@@ -1,5 +1,12 @@
 package io.dropwizard.metrics5.jetty10;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.util.Collections.unmodifiableList;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricName;
@@ -7,418 +14,402 @@ import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.RatioGauge;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.annotation.ResponseMeteredLevel;
-import org.eclipse.jetty.http.HttpMethod;
-import org.eclipse.jetty.server.AsyncContextState;
-import org.eclipse.jetty.server.HttpChannel.Listener;
-import org.eclipse.jetty.server.HttpChannelState;
-import org.eclipse.jetty.server.Request;
-
-import javax.servlet.AsyncEvent;
-import javax.servlet.AsyncListener;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import javax.servlet.AsyncEvent;
+import javax.servlet.AsyncListener;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import org.eclipse.jetty.http.HttpMethod;
+import org.eclipse.jetty.server.AsyncContextState;
+import org.eclipse.jetty.server.HttpChannel.Listener;
+import org.eclipse.jetty.server.HttpChannelState;
+import org.eclipse.jetty.server.Request;
 
 /**
- * A Jetty {@link org.eclipse.jetty.server.HttpChannel.Listener} implementation which records various metrics about
- * underlying channel instance. Unlike {@link InstrumentedHandler} that uses internal API, this class should be
- * future proof. To install it, just add instance of this class to {@link org.eclipse.jetty.server.Connector} as bean.
+ * A Jetty {@link org.eclipse.jetty.server.HttpChannel.Listener} implementation which records
+ * various metrics about underlying channel instance. Unlike {@link InstrumentedHandler} that uses
+ * internal API, this class should be future proof. To install it, just add instance of this class
+ * to {@link org.eclipse.jetty.server.Connector} as bean.
  *
  * @since TBD
  */
-public class InstrumentedHttpChannelListener
-        implements Listener {
-    private static final String START_ATTR = InstrumentedHttpChannelListener.class.getName() + ".start";
-    private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
-    private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
-
-    private final MetricRegistry metricRegistry;
-
-    // the requests handled by this handler, excluding active
-    private final Timer requests;
-
-    // the number of dispatches seen by this handler, excluding active
-    private final Timer dispatches;
-
-    // the number of active requests
-    private final Counter activeRequests;
-
-    // the number of active dispatches
-    private final Counter activeDispatches;
-
-    // the number of requests currently suspended.
-    private final Counter activeSuspended;
-
-    // the number of requests that have been asynchronously dispatched
-    private final Meter asyncDispatches;
-
-    // the number of requests that expired while suspended
-    private final Meter asyncTimeouts;
-
-    private final ResponseMeteredLevel responseMeteredLevel;
-    private final List<Meter> responses;
-    private final Map<Integer, Meter> responseCodeMeters;
-    private final MetricName prefix;
-    private final Timer getRequests;
-    private final Timer postRequests;
-    private final Timer headRequests;
-    private final Timer putRequests;
-    private final Timer deleteRequests;
-    private final Timer optionsRequests;
-    private final Timer traceRequests;
-    private final Timer connectRequests;
-    private final Timer moveRequests;
-    private final Timer otherRequests;
-
-    private final AsyncListener listener;
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     */
-    public InstrumentedHttpChannelListener(MetricRegistry registry) {
-        this(registry, null, COARSE);
-    }
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param pref     the prefix to use for the metrics names
-     */
-    public InstrumentedHttpChannelListener(MetricRegistry registry, MetricName pref) {
-        this(registry, pref, COARSE);
-    }
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param pref     the prefix to use for the metrics names
-     * @param responseMeteredLevel the level to determine individual/aggregate response codes that are instrumented
-     */
-    public InstrumentedHttpChannelListener(MetricRegistry registry, MetricName pref, ResponseMeteredLevel responseMeteredLevel) {
-        this.metricRegistry = registry;
-
-        this.prefix = (pref == null) ? MetricName.build(getClass().getName()) : pref;
-
-        this.requests = metricRegistry.timer(prefix.resolve("requests"));
-        this.dispatches = metricRegistry.timer(prefix.resolve("dispatches"));
-
-        this.activeRequests = metricRegistry.counter(prefix.resolve("active-requests"));
-        this.activeDispatches = metricRegistry.counter(prefix.resolve("active-dispatches"));
-        this.activeSuspended = metricRegistry.counter(prefix.resolve("active-suspended"));
-
-        this.asyncDispatches = metricRegistry.meter(prefix.resolve("async-dispatches"));
-        this.asyncTimeouts = metricRegistry.meter(prefix.resolve("async-timeouts"));
-
-        this.responseMeteredLevel = responseMeteredLevel;
-        this.responseCodeMeters = DETAILED_METER_LEVELS.contains(responseMeteredLevel) ? new ConcurrentHashMap<>() : Collections.emptyMap();
-        this.responses = COARSE_METER_LEVELS.contains(responseMeteredLevel) ?
-                Collections.unmodifiableList(Arrays.asList(
-                        registry.meter(prefix.resolve("1xx-responses")), // 1xx
-                        registry.meter(prefix.resolve("2xx-responses")), // 2xx
-                        registry.meter(prefix.resolve("3xx-responses")), // 3xx
-                        registry.meter(prefix.resolve("4xx-responses")), // 4xx
-                        registry.meter(prefix.resolve("5xx-responses"))  // 5xx
-                )) : Collections.emptyList();
-
-        this.getRequests = metricRegistry.timer(prefix.resolve("get-requests"));
-        this.postRequests = metricRegistry.timer(prefix.resolve("post-requests"));
-        this.headRequests = metricRegistry.timer(prefix.resolve("head-requests"));
-        this.putRequests = metricRegistry.timer(prefix.resolve("put-requests"));
-        this.deleteRequests = metricRegistry.timer(prefix.resolve("delete-requests"));
-        this.optionsRequests = metricRegistry.timer(prefix.resolve("options-requests"));
-        this.traceRequests = metricRegistry.timer(prefix.resolve("trace-requests"));
-        this.connectRequests = metricRegistry.timer(prefix.resolve("connect-requests"));
-        this.moveRequests = metricRegistry.timer(prefix.resolve("move-requests"));
-        this.otherRequests = metricRegistry.timer(prefix.resolve("other-requests"));
-
-        metricRegistry.register(prefix.resolve("percent-4xx-1m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(3).getOneMinuteRate(),
-                        requests.getOneMinuteRate());
-            }
+public class InstrumentedHttpChannelListener implements Listener {
+  private static final String START_ATTR =
+      InstrumentedHttpChannelListener.class.getName() + ".start";
+  private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
+  private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
+
+  private final MetricRegistry metricRegistry;
+
+  // the requests handled by this handler, excluding active
+  private final Timer requests;
+
+  // the number of dispatches seen by this handler, excluding active
+  private final Timer dispatches;
+
+  // the number of active requests
+  private final Counter activeRequests;
+
+  // the number of active dispatches
+  private final Counter activeDispatches;
+
+  // the number of requests currently suspended.
+  private final Counter activeSuspended;
+
+  // the number of requests that have been asynchronously dispatched
+  private final Meter asyncDispatches;
+
+  // the number of requests that expired while suspended
+  private final Meter asyncTimeouts;
+
+  private final ResponseMeteredLevel responseMeteredLevel;
+  private final List<Meter> responses;
+  private final Map<Integer, Meter> responseCodeMeters;
+  private final MetricName prefix;
+  private final Timer getRequests;
+  private final Timer postRequests;
+  private final Timer headRequests;
+  private final Timer putRequests;
+  private final Timer deleteRequests;
+  private final Timer optionsRequests;
+  private final Timer traceRequests;
+  private final Timer connectRequests;
+  private final Timer moveRequests;
+  private final Timer otherRequests;
+
+  private final AsyncListener listener;
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   */
+  public InstrumentedHttpChannelListener(MetricRegistry registry) {
+    this(registry, null, COARSE);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param pref the prefix to use for the metrics names
+   */
+  public InstrumentedHttpChannelListener(MetricRegistry registry, MetricName pref) {
+    this(registry, pref, COARSE);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param pref the prefix to use for the metrics names
+   * @param responseMeteredLevel the level to determine individual/aggregate response codes that are
+   *     instrumented
+   */
+  public InstrumentedHttpChannelListener(
+      MetricRegistry registry, MetricName pref, ResponseMeteredLevel responseMeteredLevel) {
+    this.metricRegistry = registry;
+
+    this.prefix = (pref == null) ? MetricName.build(getClass().getName()) : pref;
+
+    this.requests = metricRegistry.timer(prefix.resolve("requests"));
+    this.dispatches = metricRegistry.timer(prefix.resolve("dispatches"));
+
+    this.activeRequests = metricRegistry.counter(prefix.resolve("active-requests"));
+    this.activeDispatches = metricRegistry.counter(prefix.resolve("active-dispatches"));
+    this.activeSuspended = metricRegistry.counter(prefix.resolve("active-suspended"));
+
+    this.asyncDispatches = metricRegistry.meter(prefix.resolve("async-dispatches"));
+    this.asyncTimeouts = metricRegistry.meter(prefix.resolve("async-timeouts"));
+
+    this.responseMeteredLevel = responseMeteredLevel;
+    this.responseCodeMeters =
+        DETAILED_METER_LEVELS.contains(responseMeteredLevel)
+            ? new ConcurrentHashMap<>()
+            : ImmutableMap.of();
+    this.responses =
+        COARSE_METER_LEVELS.contains(responseMeteredLevel)
+            ? unmodifiableList(
+                Arrays.asList(
+                    registry.meter(prefix.resolve("1xx-responses")), // 1xx
+                    registry.meter(prefix.resolve("2xx-responses")), // 2xx
+                    registry.meter(prefix.resolve("3xx-responses")), // 3xx
+                    registry.meter(prefix.resolve("4xx-responses")), // 4xx
+                    registry.meter(prefix.resolve("5xx-responses")) // 5xx
+                    ))
+            : ImmutableList.of();
+
+    this.getRequests = metricRegistry.timer(prefix.resolve("get-requests"));
+    this.postRequests = metricRegistry.timer(prefix.resolve("post-requests"));
+    this.headRequests = metricRegistry.timer(prefix.resolve("head-requests"));
+    this.putRequests = metricRegistry.timer(prefix.resolve("put-requests"));
+    this.deleteRequests = metricRegistry.timer(prefix.resolve("delete-requests"));
+    this.optionsRequests = metricRegistry.timer(prefix.resolve("options-requests"));
+    this.traceRequests = metricRegistry.timer(prefix.resolve("trace-requests"));
+    this.connectRequests = metricRegistry.timer(prefix.resolve("connect-requests"));
+    this.moveRequests = metricRegistry.timer(prefix.resolve("move-requests"));
+    this.otherRequests = metricRegistry.timer(prefix.resolve("other-requests"));
+
+    metricRegistry.register(
+        prefix.resolve("percent-4xx-1m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(responses.get(3).getOneMinuteRate(), requests.getOneMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-4xx-5m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(3).getFiveMinuteRate(),
-                        requests.getFiveMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-4xx-5m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(responses.get(3).getFiveMinuteRate(), requests.getFiveMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-4xx-15m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(3).getFifteenMinuteRate(),
-                        requests.getFifteenMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-4xx-15m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(
+                responses.get(3).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-5xx-1m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(4).getOneMinuteRate(),
-                        requests.getOneMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-5xx-1m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(responses.get(4).getOneMinuteRate(), requests.getOneMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-5xx-5m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(4).getFiveMinuteRate(),
-                        requests.getFiveMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-5xx-5m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(responses.get(4).getFiveMinuteRate(), requests.getFiveMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-5xx-15m"), new RatioGauge() {
-            @Override
-            public RatioGauge.Ratio getRatio() {
-                return Ratio.of(responses.get(4).getFifteenMinuteRate(),
-                        requests.getFifteenMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-5xx-15m"),
+        new RatioGauge() {
+          @Override
+          public RatioGauge.Ratio getRatio() {
+            return Ratio.of(
+                responses.get(4).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+          }
         });
 
-        this.listener = new AsyncAttachingListener();
-    }
+    this.listener = new AsyncAttachingListener();
+  }
 
-    @Override
-    public void onRequestBegin(final Request request) {
+  @Override
+  public void onRequestBegin(final Request request) {}
 
-    }
+  @Override
+  public void onBeforeDispatch(final Request request) {
+    before(request);
+  }
 
-    @Override
-    public void onBeforeDispatch(final Request request) {
-        before(request);
-    }
+  @Override
+  public void onDispatchFailure(final Request request, final Throwable failure) {}
 
-    @Override
-    public void onDispatchFailure(final Request request, final Throwable failure) {
+  @Override
+  public void onAfterDispatch(final Request request) {
+    after(request);
+  }
 
-    }
+  @Override
+  public void onRequestContent(final Request request, final ByteBuffer content) {}
 
-    @Override
-    public void onAfterDispatch(final Request request) {
-        after(request);
-    }
+  @Override
+  public void onRequestContentEnd(final Request request) {}
 
-    @Override
-    public void onRequestContent(final Request request, final ByteBuffer content) {
+  @Override
+  public void onRequestTrailers(final Request request) {}
 
-    }
+  @Override
+  public void onRequestEnd(final Request request) {}
 
-    @Override
-    public void onRequestContentEnd(final Request request) {
+  @Override
+  public void onRequestFailure(final Request request, final Throwable failure) {}
 
-    }
+  @Override
+  public void onResponseBegin(final Request request) {}
 
-    @Override
-    public void onRequestTrailers(final Request request) {
+  @Override
+  public void onResponseCommit(final Request request) {}
 
-    }
+  @Override
+  public void onResponseContent(final Request request, final ByteBuffer content) {}
 
-    @Override
-    public void onRequestEnd(final Request request) {
+  @Override
+  public void onResponseEnd(final Request request) {}
 
-    }
+  @Override
+  public void onResponseFailure(final Request request, final Throwable failure) {}
 
-    @Override
-    public void onRequestFailure(final Request request, final Throwable failure) {
+  @Override
+  public void onComplete(final Request request) {}
 
-    }
-
-    @Override
-    public void onResponseBegin(final Request request) {
+  private void before(final Request request) {
+    activeDispatches.inc();
 
+    final long start;
+    final HttpChannelState state = request.getHttpChannelState();
+    if (state.isInitial()) {
+      // new request
+      activeRequests.inc();
+      start = request.getTimeStamp();
+      state.addListener(listener);
+    } else {
+      // resumed request
+      start = System.currentTimeMillis();
+      activeSuspended.dec();
+      if (state.isAsyncStarted()) {
+        asyncDispatches.mark();
+      }
     }
-
-    @Override
-    public void onResponseCommit(final Request request) {
-
+    request.setAttribute(START_ATTR, start);
+  }
+
+  private void after(final Request request) {
+    final long start = (long) request.getAttribute(START_ATTR);
+    final long now = System.currentTimeMillis();
+    final long dispatched = now - start;
+
+    activeDispatches.dec();
+    dispatches.update(dispatched, TimeUnit.MILLISECONDS);
+
+    final HttpChannelState state = request.getHttpChannelState();
+    if (state.isSuspended()) {
+      activeSuspended.inc();
+    } else if (state.isInitial()) {
+      updateResponses(request, request.getResponse(), start, request.isHandled());
     }
-
-    @Override
-    public void onResponseContent(final Request request, final ByteBuffer content) {
-
+    // else onCompletion will handle it.
+  }
+
+  private void updateResponses(
+      HttpServletRequest request, HttpServletResponse response, long start, boolean isHandled) {
+    if (isHandled) {
+      mark(response.getStatus());
+    } else {
+      mark(404); // will end up with a 404 response sent by HttpChannel.handle
+    }
+    activeRequests.dec();
+    final long elapsedTime = System.currentTimeMillis() - start;
+    requests.update(elapsedTime, TimeUnit.MILLISECONDS);
+    requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
+  }
+
+  private void mark(int statusCode) {
+    if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
+      getResponseCodeMeter(statusCode).mark();
     }
 
-    @Override
-    public void onResponseEnd(final Request request) {
-
+    if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
+      final int responseStatus = statusCode / 100;
+      if (responseStatus >= 1 && responseStatus <= 5) {
+        responses.get(responseStatus - 1).mark();
+      }
+    }
+  }
+
+  private Meter getResponseCodeMeter(int statusCode) {
+    return responseCodeMeters.computeIfAbsent(
+        statusCode, sc -> metricRegistry.meter(prefix.resolve(String.format("%d-responses", sc))));
+  }
+
+  private Timer requestTimer(String method) {
+    final HttpMethod m = HttpMethod.fromString(method);
+    if (m == null) {
+      return otherRequests;
+    } else {
+      switch (m) {
+        case GET:
+          return getRequests;
+        case POST:
+          return postRequests;
+        case PUT:
+          return putRequests;
+        case HEAD:
+          return headRequests;
+        case DELETE:
+          return deleteRequests;
+        case OPTIONS:
+          return optionsRequests;
+        case TRACE:
+          return traceRequests;
+        case CONNECT:
+          return connectRequests;
+        case MOVE:
+          return moveRequests;
+        default:
+          return otherRequests;
+      }
     }
+  }
+
+  private class AsyncAttachingListener implements AsyncListener {
 
     @Override
-    public void onResponseFailure(final Request request, final Throwable failure) {
+    public void onTimeout(AsyncEvent event) throws IOException {}
 
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {
+      event.getAsyncContext().addListener(new InstrumentedAsyncListener());
     }
 
     @Override
-    public void onComplete(final Request request) {
-
-    }
+    public void onError(AsyncEvent event) throws IOException {}
 
-    private void before(final Request request) {
-        activeDispatches.inc();
-
-        final long start;
-        final HttpChannelState state = request.getHttpChannelState();
-        if (state.isInitial()) {
-            // new request
-            activeRequests.inc();
-            start = request.getTimeStamp();
-            state.addListener(listener);
-        } else {
-            // resumed request
-            start = System.currentTimeMillis();
-            activeSuspended.dec();
-            if (state.isAsyncStarted()) {
-                asyncDispatches.mark();
-            }
-        }
-        request.setAttribute(START_ATTR, start);
-    }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {}
+  }
+  ;
 
-    private void after(final Request request) {
-        final long start = (long) request.getAttribute(START_ATTR);
-        final long now = System.currentTimeMillis();
-        final long dispatched = now - start;
-
-        activeDispatches.dec();
-        dispatches.update(dispatched, TimeUnit.MILLISECONDS);
-
-        final HttpChannelState state = request.getHttpChannelState();
-        if (state.isSuspended()) {
-            activeSuspended.inc();
-        } else if (state.isInitial()) {
-            updateResponses(request, request.getResponse(), start, request.isHandled());
-        }
-        // else onCompletion will handle it.
-    }
+  private class InstrumentedAsyncListener implements AsyncListener {
+    private final long startTime;
 
-    private void updateResponses(HttpServletRequest request, HttpServletResponse response, long start, boolean isHandled) {
-        if (isHandled) {
-            mark(response.getStatus());
-        } else {
-            mark(404); // will end up with a 404 response sent by HttpChannel.handle
-        }
-        activeRequests.dec();
-        final long elapsedTime = System.currentTimeMillis() - start;
-        requests.update(elapsedTime, TimeUnit.MILLISECONDS);
-        requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
+    InstrumentedAsyncListener() {
+      this.startTime = System.currentTimeMillis();
     }
 
-    private void mark(int statusCode) {
-        if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
-            getResponseCodeMeter(statusCode).mark();
-        }
-
-        if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
-            final int responseStatus = statusCode / 100;
-            if (responseStatus >= 1 && responseStatus <= 5) {
-                responses.get(responseStatus - 1).mark();
-            }
-        }
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {
+      asyncTimeouts.mark();
     }
 
-    private Meter getResponseCodeMeter(int statusCode) {
-        return responseCodeMeters
-                .computeIfAbsent(statusCode, sc -> metricRegistry
-                        .meter(prefix.resolve(String.format("%d-responses", sc))));
-    }
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {}
 
-    private Timer requestTimer(String method) {
-        final HttpMethod m = HttpMethod.fromString(method);
-        if (m == null) {
-            return otherRequests;
-        } else {
-            switch (m) {
-                case GET:
-                    return getRequests;
-                case POST:
-                    return postRequests;
-                case PUT:
-                    return putRequests;
-                case HEAD:
-                    return headRequests;
-                case DELETE:
-                    return deleteRequests;
-                case OPTIONS:
-                    return optionsRequests;
-                case TRACE:
-                    return traceRequests;
-                case CONNECT:
-                    return connectRequests;
-                case MOVE:
-                    return moveRequests;
-                default:
-                    return otherRequests;
-            }
-        }
-    }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {}
 
-    private class AsyncAttachingListener implements AsyncListener {
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {}
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-            event.getAsyncContext().addListener(new InstrumentedAsyncListener());
-        }
-
-        @Override
-        public void onError(AsyncEvent event) throws IOException {}
-
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {}
-    };
-
-    private class InstrumentedAsyncListener implements AsyncListener {
-        private final long startTime;
-
-        InstrumentedAsyncListener() {
-            this.startTime = System.currentTimeMillis();
-        }
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {
-            asyncTimeouts.mark();
-        }
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-        }
-
-        @Override
-        public void onError(AsyncEvent event) throws IOException {
-        }
-
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {
-            final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
-            final HttpServletRequest request = (HttpServletRequest) state.getRequest();
-            final HttpServletResponse response = (HttpServletResponse) state.getResponse();
-            updateResponses(request, response, startTime, true);
-            if (!state.getHttpChannelState().isSuspended()) {
-                activeSuspended.dec();
-            }
-        }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {
+      final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
+      final HttpServletRequest request = (HttpServletRequest) state.getRequest();
+      final HttpServletResponse response = (HttpServletResponse) state.getResponse();
+      updateResponses(request, response, startTime, true);
+      if (!state.getHttpChannelState().isSuspended()) {
+        activeSuspended.dec();
+      }
     }
+  }
 }
--- a/metrics-jetty10/src/main/java/io/dropwizard/metrics5/jetty10/InstrumentedQueuedThreadPool.java
+++ b/metrics-jetty10/src/main/java/io/dropwizard/metrics5/jetty10/InstrumentedQueuedThreadPool.java
@@ -1,120 +1,131 @@
 package io.dropwizard.metrics5.jetty10;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.RatioGauge;
+import java.util.concurrent.BlockingQueue;
 import org.eclipse.jetty.util.annotation.Name;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
 
-import java.util.concurrent.BlockingQueue;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 public class InstrumentedQueuedThreadPool extends QueuedThreadPool {
-    private static final String NAME_UTILIZATION = "utilization";
-    private static final String NAME_UTILIZATION_MAX = "utilization-max";
-    private static final String NAME_SIZE = "size";
-    private static final String NAME_JOBS = "jobs";
-    private static final String NAME_JOBS_QUEUE_UTILIZATION = "jobs-queue-utilization";
-
-    private final MetricRegistry metricRegistry;
-    private String prefix;
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry) {
-        this(registry, 200);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads) {
-        this(registry, maxThreads, 8);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads) {
-        this(registry, maxThreads, minThreads, 60000);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout) {
-        this(registry, maxThreads, minThreads, idleTimeout, null);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("queue") BlockingQueue<Runnable> queue) {
-        this(registry, maxThreads, minThreads, idleTimeout, queue, null);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("queue") BlockingQueue<Runnable> queue,
-                                        @Name("prefix") String prefix) {
-        super(maxThreads, minThreads, idleTimeout, queue);
-        this.metricRegistry = registry;
-        this.prefix = prefix;
-    }
-
-    public String getPrefix() {
-        return prefix;
-    }
-
-    public void setPrefix(String prefix) {
-        this.prefix = prefix;
-    }
-
-    @Override
-    protected void doStart() throws Exception {
-        super.doStart();
-
-        final MetricName prefix = getMetricPrefix();
-
-        metricRegistry.register(prefix.resolve("utilization"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(getThreads() - getIdleThreads(), getThreads());
-            }
+  private static final String NAME_UTILIZATION = "utilization";
+  private static final String NAME_UTILIZATION_MAX = "utilization-max";
+  private static final String NAME_SIZE = "size";
+  private static final String NAME_JOBS = "jobs";
+  private static final String NAME_JOBS_QUEUE_UTILIZATION = "jobs-queue-utilization";
+
+  private final MetricRegistry metricRegistry;
+  private String prefix;
+
+  public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry) {
+    this(registry, 200);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry, @Name("maxThreads") int maxThreads) {
+    this(registry, maxThreads, 8);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads) {
+    this(registry, maxThreads, minThreads, 60000);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout) {
+    this(registry, maxThreads, minThreads, idleTimeout, null);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("queue") BlockingQueue<Runnable> queue) {
+    this(registry, maxThreads, minThreads, idleTimeout, queue, null);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("queue") BlockingQueue<Runnable> queue,
+      @Name("prefix") String prefix) {
+    super(maxThreads, minThreads, idleTimeout, queue);
+    this.metricRegistry = registry;
+    this.prefix = prefix;
+  }
+
+  public String getPrefix() {
+    return prefix;
+  }
+
+  public void setPrefix(String prefix) {
+    this.prefix = prefix;
+  }
+
+  @Override
+  protected void doStart() throws Exception {
+    super.doStart();
+
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.register(
+        prefix.resolve("utilization"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(getThreads() - getIdleThreads(), getThreads());
+          }
         });
-        metricRegistry.register(prefix.resolve("utilization-max"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(getThreads() - getIdleThreads(), getMaxThreads());
-            }
+    metricRegistry.register(
+        prefix.resolve("utilization-max"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(getThreads() - getIdleThreads(), getMaxThreads());
+          }
         });
-        // This assumes the QueuedThreadPool is using a BlockingArrayQueue or
-        // ArrayBlockingQueue for its queue, and is therefore a constant-time operation.
-
-        metricRegistry.registerGauge(prefix.resolve(NAME_SIZE), this::getThreads);
-        metricRegistry.registerGauge(prefix.resolve(NAME_JOBS), () -> getQueue().size());
-        metricRegistry.register(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                BlockingQueue<Runnable> queue = getQueue();
-                return Ratio.of(queue.size(), queue.size() + queue.remainingCapacity());
-            }
+    // This assumes the QueuedThreadPool is using a BlockingArrayQueue or
+    // ArrayBlockingQueue for its queue, and is therefore a constant-time operation.
+
+    metricRegistry.registerGauge(prefix.resolve(NAME_SIZE), this::getThreads);
+    metricRegistry.registerGauge(prefix.resolve(NAME_JOBS), () -> getQueue().size());
+    metricRegistry.register(
+        prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            BlockingQueue<Runnable> queue = getQueue();
+            return Ratio.of(queue.size(), queue.size() + queue.remainingCapacity());
+          }
         });
-    }
-
-    @Override
-    protected void doStop() throws Exception {
-        final MetricName prefix = getMetricPrefix();
-
-        metricRegistry.remove(prefix.resolve(NAME_UTILIZATION));
-        metricRegistry.remove(prefix.resolve(NAME_UTILIZATION_MAX));
-        metricRegistry.remove(prefix.resolve(NAME_SIZE));
-        metricRegistry.remove(prefix.resolve(NAME_JOBS));
-        metricRegistry.remove(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION));
-
-        super.doStop();
-    }
-
-    private MetricName getMetricPrefix() {
-        return this.prefix == null ? name(QueuedThreadPool.class, getName()) : name(this.prefix, getName());
-    }
+  }
+
+  @Override
+  protected void doStop() throws Exception {
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.remove(prefix.resolve(NAME_UTILIZATION));
+    metricRegistry.remove(prefix.resolve(NAME_UTILIZATION_MAX));
+    metricRegistry.remove(prefix.resolve(NAME_SIZE));
+    metricRegistry.remove(prefix.resolve(NAME_JOBS));
+    metricRegistry.remove(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION));
+
+    super.doStop();
+  }
+
+  private MetricName getMetricPrefix() {
+    return this.prefix == null
+        ? name(QueuedThreadPool.class, getName())
+        : name(this.prefix, getName());
+  }
 }
--- a/metrics-jetty10/src/test/java/io/dropwizard/metrics5/jetty10/InstrumentedConnectionFactoryTest.java
+++ b/metrics-jetty10/src/test/java/io/dropwizard/metrics5/jetty10/InstrumentedConnectionFactoryTest.java
@@ -1,8 +1,15 @@
 package io.dropwizard.metrics5.jetty10;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.io.IOException;
+import java.io.PrintWriter;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import org.eclipse.jetty.client.HttpClient;
 import org.eclipse.jetty.client.api.ContentResponse;
 import org.eclipse.jetty.server.HttpConnectionFactory;
@@ -14,80 +21,75 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.PrintWriter;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-class InstrumentedConnectionFactoryTest {
-    private final MetricRegistry registry = new MetricRegistry();
-    private final Server server = new Server();
-    private final ServerConnector connector =
-            new ServerConnector(server, new InstrumentedConnectionFactory(new HttpConnectionFactory(),
-                    registry.timer("http.connections"),
-                    registry.counter("http.active-connections")));
-    private final HttpClient client = new HttpClient();
-
-    @BeforeEach
-    void setUp() throws Exception {
-        server.setHandler(new AbstractHandler() {
-            @Override
-            public void handle(String target,
-                    Request baseRequest,
-                    HttpServletRequest request,
-                    HttpServletResponse response) throws IOException, ServletException {
-                try (PrintWriter writer = response.getWriter()) {
-                    writer.println("OK");
-                }
+final class InstrumentedConnectionFactoryTest {
+  private final MetricRegistry registry = new MetricRegistry();
+  private final Server server = new Server();
+  private final ServerConnector connector =
+      new ServerConnector(
+          server,
+          new InstrumentedConnectionFactory(
+              new HttpConnectionFactory(),
+              registry.timer("http.connections"),
+              registry.counter("http.active-connections")));
+  private final HttpClient client = new HttpClient();
+
+  @BeforeEach
+  void setUp() throws Exception {
+    server.setHandler(
+        new AbstractHandler() {
+          @Override
+          public void handle(
+              String target,
+              Request baseRequest,
+              HttpServletRequest request,
+              HttpServletResponse response)
+              throws IOException, ServletException {
+            try (PrintWriter writer = response.getWriter()) {
+              writer.println("OK");
             }
+          }
         });
 
-        server.addConnector(connector);
-        server.start();
+    server.addConnector(connector);
+    server.start();
 
-        client.start();
-    }
+    client.start();
+  }
 
-    @AfterEach
-    void tearDown() throws Exception {
-        server.stop();
-        client.stop();
-    }
+  @AfterEach
+  void tearDown() throws Exception {
+    server.stop();
+    client.stop();
+  }
 
-    @Test
-    void instrumentsConnectionTimes() throws Exception {
-        final ContentResponse response = client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
-        assertThat(response.getStatus())
-                .isEqualTo(200);
+  @Test
+  void instrumentsConnectionTimes() throws Exception {
+    final ContentResponse response =
+        client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
+    assertThat(response.getStatus()).isEqualTo(200);
 
-        client.stop(); // close the connection
+    client.stop(); // close the connection
 
-        Thread.sleep(100); // make sure the connection is closed
+    Thread.sleep(100); // make sure the connection is closed
 
-        final Timer timer = registry.timer(MetricRegistry.name("http.connections"));
-        assertThat(timer.getCount())
-                .isEqualTo(1);
-    }
+    final Timer timer = registry.timer(MetricRegistry.name("http.connections"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void instrumentsActiveConnections() throws Exception {
-        final Counter counter = registry.counter("http.active-connections");
+  @Test
+  void instrumentsActiveConnections() throws Exception {
+    final Counter counter = registry.counter("http.active-connections");
 
-        final ContentResponse response = client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
-        assertThat(response.getStatus())
-                .isEqualTo(200);
+    final ContentResponse response =
+        client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
+    assertThat(response.getStatus()).isEqualTo(200);
 
-        assertThat(counter.getCount())
-                .isEqualTo(1);
+    assertThat(counter.getCount()).isEqualTo(1);
 
-        client.stop(); // close the connection
+    client.stop(); // close the connection
 
-        Thread.sleep(100); // make sure the connection is closed
+    Thread.sleep(100); // make sure the connection is closed
 
-        assertThat(counter.getCount())
-                .isEqualTo(0);
-    }
+    assertThat(counter.getCount()).isEqualTo(0);
+  }
 }
--- a/metrics-jetty10/src/test/java/io/dropwizard/metrics5/jetty10/InstrumentedHandlerTest.java
+++ b/metrics-jetty10/src/test/java/io/dropwizard/metrics5/jetty10/InstrumentedHandlerTest.java
@@ -1,7 +1,22 @@
 package io.dropwizard.metrics5.jetty10;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.AssertionsForClassTypes.assertThatCode;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import javax.servlet.AsyncContext;
+import javax.servlet.ServletException;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.WriteListener;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import org.eclipse.jetty.client.HttpClient;
 import org.eclipse.jetty.client.api.ContentResponse;
 import org.eclipse.jetty.server.Request;
@@ -13,234 +28,221 @@ import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.ServletException;
-import javax.servlet.ServletOutputStream;
-import javax.servlet.WriteListener;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.AssertionsForClassTypes.assertThatCode;
-
-class InstrumentedHandlerTest {
-    private final HttpClient client = new HttpClient();
-    private final MetricRegistry registry = new MetricRegistry();
-    private final Server server = new Server();
-    private final ServerConnector connector = new ServerConnector(server);
-    private final InstrumentedHandler handler = new InstrumentedHandler(registry, null, ALL);
-
-    @BeforeEach
-    void setUp() throws Exception {
-        handler.setName("handler");
-        handler.setHandler(new TestHandler());
-        server.addConnector(connector);
-        server.setHandler(handler);
-        server.start();
-        client.start();
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        server.stop();
-        client.stop();
-    }
-
-    @Test
-    void hasAName() throws Exception {
-        assertThat(handler.getName())
-                .isEqualTo("handler");
-    }
-
-    @Test
-    void createsAndRemovesMetricsForTheHandler() throws Exception {
-        final ContentResponse response = client.GET(uri("/hello"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(404);
-
-        assertThat(registry.getNames())
-                .containsOnly(
-                        MetricRegistry.name(TestHandler.class, "handler.1xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.2xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.3xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.4xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.404-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.5xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-1m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-5m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-15m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-1m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-5m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-15m"),
-                        MetricRegistry.name(TestHandler.class, "handler.requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-suspended"),
-                        MetricRegistry.name(TestHandler.class, "handler.async-dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.async-timeouts"),
-                        MetricRegistry.name(TestHandler.class, "handler.get-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.put-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.trace-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.other-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.connect-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.head-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.post-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.options-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.delete-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.move-requests")
-                );
-
-        server.stop();
-
-        assertThat(registry.getNames())
-                .isEmpty();
-    }
-
-    @Test
-    void responseTimesAreRecordedForBlockingResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/blocking"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-
-        assertResponseTimesValid();
-    }
-
-    @Test
-    void doStopDoesNotThrowNPE() throws Exception {
-        InstrumentedHandler handler = new InstrumentedHandler(registry, null, ALL);
-        handler.setHandler(new TestHandler());
-
-        assertThatCode(handler::doStop).doesNotThrowAnyException();
-    }
-
-    @Test
-    public void gaugesAreRegisteredWithResponseMeteredLevelCoarse() throws Exception {
-        InstrumentedHandler handler = new InstrumentedHandler(registry, "coarse", COARSE);
-        handler.setHandler(new TestHandler());
-        handler.setName("handler");
-        handler.doStart();
-        assertThat(registry.getGauges()).containsKey(MetricName.build("coarse", "handler", "percent-4xx-1m"));
-    }
-
-    @Test
-    public void gaugesAreNotRegisteredWithResponseMeteredLevelDetailed() throws Exception {
-        InstrumentedHandler handler = new InstrumentedHandler(registry, "detailed", DETAILED);
-        handler.setHandler(new TestHandler());
-        handler.setName("handler");
-        handler.doStart();
-        assertThat(registry.getGauges()).doesNotContainKey(MetricName.build("detailed", "handler", "percent-4xx-1m"));
-    }
-
-    @Test
-    @Disabled("flaky on virtual machines")
-    void responseTimesAreRecordedForAsyncResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/async"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-
-        assertResponseTimesValid();
-    }
-
-    private void assertResponseTimesValid() {
-        assertThat(registry.getMeters().get(metricName().resolve("200-responses"))
-                .getCount()).isGreaterThan(0L);
-
-
-        assertThat(registry.getTimers().get(metricName().resolve("get-requests"))
-                .getSnapshot().getMedian()).isGreaterThan(0.0).isLessThan(TimeUnit.SECONDS.toNanos(1));
-
-        assertThat(registry.getTimers().get(metricName().resolve("requests"))
-                .getSnapshot().getMedian()).isGreaterThan(0.0).isLessThan(TimeUnit.SECONDS.toNanos(1));
-    }
-
-    private String uri(String path) {
-        return "http://localhost:" + connector.getLocalPort() + path;
-    }
-
-    private MetricName metricName() {
-        return MetricRegistry.name(TestHandler.class.getName(), "handler");
-    }
-
-    /**
-     * test handler.
-     * <p>
-     * Supports
-     * <p>
-     * /blocking - uses the standard servlet api
-     * /async - uses the 3.1 async api to complete the request
-     * <p>
-     * all other requests will return 404
-     */
-    private static class TestHandler extends AbstractHandler {
-        @Override
-        public void handle(
-                String path,
-                Request request,
-                final HttpServletRequest httpServletRequest,
-                final HttpServletResponse httpServletResponse
-        ) throws IOException, ServletException {
-            switch (path) {
-                case "/blocking":
-                    request.setHandled(true);
+final class InstrumentedHandlerTest {
+  private final HttpClient client = new HttpClient();
+  private final MetricRegistry registry = new MetricRegistry();
+  private final Server server = new Server();
+  private final ServerConnector connector = new ServerConnector(server);
+  private final InstrumentedHandler handler = new InstrumentedHandler(registry, null, ALL);
+
+  @BeforeEach
+  void setUp() throws Exception {
+    handler.setName("handler");
+    handler.setHandler(new TestHandler());
+    server.addConnector(connector);
+    server.setHandler(handler);
+    server.start();
+    client.start();
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    server.stop();
+    client.stop();
+  }
+
+  @Test
+  void hasAName() throws Exception {
+    assertThat(handler.getName()).isEqualTo("handler");
+  }
+
+  @Test
+  void createsAndRemovesMetricsForTheHandler() throws Exception {
+    final ContentResponse response = client.GET(uri("/hello"));
+
+    assertThat(response.getStatus()).isEqualTo(404);
+
+    assertThat(registry.getNames())
+        .containsOnly(
+            MetricRegistry.name(TestHandler.class, "handler.1xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.2xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.3xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.4xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.404-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.5xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-1m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-5m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-15m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-1m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-5m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-15m"),
+            MetricRegistry.name(TestHandler.class, "handler.requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-suspended"),
+            MetricRegistry.name(TestHandler.class, "handler.async-dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.async-timeouts"),
+            MetricRegistry.name(TestHandler.class, "handler.get-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.put-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.trace-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.other-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.connect-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.head-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.post-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.options-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.delete-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.move-requests"));
+
+    server.stop();
+
+    assertThat(registry.getNames()).isEmpty();
+  }
+
+  @Test
+  void responseTimesAreRecordedForBlockingResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/blocking"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+
+    assertResponseTimesValid();
+  }
+
+  @Test
+  void doStopDoesNotThrowNPE() throws Exception {
+    InstrumentedHandler handler = new InstrumentedHandler(registry, null, ALL);
+    handler.setHandler(new TestHandler());
+
+    assertThatCode(handler::doStop).doesNotThrowAnyException();
+  }
+
+  @Test
+  void gaugesAreRegisteredWithResponseMeteredLevelCoarse() throws Exception {
+    InstrumentedHandler handler = new InstrumentedHandler(registry, "coarse", COARSE);
+    handler.setHandler(new TestHandler());
+    handler.setName("handler");
+    handler.doStart();
+    assertThat(registry.getGauges())
+        .containsKey(MetricName.build("coarse", "handler", "percent-4xx-1m"));
+  }
+
+  @Test
+  void gaugesAreNotRegisteredWithResponseMeteredLevelDetailed() throws Exception {
+    InstrumentedHandler handler = new InstrumentedHandler(registry, "detailed", DETAILED);
+    handler.setHandler(new TestHandler());
+    handler.setName("handler");
+    handler.doStart();
+    assertThat(registry.getGauges())
+        .doesNotContainKey(MetricName.build("detailed", "handler", "percent-4xx-1m"));
+  }
+
+  @Disabled("flaky on virtual machines")
+  @Test
+  void responseTimesAreRecordedForAsyncResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/async"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+
+    assertResponseTimesValid();
+  }
+
+  private void assertResponseTimesValid() {
+    assertThat(registry.getMeters().get(metricName().resolve("200-responses")).getCount())
+        .isPositive();
+
+    assertThat(
+            registry
+                .getTimers()
+                .get(metricName().resolve("get-requests"))
+                .getSnapshot()
+                .getMedian())
+        .isPositive()
+        .isLessThan(TimeUnit.SECONDS.toNanos(1));
+
+    assertThat(registry.getTimers().get(metricName().resolve("requests")).getSnapshot().getMedian())
+        .isPositive()
+        .isLessThan(TimeUnit.SECONDS.toNanos(1));
+  }
+
+  private String uri(String path) {
+    return "http://localhost:" + connector.getLocalPort() + path;
+  }
+
+  private MetricName metricName() {
+    return MetricRegistry.name(TestHandler.class.getName(), "handler");
+  }
+
+  /**
+   * test handler.
+   *
+   * <p>Supports
+   *
+   * <p>/blocking - uses the standard servlet api /async - uses the 3.1 async api to complete the
+   * request
+   *
+   * <p>all other requests will return 404
+   */
+  private static class TestHandler extends AbstractHandler {
+    @Override
+    public void handle(
+        String path,
+        Request request,
+        final HttpServletRequest httpServletRequest,
+        final HttpServletResponse httpServletResponse)
+        throws IOException, ServletException {
+      switch (path) {
+        case "/blocking":
+          request.setHandled(true);
+          try {
+            Thread.sleep(100);
+          } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+          }
+          httpServletResponse.setStatus(200);
+          httpServletResponse.setContentType("text/plain");
+          httpServletResponse.getWriter().write("some content from the blocking request\n");
+          break;
+        case "/async":
+          request.setHandled(true);
+          final AsyncContext context = request.startAsync();
+          Thread t =
+              new Thread(
+                  () -> {
                     try {
-                        Thread.sleep(100);
+                      Thread.sleep(100);
                     } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
+                      Thread.currentThread().interrupt();
                     }
                     httpServletResponse.setStatus(200);
                     httpServletResponse.setContentType("text/plain");
-                    httpServletResponse.getWriter().write("some content from the blocking request\n");
-                    break;
-                case "/async":
-                    request.setHandled(true);
-                    final AsyncContext context = request.startAsync();
-                    Thread t = new Thread(() -> {
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e) {
-                            Thread.currentThread().interrupt();
-                        }
-                        httpServletResponse.setStatus(200);
-                        httpServletResponse.setContentType("text/plain");
-                        final ServletOutputStream servletOutputStream;
-                        try {
-                            servletOutputStream = httpServletResponse.getOutputStream();
-                            servletOutputStream.setWriteListener(
-                                    new WriteListener() {
-                                        @Override
-                                        public void onWritePossible() throws IOException {
-                                            servletOutputStream.write("some content from the async\n"
-                                                    .getBytes(StandardCharsets.UTF_8));
-                                            context.complete();
-                                        }
-
-                                        @Override
-                                        public void onError(Throwable throwable) {
-                                            context.complete();
-                                        }
-                                    }
-                            );
-                        } catch (IOException e) {
-                            context.complete();
-                        }
-                    });
-                    t.start();
-                    break;
-                default:
-                    break;
-            }
-        }
+                    final ServletOutputStream servletOutputStream;
+                    try {
+                      servletOutputStream = httpServletResponse.getOutputStream();
+                      servletOutputStream.setWriteListener(
+                          new WriteListener() {
+                            @Override
+                            public void onWritePossible() throws IOException {
+                              servletOutputStream.write(
+                                  "some content from the async\n".getBytes(UTF_8));
+                              context.complete();
+                            }
+
+                            @Override
+                            public void onError(Throwable throwable) {
+                              context.complete();
+                            }
+                          });
+                    } catch (IOException e) {
+                      context.complete();
+                    }
+                  });
+          t.start();
+          break;
+        default:
+          break;
+      }
     }
+  }
 }
--- a/metrics-jetty10/src/test/java/io/dropwizard/metrics5/jetty10/InstrumentedHttpChannelListenerTest.java
+++ b/metrics-jetty10/src/test/java/io/dropwizard/metrics5/jetty10/InstrumentedHttpChannelListenerTest.java
@@ -1,7 +1,17 @@
 package io.dropwizard.metrics5.jetty10;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
+import java.io.IOException;
+import javax.servlet.AsyncContext;
+import javax.servlet.ServletOutputStream;
+import javax.servlet.WriteListener;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import org.eclipse.jetty.client.HttpClient;
 import org.eclipse.jetty.client.api.ContentResponse;
 import org.eclipse.jetty.server.Request;
@@ -12,202 +22,190 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import javax.servlet.AsyncContext;
-import javax.servlet.ServletOutputStream;
-import javax.servlet.WriteListener;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static org.assertj.core.api.Assertions.assertThat;
-
-class InstrumentedHttpChannelListenerTest {
-    private final HttpClient client = new HttpClient();
-    private final Server server = new Server();
-    private final ServerConnector connector = new ServerConnector(server);
-    private final TestHandler handler = new TestHandler();
-    private MetricRegistry registry;
-
-    @BeforeEach
-    void setUp() throws Exception {
-        registry = new MetricRegistry();
-        connector.addBean(new InstrumentedHttpChannelListener(registry, MetricRegistry.name(TestHandler.class, "handler"), ALL));
-        server.addConnector(connector);
-        server.setHandler(handler);
-        server.start();
-        client.start();
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        server.stop();
-        client.stop();
-    }
-
-    @Test
-    void createsMetricsForTheHandler() throws Exception {
-        final ContentResponse response = client.GET(uri("/hello"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(404);
-
-        assertThat(registry.getNames())
-                .containsOnly(
-                        metricName("1xx-responses"),
-                        metricName("2xx-responses"),
-                        metricName("3xx-responses"),
-                        metricName("404-responses"),
-                        metricName("4xx-responses"),
-                        metricName("5xx-responses"),
-                        metricName("percent-4xx-1m"),
-                        metricName("percent-4xx-5m"),
-                        metricName("percent-4xx-15m"),
-                        metricName("percent-5xx-1m"),
-                        metricName("percent-5xx-5m"),
-                        metricName("percent-5xx-15m"),
-                        metricName("requests"),
-                        metricName("active-suspended"),
-                        metricName("async-dispatches"),
-                        metricName("async-timeouts"),
-                        metricName("get-requests"),
-                        metricName("put-requests"),
-                        metricName("active-dispatches"),
-                        metricName("trace-requests"),
-                        metricName("other-requests"),
-                        metricName("connect-requests"),
-                        metricName("dispatches"),
-                        metricName("head-requests"),
-                        metricName("post-requests"),
-                        metricName("options-requests"),
-                        metricName("active-requests"),
-                        metricName("delete-requests"),
-                        metricName("move-requests")
-                );
+final class InstrumentedHttpChannelListenerTest {
+  private final HttpClient client = new HttpClient();
+  private final Server server = new Server();
+  private final ServerConnector connector = new ServerConnector(server);
+  private final TestHandler handler = new TestHandler();
+  private MetricRegistry registry;
+
+  @BeforeEach
+  void setUp() throws Exception {
+    registry = new MetricRegistry();
+    connector.addBean(
+        new InstrumentedHttpChannelListener(
+            registry, MetricRegistry.name(TestHandler.class, "handler"), ALL));
+    server.addConnector(connector);
+    server.setHandler(handler);
+    server.start();
+    client.start();
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    server.stop();
+    client.stop();
+  }
+
+  @Test
+  void createsMetricsForTheHandler() throws Exception {
+    final ContentResponse response = client.GET(uri("/hello"));
+
+    assertThat(response.getStatus()).isEqualTo(404);
+
+    assertThat(registry.getNames())
+        .containsOnly(
+            metricName("1xx-responses"),
+            metricName("2xx-responses"),
+            metricName("3xx-responses"),
+            metricName("404-responses"),
+            metricName("4xx-responses"),
+            metricName("5xx-responses"),
+            metricName("percent-4xx-1m"),
+            metricName("percent-4xx-5m"),
+            metricName("percent-4xx-15m"),
+            metricName("percent-5xx-1m"),
+            metricName("percent-5xx-5m"),
+            metricName("percent-5xx-15m"),
+            metricName("requests"),
+            metricName("active-suspended"),
+            metricName("async-dispatches"),
+            metricName("async-timeouts"),
+            metricName("get-requests"),
+            metricName("put-requests"),
+            metricName("active-dispatches"),
+            metricName("trace-requests"),
+            metricName("other-requests"),
+            metricName("connect-requests"),
+            metricName("dispatches"),
+            metricName("head-requests"),
+            metricName("post-requests"),
+            metricName("options-requests"),
+            metricName("active-requests"),
+            metricName("delete-requests"),
+            metricName("move-requests"));
+  }
+
+  @Test
+  void responseTimesAreRecordedForBlockingResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/blocking"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getMediaType()).isEqualTo("text/plain");
+    assertThat(response.getContentAsString()).isEqualTo("some content from the blocking request");
+
+    assertResponseTimesValid();
+  }
+
+  @Test
+  void responseTimesAreRecordedForAsyncResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/async"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getMediaType()).isEqualTo("text/plain");
+    assertThat(response.getContentAsString()).isEqualTo("some content from the async");
+
+    assertResponseTimesValid();
+  }
+
+  private void assertResponseTimesValid() {
+    try {
+      Thread.sleep(100);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
     }
 
-
-    @Test
-    void responseTimesAreRecordedForBlockingResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/blocking"));
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.getMediaType()).isEqualTo("text/plain");
-        assertThat(response.getContentAsString()).isEqualTo("some content from the blocking request");
-
-        assertResponseTimesValid();
-    }
-
-    @Test
-    void responseTimesAreRecordedForAsyncResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/async"));
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.getMediaType()).isEqualTo("text/plain");
-        assertThat(response.getContentAsString()).isEqualTo("some content from the async");
-
-        assertResponseTimesValid();
-    }
-
-    private void assertResponseTimesValid() {
-        try {
+    assertThat(registry.getMeters().get(metricName("2xx-responses")).getCount()).isPositive();
+    assertThat(registry.getMeters().get(metricName("200-responses")).getCount()).isPositive();
+
+    assertThat(registry.getTimers().get(metricName("get-requests")).getSnapshot().getMedian())
+        .isPositive();
+
+    assertThat(registry.getTimers().get(metricName("requests")).getSnapshot().getMedian())
+        .isPositive();
+  }
+
+  private String uri(String path) {
+    return "http://localhost:" + connector.getLocalPort() + path;
+  }
+
+  private MetricName metricName(String metricName) {
+    return MetricRegistry.name(TestHandler.class.getName(), "handler", metricName);
+  }
+
+  /**
+   * test handler.
+   *
+   * <p>Supports
+   *
+   * <p>/blocking - uses the standard servlet api /async - uses the 3.1 async api to complete the
+   * request
+   *
+   * <p>all other requests will return 404
+   */
+  private static class TestHandler extends AbstractHandler {
+    @Override
+    public void handle(
+        String path,
+        Request request,
+        final HttpServletRequest httpServletRequest,
+        final HttpServletResponse httpServletResponse)
+        throws IOException {
+      switch (path) {
+        case "/blocking":
+          request.setHandled(true);
+          httpServletResponse.setStatus(200);
+          httpServletResponse.setContentType("text/plain");
+          httpServletResponse.getWriter().write("some content from the blocking request");
+          try {
             Thread.sleep(100);
-        } catch (InterruptedException e) {
+          } catch (InterruptedException e) {
+            httpServletResponse.setStatus(500);
             Thread.currentThread().interrupt();
-        }
-
-        assertThat(registry.getMeters().get(metricName("2xx-responses"))
-                .getCount()).isPositive();
-        assertThat(registry.getMeters().get(metricName("200-responses"))
-                .getCount()).isPositive();
-
-        assertThat(registry.getTimers().get(metricName("get-requests"))
-                .getSnapshot().getMedian()).isPositive();
-
-        assertThat(registry.getTimers().get(metricName("requests"))
-                .getSnapshot().getMedian()).isPositive();
-    }
-
-    private String uri(String path) {
-        return "http://localhost:" + connector.getLocalPort() + path;
-    }
-
-    private MetricName metricName(String metricName) {
-        return MetricRegistry.name(TestHandler.class.getName(), "handler", metricName);
-    }
-
-    /**
-     * test handler.
-     * <p>
-     * Supports
-     * <p>
-     * /blocking - uses the standard servlet api
-     * /async - uses the 3.1 async api to complete the request
-     * <p>
-     * all other requests will return 404
-     */
-    private static class TestHandler extends AbstractHandler {
-        @Override
-        public void handle(
-                String path,
-                Request request,
-                final HttpServletRequest httpServletRequest,
-                final HttpServletResponse httpServletResponse) throws IOException {
-            switch (path) {
-                case "/blocking":
-                    request.setHandled(true);
+          }
+          break;
+        case "/async":
+          request.setHandled(true);
+          final AsyncContext context = request.startAsync();
+          Thread t =
+              new Thread(
+                  () -> {
                     httpServletResponse.setStatus(200);
                     httpServletResponse.setContentType("text/plain");
-                    httpServletResponse.getWriter().write("some content from the blocking request");
                     try {
-                        Thread.sleep(100);
+                      Thread.sleep(100);
                     } catch (InterruptedException e) {
-                        httpServletResponse.setStatus(500);
-                        Thread.currentThread().interrupt();
+                      httpServletResponse.setStatus(500);
+                      Thread.currentThread().interrupt();
+                    }
+                    final ServletOutputStream servletOutputStream;
+                    try {
+                      servletOutputStream = httpServletResponse.getOutputStream();
+                      servletOutputStream.setWriteListener(
+                          new WriteListener() {
+                            @Override
+                            public void onWritePossible() throws IOException {
+                              servletOutputStream.write(
+                                  "some content from the async".getBytes(UTF_8));
+                              context.complete();
+                            }
+
+                            @Override
+                            public void onError(Throwable throwable) {
+                              context.complete();
+                            }
+                          });
+                    } catch (IOException e) {
+                      context.complete();
                     }
-                    break;
-                case "/async":
-                    request.setHandled(true);
-                    final AsyncContext context = request.startAsync();
-                    Thread t = new Thread(() -> {
-                        httpServletResponse.setStatus(200);
-                        httpServletResponse.setContentType("text/plain");
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e) {
-                            httpServletResponse.setStatus(500);
-                            Thread.currentThread().interrupt();
-                        }
-                        final ServletOutputStream servletOutputStream;
-                        try {
-                            servletOutputStream = httpServletResponse.getOutputStream();
-                            servletOutputStream.setWriteListener(
-                                    new WriteListener() {
-                                        @Override
-                                        public void onWritePossible() throws IOException {
-                                            servletOutputStream.write("some content from the async"
-                                                    .getBytes(StandardCharsets.UTF_8));
-                                            context.complete();
-                                        }
-
-                                        @Override
-                                        public void onError(Throwable throwable) {
-                                            context.complete();
-                                        }
-                                    }
-                            );
-                        } catch (IOException e) {
-                            context.complete();
-                        }
-                    });
-                    t.start();
-                    break;
-                default:
-                    break;
-            }
-        }
+                  });
+          t.start();
+          break;
+        default:
+          break;
+      }
     }
+  }
 }
--- a/metrics-jetty10/src/test/java/io/dropwizard/metrics5/jetty10/InstrumentedQueuedThreadPoolTest.java
+++ b/metrics-jetty10/src/test/java/io/dropwizard/metrics5/jetty10/InstrumentedQueuedThreadPoolTest.java
@@ -1,52 +1,52 @@
 package io.dropwizard.metrics5.jetty10;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class InstrumentedQueuedThreadPoolTest {
-    private static final String PREFIX = "prefix";
-
-    private MetricRegistry metricRegistry;
-    private InstrumentedQueuedThreadPool iqtp;
-
-    @BeforeEach
-    void setUp() {
-        metricRegistry = new MetricRegistry();
-        iqtp = new InstrumentedQueuedThreadPool(metricRegistry);
-    }
-
-    @Test
-    void customMetricsPrefix() throws Exception {
-        iqtp.setPrefix(PREFIX);
-        iqtp.start();
-
-        assertThat(metricRegistry.getNames())
-                .extracting(MetricName::getKey)
-                .overridingErrorMessage("Custom metrics prefix doesn't match")
-                .allSatisfy(name -> assertThat(name).startsWith(PREFIX));
-
-        iqtp.stop();
-        assertThat(metricRegistry.getMetrics())
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .isEmpty();
-    }
-
-    @Test
-    void metricsPrefixBackwardCompatible() throws Exception {
-        iqtp.start();
-        assertThat(metricRegistry.getNames())
-                .extracting(MetricName::getKey)
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .allSatisfy(name -> assertThat(name).startsWith(QueuedThreadPool.class.getName()));
-
-        iqtp.stop();
-        assertThat(metricRegistry.getMetrics())
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .isEmpty();
-    }
+final class InstrumentedQueuedThreadPoolTest {
+  private static final String PREFIX = "prefix";
+
+  private MetricRegistry metricRegistry;
+  private InstrumentedQueuedThreadPool iqtp;
+
+  @BeforeEach
+  void setUp() {
+    metricRegistry = new MetricRegistry();
+    iqtp = new InstrumentedQueuedThreadPool(metricRegistry);
+  }
+
+  @Test
+  void customMetricsPrefix() throws Exception {
+    iqtp.setPrefix(PREFIX);
+    iqtp.start();
+
+    assertThat(metricRegistry.getNames())
+        .extracting(MetricName::getKey)
+        .overridingErrorMessage("Custom metrics prefix doesn't match")
+        .allSatisfy(name -> assertThat(name).startsWith(PREFIX));
+
+    iqtp.stop();
+    assertThat(metricRegistry.getMetrics())
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .isEmpty();
+  }
+
+  @Test
+  void metricsPrefixBackwardCompatible() throws Exception {
+    iqtp.start();
+    assertThat(metricRegistry.getNames())
+        .extracting(MetricName::getKey)
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .allSatisfy(name -> assertThat(name).startsWith(QueuedThreadPool.class.getName()));
+
+    iqtp.stop();
+    assertThat(metricRegistry.getMetrics())
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .isEmpty();
+  }
 }
--- a/metrics-jetty11/src/main/java/io/dropwizard/metrics5/jetty11/InstrumentedConnectionFactory.java
+++ b/metrics-jetty11/src/main/java/io/dropwizard/metrics5/jetty11/InstrumentedConnectionFactory.java
@@ -2,62 +2,63 @@ package io.dropwizard.metrics5.jetty11;
 
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Timer;
+import java.util.List;
 import org.eclipse.jetty.io.Connection;
 import org.eclipse.jetty.io.EndPoint;
 import org.eclipse.jetty.server.ConnectionFactory;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.util.component.ContainerLifeCycle;
 
-import java.util.List;
-
 public class InstrumentedConnectionFactory extends ContainerLifeCycle implements ConnectionFactory {
-    private final ConnectionFactory connectionFactory;
-    private final Timer timer;
-    private final Counter counter;
-
-    public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer) {
-        this(connectionFactory, timer, null);
-    }
-
-    public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer, Counter counter) {
-        this.connectionFactory = connectionFactory;
-        this.timer = timer;
-        this.counter = counter;
-        addBean(connectionFactory);
-    }
-
-    @Override
-    public String getProtocol() {
-        return connectionFactory.getProtocol();
-    }
-
-    @Override
-    public List<String> getProtocols() {
-        return connectionFactory.getProtocols();
-    }
-
-    @Override
-    public Connection newConnection(Connector connector, EndPoint endPoint) {
-        final Connection connection = connectionFactory.newConnection(connector, endPoint);
-        connection.addEventListener(new Connection.Listener() {
-            private Timer.Context context;
-
-            @Override
-            public void onOpened(Connection connection) {
-                this.context = timer.time();
-                if (counter != null) {
-                    counter.inc();
-                }
+  private final ConnectionFactory connectionFactory;
+  private final Timer timer;
+  private final Counter counter;
+
+  public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer) {
+    this(connectionFactory, timer, null);
+  }
+
+  public InstrumentedConnectionFactory(
+      ConnectionFactory connectionFactory, Timer timer, Counter counter) {
+    this.connectionFactory = connectionFactory;
+    this.timer = timer;
+    this.counter = counter;
+    addBean(connectionFactory);
+  }
+
+  @Override
+  public String getProtocol() {
+    return connectionFactory.getProtocol();
+  }
+
+  @Override
+  public List<String> getProtocols() {
+    return connectionFactory.getProtocols();
+  }
+
+  @Override
+  public Connection newConnection(Connector connector, EndPoint endPoint) {
+    final Connection connection = connectionFactory.newConnection(connector, endPoint);
+    connection.addEventListener(
+        new Connection.Listener() {
+          private Timer.Context context;
+
+          @Override
+          public void onOpened(Connection connection) {
+            this.context = timer.time();
+            if (counter != null) {
+              counter.inc();
             }
+          }
 
-            @Override
-            public void onClosed(Connection connection) {
-                context.stop();
-                if (counter != null) {
-                    counter.dec();
-                }
+          @Override
+          public void onClosed(Connection connection) {
+            context.stop();
+            if (counter != null) {
+              counter.dec();
             }
+          }
         });
-        return connection;
-    }
+    return connection;
+  }
 }
--- a/metrics-jetty11/src/main/java/io/dropwizard/metrics5/jetty11/InstrumentedHandler.java
+++ b/metrics-jetty11/src/main/java/io/dropwizard/metrics5/jetty11/InstrumentedHandler.java
@@ -1,5 +1,13 @@
 package io.dropwizard.metrics5.jetty11;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.util.Collections.unmodifiableList;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricName;
@@ -12,433 +20,444 @@ import jakarta.servlet.AsyncListener;
 import jakarta.servlet.ServletException;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
-import org.eclipse.jetty.http.HttpMethod;
-import org.eclipse.jetty.server.AsyncContextState;
-import org.eclipse.jetty.server.Handler;
-import org.eclipse.jetty.server.HttpChannelState;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.HandlerWrapper;
-
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import org.eclipse.jetty.http.HttpMethod;
+import org.eclipse.jetty.server.AsyncContextState;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.HttpChannelState;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.HandlerWrapper;
 
 /**
  * A Jetty {@link Handler} which records various metrics about an underlying {@link Handler}
  * instance.
  */
 public class InstrumentedHandler extends HandlerWrapper {
-    private static final String NAME_REQUESTS = "requests";
-    private static final String NAME_DISPATCHES = "dispatches";
-    private static final String NAME_ACTIVE_REQUESTS = "active-requests";
-    private static final String NAME_ACTIVE_DISPATCHES = "active-dispatches";
-    private static final String NAME_ACTIVE_SUSPENDED = "active-suspended";
-    private static final String NAME_ASYNC_DISPATCHES = "async-dispatches";
-    private static final String NAME_ASYNC_TIMEOUTS = "async-timeouts";
-    private static final String NAME_1XX_RESPONSES = "1xx-responses";
-    private static final String NAME_2XX_RESPONSES = "2xx-responses";
-    private static final String NAME_3XX_RESPONSES = "3xx-responses";
-    private static final String NAME_4XX_RESPONSES = "4xx-responses";
-    private static final String NAME_5XX_RESPONSES = "5xx-responses";
-    private static final String NAME_GET_REQUESTS = "get-requests";
-    private static final String NAME_POST_REQUESTS = "post-requests";
-    private static final String NAME_HEAD_REQUESTS = "head-requests";
-    private static final String NAME_PUT_REQUESTS = "put-requests";
-    private static final String NAME_DELETE_REQUESTS = "delete-requests";
-    private static final String NAME_OPTIONS_REQUESTS = "options-requests";
-    private static final String NAME_TRACE_REQUESTS = "trace-requests";
-    private static final String NAME_CONNECT_REQUESTS = "connect-requests";
-    private static final String NAME_MOVE_REQUESTS = "move-requests";
-    private static final String NAME_OTHER_REQUESTS = "other-requests";
-    private static final String NAME_PERCENT_4XX_1M = "percent-4xx-1m";
-    private static final String NAME_PERCENT_4XX_5M = "percent-4xx-5m";
-    private static final String NAME_PERCENT_4XX_15M = "percent-4xx-15m";
-    private static final String NAME_PERCENT_5XX_1M = "percent-5xx-1m";
-    private static final String NAME_PERCENT_5XX_5M = "percent-5xx-5m";
-    private static final String NAME_PERCENT_5XX_15M = "percent-5xx-15m";
-    private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
-    private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
-
-    private final MetricRegistry metricRegistry;
-
-    private String name;
-    private final String prefix;
-
-    // the requests handled by this handler, excluding active
-    private Timer requests;
-
-    // the number of dispatches seen by this handler, excluding active
-    private Timer dispatches;
-
-    // the number of active requests
-    private Counter activeRequests;
-
-    // the number of active dispatches
-    private Counter activeDispatches;
-
-    // the number of requests currently suspended.
-    private Counter activeSuspended;
-
-    // the number of requests that have been asynchronously dispatched
-    private Meter asyncDispatches;
-
-    // the number of requests that expired while suspended
-    private Meter asyncTimeouts;
-
-    private final ResponseMeteredLevel responseMeteredLevel;
-    private List<Meter> responses;
-    private Map<Integer, Meter> responseCodeMeters;
-
-    private Timer getRequests;
-    private Timer postRequests;
-    private Timer headRequests;
-    private Timer putRequests;
-    private Timer deleteRequests;
-    private Timer optionsRequests;
-    private Timer traceRequests;
-    private Timer connectRequests;
-    private Timer moveRequests;
-    private Timer otherRequests;
-
-    private AsyncListener listener;
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     */
-    public InstrumentedHandler(MetricRegistry registry) {
-        this(registry, null);
+  private static final String NAME_REQUESTS = "requests";
+  private static final String NAME_DISPATCHES = "dispatches";
+  private static final String NAME_ACTIVE_REQUESTS = "active-requests";
+  private static final String NAME_ACTIVE_DISPATCHES = "active-dispatches";
+  private static final String NAME_ACTIVE_SUSPENDED = "active-suspended";
+  private static final String NAME_ASYNC_DISPATCHES = "async-dispatches";
+  private static final String NAME_ASYNC_TIMEOUTS = "async-timeouts";
+  private static final String NAME_1XX_RESPONSES = "1xx-responses";
+  private static final String NAME_2XX_RESPONSES = "2xx-responses";
+  private static final String NAME_3XX_RESPONSES = "3xx-responses";
+  private static final String NAME_4XX_RESPONSES = "4xx-responses";
+  private static final String NAME_5XX_RESPONSES = "5xx-responses";
+  private static final String NAME_GET_REQUESTS = "get-requests";
+  private static final String NAME_POST_REQUESTS = "post-requests";
+  private static final String NAME_HEAD_REQUESTS = "head-requests";
+  private static final String NAME_PUT_REQUESTS = "put-requests";
+  private static final String NAME_DELETE_REQUESTS = "delete-requests";
+  private static final String NAME_OPTIONS_REQUESTS = "options-requests";
+  private static final String NAME_TRACE_REQUESTS = "trace-requests";
+  private static final String NAME_CONNECT_REQUESTS = "connect-requests";
+  private static final String NAME_MOVE_REQUESTS = "move-requests";
+  private static final String NAME_OTHER_REQUESTS = "other-requests";
+  private static final String NAME_PERCENT_4XX_1M = "percent-4xx-1m";
+  private static final String NAME_PERCENT_4XX_5M = "percent-4xx-5m";
+  private static final String NAME_PERCENT_4XX_15M = "percent-4xx-15m";
+  private static final String NAME_PERCENT_5XX_1M = "percent-5xx-1m";
+  private static final String NAME_PERCENT_5XX_5M = "percent-5xx-5m";
+  private static final String NAME_PERCENT_5XX_15M = "percent-5xx-15m";
+  private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
+  private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
+
+  private final MetricRegistry metricRegistry;
+
+  private String name;
+  private final String prefix;
+
+  // the requests handled by this handler, excluding active
+  private Timer requests;
+
+  // the number of dispatches seen by this handler, excluding active
+  private Timer dispatches;
+
+  // the number of active requests
+  private Counter activeRequests;
+
+  // the number of active dispatches
+  private Counter activeDispatches;
+
+  // the number of requests currently suspended.
+  private Counter activeSuspended;
+
+  // the number of requests that have been asynchronously dispatched
+  private Meter asyncDispatches;
+
+  // the number of requests that expired while suspended
+  private Meter asyncTimeouts;
+
+  private final ResponseMeteredLevel responseMeteredLevel;
+  private List<Meter> responses;
+  private Map<Integer, Meter> responseCodeMeters;
+
+  private Timer getRequests;
+  private Timer postRequests;
+  private Timer headRequests;
+  private Timer putRequests;
+  private Timer deleteRequests;
+  private Timer optionsRequests;
+  private Timer traceRequests;
+  private Timer connectRequests;
+  private Timer moveRequests;
+  private Timer otherRequests;
+
+  private AsyncListener listener;
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   */
+  public InstrumentedHandler(MetricRegistry registry) {
+    this(registry, null);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param prefix the prefix to use for the metrics names
+   */
+  public InstrumentedHandler(MetricRegistry registry, String prefix) {
+    this(registry, prefix, COARSE);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param prefix the prefix to use for the metrics names
+   * @param responseMeteredLevel the level to determine individual/aggregate response codes that are
+   *     instrumented
+   */
+  public InstrumentedHandler(
+      MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
+    this.responseMeteredLevel = responseMeteredLevel;
+    this.metricRegistry = registry;
+    this.prefix = prefix;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  @Override
+  protected void doStart() throws Exception {
+    super.doStart();
+
+    final MetricName prefix = getMetricPrefix();
+
+    this.requests = metricRegistry.timer(prefix.resolve(NAME_REQUESTS));
+    this.dispatches = metricRegistry.timer(prefix.resolve(NAME_DISPATCHES));
+
+    this.activeRequests = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_REQUESTS));
+    this.activeDispatches = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_DISPATCHES));
+    this.activeSuspended = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_SUSPENDED));
+
+    this.asyncDispatches = metricRegistry.meter(prefix.resolve(NAME_ASYNC_DISPATCHES));
+    this.asyncTimeouts = metricRegistry.meter(prefix.resolve(NAME_ASYNC_TIMEOUTS));
+
+    this.responseCodeMeters =
+        DETAILED_METER_LEVELS.contains(responseMeteredLevel)
+            ? new ConcurrentHashMap<>()
+            : ImmutableMap.of();
+
+    this.getRequests = metricRegistry.timer(prefix.resolve(NAME_GET_REQUESTS));
+    this.postRequests = metricRegistry.timer(prefix.resolve(NAME_POST_REQUESTS));
+    this.headRequests = metricRegistry.timer(prefix.resolve(NAME_HEAD_REQUESTS));
+    this.putRequests = metricRegistry.timer(prefix.resolve(NAME_PUT_REQUESTS));
+    this.deleteRequests = metricRegistry.timer(prefix.resolve(NAME_DELETE_REQUESTS));
+    this.optionsRequests = metricRegistry.timer(prefix.resolve(NAME_OPTIONS_REQUESTS));
+    this.traceRequests = metricRegistry.timer(prefix.resolve(NAME_TRACE_REQUESTS));
+    this.connectRequests = metricRegistry.timer(prefix.resolve(NAME_CONNECT_REQUESTS));
+    this.moveRequests = metricRegistry.timer(prefix.resolve(NAME_MOVE_REQUESTS));
+    this.otherRequests = metricRegistry.timer(prefix.resolve(NAME_OTHER_REQUESTS));
+
+    if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
+      this.responses =
+          unmodifiableList(
+              Arrays.asList(
+                  metricRegistry.meter(prefix.resolve(NAME_1XX_RESPONSES)), // 1xx
+                  metricRegistry.meter(prefix.resolve(NAME_2XX_RESPONSES)), // 2xx
+                  metricRegistry.meter(prefix.resolve(NAME_3XX_RESPONSES)), // 3xx
+                  metricRegistry.meter(prefix.resolve(NAME_4XX_RESPONSES)), // 4xx
+                  metricRegistry.meter(prefix.resolve(NAME_5XX_RESPONSES)) // 5xx
+                  ));
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_1M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(3).getOneMinuteRate(), requests.getOneMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_5M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(3).getFiveMinuteRate(), requests.getFiveMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_15M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(
+                  responses.get(3).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_1M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(4).getOneMinuteRate(), requests.getOneMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_5M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(4).getFiveMinuteRate(), requests.getFiveMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_15M),
+          new RatioGauge() {
+            @Override
+            public Ratio getRatio() {
+              return Ratio.of(
+                  responses.get(4).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+            }
+          });
+    } else {
+      this.responses = ImmutableList.of();
     }
 
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param prefix   the prefix to use for the metrics names
-     */
-    public InstrumentedHandler(MetricRegistry registry, String prefix) {
-        this(registry, prefix, COARSE);
+    this.listener = new AsyncAttachingListener();
+  }
+
+  @Override
+  protected void doStop() throws Exception {
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.remove(prefix.resolve(NAME_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_SUSPENDED));
+    metricRegistry.remove(prefix.resolve(NAME_ASYNC_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ASYNC_TIMEOUTS));
+    metricRegistry.remove(prefix.resolve(NAME_1XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_2XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_3XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_4XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_5XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_GET_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_POST_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_HEAD_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_PUT_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_DELETE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_OPTIONS_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_TRACE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_CONNECT_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_MOVE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_OTHER_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_1M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_5M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_15M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_1M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_5M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_15M));
+
+    if (responseCodeMeters != null) {
+      responseCodeMeters.keySet().stream()
+          .map(sc -> getMetricPrefix().resolve(String.format("%d-responses", sc)))
+          .forEach(metricRegistry::remove);
     }
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param prefix   the prefix to use for the metrics names
-     * @param responseMeteredLevel the level to determine individual/aggregate response codes that are instrumented
-     */
-    public InstrumentedHandler(MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
-        this.responseMeteredLevel = responseMeteredLevel;
-        this.metricRegistry = registry;
-        this.prefix = prefix;
+    super.doStop();
+  }
+
+  @Override
+  public void handle(
+      String path,
+      Request request,
+      HttpServletRequest httpRequest,
+      HttpServletResponse httpResponse)
+      throws IOException, ServletException {
+
+    activeDispatches.inc();
+
+    final long start;
+    final HttpChannelState state = request.getHttpChannelState();
+    if (state.isInitial()) {
+      // new request
+      activeRequests.inc();
+      start = request.getTimeStamp();
+      state.addListener(listener);
+    } else {
+      // resumed request
+      start = System.currentTimeMillis();
+      activeSuspended.dec();
+      if (state.getState() == HttpChannelState.State.HANDLING) {
+        asyncDispatches.mark();
+      }
     }
 
-    public String getName() {
-        return name;
+    try {
+      super.handle(path, request, httpRequest, httpResponse);
+    } finally {
+      final long now = System.currentTimeMillis();
+      final long dispatched = now - start;
+
+      activeDispatches.dec();
+      dispatches.update(dispatched, TimeUnit.MILLISECONDS);
+
+      if (state.isSuspended()) {
+        activeSuspended.inc();
+      } else if (state.isInitial()) {
+        updateResponses(httpRequest, httpResponse, start, request.isHandled());
+      }
+      // else onCompletion will handle it.
     }
-
-    public void setName(String name) {
-        this.name = name;
+  }
+
+  private Timer requestTimer(String method) {
+    final HttpMethod m = HttpMethod.fromString(method);
+    if (m == null) {
+      return otherRequests;
+    } else {
+      switch (m) {
+        case GET:
+          return getRequests;
+        case POST:
+          return postRequests;
+        case PUT:
+          return putRequests;
+        case HEAD:
+          return headRequests;
+        case DELETE:
+          return deleteRequests;
+        case OPTIONS:
+          return optionsRequests;
+        case TRACE:
+          return traceRequests;
+        case CONNECT:
+          return connectRequests;
+        case MOVE:
+          return moveRequests;
+        default:
+          return otherRequests;
+      }
     }
-
-    @Override
-    protected void doStart() throws Exception {
-        super.doStart();
-
-        final MetricName prefix = getMetricPrefix();
-
-        this.requests = metricRegistry.timer(prefix.resolve(NAME_REQUESTS));
-        this.dispatches = metricRegistry.timer(prefix.resolve(NAME_DISPATCHES));
-
-        this.activeRequests = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_REQUESTS));
-        this.activeDispatches = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_DISPATCHES));
-        this.activeSuspended = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_SUSPENDED));
-
-        this.asyncDispatches = metricRegistry.meter(prefix.resolve(NAME_ASYNC_DISPATCHES));
-        this.asyncTimeouts = metricRegistry.meter(prefix.resolve(NAME_ASYNC_TIMEOUTS));
-
-        this.responseCodeMeters = DETAILED_METER_LEVELS.contains(responseMeteredLevel) ? new ConcurrentHashMap<>() : Collections.emptyMap();
-
-        this.getRequests = metricRegistry.timer(prefix.resolve(NAME_GET_REQUESTS));
-        this.postRequests = metricRegistry.timer(prefix.resolve(NAME_POST_REQUESTS));
-        this.headRequests = metricRegistry.timer(prefix.resolve(NAME_HEAD_REQUESTS));
-        this.putRequests = metricRegistry.timer(prefix.resolve(NAME_PUT_REQUESTS));
-        this.deleteRequests = metricRegistry.timer(prefix.resolve(NAME_DELETE_REQUESTS));
-        this.optionsRequests = metricRegistry.timer(prefix.resolve(NAME_OPTIONS_REQUESTS));
-        this.traceRequests = metricRegistry.timer(prefix.resolve(NAME_TRACE_REQUESTS));
-        this.connectRequests = metricRegistry.timer(prefix.resolve(NAME_CONNECT_REQUESTS));
-        this.moveRequests = metricRegistry.timer(prefix.resolve(NAME_MOVE_REQUESTS));
-        this.otherRequests = metricRegistry.timer(prefix.resolve(NAME_OTHER_REQUESTS));
-
-        if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
-            this.responses =  Collections.unmodifiableList(Arrays.asList(
-                    metricRegistry.meter(prefix.resolve(NAME_1XX_RESPONSES)), // 1xx
-                    metricRegistry.meter(prefix.resolve(NAME_2XX_RESPONSES)), // 2xx
-                    metricRegistry.meter(prefix.resolve(NAME_3XX_RESPONSES)), // 3xx
-                    metricRegistry.meter(prefix.resolve(NAME_4XX_RESPONSES)), // 4xx
-                    metricRegistry.meter(prefix.resolve(NAME_5XX_RESPONSES))  // 5xx
-            ));
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_1M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getOneMinuteRate(),
-                            requests.getOneMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_5M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getFiveMinuteRate(),
-                            requests.getFiveMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_15M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getFifteenMinuteRate(),
-                            requests.getFifteenMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_1M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getOneMinuteRate(),
-                            requests.getOneMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_5M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getFiveMinuteRate(),
-                            requests.getFiveMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_15M), new RatioGauge() {
-                @Override
-                public Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getFifteenMinuteRate(),
-                            requests.getFifteenMinuteRate());
-                }
-            });
-        } else {
-            this.responses =  Collections.emptyList();
-        }
-
-        this.listener = new AsyncAttachingListener();
+  }
+
+  private void updateResponses(
+      HttpServletRequest request, HttpServletResponse response, long start, boolean isHandled) {
+    if (isHandled) {
+      mark(response.getStatus());
+    } else {
+      mark(404);
+      ; // will end up with a 404 response sent by HttpChannel.handle
     }
-
-    @Override
-    protected void doStop() throws Exception {
-        final MetricName prefix = getMetricPrefix();
-
-        metricRegistry.remove(prefix.resolve(NAME_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_SUSPENDED));
-        metricRegistry.remove(prefix.resolve(NAME_ASYNC_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ASYNC_TIMEOUTS));
-        metricRegistry.remove(prefix.resolve(NAME_1XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_2XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_3XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_4XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_5XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_GET_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_POST_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_HEAD_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_PUT_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_DELETE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_OPTIONS_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_TRACE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_CONNECT_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_MOVE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_OTHER_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_1M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_5M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_15M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_1M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_5M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_15M));
-
-        if (responseCodeMeters != null) {
-            responseCodeMeters.keySet().stream()
-                    .map(sc -> getMetricPrefix().resolve(String.format("%d-responses", sc)))
-                    .forEach(metricRegistry::remove);
-        }
-        super.doStop();
+    activeRequests.dec();
+    final long elapsedTime = System.currentTimeMillis() - start;
+    requests.update(elapsedTime, TimeUnit.MILLISECONDS);
+    requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
+  }
+
+  private MetricName getMetricPrefix() {
+    return this.prefix == null ? name(getHandler().getClass(), name) : name(this.prefix, name);
+  }
+
+  private void mark(int statusCode) {
+    if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
+      getResponseCodeMeter(statusCode).mark();
     }
 
-    @Override
-    public void handle(String path,
-                       Request request,
-                       HttpServletRequest httpRequest,
-                       HttpServletResponse httpResponse) throws IOException, ServletException {
-
-        activeDispatches.inc();
-
-        final long start;
-        final HttpChannelState state = request.getHttpChannelState();
-        if (state.isInitial()) {
-            // new request
-            activeRequests.inc();
-            start = request.getTimeStamp();
-            state.addListener(listener);
-        } else {
-            // resumed request
-            start = System.currentTimeMillis();
-            activeSuspended.dec();
-            if (state.getState() == HttpChannelState.State.HANDLING) {
-                asyncDispatches.mark();
-            }
-        }
+    if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
+      final int responseStatus = statusCode / 100;
+      if (responseStatus >= 1 && responseStatus <= 5) {
+        responses.get(responseStatus - 1).mark();
+      }
+    }
+  }
 
-        try {
-            super.handle(path, request, httpRequest, httpResponse);
-        } finally {
-            final long now = System.currentTimeMillis();
-            final long dispatched = now - start;
+  private Meter getResponseCodeMeter(int statusCode) {
+    return responseCodeMeters.computeIfAbsent(
+        statusCode,
+        sc -> metricRegistry.meter(getMetricPrefix().resolve(String.format("%d-responses", sc))));
+  }
 
-            activeDispatches.dec();
-            dispatches.update(dispatched, TimeUnit.MILLISECONDS);
+  private class AsyncAttachingListener implements AsyncListener {
 
-            if (state.isSuspended()) {
-                activeSuspended.inc();
-            } else if (state.isInitial()) {
-                updateResponses(httpRequest, httpResponse, start, request.isHandled());
-            }
-            // else onCompletion will handle it.
-        }
-    }
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {}
 
-    private Timer requestTimer(String method) {
-        final HttpMethod m = HttpMethod.fromString(method);
-        if (m == null) {
-            return otherRequests;
-        } else {
-            switch (m) {
-                case GET:
-                    return getRequests;
-                case POST:
-                    return postRequests;
-                case PUT:
-                    return putRequests;
-                case HEAD:
-                    return headRequests;
-                case DELETE:
-                    return deleteRequests;
-                case OPTIONS:
-                    return optionsRequests;
-                case TRACE:
-                    return traceRequests;
-                case CONNECT:
-                    return connectRequests;
-                case MOVE:
-                    return moveRequests;
-                default:
-                    return otherRequests;
-            }
-        }
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {
+      event.getAsyncContext().addListener(new InstrumentedAsyncListener());
     }
 
-    private void updateResponses(HttpServletRequest request, HttpServletResponse response, long start, boolean isHandled) {
-        if (isHandled) {
-            mark(response.getStatus());
-        } else {
-            mark(404);; // will end up with a 404 response sent by HttpChannel.handle
-        }
-        activeRequests.dec();
-        final long elapsedTime = System.currentTimeMillis() - start;
-        requests.update(elapsedTime, TimeUnit.MILLISECONDS);
-        requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
-    }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {}
 
-    private MetricName getMetricPrefix() {
-        return this.prefix == null ? name(getHandler().getClass(), name) : name(this.prefix, name);
-    }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {}
+  }
+  ;
 
-    private void mark(int statusCode) {
-        if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
-            getResponseCodeMeter(statusCode).mark();
-        }
+  private class InstrumentedAsyncListener implements AsyncListener {
+    private final long startTime;
 
-        if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
-            final int responseStatus = statusCode / 100;
-            if (responseStatus >= 1 && responseStatus <= 5) {
-                responses.get(responseStatus - 1).mark();
-            }
-        }
+    InstrumentedAsyncListener() {
+      this.startTime = System.currentTimeMillis();
     }
 
-    private Meter getResponseCodeMeter(int statusCode) {
-        return responseCodeMeters
-                .computeIfAbsent(statusCode, sc -> metricRegistry
-                        .meter(getMetricPrefix().resolve(String.format("%d-responses", sc))));
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {
+      asyncTimeouts.mark();
     }
 
-    private class AsyncAttachingListener implements AsyncListener {
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {}
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-            event.getAsyncContext().addListener(new InstrumentedAsyncListener());
-        }
-
-        @Override
-        public void onError(AsyncEvent event) throws IOException {}
-
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {}
-    };
-
-    private class InstrumentedAsyncListener implements AsyncListener {
-        private final long startTime;
-
-        InstrumentedAsyncListener() {
-            this.startTime = System.currentTimeMillis();
-        }
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {
-            asyncTimeouts.mark();
-        }
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-        }
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {}
 
-        @Override
-        public void onError(AsyncEvent event) throws IOException {
-        }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {}
 
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {
-            final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
-            final HttpServletRequest request = (HttpServletRequest) state.getRequest();
-            final HttpServletResponse response = (HttpServletResponse) state.getResponse();
-            updateResponses(request, response, startTime, true);
-            if (!state.getHttpChannelState().isSuspended()) {
-                activeSuspended.dec();
-            }
-        }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {
+      final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
+      final HttpServletRequest request = (HttpServletRequest) state.getRequest();
+      final HttpServletResponse response = (HttpServletResponse) state.getResponse();
+      updateResponses(request, response, startTime, true);
+      if (!state.getHttpChannelState().isSuspended()) {
+        activeSuspended.dec();
+      }
     }
+  }
 }
--- a/metrics-jetty11/src/main/java/io/dropwizard/metrics5/jetty11/InstrumentedHttpChannelListener.java
+++ b/metrics-jetty11/src/main/java/io/dropwizard/metrics5/jetty11/InstrumentedHttpChannelListener.java
@@ -1,5 +1,12 @@
 package io.dropwizard.metrics5.jetty11;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.util.Collections.unmodifiableList;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricName;
@@ -11,415 +18,398 @@ import jakarta.servlet.AsyncEvent;
 import jakarta.servlet.AsyncListener;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
-import org.eclipse.jetty.http.HttpMethod;
-import org.eclipse.jetty.server.AsyncContextState;
-import org.eclipse.jetty.server.HttpChannel.Listener;
-import org.eclipse.jetty.server.HttpChannelState;
-import org.eclipse.jetty.server.Request;
-
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
-
+import org.eclipse.jetty.http.HttpMethod;
+import org.eclipse.jetty.server.AsyncContextState;
+import org.eclipse.jetty.server.HttpChannel.Listener;
+import org.eclipse.jetty.server.HttpChannelState;
+import org.eclipse.jetty.server.Request;
 
 /**
- * A Jetty {@link org.eclipse.jetty.server.HttpChannel.Listener} implementation which records various metrics about
- * underlying channel instance. Unlike {@link InstrumentedHandler} that uses internal API, this class should be
- * future proof. To install it, just add instance of this class to {@link org.eclipse.jetty.server.Connector} as bean.
+ * A Jetty {@link org.eclipse.jetty.server.HttpChannel.Listener} implementation which records
+ * various metrics about underlying channel instance. Unlike {@link InstrumentedHandler} that uses
+ * internal API, this class should be future proof. To install it, just add instance of this class
+ * to {@link org.eclipse.jetty.server.Connector} as bean.
  *
  * @since TBD
  */
-public class InstrumentedHttpChannelListener
-        implements Listener {
-    private static final String START_ATTR = InstrumentedHttpChannelListener.class.getName() + ".start";
-    private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
-    private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
-
-    private final MetricRegistry metricRegistry;
-
-    // the requests handled by this handler, excluding active
-    private final Timer requests;
-
-    // the number of dispatches seen by this handler, excluding active
-    private final Timer dispatches;
-
-    // the number of active requests
-    private final Counter activeRequests;
-
-    // the number of active dispatches
-    private final Counter activeDispatches;
-
-    // the number of requests currently suspended.
-    private final Counter activeSuspended;
-
-    // the number of requests that have been asynchronously dispatched
-    private final Meter asyncDispatches;
-
-    // the number of requests that expired while suspended
-    private final Meter asyncTimeouts;
-
-    private final ResponseMeteredLevel responseMeteredLevel;
-    private final List<Meter> responses;
-    private final Map<Integer, Meter> responseCodeMeters;
-    private final MetricName prefix;
-    private final Timer getRequests;
-    private final Timer postRequests;
-    private final Timer headRequests;
-    private final Timer putRequests;
-    private final Timer deleteRequests;
-    private final Timer optionsRequests;
-    private final Timer traceRequests;
-    private final Timer connectRequests;
-    private final Timer moveRequests;
-    private final Timer otherRequests;
-
-    private final AsyncListener listener;
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     */
-    public InstrumentedHttpChannelListener(MetricRegistry registry) {
-        this(registry, null, COARSE);
-    }
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param pref     the prefix to use for the metrics names
-     */
-    public InstrumentedHttpChannelListener(MetricRegistry registry, MetricName pref) {
-        this(registry, pref, COARSE);
-    }
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param pref     the prefix to use for the metrics names
-     * @param responseMeteredLevel the level to determine individual/aggregate response codes that are instrumented
-     */
-    public InstrumentedHttpChannelListener(MetricRegistry registry, MetricName pref, ResponseMeteredLevel responseMeteredLevel) {
-        this.metricRegistry = registry;
-
-        this.prefix = (pref == null) ? MetricName.build(getClass().getName()) : pref;
-
-        this.requests = metricRegistry.timer(prefix.resolve("requests"));
-        this.dispatches = metricRegistry.timer(prefix.resolve("dispatches"));
-
-        this.activeRequests = metricRegistry.counter(prefix.resolve("active-requests"));
-        this.activeDispatches = metricRegistry.counter(prefix.resolve("active-dispatches"));
-        this.activeSuspended = metricRegistry.counter(prefix.resolve("active-suspended"));
-
-        this.asyncDispatches = metricRegistry.meter(prefix.resolve("async-dispatches"));
-        this.asyncTimeouts = metricRegistry.meter(prefix.resolve("async-timeouts"));
-
-        this.responseMeteredLevel = responseMeteredLevel;
-        this.responseCodeMeters = DETAILED_METER_LEVELS.contains(responseMeteredLevel) ? new ConcurrentHashMap<>() : Collections.emptyMap();
-        this.responses = COARSE_METER_LEVELS.contains(responseMeteredLevel) ?
-                Collections.unmodifiableList(Arrays.asList(
-                        registry.meter(prefix.resolve("1xx-responses")), // 1xx
-                        registry.meter(prefix.resolve("2xx-responses")), // 2xx
-                        registry.meter(prefix.resolve("3xx-responses")), // 3xx
-                        registry.meter(prefix.resolve("4xx-responses")), // 4xx
-                        registry.meter(prefix.resolve("5xx-responses"))  // 5xx
-                )) : Collections.emptyList();
-
-        this.getRequests = metricRegistry.timer(prefix.resolve("get-requests"));
-        this.postRequests = metricRegistry.timer(prefix.resolve("post-requests"));
-        this.headRequests = metricRegistry.timer(prefix.resolve("head-requests"));
-        this.putRequests = metricRegistry.timer(prefix.resolve("put-requests"));
-        this.deleteRequests = metricRegistry.timer(prefix.resolve("delete-requests"));
-        this.optionsRequests = metricRegistry.timer(prefix.resolve("options-requests"));
-        this.traceRequests = metricRegistry.timer(prefix.resolve("trace-requests"));
-        this.connectRequests = metricRegistry.timer(prefix.resolve("connect-requests"));
-        this.moveRequests = metricRegistry.timer(prefix.resolve("move-requests"));
-        this.otherRequests = metricRegistry.timer(prefix.resolve("other-requests"));
-
-        metricRegistry.register(prefix.resolve("percent-4xx-1m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(3).getOneMinuteRate(),
-                        requests.getOneMinuteRate());
-            }
+public class InstrumentedHttpChannelListener implements Listener {
+  private static final String START_ATTR =
+      InstrumentedHttpChannelListener.class.getName() + ".start";
+  private static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
+  private static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
+
+  private final MetricRegistry metricRegistry;
+
+  // the requests handled by this handler, excluding active
+  private final Timer requests;
+
+  // the number of dispatches seen by this handler, excluding active
+  private final Timer dispatches;
+
+  // the number of active requests
+  private final Counter activeRequests;
+
+  // the number of active dispatches
+  private final Counter activeDispatches;
+
+  // the number of requests currently suspended.
+  private final Counter activeSuspended;
+
+  // the number of requests that have been asynchronously dispatched
+  private final Meter asyncDispatches;
+
+  // the number of requests that expired while suspended
+  private final Meter asyncTimeouts;
+
+  private final ResponseMeteredLevel responseMeteredLevel;
+  private final List<Meter> responses;
+  private final Map<Integer, Meter> responseCodeMeters;
+  private final MetricName prefix;
+  private final Timer getRequests;
+  private final Timer postRequests;
+  private final Timer headRequests;
+  private final Timer putRequests;
+  private final Timer deleteRequests;
+  private final Timer optionsRequests;
+  private final Timer traceRequests;
+  private final Timer connectRequests;
+  private final Timer moveRequests;
+  private final Timer otherRequests;
+
+  private final AsyncListener listener;
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   */
+  public InstrumentedHttpChannelListener(MetricRegistry registry) {
+    this(registry, null, COARSE);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param pref the prefix to use for the metrics names
+   */
+  public InstrumentedHttpChannelListener(MetricRegistry registry, MetricName pref) {
+    this(registry, pref, COARSE);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param pref the prefix to use for the metrics names
+   * @param responseMeteredLevel the level to determine individual/aggregate response codes that are
+   *     instrumented
+   */
+  public InstrumentedHttpChannelListener(
+      MetricRegistry registry, MetricName pref, ResponseMeteredLevel responseMeteredLevel) {
+    this.metricRegistry = registry;
+
+    this.prefix = (pref == null) ? MetricName.build(getClass().getName()) : pref;
+
+    this.requests = metricRegistry.timer(prefix.resolve("requests"));
+    this.dispatches = metricRegistry.timer(prefix.resolve("dispatches"));
+
+    this.activeRequests = metricRegistry.counter(prefix.resolve("active-requests"));
+    this.activeDispatches = metricRegistry.counter(prefix.resolve("active-dispatches"));
+    this.activeSuspended = metricRegistry.counter(prefix.resolve("active-suspended"));
+
+    this.asyncDispatches = metricRegistry.meter(prefix.resolve("async-dispatches"));
+    this.asyncTimeouts = metricRegistry.meter(prefix.resolve("async-timeouts"));
+
+    this.responseMeteredLevel = responseMeteredLevel;
+    this.responseCodeMeters =
+        DETAILED_METER_LEVELS.contains(responseMeteredLevel)
+            ? new ConcurrentHashMap<>()
+            : ImmutableMap.of();
+    this.responses =
+        COARSE_METER_LEVELS.contains(responseMeteredLevel)
+            ? unmodifiableList(
+                Arrays.asList(
+                    registry.meter(prefix.resolve("1xx-responses")), // 1xx
+                    registry.meter(prefix.resolve("2xx-responses")), // 2xx
+                    registry.meter(prefix.resolve("3xx-responses")), // 3xx
+                    registry.meter(prefix.resolve("4xx-responses")), // 4xx
+                    registry.meter(prefix.resolve("5xx-responses")) // 5xx
+                    ))
+            : ImmutableList.of();
+
+    this.getRequests = metricRegistry.timer(prefix.resolve("get-requests"));
+    this.postRequests = metricRegistry.timer(prefix.resolve("post-requests"));
+    this.headRequests = metricRegistry.timer(prefix.resolve("head-requests"));
+    this.putRequests = metricRegistry.timer(prefix.resolve("put-requests"));
+    this.deleteRequests = metricRegistry.timer(prefix.resolve("delete-requests"));
+    this.optionsRequests = metricRegistry.timer(prefix.resolve("options-requests"));
+    this.traceRequests = metricRegistry.timer(prefix.resolve("trace-requests"));
+    this.connectRequests = metricRegistry.timer(prefix.resolve("connect-requests"));
+    this.moveRequests = metricRegistry.timer(prefix.resolve("move-requests"));
+    this.otherRequests = metricRegistry.timer(prefix.resolve("other-requests"));
+
+    metricRegistry.register(
+        prefix.resolve("percent-4xx-1m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(responses.get(3).getOneMinuteRate(), requests.getOneMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-4xx-5m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(3).getFiveMinuteRate(),
-                        requests.getFiveMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-4xx-5m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(responses.get(3).getFiveMinuteRate(), requests.getFiveMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-4xx-15m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(3).getFifteenMinuteRate(),
-                        requests.getFifteenMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-4xx-15m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(
+                responses.get(3).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-5xx-1m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(4).getOneMinuteRate(),
-                        requests.getOneMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-5xx-1m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(responses.get(4).getOneMinuteRate(), requests.getOneMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-5xx-5m"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(responses.get(4).getFiveMinuteRate(),
-                        requests.getFiveMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-5xx-5m"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(responses.get(4).getFiveMinuteRate(), requests.getFiveMinuteRate());
+          }
         });
 
-        metricRegistry.register(prefix.resolve("percent-5xx-15m"), new RatioGauge() {
-            @Override
-            public RatioGauge.Ratio getRatio() {
-                return Ratio.of(responses.get(4).getFifteenMinuteRate(),
-                        requests.getFifteenMinuteRate());
-            }
+    metricRegistry.register(
+        prefix.resolve("percent-5xx-15m"),
+        new RatioGauge() {
+          @Override
+          public RatioGauge.Ratio getRatio() {
+            return Ratio.of(
+                responses.get(4).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+          }
         });
 
-        this.listener = new AsyncAttachingListener();
-    }
+    this.listener = new AsyncAttachingListener();
+  }
 
-    @Override
-    public void onRequestBegin(final Request request) {
+  @Override
+  public void onRequestBegin(final Request request) {}
 
-    }
-
-    @Override
-    public void onBeforeDispatch(final Request request) {
-        before(request);
-    }
+  @Override
+  public void onBeforeDispatch(final Request request) {
+    before(request);
+  }
 
-    @Override
-    public void onDispatchFailure(final Request request, final Throwable failure) {
+  @Override
+  public void onDispatchFailure(final Request request, final Throwable failure) {}
 
-    }
+  @Override
+  public void onAfterDispatch(final Request request) {
+    after(request);
+  }
 
-    @Override
-    public void onAfterDispatch(final Request request) {
-        after(request);
-    }
+  @Override
+  public void onRequestContent(final Request request, final ByteBuffer content) {}
 
-    @Override
-    public void onRequestContent(final Request request, final ByteBuffer content) {
+  @Override
+  public void onRequestContentEnd(final Request request) {}
 
-    }
+  @Override
+  public void onRequestTrailers(final Request request) {}
 
-    @Override
-    public void onRequestContentEnd(final Request request) {
+  @Override
+  public void onRequestEnd(final Request request) {}
 
-    }
+  @Override
+  public void onRequestFailure(final Request request, final Throwable failure) {}
 
-    @Override
-    public void onRequestTrailers(final Request request) {
+  @Override
+  public void onResponseBegin(final Request request) {}
 
-    }
+  @Override
+  public void onResponseCommit(final Request request) {}
 
-    @Override
-    public void onRequestEnd(final Request request) {
+  @Override
+  public void onResponseContent(final Request request, final ByteBuffer content) {}
 
-    }
+  @Override
+  public void onResponseEnd(final Request request) {}
 
-    @Override
-    public void onRequestFailure(final Request request, final Throwable failure) {
+  @Override
+  public void onResponseFailure(final Request request, final Throwable failure) {}
 
-    }
+  @Override
+  public void onComplete(final Request request) {}
 
-    @Override
-    public void onResponseBegin(final Request request) {
+  private void before(final Request request) {
+    activeDispatches.inc();
 
+    final long start;
+    final HttpChannelState state = request.getHttpChannelState();
+    if (state.isInitial()) {
+      // new request
+      activeRequests.inc();
+      start = request.getTimeStamp();
+      state.addListener(listener);
+    } else {
+      // resumed request
+      start = System.currentTimeMillis();
+      activeSuspended.dec();
+      if (state.isAsyncStarted()) {
+        asyncDispatches.mark();
+      }
     }
-
-    @Override
-    public void onResponseCommit(final Request request) {
-
+    request.setAttribute(START_ATTR, start);
+  }
+
+  private void after(final Request request) {
+    final long start = (long) request.getAttribute(START_ATTR);
+    final long now = System.currentTimeMillis();
+    final long dispatched = now - start;
+
+    activeDispatches.dec();
+    dispatches.update(dispatched, TimeUnit.MILLISECONDS);
+
+    final HttpChannelState state = request.getHttpChannelState();
+    if (state.isSuspended()) {
+      activeSuspended.inc();
+    } else if (state.isInitial()) {
+      updateResponses(request, request.getResponse(), start, request.isHandled());
     }
-
-    @Override
-    public void onResponseContent(final Request request, final ByteBuffer content) {
-
+    // else onCompletion will handle it.
+  }
+
+  private void updateResponses(
+      HttpServletRequest request, HttpServletResponse response, long start, boolean isHandled) {
+    if (isHandled) {
+      mark(response.getStatus());
+    } else {
+      mark(404); // will end up with a 404 response sent by HttpChannel.handle
+    }
+    activeRequests.dec();
+    final long elapsedTime = System.currentTimeMillis() - start;
+    requests.update(elapsedTime, TimeUnit.MILLISECONDS);
+    requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
+  }
+
+  private void mark(int statusCode) {
+    if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
+      getResponseCodeMeter(statusCode).mark();
     }
 
-    @Override
-    public void onResponseEnd(final Request request) {
-
+    if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
+      final int responseStatus = statusCode / 100;
+      if (responseStatus >= 1 && responseStatus <= 5) {
+        responses.get(responseStatus - 1).mark();
+      }
     }
+  }
+
+  private Meter getResponseCodeMeter(int statusCode) {
+    return responseCodeMeters.computeIfAbsent(
+        statusCode, sc -> metricRegistry.meter(prefix.resolve(String.format("%d-responses", sc))));
+  }
+
+  private Timer requestTimer(String method) {
+    final HttpMethod m = HttpMethod.fromString(method);
+    if (m == null) {
+      return otherRequests;
+    } else {
+      switch (m) {
+        case GET:
+          return getRequests;
+        case POST:
+          return postRequests;
+        case PUT:
+          return putRequests;
+        case HEAD:
+          return headRequests;
+        case DELETE:
+          return deleteRequests;
+        case OPTIONS:
+          return optionsRequests;
+        case TRACE:
+          return traceRequests;
+        case CONNECT:
+          return connectRequests;
+        case MOVE:
+          return moveRequests;
+        default:
+          return otherRequests;
+      }
+    }
+  }
+
+  private class AsyncAttachingListener implements AsyncListener {
 
     @Override
-    public void onResponseFailure(final Request request, final Throwable failure) {
+    public void onTimeout(AsyncEvent event) throws IOException {}
 
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {
+      event.getAsyncContext().addListener(new InstrumentedAsyncListener());
     }
 
     @Override
-    public void onComplete(final Request request) {
-
-    }
+    public void onError(AsyncEvent event) throws IOException {}
 
-    private void before(final Request request) {
-        activeDispatches.inc();
-
-        final long start;
-        final HttpChannelState state = request.getHttpChannelState();
-        if (state.isInitial()) {
-            // new request
-            activeRequests.inc();
-            start = request.getTimeStamp();
-            state.addListener(listener);
-        } else {
-            // resumed request
-            start = System.currentTimeMillis();
-            activeSuspended.dec();
-            if (state.isAsyncStarted()) {
-                asyncDispatches.mark();
-            }
-        }
-        request.setAttribute(START_ATTR, start);
-    }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {}
+  }
+  ;
 
-    private void after(final Request request) {
-        final long start = (long) request.getAttribute(START_ATTR);
-        final long now = System.currentTimeMillis();
-        final long dispatched = now - start;
-
-        activeDispatches.dec();
-        dispatches.update(dispatched, TimeUnit.MILLISECONDS);
-
-        final HttpChannelState state = request.getHttpChannelState();
-        if (state.isSuspended()) {
-            activeSuspended.inc();
-        } else if (state.isInitial()) {
-            updateResponses(request, request.getResponse(), start, request.isHandled());
-        }
-        // else onCompletion will handle it.
-    }
+  private class InstrumentedAsyncListener implements AsyncListener {
+    private final long startTime;
 
-    private void updateResponses(HttpServletRequest request, HttpServletResponse response, long start, boolean isHandled) {
-        if (isHandled) {
-            mark(response.getStatus());
-        } else {
-            mark(404); // will end up with a 404 response sent by HttpChannel.handle
-        }
-        activeRequests.dec();
-        final long elapsedTime = System.currentTimeMillis() - start;
-        requests.update(elapsedTime, TimeUnit.MILLISECONDS);
-        requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
+    InstrumentedAsyncListener() {
+      this.startTime = System.currentTimeMillis();
     }
 
-    private void mark(int statusCode) {
-        if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
-            getResponseCodeMeter(statusCode).mark();
-        }
-
-        if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
-            final int responseStatus = statusCode / 100;
-            if (responseStatus >= 1 && responseStatus <= 5) {
-                responses.get(responseStatus - 1).mark();
-            }
-        }
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {
+      asyncTimeouts.mark();
     }
 
-    private Meter getResponseCodeMeter(int statusCode) {
-        return responseCodeMeters
-                .computeIfAbsent(statusCode, sc -> metricRegistry
-                        .meter(prefix.resolve(String.format("%d-responses", sc))));
-    }
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {}
 
-    private Timer requestTimer(String method) {
-        final HttpMethod m = HttpMethod.fromString(method);
-        if (m == null) {
-            return otherRequests;
-        } else {
-            switch (m) {
-                case GET:
-                    return getRequests;
-                case POST:
-                    return postRequests;
-                case PUT:
-                    return putRequests;
-                case HEAD:
-                    return headRequests;
-                case DELETE:
-                    return deleteRequests;
-                case OPTIONS:
-                    return optionsRequests;
-                case TRACE:
-                    return traceRequests;
-                case CONNECT:
-                    return connectRequests;
-                case MOVE:
-                    return moveRequests;
-                default:
-                    return otherRequests;
-            }
-        }
-    }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {}
 
-    private class AsyncAttachingListener implements AsyncListener {
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {}
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-            event.getAsyncContext().addListener(new InstrumentedAsyncListener());
-        }
-
-        @Override
-        public void onError(AsyncEvent event) throws IOException {}
-
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {}
-    };
-
-    private class InstrumentedAsyncListener implements AsyncListener {
-        private final long startTime;
-
-        InstrumentedAsyncListener() {
-            this.startTime = System.currentTimeMillis();
-        }
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {
-            asyncTimeouts.mark();
-        }
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-        }
-
-        @Override
-        public void onError(AsyncEvent event) throws IOException {
-        }
-
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {
-            final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
-            final HttpServletRequest request = (HttpServletRequest) state.getRequest();
-            final HttpServletResponse response = (HttpServletResponse) state.getResponse();
-            updateResponses(request, response, startTime, true);
-            if (!state.getHttpChannelState().isSuspended()) {
-                activeSuspended.dec();
-            }
-        }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {
+      final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
+      final HttpServletRequest request = (HttpServletRequest) state.getRequest();
+      final HttpServletResponse response = (HttpServletResponse) state.getResponse();
+      updateResponses(request, response, startTime, true);
+      if (!state.getHttpChannelState().isSuspended()) {
+        activeSuspended.dec();
+      }
     }
+  }
 }
--- a/metrics-jetty11/src/main/java/io/dropwizard/metrics5/jetty11/InstrumentedQueuedThreadPool.java
+++ b/metrics-jetty11/src/main/java/io/dropwizard/metrics5/jetty11/InstrumentedQueuedThreadPool.java
@@ -1,119 +1,130 @@
 package io.dropwizard.metrics5.jetty11;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.RatioGauge;
+import java.util.concurrent.BlockingQueue;
 import org.eclipse.jetty.util.annotation.Name;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
 
-import java.util.concurrent.BlockingQueue;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 public class InstrumentedQueuedThreadPool extends QueuedThreadPool {
-    private static final String NAME_UTILIZATION = "utilization";
-    private static final String NAME_UTILIZATION_MAX = "utilization-max";
-    private static final String NAME_SIZE = "size";
-    private static final String NAME_JOBS = "jobs";
-    private static final String NAME_JOBS_QUEUE_UTILIZATION = "jobs-queue-utilization";
-
-    private final MetricRegistry metricRegistry;
-    private String prefix;
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry) {
-        this(registry, 200);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads) {
-        this(registry, maxThreads, 8);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads) {
-        this(registry, maxThreads, minThreads, 60000);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout) {
-        this(registry, maxThreads, minThreads, idleTimeout, null);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("queue") BlockingQueue<Runnable> queue) {
-        this(registry, maxThreads, minThreads, idleTimeout, queue, null);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("queue") BlockingQueue<Runnable> queue,
-                                        @Name("prefix") String prefix) {
-        super(maxThreads, minThreads, idleTimeout, queue);
-        this.metricRegistry = registry;
-        this.prefix = prefix;
-    }
-
-    public String getPrefix() {
-        return prefix;
-    }
-
-    public void setPrefix(String prefix) {
-        this.prefix = prefix;
-    }
-
-    @Override
-    protected void doStart() throws Exception {
-        super.doStart();
-
-        final MetricName prefix = getMetricPrefix();
-
-        metricRegistry.register(prefix.resolve(NAME_UTILIZATION), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(getThreads() - getIdleThreads(), getThreads());
-            }
+  private static final String NAME_UTILIZATION = "utilization";
+  private static final String NAME_UTILIZATION_MAX = "utilization-max";
+  private static final String NAME_SIZE = "size";
+  private static final String NAME_JOBS = "jobs";
+  private static final String NAME_JOBS_QUEUE_UTILIZATION = "jobs-queue-utilization";
+
+  private final MetricRegistry metricRegistry;
+  private String prefix;
+
+  public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry) {
+    this(registry, 200);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry, @Name("maxThreads") int maxThreads) {
+    this(registry, maxThreads, 8);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads) {
+    this(registry, maxThreads, minThreads, 60000);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout) {
+    this(registry, maxThreads, minThreads, idleTimeout, null);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("queue") BlockingQueue<Runnable> queue) {
+    this(registry, maxThreads, minThreads, idleTimeout, queue, null);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("queue") BlockingQueue<Runnable> queue,
+      @Name("prefix") String prefix) {
+    super(maxThreads, minThreads, idleTimeout, queue);
+    this.metricRegistry = registry;
+    this.prefix = prefix;
+  }
+
+  public String getPrefix() {
+    return prefix;
+  }
+
+  public void setPrefix(String prefix) {
+    this.prefix = prefix;
+  }
+
+  @Override
+  protected void doStart() throws Exception {
+    super.doStart();
+
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.register(
+        prefix.resolve(NAME_UTILIZATION),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(getThreads() - getIdleThreads(), getThreads());
+          }
         });
-        metricRegistry.register(prefix.resolve(NAME_UTILIZATION_MAX), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(getThreads() - getIdleThreads(), getMaxThreads());
-            }
+    metricRegistry.register(
+        prefix.resolve(NAME_UTILIZATION_MAX),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(getThreads() - getIdleThreads(), getMaxThreads());
+          }
         });
-        metricRegistry.registerGauge(prefix.resolve(NAME_SIZE), this::getThreads);
-        // This assumes the QueuedThreadPool is using a BlockingArrayQueue or
-        // ArrayBlockingQueue for its queue, and is therefore a constant-time operation.
-        metricRegistry.registerGauge(prefix.resolve(NAME_JOBS), () -> getQueue().size());
-        metricRegistry.register(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                BlockingQueue<Runnable> queue = getQueue();
-                return Ratio.of(queue.size(), queue.size() + queue.remainingCapacity());
-            }
+    metricRegistry.registerGauge(prefix.resolve(NAME_SIZE), this::getThreads);
+    // This assumes the QueuedThreadPool is using a BlockingArrayQueue or
+    // ArrayBlockingQueue for its queue, and is therefore a constant-time operation.
+    metricRegistry.registerGauge(prefix.resolve(NAME_JOBS), () -> getQueue().size());
+    metricRegistry.register(
+        prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            BlockingQueue<Runnable> queue = getQueue();
+            return Ratio.of(queue.size(), queue.size() + queue.remainingCapacity());
+          }
         });
-    }
-
-    @Override
-    protected void doStop() throws Exception {
-        final MetricName prefix = getMetricPrefix();
-
-        metricRegistry.remove(prefix.resolve(NAME_UTILIZATION));
-        metricRegistry.remove(prefix.resolve(NAME_UTILIZATION_MAX));
-        metricRegistry.remove(prefix.resolve(NAME_SIZE));
-        metricRegistry.remove(prefix.resolve(NAME_JOBS));
-        metricRegistry.remove(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION));
-
-        super.doStop();
-    }
-
-    private MetricName getMetricPrefix() {
-        return this.prefix == null ? name(QueuedThreadPool.class, getName()) : name(this.prefix, getName());
-    }
+  }
+
+  @Override
+  protected void doStop() throws Exception {
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.remove(prefix.resolve(NAME_UTILIZATION));
+    metricRegistry.remove(prefix.resolve(NAME_UTILIZATION_MAX));
+    metricRegistry.remove(prefix.resolve(NAME_SIZE));
+    metricRegistry.remove(prefix.resolve(NAME_JOBS));
+    metricRegistry.remove(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION));
+
+    super.doStop();
+  }
+
+  private MetricName getMetricPrefix() {
+    return this.prefix == null
+        ? name(QueuedThreadPool.class, getName())
+        : name(this.prefix, getName());
+  }
 }
--- a/metrics-jetty11/src/test/java/io/dropwizard/metrics5/jetty11/InstrumentedConnectionFactoryTest.java
+++ b/metrics-jetty11/src/test/java/io/dropwizard/metrics5/jetty11/InstrumentedConnectionFactoryTest.java
@@ -1,11 +1,15 @@
 package io.dropwizard.metrics5.jetty11;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
 import jakarta.servlet.ServletException;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.io.PrintWriter;
 import org.eclipse.jetty.client.HttpClient;
 import org.eclipse.jetty.client.api.ContentResponse;
 import org.eclipse.jetty.server.HttpConnectionFactory;
@@ -17,77 +21,75 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.io.IOException;
-import java.io.PrintWriter;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-class InstrumentedConnectionFactoryTest {
-    private final MetricRegistry registry = new MetricRegistry();
-    private final Server server = new Server();
-    private final ServerConnector connector =
-            new ServerConnector(server, new InstrumentedConnectionFactory(new HttpConnectionFactory(),
-                    registry.timer("http.connections"),
-                    registry.counter("http.active-connections")));
-    private final HttpClient client = new HttpClient();
-
-    @BeforeEach
-    void setUp() throws Exception {
-        server.setHandler(new AbstractHandler() {
-            @Override
-            public void handle(String target,
-                    Request baseRequest,
-                    HttpServletRequest request,
-                    HttpServletResponse response) throws IOException, ServletException {
-                try (PrintWriter writer = response.getWriter()) {
-                    writer.println("OK");
-                }
+final class InstrumentedConnectionFactoryTest {
+  private final MetricRegistry registry = new MetricRegistry();
+  private final Server server = new Server();
+  private final ServerConnector connector =
+      new ServerConnector(
+          server,
+          new InstrumentedConnectionFactory(
+              new HttpConnectionFactory(),
+              registry.timer("http.connections"),
+              registry.counter("http.active-connections")));
+  private final HttpClient client = new HttpClient();
+
+  @BeforeEach
+  void setUp() throws Exception {
+    server.setHandler(
+        new AbstractHandler() {
+          @Override
+          public void handle(
+              String target,
+              Request baseRequest,
+              HttpServletRequest request,
+              HttpServletResponse response)
+              throws IOException, ServletException {
+            try (PrintWriter writer = response.getWriter()) {
+              writer.println("OK");
             }
+          }
         });
 
-        server.addConnector(connector);
-        server.start();
+    server.addConnector(connector);
+    server.start();
 
-        client.start();
-    }
+    client.start();
+  }
 
-    @AfterEach
-    void tearDown() throws Exception {
-        server.stop();
-        client.stop();
-    }
+  @AfterEach
+  void tearDown() throws Exception {
+    server.stop();
+    client.stop();
+  }
 
-    @Test
-    void instrumentsConnectionTimes() throws Exception {
-        final ContentResponse response = client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
-        assertThat(response.getStatus())
-                .isEqualTo(200);
+  @Test
+  void instrumentsConnectionTimes() throws Exception {
+    final ContentResponse response =
+        client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
+    assertThat(response.getStatus()).isEqualTo(200);
 
-        client.stop(); // close the connection
+    client.stop(); // close the connection
 
-        Thread.sleep(100); // make sure the connection is closed
+    Thread.sleep(100); // make sure the connection is closed
 
-        final Timer timer = registry.timer(MetricRegistry.name("http.connections"));
-        assertThat(timer.getCount())
-                .isEqualTo(1);
-    }
+    final Timer timer = registry.timer(MetricRegistry.name("http.connections"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void instrumentsActiveConnections() throws Exception {
-        final Counter counter = registry.counter("http.active-connections");
+  @Test
+  void instrumentsActiveConnections() throws Exception {
+    final Counter counter = registry.counter("http.active-connections");
 
-        final ContentResponse response = client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
-        assertThat(response.getStatus())
-                .isEqualTo(200);
+    final ContentResponse response =
+        client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
+    assertThat(response.getStatus()).isEqualTo(200);
 
-        assertThat(counter.getCount())
-                .isEqualTo(1);
+    assertThat(counter.getCount()).isEqualTo(1);
 
-        client.stop(); // close the connection
+    client.stop(); // close the connection
 
-        Thread.sleep(100); // make sure the connection is closed
+    Thread.sleep(100); // make sure the connection is closed
 
-        assertThat(counter.getCount())
-                .isEqualTo(0);
-    }
+    assertThat(counter.getCount()).isEqualTo(0);
+  }
 }
--- a/metrics-jetty11/src/test/java/io/dropwizard/metrics5/jetty11/InstrumentedHandlerTest.java
+++ b/metrics-jetty11/src/test/java/io/dropwizard/metrics5/jetty11/InstrumentedHandlerTest.java
@@ -1,5 +1,12 @@
 package io.dropwizard.metrics5.jetty11;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.AssertionsForClassTypes.assertThatCode;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import jakarta.servlet.AsyncContext;
@@ -8,6 +15,8 @@ import jakarta.servlet.ServletOutputStream;
 import jakarta.servlet.WriteListener;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 import org.eclipse.jetty.client.HttpClient;
 import org.eclipse.jetty.client.api.ContentResponse;
 import org.eclipse.jetty.server.Request;
@@ -19,228 +28,221 @@ import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.AssertionsForClassTypes.assertThatCode;
-
-class InstrumentedHandlerTest {
-    private final HttpClient client = new HttpClient();
-    private final MetricRegistry registry = new MetricRegistry();
-    private final Server server = new Server();
-    private final ServerConnector connector = new ServerConnector(server);
-    private final InstrumentedHandler handler = new InstrumentedHandler(registry, null, ALL);
-
-    @BeforeEach
-    void setUp() throws Exception {
-        handler.setName("handler");
-        handler.setHandler(new TestHandler());
-        server.addConnector(connector);
-        server.setHandler(handler);
-        server.start();
-        client.start();
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        server.stop();
-        client.stop();
-    }
-
-    @Test
-    void hasAName() throws Exception {
-        assertThat(handler.getName())
-                .isEqualTo("handler");
-    }
-
-    @Test
-    void createsAndRemovesMetricsForTheHandler() throws Exception {
-        final ContentResponse response = client.GET(uri("/hello"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(404);
-
-        assertThat(registry.getNames())
-                .containsOnly(
-                        MetricRegistry.name(TestHandler.class, "handler.1xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.2xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.3xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.4xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.404-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.5xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-1m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-5m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-15m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-1m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-5m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-15m"),
-                        MetricRegistry.name(TestHandler.class, "handler.requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-suspended"),
-                        MetricRegistry.name(TestHandler.class, "handler.async-dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.async-timeouts"),
-                        MetricRegistry.name(TestHandler.class, "handler.get-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.put-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.trace-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.other-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.connect-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.head-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.post-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.options-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.delete-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.move-requests")
-                );
-
-        server.stop();
-
-        assertThat(registry.getNames())
-                .isEmpty();
-    }
-
-    @Test
-    void responseTimesAreRecordedForBlockingResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/blocking"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-
-        assertResponseTimesValid();
-    }
-
-    @Test
-    void doStopDoesNotThrowNPE() throws Exception {
-        InstrumentedHandler handler = new InstrumentedHandler(registry, null, ALL);
-        handler.setHandler(new TestHandler());
-
-        assertThatCode(handler::doStop).doesNotThrowAnyException();
-    }
-
-    @Test
-    public void gaugesAreRegisteredWithResponseMeteredLevelCoarse() throws Exception {
-        InstrumentedHandler handler = new InstrumentedHandler(registry, "coarse", COARSE);
-        handler.setHandler(new TestHandler());
-        handler.setName("handler");
-        handler.doStart();
-        assertThat(registry.getGauges()).containsKey(MetricName.build("coarse", "handler", "percent-4xx-1m"));
-    }
-
-    @Test
-    public void gaugesAreNotRegisteredWithResponseMeteredLevelDetailed() throws Exception {
-        InstrumentedHandler handler = new InstrumentedHandler(registry, "detailed", DETAILED);
-        handler.setHandler(new TestHandler());
-        handler.setName("handler");
-        handler.doStart();
-        assertThat(registry.getGauges()).doesNotContainKey(MetricName.build("detailed", "handler", "percent-4xx-1m"));
-    }
-
-    @Test
-    @Disabled("flaky on virtual machines")
-    void responseTimesAreRecordedForAsyncResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/async"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-
-        assertResponseTimesValid();
-    }
-
-    private void assertResponseTimesValid() {
-        assertThat(registry.getMeters().get(metricName().resolve("200-responses"))
-                .getCount()).isGreaterThan(0L);
-
-
-        assertThat(registry.getTimers().get(metricName().resolve("get-requests"))
-                .getSnapshot().getMedian()).isGreaterThan(0.0).isLessThan(TimeUnit.SECONDS.toNanos(1));
-
-        assertThat(registry.getTimers().get(metricName().resolve("requests"))
-                .getSnapshot().getMedian()).isGreaterThan(0.0).isLessThan(TimeUnit.SECONDS.toNanos(1));
-    }
-
-    private String uri(String path) {
-        return "http://localhost:" + connector.getLocalPort() + path;
-    }
-
-    private MetricName metricName() {
-        return MetricRegistry.name(TestHandler.class.getName(), "handler");
-    }
-
-    /**
-     * test handler.
-     * <p>
-     * Supports
-     * <p>
-     * /blocking - uses the standard servlet api
-     * /async - uses the 3.1 async api to complete the request
-     * <p>
-     * all other requests will return 404
-     */
-    private static class TestHandler extends AbstractHandler {
-        @Override
-        public void handle(
-                String path,
-                Request request,
-                final HttpServletRequest httpServletRequest,
-                final HttpServletResponse httpServletResponse
-        ) throws IOException, ServletException {
-            switch (path) {
-                case "/blocking":
-                    request.setHandled(true);
+final class InstrumentedHandlerTest {
+  private final HttpClient client = new HttpClient();
+  private final MetricRegistry registry = new MetricRegistry();
+  private final Server server = new Server();
+  private final ServerConnector connector = new ServerConnector(server);
+  private final InstrumentedHandler handler = new InstrumentedHandler(registry, null, ALL);
+
+  @BeforeEach
+  void setUp() throws Exception {
+    handler.setName("handler");
+    handler.setHandler(new TestHandler());
+    server.addConnector(connector);
+    server.setHandler(handler);
+    server.start();
+    client.start();
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    server.stop();
+    client.stop();
+  }
+
+  @Test
+  void hasAName() throws Exception {
+    assertThat(handler.getName()).isEqualTo("handler");
+  }
+
+  @Test
+  void createsAndRemovesMetricsForTheHandler() throws Exception {
+    final ContentResponse response = client.GET(uri("/hello"));
+
+    assertThat(response.getStatus()).isEqualTo(404);
+
+    assertThat(registry.getNames())
+        .containsOnly(
+            MetricRegistry.name(TestHandler.class, "handler.1xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.2xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.3xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.4xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.404-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.5xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-1m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-5m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-15m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-1m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-5m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-15m"),
+            MetricRegistry.name(TestHandler.class, "handler.requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-suspended"),
+            MetricRegistry.name(TestHandler.class, "handler.async-dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.async-timeouts"),
+            MetricRegistry.name(TestHandler.class, "handler.get-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.put-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.trace-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.other-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.connect-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.head-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.post-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.options-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.delete-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.move-requests"));
+
+    server.stop();
+
+    assertThat(registry.getNames()).isEmpty();
+  }
+
+  @Test
+  void responseTimesAreRecordedForBlockingResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/blocking"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+
+    assertResponseTimesValid();
+  }
+
+  @Test
+  void doStopDoesNotThrowNPE() throws Exception {
+    InstrumentedHandler handler = new InstrumentedHandler(registry, null, ALL);
+    handler.setHandler(new TestHandler());
+
+    assertThatCode(handler::doStop).doesNotThrowAnyException();
+  }
+
+  @Test
+  void gaugesAreRegisteredWithResponseMeteredLevelCoarse() throws Exception {
+    InstrumentedHandler handler = new InstrumentedHandler(registry, "coarse", COARSE);
+    handler.setHandler(new TestHandler());
+    handler.setName("handler");
+    handler.doStart();
+    assertThat(registry.getGauges())
+        .containsKey(MetricName.build("coarse", "handler", "percent-4xx-1m"));
+  }
+
+  @Test
+  void gaugesAreNotRegisteredWithResponseMeteredLevelDetailed() throws Exception {
+    InstrumentedHandler handler = new InstrumentedHandler(registry, "detailed", DETAILED);
+    handler.setHandler(new TestHandler());
+    handler.setName("handler");
+    handler.doStart();
+    assertThat(registry.getGauges())
+        .doesNotContainKey(MetricName.build("detailed", "handler", "percent-4xx-1m"));
+  }
+
+  @Disabled("flaky on virtual machines")
+  @Test
+  void responseTimesAreRecordedForAsyncResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/async"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+
+    assertResponseTimesValid();
+  }
+
+  private void assertResponseTimesValid() {
+    assertThat(registry.getMeters().get(metricName().resolve("200-responses")).getCount())
+        .isPositive();
+
+    assertThat(
+            registry
+                .getTimers()
+                .get(metricName().resolve("get-requests"))
+                .getSnapshot()
+                .getMedian())
+        .isPositive()
+        .isLessThan(TimeUnit.SECONDS.toNanos(1));
+
+    assertThat(registry.getTimers().get(metricName().resolve("requests")).getSnapshot().getMedian())
+        .isPositive()
+        .isLessThan(TimeUnit.SECONDS.toNanos(1));
+  }
+
+  private String uri(String path) {
+    return "http://localhost:" + connector.getLocalPort() + path;
+  }
+
+  private MetricName metricName() {
+    return MetricRegistry.name(TestHandler.class.getName(), "handler");
+  }
+
+  /**
+   * test handler.
+   *
+   * <p>Supports
+   *
+   * <p>/blocking - uses the standard servlet api /async - uses the 3.1 async api to complete the
+   * request
+   *
+   * <p>all other requests will return 404
+   */
+  private static class TestHandler extends AbstractHandler {
+    @Override
+    public void handle(
+        String path,
+        Request request,
+        final HttpServletRequest httpServletRequest,
+        final HttpServletResponse httpServletResponse)
+        throws IOException, ServletException {
+      switch (path) {
+        case "/blocking":
+          request.setHandled(true);
+          try {
+            Thread.sleep(100);
+          } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+          }
+          httpServletResponse.setStatus(200);
+          httpServletResponse.setContentType("text/plain");
+          httpServletResponse.getWriter().write("some content from the blocking request\n");
+          break;
+        case "/async":
+          request.setHandled(true);
+          final AsyncContext context = request.startAsync();
+          Thread t =
+              new Thread(
+                  () -> {
                     try {
-                        Thread.sleep(100);
+                      Thread.sleep(100);
                     } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
+                      Thread.currentThread().interrupt();
                     }
                     httpServletResponse.setStatus(200);
                     httpServletResponse.setContentType("text/plain");
-                    httpServletResponse.getWriter().write("some content from the blocking request\n");
-                    break;
-                case "/async":
-                    request.setHandled(true);
-                    final AsyncContext context = request.startAsync();
-                    Thread t = new Thread(() -> {
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e) {
-                            Thread.currentThread().interrupt();
-                        }
-                        httpServletResponse.setStatus(200);
-                        httpServletResponse.setContentType("text/plain");
-                        final ServletOutputStream servletOutputStream;
-                        try {
-                            servletOutputStream = httpServletResponse.getOutputStream();
-                            servletOutputStream.setWriteListener(
-                                    new WriteListener() {
-                                        @Override
-                                        public void onWritePossible() throws IOException {
-                                            servletOutputStream.write("some content from the async\n"
-                                                    .getBytes(StandardCharsets.UTF_8));
-                                            context.complete();
-                                        }
-
-                                        @Override
-                                        public void onError(Throwable throwable) {
-                                            context.complete();
-                                        }
-                                    }
-                            );
-                        } catch (IOException e) {
-                            context.complete();
-                        }
-                    });
-                    t.start();
-                    break;
-                default:
-                    break;
-            }
-        }
+                    final ServletOutputStream servletOutputStream;
+                    try {
+                      servletOutputStream = httpServletResponse.getOutputStream();
+                      servletOutputStream.setWriteListener(
+                          new WriteListener() {
+                            @Override
+                            public void onWritePossible() throws IOException {
+                              servletOutputStream.write(
+                                  "some content from the async\n".getBytes(UTF_8));
+                              context.complete();
+                            }
+
+                            @Override
+                            public void onError(Throwable throwable) {
+                              context.complete();
+                            }
+                          });
+                    } catch (IOException e) {
+                      context.complete();
+                    }
+                  });
+          t.start();
+          break;
+        default:
+          break;
+      }
     }
+  }
 }
--- a/metrics-jetty11/src/test/java/io/dropwizard/metrics5/jetty11/InstrumentedHttpChannelListenerTest.java
+++ b/metrics-jetty11/src/test/java/io/dropwizard/metrics5/jetty11/InstrumentedHttpChannelListenerTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.jetty11;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import jakarta.servlet.AsyncContext;
@@ -7,6 +11,7 @@ import jakarta.servlet.ServletOutputStream;
 import jakarta.servlet.WriteListener;
 import jakarta.servlet.http.HttpServletRequest;
 import jakarta.servlet.http.HttpServletResponse;
+import java.io.IOException;
 import org.eclipse.jetty.client.HttpClient;
 import org.eclipse.jetty.client.api.ContentResponse;
 import org.eclipse.jetty.server.Request;
@@ -17,197 +22,190 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static org.assertj.core.api.Assertions.assertThat;
-
-class InstrumentedHttpChannelListenerTest {
-    private final HttpClient client = new HttpClient();
-    private final Server server = new Server();
-    private final ServerConnector connector = new ServerConnector(server);
-    private final TestHandler handler = new TestHandler();
-    private MetricRegistry registry;
-
-    @BeforeEach
-    void setUp() throws Exception {
-        registry = new MetricRegistry();
-        connector.addBean(new InstrumentedHttpChannelListener(registry, MetricRegistry.name(TestHandler.class, "handler"), ALL));
-        server.addConnector(connector);
-        server.setHandler(handler);
-        server.start();
-        client.start();
+final class InstrumentedHttpChannelListenerTest {
+  private final HttpClient client = new HttpClient();
+  private final Server server = new Server();
+  private final ServerConnector connector = new ServerConnector(server);
+  private final TestHandler handler = new TestHandler();
+  private MetricRegistry registry;
+
+  @BeforeEach
+  void setUp() throws Exception {
+    registry = new MetricRegistry();
+    connector.addBean(
+        new InstrumentedHttpChannelListener(
+            registry, MetricRegistry.name(TestHandler.class, "handler"), ALL));
+    server.addConnector(connector);
+    server.setHandler(handler);
+    server.start();
+    client.start();
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    server.stop();
+    client.stop();
+  }
+
+  @Test
+  void createsMetricsForTheHandler() throws Exception {
+    final ContentResponse response = client.GET(uri("/hello"));
+
+    assertThat(response.getStatus()).isEqualTo(404);
+
+    assertThat(registry.getNames())
+        .containsOnly(
+            metricName("1xx-responses"),
+            metricName("2xx-responses"),
+            metricName("3xx-responses"),
+            metricName("404-responses"),
+            metricName("4xx-responses"),
+            metricName("5xx-responses"),
+            metricName("percent-4xx-1m"),
+            metricName("percent-4xx-5m"),
+            metricName("percent-4xx-15m"),
+            metricName("percent-5xx-1m"),
+            metricName("percent-5xx-5m"),
+            metricName("percent-5xx-15m"),
+            metricName("requests"),
+            metricName("active-suspended"),
+            metricName("async-dispatches"),
+            metricName("async-timeouts"),
+            metricName("get-requests"),
+            metricName("put-requests"),
+            metricName("active-dispatches"),
+            metricName("trace-requests"),
+            metricName("other-requests"),
+            metricName("connect-requests"),
+            metricName("dispatches"),
+            metricName("head-requests"),
+            metricName("post-requests"),
+            metricName("options-requests"),
+            metricName("active-requests"),
+            metricName("delete-requests"),
+            metricName("move-requests"));
+  }
+
+  @Test
+  void responseTimesAreRecordedForBlockingResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/blocking"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getMediaType()).isEqualTo("text/plain");
+    assertThat(response.getContentAsString()).isEqualTo("some content from the blocking request");
+
+    assertResponseTimesValid();
+  }
+
+  @Test
+  void responseTimesAreRecordedForAsyncResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/async"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getMediaType()).isEqualTo("text/plain");
+    assertThat(response.getContentAsString()).isEqualTo("some content from the async");
+
+    assertResponseTimesValid();
+  }
+
+  private void assertResponseTimesValid() {
+    try {
+      Thread.sleep(100);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
     }
 
-    @AfterEach
-    void tearDown() throws Exception {
-        server.stop();
-        client.stop();
-    }
-
-    @Test
-    void createsMetricsForTheHandler() throws Exception {
-        final ContentResponse response = client.GET(uri("/hello"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(404);
-
-        assertThat(registry.getNames())
-                .containsOnly(
-                        metricName("1xx-responses"),
-                        metricName("2xx-responses"),
-                        metricName("3xx-responses"),
-                        metricName("404-responses"),
-                        metricName("4xx-responses"),
-                        metricName("5xx-responses"),
-                        metricName("percent-4xx-1m"),
-                        metricName("percent-4xx-5m"),
-                        metricName("percent-4xx-15m"),
-                        metricName("percent-5xx-1m"),
-                        metricName("percent-5xx-5m"),
-                        metricName("percent-5xx-15m"),
-                        metricName("requests"),
-                        metricName("active-suspended"),
-                        metricName("async-dispatches"),
-                        metricName("async-timeouts"),
-                        metricName("get-requests"),
-                        metricName("put-requests"),
-                        metricName("active-dispatches"),
-                        metricName("trace-requests"),
-                        metricName("other-requests"),
-                        metricName("connect-requests"),
-                        metricName("dispatches"),
-                        metricName("head-requests"),
-                        metricName("post-requests"),
-                        metricName("options-requests"),
-                        metricName("active-requests"),
-                        metricName("delete-requests"),
-                        metricName("move-requests")
-                );
-    }
-
-
-    @Test
-    void responseTimesAreRecordedForBlockingResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/blocking"));
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.getMediaType()).isEqualTo("text/plain");
-        assertThat(response.getContentAsString()).isEqualTo("some content from the blocking request");
-
-        assertResponseTimesValid();
-    }
-
-    @Test
-    void responseTimesAreRecordedForAsyncResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/async"));
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.getMediaType()).isEqualTo("text/plain");
-        assertThat(response.getContentAsString()).isEqualTo("some content from the async");
-
-        assertResponseTimesValid();
-    }
-
-    private void assertResponseTimesValid() {
-        try {
+    assertThat(registry.getMeters().get(metricName("2xx-responses")).getCount()).isPositive();
+    assertThat(registry.getMeters().get(metricName("200-responses")).getCount()).isPositive();
+
+    assertThat(registry.getTimers().get(metricName("get-requests")).getSnapshot().getMedian())
+        .isPositive();
+
+    assertThat(registry.getTimers().get(metricName("requests")).getSnapshot().getMedian())
+        .isPositive();
+  }
+
+  private String uri(String path) {
+    return "http://localhost:" + connector.getLocalPort() + path;
+  }
+
+  private MetricName metricName(String metricName) {
+    return MetricRegistry.name(TestHandler.class.getName(), "handler", metricName);
+  }
+
+  /**
+   * test handler.
+   *
+   * <p>Supports
+   *
+   * <p>/blocking - uses the standard servlet api /async - uses the 3.1 async api to complete the
+   * request
+   *
+   * <p>all other requests will return 404
+   */
+  private static class TestHandler extends AbstractHandler {
+    @Override
+    public void handle(
+        String path,
+        Request request,
+        final HttpServletRequest httpServletRequest,
+        final HttpServletResponse httpServletResponse)
+        throws IOException {
+      switch (path) {
+        case "/blocking":
+          request.setHandled(true);
+          httpServletResponse.setStatus(200);
+          httpServletResponse.setContentType("text/plain");
+          httpServletResponse.getWriter().write("some content from the blocking request");
+          try {
             Thread.sleep(100);
-        } catch (InterruptedException e) {
+          } catch (InterruptedException e) {
+            httpServletResponse.setStatus(500);
             Thread.currentThread().interrupt();
-        }
-
-        assertThat(registry.getMeters().get(metricName("2xx-responses"))
-                .getCount()).isPositive();
-        assertThat(registry.getMeters().get(metricName("200-responses"))
-                .getCount()).isPositive();
-
-        assertThat(registry.getTimers().get(metricName("get-requests"))
-                .getSnapshot().getMedian()).isPositive();
-
-        assertThat(registry.getTimers().get(metricName("requests"))
-                .getSnapshot().getMedian()).isPositive();
-    }
-
-    private String uri(String path) {
-        return "http://localhost:" + connector.getLocalPort() + path;
-    }
-
-    private MetricName metricName(String metricName) {
-        return MetricRegistry.name(TestHandler.class.getName(), "handler", metricName);
-    }
-
-    /**
-     * test handler.
-     * <p>
-     * Supports
-     * <p>
-     * /blocking - uses the standard servlet api
-     * /async - uses the 3.1 async api to complete the request
-     * <p>
-     * all other requests will return 404
-     */
-    private static class TestHandler extends AbstractHandler {
-        @Override
-        public void handle(
-                String path,
-                Request request,
-                final HttpServletRequest httpServletRequest,
-                final HttpServletResponse httpServletResponse) throws IOException {
-            switch (path) {
-                case "/blocking":
-                    request.setHandled(true);
+          }
+          break;
+        case "/async":
+          request.setHandled(true);
+          final AsyncContext context = request.startAsync();
+          Thread t =
+              new Thread(
+                  () -> {
                     httpServletResponse.setStatus(200);
                     httpServletResponse.setContentType("text/plain");
-                    httpServletResponse.getWriter().write("some content from the blocking request");
                     try {
-                        Thread.sleep(100);
+                      Thread.sleep(100);
                     } catch (InterruptedException e) {
-                        httpServletResponse.setStatus(500);
-                        Thread.currentThread().interrupt();
+                      httpServletResponse.setStatus(500);
+                      Thread.currentThread().interrupt();
+                    }
+                    final ServletOutputStream servletOutputStream;
+                    try {
+                      servletOutputStream = httpServletResponse.getOutputStream();
+                      servletOutputStream.setWriteListener(
+                          new WriteListener() {
+                            @Override
+                            public void onWritePossible() throws IOException {
+                              servletOutputStream.write(
+                                  "some content from the async".getBytes(UTF_8));
+                              context.complete();
+                            }
+
+                            @Override
+                            public void onError(Throwable throwable) {
+                              context.complete();
+                            }
+                          });
+                    } catch (IOException e) {
+                      context.complete();
                     }
-                    break;
-                case "/async":
-                    request.setHandled(true);
-                    final AsyncContext context = request.startAsync();
-                    Thread t = new Thread(() -> {
-                        httpServletResponse.setStatus(200);
-                        httpServletResponse.setContentType("text/plain");
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e) {
-                            httpServletResponse.setStatus(500);
-                            Thread.currentThread().interrupt();
-                        }
-                        final ServletOutputStream servletOutputStream;
-                        try {
-                            servletOutputStream = httpServletResponse.getOutputStream();
-                            servletOutputStream.setWriteListener(
-                                    new WriteListener() {
-                                        @Override
-                                        public void onWritePossible() throws IOException {
-                                            servletOutputStream.write("some content from the async"
-                                                    .getBytes(StandardCharsets.UTF_8));
-                                            context.complete();
-                                        }
-
-                                        @Override
-                                        public void onError(Throwable throwable) {
-                                            context.complete();
-                                        }
-                                    }
-                            );
-                        } catch (IOException e) {
-                            context.complete();
-                        }
-                    });
-                    t.start();
-                    break;
-                default:
-                    break;
-            }
-        }
+                  });
+          t.start();
+          break;
+        default:
+          break;
+      }
     }
+  }
 }
--- a/metrics-jetty11/src/test/java/io/dropwizard/metrics5/jetty11/InstrumentedQueuedThreadPoolTest.java
+++ b/metrics-jetty11/src/test/java/io/dropwizard/metrics5/jetty11/InstrumentedQueuedThreadPoolTest.java
@@ -1,52 +1,52 @@
 package io.dropwizard.metrics5.jetty11;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class InstrumentedQueuedThreadPoolTest {
-    private static final String PREFIX = "prefix";
-
-    private MetricRegistry metricRegistry;
-    private InstrumentedQueuedThreadPool iqtp;
-
-    @BeforeEach
-    void setUp() {
-        metricRegistry = new MetricRegistry();
-        iqtp = new InstrumentedQueuedThreadPool(metricRegistry);
-    }
-
-    @Test
-    void customMetricsPrefix() throws Exception {
-        iqtp.setPrefix(PREFIX);
-        iqtp.start();
-
-        assertThat(metricRegistry.getNames())
-                .extracting(MetricName::getKey)
-                .overridingErrorMessage("Custom metrics prefix doesn't match")
-                .allSatisfy(name -> assertThat(name).startsWith(PREFIX));
-
-        iqtp.stop();
-        assertThat(metricRegistry.getMetrics())
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .isEmpty();
-    }
-
-    @Test
-    void metricsPrefixBackwardCompatible() throws Exception {
-        iqtp.start();
-        assertThat(metricRegistry.getNames())
-                .extracting(MetricName::getKey)
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .allSatisfy(name -> assertThat(name).startsWith(QueuedThreadPool.class.getName()));
-
-        iqtp.stop();
-        assertThat(metricRegistry.getMetrics())
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .isEmpty();
-    }
+final class InstrumentedQueuedThreadPoolTest {
+  private static final String PREFIX = "prefix";
+
+  private MetricRegistry metricRegistry;
+  private InstrumentedQueuedThreadPool iqtp;
+
+  @BeforeEach
+  void setUp() {
+    metricRegistry = new MetricRegistry();
+    iqtp = new InstrumentedQueuedThreadPool(metricRegistry);
+  }
+
+  @Test
+  void customMetricsPrefix() throws Exception {
+    iqtp.setPrefix(PREFIX);
+    iqtp.start();
+
+    assertThat(metricRegistry.getNames())
+        .extracting(MetricName::getKey)
+        .overridingErrorMessage("Custom metrics prefix doesn't match")
+        .allSatisfy(name -> assertThat(name).startsWith(PREFIX));
+
+    iqtp.stop();
+    assertThat(metricRegistry.getMetrics())
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .isEmpty();
+  }
+
+  @Test
+  void metricsPrefixBackwardCompatible() throws Exception {
+    iqtp.start();
+    assertThat(metricRegistry.getNames())
+        .extracting(MetricName::getKey)
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .allSatisfy(name -> assertThat(name).startsWith(QueuedThreadPool.class.getName()));
+
+    iqtp.stop();
+    assertThat(metricRegistry.getMetrics())
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .isEmpty();
+  }
 }
--- a/metrics-jetty12-ee10/src/main/java/io/dropwizard/metrics/jetty12/ee10/InstrumentedEE10Handler.java
+++ b/metrics-jetty12-ee10/src/main/java/io/dropwizard/metrics/jetty12/ee10/InstrumentedEE10Handler.java
@@ -1,10 +1,14 @@
 package io.dropwizard.metrics.jetty12.ee10;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+
+import io.dropwizard.metrics.jetty12.AbstractInstrumentedHandler;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.annotation.ResponseMeteredLevel;
-import io.dropwizard.metrics.jetty12.AbstractInstrumentedHandler;
 import jakarta.servlet.AsyncEvent;
 import jakarta.servlet.AsyncListener;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 import org.eclipse.jetty.ee10.servlet.AsyncContextState;
 import org.eclipse.jetty.ee10.servlet.ServletApiRequest;
 import org.eclipse.jetty.ee10.servlet.ServletApiResponse;
@@ -15,162 +19,160 @@ import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Response;
 import org.eclipse.jetty.util.Callback;
 
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-
 /**
  * A Jetty {@link Handler} which records various metrics about an underlying {@link Handler}
- * instance. This {@link Handler} requires a {@link org.eclipse.jetty.ee10.servlet.ServletContextHandler} to be present.
- * For correct behaviour, the {@link org.eclipse.jetty.ee10.servlet.ServletContextHandler} should be before this handler
- * in the handler chain. To achieve this, one can use
- * {@link org.eclipse.jetty.ee10.servlet.ServletContextHandler#insertHandler(Singleton)}.
+ * instance. This {@link Handler} requires a {@link
+ * org.eclipse.jetty.ee10.servlet.ServletContextHandler} to be present. For correct behaviour, the
+ * {@link org.eclipse.jetty.ee10.servlet.ServletContextHandler} should be before this handler in the
+ * handler chain. To achieve this, one can use {@link
+ * org.eclipse.jetty.ee10.servlet.ServletContextHandler#insertHandler(Singleton)}.
  */
 public class InstrumentedEE10Handler extends AbstractInstrumentedHandler {
-    private AsyncListener listener;
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     */
-    public InstrumentedEE10Handler(MetricRegistry registry) {
-        super(registry, null);
+  private AsyncListener listener;
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   */
+  public InstrumentedEE10Handler(MetricRegistry registry) {
+    super(registry, null);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param prefix the prefix to use for the metrics names
+   */
+  public InstrumentedEE10Handler(MetricRegistry registry, String prefix) {
+    super(registry, prefix, COARSE);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param prefix the prefix to use for the metrics names
+   * @param responseMeteredLevel the level to determine individual/aggregate response codes that are
+   *     instrumented
+   */
+  public InstrumentedEE10Handler(
+      MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
+    super(registry, prefix, responseMeteredLevel);
+  }
+
+  @Override
+  protected void doStart() throws Exception {
+    super.doStart();
+
+    this.listener = new AsyncAttachingListener();
+  }
+
+  @Override
+  protected void doStop() throws Exception {
+    super.doStop();
+  }
+
+  @Override
+  public boolean handle(Request request, Response response, Callback callback) throws Exception {
+    ServletContextRequest servletContextRequest = Request.as(request, ServletContextRequest.class);
+
+    // only handle servlet requests with the InstrumentedHandler
+    // because it depends on the ServletRequestState
+    if (servletContextRequest == null) {
+      return super.handle(request, response, callback);
     }
 
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param prefix   the prefix to use for the metrics names
-     */
-    public InstrumentedEE10Handler(MetricRegistry registry, String prefix) {
-        super(registry, prefix, COARSE);
+    activeDispatches.inc();
+
+    final long start;
+    final ServletChannelState state = servletContextRequest.getServletRequestState();
+    if (state.isInitial()) {
+      // new request
+      activeRequests.inc();
+      start = Request.getTimeStamp(request);
+      state.addListener(listener);
+    } else {
+      // resumed request
+      start = System.currentTimeMillis();
+      activeSuspended.dec();
+      if (state.getState() == ServletChannelState.State.HANDLING) {
+        asyncDispatches.mark();
+      }
     }
 
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param prefix   the prefix to use for the metrics names
-     * @param responseMeteredLevel the level to determine individual/aggregate response codes that are instrumented
-     */
-    public InstrumentedEE10Handler(MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
-        super(registry, prefix, responseMeteredLevel);
-    }
+    boolean handled = false;
 
-    @Override
-    protected void doStart() throws Exception {
-        super.doStart();
+    try {
+      handled = super.handle(request, response, callback);
+    } finally {
+      final long now = System.currentTimeMillis();
+      final long dispatched = now - start;
 
-        this.listener = new AsyncAttachingListener();
+      activeDispatches.dec();
+      dispatches.update(dispatched, TimeUnit.MILLISECONDS);
+
+      if (state.isSuspended()) {
+        activeSuspended.inc();
+      } else if (state.isInitial()) {
+        updateResponses(request, response, start, handled);
+      }
+      // else onCompletion will handle it.
     }
 
+    return handled;
+  }
+
+  private class AsyncAttachingListener implements AsyncListener {
+
     @Override
-    protected void doStop() throws Exception {
-        super.doStop();
-    }
+    public void onTimeout(AsyncEvent event) throws IOException {}
 
     @Override
-    public boolean handle(Request request, Response response, Callback callback) throws Exception {
-        ServletContextRequest servletContextRequest = Request.as(request, ServletContextRequest.class);
-
-        // only handle servlet requests with the InstrumentedHandler
-        // because it depends on the ServletRequestState
-        if (servletContextRequest == null) {
-            return super.handle(request, response, callback);
-        }
-
-        activeDispatches.inc();
-
-        final long start;
-        final ServletChannelState state = servletContextRequest.getServletRequestState();
-        if (state.isInitial()) {
-            // new request
-            activeRequests.inc();
-            start = Request.getTimeStamp(request);
-            state.addListener(listener);
-        } else {
-            // resumed request
-            start = System.currentTimeMillis();
-            activeSuspended.dec();
-            if (state.getState() == ServletChannelState.State.HANDLING) {
-                asyncDispatches.mark();
-            }
-        }
-
-        boolean handled = false;
-
-        try {
-            handled = super.handle(request, response, callback);
-        } finally {
-            final long now = System.currentTimeMillis();
-            final long dispatched = now - start;
-
-            activeDispatches.dec();
-            dispatches.update(dispatched, TimeUnit.MILLISECONDS);
-
-            if (state.isSuspended()) {
-                activeSuspended.inc();
-            } else if (state.isInitial()) {
-                updateResponses(request, response, start, handled);
-            }
-            // else onCompletion will handle it.
-        }
-
-        return handled;
+    public void onStartAsync(AsyncEvent event) throws IOException {
+      event.getAsyncContext().addListener(new InstrumentedAsyncListener());
     }
 
-    private class AsyncAttachingListener implements AsyncListener {
+    @Override
+    public void onError(AsyncEvent event) throws IOException {}
 
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {}
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {}
+  }
 
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-            event.getAsyncContext().addListener(new InstrumentedAsyncListener());
-        }
+  private class InstrumentedAsyncListener implements AsyncListener {
+    private final long startTime;
 
-        @Override
-        public void onError(AsyncEvent event) throws IOException {}
+    InstrumentedAsyncListener() {
+      this.startTime = System.currentTimeMillis();
+    }
 
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {}
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {
+      asyncTimeouts.mark();
     }
 
-    private class InstrumentedAsyncListener implements AsyncListener {
-        private final long startTime;
-
-        InstrumentedAsyncListener() {
-            this.startTime = System.currentTimeMillis();
-        }
-
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {
-            asyncTimeouts.mark();
-        }
-
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
-        }
-
-        @Override
-        public void onError(AsyncEvent event) throws IOException {
-        }
-
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {
-            final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
-            final ServletApiRequest request = (ServletApiRequest) state.getRequest();
-            final ServletApiResponse response = (ServletApiResponse) state.getResponse();
-            updateResponses(request.getRequest(), response.getResponse(), startTime, true);
-
-            final ServletContextRequest servletContextRequest = Request.as(request.getRequest(), ServletContextRequest.class);
-            final ServletChannelState servletRequestState = servletContextRequest.getServletRequestState();
-            if (!servletRequestState.isSuspended()) {
-                activeSuspended.dec();
-            }
-        }
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {}
+
+    @Override
+    public void onError(AsyncEvent event) throws IOException {}
+
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {
+      final AsyncContextState state = (AsyncContextState) event.getAsyncContext();
+      final ServletApiRequest request = (ServletApiRequest) state.getRequest();
+      final ServletApiResponse response = (ServletApiResponse) state.getResponse();
+      updateResponses(request.getRequest(), response.getResponse(), startTime, true);
+
+      final ServletContextRequest servletContextRequest =
+          Request.as(request.getRequest(), ServletContextRequest.class);
+      final ServletChannelState servletRequestState =
+          servletContextRequest.getServletRequestState();
+      if (!servletRequestState.isSuspended()) {
+        activeSuspended.dec();
+      }
     }
+  }
 }
--- a/metrics-jetty12-ee10/src/test/java/io/dropwizard/metrics/jetty12/ee10/InstrumentedEE10HandlerTest.java
+++ b/metrics-jetty12-ee10/src/test/java/io/dropwizard/metrics/jetty12/ee10/InstrumentedEE10HandlerTest.java
@@ -1,7 +1,21 @@
 package io.dropwizard.metrics.jetty12.ee10;
 
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatCode;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
+import jakarta.servlet.AsyncContext;
+import jakarta.servlet.ServletOutputStream;
+import jakarta.servlet.WriteListener;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 import org.eclipse.jetty.client.ContentResponse;
 import org.eclipse.jetty.client.HttpClient;
 import org.eclipse.jetty.ee10.servlet.DefaultServlet;
@@ -13,262 +27,251 @@ import org.eclipse.jetty.server.Response;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.util.Callback;
-
-import jakarta.servlet.AsyncContext;
-import jakarta.servlet.ServletOutputStream;
-import jakarta.servlet.WriteListener;
-import jakarta.servlet.http.HttpServletRequest;
-import jakarta.servlet.http.HttpServletResponse;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatCode;
-
-public class InstrumentedEE10HandlerTest {
-    private final HttpClient client = new HttpClient();
-    private final MetricRegistry registry = new MetricRegistry();
-    private final Server server = new Server();
-    private final ServerConnector connector = new ServerConnector(server);
-    private final InstrumentedEE10Handler handler = new InstrumentedEE10Handler(registry, null, ALL);
-
-    @BeforeEach
-    public void setUp() throws Exception {
-        handler.setName("handler");
-
-        TestHandler testHandler = new TestHandler();
-        // a servlet handler needs a servlet mapping, else the request will be short-circuited
-        // so use the DefaultServlet here
-        testHandler.addServletWithMapping(DefaultServlet.class, "/");
-
-        // builds the following handler chain:
-        // ServletContextHandler -> InstrumentedHandler -> TestHandler
-        // the ServletContextHandler is needed to utilize servlet related classes
-        ServletContextHandler servletContextHandler = new ServletContextHandler();
-        servletContextHandler.setHandler(testHandler);
-        servletContextHandler.insertHandler(handler);
-        server.setHandler(servletContextHandler);
-
-        server.addConnector(connector);
-        server.start();
-        client.start();
-    }
-
-    @AfterEach
-    public void tearDown() throws Exception {
-        server.stop();
-        client.stop();
-    }
-
-    @Test
-    public void hasAName() throws Exception {
-        assertThat(handler.getName())
-                .isEqualTo("handler");
-    }
-
-    @Test
-    public void createsAndRemovesMetricsForTheHandler() throws Exception {
-        final ContentResponse response = client.GET(uri("/hello"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(404);
-
-        assertThat(registry.getNames())
-                .containsOnly(
-                        MetricRegistry.name(TestHandler.class, "handler.1xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.2xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.3xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.4xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.404-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.5xx-responses"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-1m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-5m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-4xx-15m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-1m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-5m"),
-                        MetricRegistry.name(TestHandler.class, "handler.percent-5xx-15m"),
-                        MetricRegistry.name(TestHandler.class, "handler.requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-suspended"),
-                        MetricRegistry.name(TestHandler.class, "handler.async-dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.async-timeouts"),
-                        MetricRegistry.name(TestHandler.class, "handler.get-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.put-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.trace-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.other-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.connect-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.dispatches"),
-                        MetricRegistry.name(TestHandler.class, "handler.head-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.post-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.options-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.active-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.delete-requests"),
-                        MetricRegistry.name(TestHandler.class, "handler.move-requests")
-                );
-
-        server.stop();
-
-        assertThat(registry.getNames())
-                .isEmpty();
-    }
-
-    @Test
-    @Disabled("flaky on virtual machines")
-    public void responseTimesAreRecordedForBlockingResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/blocking"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-
-        assertResponseTimesValid();
-    }
-
-    @Test
-    public void doStopDoesNotThrowNPE() throws Exception {
-        InstrumentedEE10Handler handler = new InstrumentedEE10Handler(registry, null, ALL);
-        handler.setHandler(new TestHandler());
-
-        assertThatCode(handler::doStop).doesNotThrowAnyException();
-    }
-
-    @Test
-    public void gaugesAreRegisteredWithResponseMeteredLevelCoarse() throws Exception {
-        InstrumentedEE10Handler handler = new InstrumentedEE10Handler(registry, "coarse", COARSE);
-        handler.setHandler(new TestHandler());
-        handler.setName("handler");
-        handler.doStart();
-        assertThat(registry.getGauges()).containsKey(MetricName.build("coarse", "handler", "percent-4xx-1m"));
-    }
-
-    @Test
-    public void gaugesAreNotRegisteredWithResponseMeteredLevelDetailed() throws Exception {
-        InstrumentedEE10Handler handler = new InstrumentedEE10Handler(registry, "detailed", DETAILED);
-        handler.setHandler(new TestHandler());
-        handler.setName("handler");
-        handler.doStart();
-        assertThat(registry.getGauges()).doesNotContainKey(MetricName.build("detailed", "handler", "percent-4xx-1m"));
-    }
-
-    @Test
-    @Disabled("flaky on virtual machines")
-    public void responseTimesAreRecordedForAsyncResponses() throws Exception {
-
-        final ContentResponse response = client.GET(uri("/async"));
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-
-        assertResponseTimesValid();
-    }
-
-    private void assertResponseTimesValid() {
-        assertThat(registry.getMeters().get(metricName().resolve("2xx-responses"))
-                .getCount()).isGreaterThan(0L);
-        assertThat(registry.getMeters().get(metricName().resolve(".200-responses"))
-                .getCount()).isGreaterThan(0L);
-
-
-        assertThat(registry.getTimers().get(metricName().resolve(".get-requests"))
-                .getSnapshot().getMedian()).isGreaterThan(0.0).isLessThan(TimeUnit.SECONDS.toNanos(1));
-
-        assertThat(registry.getTimers().get(metricName().resolve(".requests"))
-                .getSnapshot().getMedian()).isGreaterThan(0.0).isLessThan(TimeUnit.SECONDS.toNanos(1));
-    }
-
-    private String uri(String path) {
-        return "http://localhost:" + connector.getLocalPort() + path;
-    }
-
-    private MetricName metricName() {
-        return MetricRegistry.name(TestHandler.class.getName(), "handler");
-    }
-
-    /**
-     * test handler.
-     * <p>
-     * Supports
-     * <p>
-     * /blocking - uses the standard servlet api
-     * /async - uses the 3.1 async api to complete the request
-     * <p>
-     * all other requests will return 404
-     */
-    private static class TestHandler extends ServletHandler {
-        @Override
-        public boolean handle(Request request, Response response, Callback callback) throws Exception {
-            ServletContextRequest servletContextRequest = Request.as(request, ServletContextRequest.class);
-            if (servletContextRequest == null) {
-                return false;
-            }
-
-            HttpServletRequest httpServletRequest = servletContextRequest.getServletApiRequest();
-            HttpServletResponse httpServletResponse = servletContextRequest.getHttpServletResponse();
-
-            String path = request.getHttpURI().getPath();
-            switch (path) {
-                case "/blocking":
+final class InstrumentedEE10HandlerTest {
+  private final HttpClient client = new HttpClient();
+  private final MetricRegistry registry = new MetricRegistry();
+  private final Server server = new Server();
+  private final ServerConnector connector = new ServerConnector(server);
+  private final InstrumentedEE10Handler handler = new InstrumentedEE10Handler(registry, null, ALL);
+
+  @BeforeEach
+  void setUp() throws Exception {
+    handler.setName("handler");
+
+    TestHandler testHandler = new TestHandler();
+    // a servlet handler needs a servlet mapping, else the request will be short-circuited
+    // so use the DefaultServlet here
+    testHandler.addServletWithMapping(DefaultServlet.class, "/");
+
+    // builds the following handler chain:
+    // ServletContextHandler -> InstrumentedHandler -> TestHandler
+    // the ServletContextHandler is needed to utilize servlet related classes
+    ServletContextHandler servletContextHandler = new ServletContextHandler();
+    servletContextHandler.setHandler(testHandler);
+    servletContextHandler.insertHandler(handler);
+    server.setHandler(servletContextHandler);
+
+    server.addConnector(connector);
+    server.start();
+    client.start();
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    server.stop();
+    client.stop();
+  }
+
+  @Test
+  void hasAName() throws Exception {
+    assertThat(handler.getName()).isEqualTo("handler");
+  }
+
+  @Test
+  void createsAndRemovesMetricsForTheHandler() throws Exception {
+    final ContentResponse response = client.GET(uri("/hello"));
+
+    assertThat(response.getStatus()).isEqualTo(404);
+
+    assertThat(registry.getNames())
+        .containsOnly(
+            MetricRegistry.name(TestHandler.class, "handler.1xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.2xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.3xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.4xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.404-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.5xx-responses"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-1m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-5m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-4xx-15m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-1m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-5m"),
+            MetricRegistry.name(TestHandler.class, "handler.percent-5xx-15m"),
+            MetricRegistry.name(TestHandler.class, "handler.requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-suspended"),
+            MetricRegistry.name(TestHandler.class, "handler.async-dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.async-timeouts"),
+            MetricRegistry.name(TestHandler.class, "handler.get-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.put-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.trace-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.other-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.connect-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.dispatches"),
+            MetricRegistry.name(TestHandler.class, "handler.head-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.post-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.options-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.active-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.delete-requests"),
+            MetricRegistry.name(TestHandler.class, "handler.move-requests"));
+
+    server.stop();
+
+    assertThat(registry.getNames()).isEmpty();
+  }
+
+  @Disabled("flaky on virtual machines")
+  @Test
+  void responseTimesAreRecordedForBlockingResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/blocking"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+
+    assertResponseTimesValid();
+  }
+
+  @Test
+  void doStopDoesNotThrowNPE() throws Exception {
+    InstrumentedEE10Handler handler = new InstrumentedEE10Handler(registry, null, ALL);
+    handler.setHandler(new TestHandler());
+
+    assertThatCode(handler::doStop).doesNotThrowAnyException();
+  }
+
+  @Test
+  void gaugesAreRegisteredWithResponseMeteredLevelCoarse() throws Exception {
+    InstrumentedEE10Handler handler = new InstrumentedEE10Handler(registry, "coarse", COARSE);
+    handler.setHandler(new TestHandler());
+    handler.setName("handler");
+    handler.doStart();
+    assertThat(registry.getGauges())
+        .containsKey(MetricName.build("coarse", "handler", "percent-4xx-1m"));
+  }
+
+  @Test
+  void gaugesAreNotRegisteredWithResponseMeteredLevelDetailed() throws Exception {
+    InstrumentedEE10Handler handler = new InstrumentedEE10Handler(registry, "detailed", DETAILED);
+    handler.setHandler(new TestHandler());
+    handler.setName("handler");
+    handler.doStart();
+    assertThat(registry.getGauges())
+        .doesNotContainKey(MetricName.build("detailed", "handler", "percent-4xx-1m"));
+  }
+
+  @Disabled("flaky on virtual machines")
+  @Test
+  void responseTimesAreRecordedForAsyncResponses() throws Exception {
+
+    final ContentResponse response = client.GET(uri("/async"));
+
+    assertThat(response.getStatus()).isEqualTo(200);
+
+    assertResponseTimesValid();
+  }
+
+  private void assertResponseTimesValid() {
+    assertThat(registry.getMeters().get(metricName().resolve("2xx-responses")).getCount())
+        .isPositive();
+    assertThat(registry.getMeters().get(metricName().resolve(".200-responses")).getCount())
+        .isPositive();
+
+    assertThat(
+            registry
+                .getTimers()
+                .get(metricName().resolve(".get-requests"))
+                .getSnapshot()
+                .getMedian())
+        .isPositive()
+        .isLessThan(TimeUnit.SECONDS.toNanos(1));
+
+    assertThat(
+            registry.getTimers().get(metricName().resolve(".requests")).getSnapshot().getMedian())
+        .isPositive()
+        .isLessThan(TimeUnit.SECONDS.toNanos(1));
+  }
+
+  private String uri(String path) {
+    return "http://localhost:" + connector.getLocalPort() + path;
+  }
+
+  private MetricName metricName() {
+    return MetricRegistry.name(TestHandler.class.getName(), "handler");
+  }
+
+  /**
+   * test handler.
+   *
+   * <p>Supports
+   *
+   * <p>/blocking - uses the standard servlet api /async - uses the 3.1 async api to complete the
+   * request
+   *
+   * <p>all other requests will return 404
+   */
+  private static class TestHandler extends ServletHandler {
+    @Override
+    public boolean handle(Request request, Response response, Callback callback) throws Exception {
+      ServletContextRequest servletContextRequest =
+          Request.as(request, ServletContextRequest.class);
+      if (servletContextRequest == null) {
+        return false;
+      }
+
+      HttpServletRequest httpServletRequest = servletContextRequest.getServletApiRequest();
+      HttpServletResponse httpServletResponse = servletContextRequest.getHttpServletResponse();
+
+      String path = request.getHttpURI().getPath();
+      switch (path) {
+        case "/blocking":
+          try {
+            Thread.sleep(100);
+          } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+          }
+          httpServletResponse.setStatus(200);
+          httpServletResponse.setContentType("text/plain");
+          httpServletResponse.getWriter().write("some content from the blocking request\n");
+          callback.succeeded();
+          return true;
+        case "/async":
+          servletContextRequest.getState().handling();
+          final AsyncContext context = httpServletRequest.startAsync();
+          Thread t =
+              new Thread(
+                  () -> {
                     try {
-                        Thread.sleep(100);
+                      Thread.sleep(100);
                     } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
+                      Thread.currentThread().interrupt();
                     }
                     httpServletResponse.setStatus(200);
                     httpServletResponse.setContentType("text/plain");
-                    httpServletResponse.getWriter().write("some content from the blocking request\n");
-                    callback.succeeded();
-                    return true;
-                case "/async":
-                    servletContextRequest.getState().handling();
-                    final AsyncContext context = httpServletRequest.startAsync();
-                    Thread t = new Thread(() -> {
-                        try {
-                            Thread.sleep(100);
-                        } catch (InterruptedException e) {
-                            Thread.currentThread().interrupt();
-                        }
-                        httpServletResponse.setStatus(200);
-                        httpServletResponse.setContentType("text/plain");
-                        final ServletOutputStream servletOutputStream;
-                        try {
-                            servletOutputStream = httpServletResponse.getOutputStream();
-                            servletOutputStream.setWriteListener(
-                                    new WriteListener() {
-                                        @Override
-                                        public void onWritePossible() throws IOException {
-                                            servletOutputStream.write("some content from the async\n"
-                                                    .getBytes(StandardCharsets.UTF_8));
-                                            context.complete();
-                                            servletContextRequest.getServletChannel().handle();
-                                        }
-
-                                        @Override
-                                        public void onError(Throwable throwable) {
-                                            context.complete();
-                                            servletContextRequest.getServletChannel().handle();
-                                        }
-                                    }
-                            );
-                            servletContextRequest.getHttpOutput().run();
-                        } catch (IOException e) {
-                            context.complete();
-                            servletContextRequest.getServletChannel().handle();
-                        }
-                    });
-                    t.start();
-                    return true;
-                default:
-                    return false;
-            }
-        }
+                    final ServletOutputStream servletOutputStream;
+                    try {
+                      servletOutputStream = httpServletResponse.getOutputStream();
+                      servletOutputStream.setWriteListener(
+                          new WriteListener() {
+                            @Override
+                            public void onWritePossible() throws IOException {
+                              servletOutputStream.write(
+                                  "some content from the async\n".getBytes(UTF_8));
+                              context.complete();
+                              servletContextRequest.getServletChannel().handle();
+                            }
+
+                            @Override
+                            public void onError(Throwable throwable) {
+                              context.complete();
+                              servletContextRequest.getServletChannel().handle();
+                            }
+                          });
+                      servletContextRequest.getHttpOutput().run();
+                    } catch (IOException e) {
+                      context.complete();
+                      servletContextRequest.getServletChannel().handle();
+                    }
+                  });
+          t.start();
+          return true;
+        default:
+          return false;
+      }
     }
+  }
 }
--- a/metrics-jetty12/src/main/java/io/dropwizard/metrics/jetty12/AbstractInstrumentedHandler.java
+++ b/metrics-jetty12/src/main/java/io/dropwizard/metrics/jetty12/AbstractInstrumentedHandler.java
@@ -1,5 +1,13 @@
 package io.dropwizard.metrics.jetty12;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
+import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import static java.util.Collections.unmodifiableList;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricName;
@@ -7,335 +15,345 @@ import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.RatioGauge;
 import io.dropwizard.metrics5.Timer;
 import io.dropwizard.metrics5.annotation.ResponseMeteredLevel;
-import org.eclipse.jetty.http.HttpMethod;
-import org.eclipse.jetty.server.Handler;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.Response;
-
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.ALL;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.COARSE;
-import static io.dropwizard.metrics5.annotation.ResponseMeteredLevel.DETAILED;
+import org.eclipse.jetty.http.HttpMethod;
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Response;
 
 /**
- * An abstract base class of a Jetty {@link Handler} which records various metrics about an underlying {@link Handler}
- * instance.
+ * An abstract base class of a Jetty {@link Handler} which records various metrics about an
+ * underlying {@link Handler} instance.
  */
 public abstract class AbstractInstrumentedHandler extends Handler.Wrapper {
-    protected static final String NAME_REQUESTS = "requests";
-    protected static final String NAME_DISPATCHES = "dispatches";
-    protected static final String NAME_ACTIVE_REQUESTS = "active-requests";
-    protected static final String NAME_ACTIVE_DISPATCHES = "active-dispatches";
-    protected static final String NAME_ACTIVE_SUSPENDED = "active-suspended";
-    protected static final String NAME_ASYNC_DISPATCHES = "async-dispatches";
-    protected static final String NAME_ASYNC_TIMEOUTS = "async-timeouts";
-    protected static final String NAME_1XX_RESPONSES = "1xx-responses";
-    protected static final String NAME_2XX_RESPONSES = "2xx-responses";
-    protected static final String NAME_3XX_RESPONSES = "3xx-responses";
-    protected static final String NAME_4XX_RESPONSES = "4xx-responses";
-    protected static final String NAME_5XX_RESPONSES = "5xx-responses";
-    protected static final String NAME_GET_REQUESTS = "get-requests";
-    protected static final String NAME_POST_REQUESTS = "post-requests";
-    protected static final String NAME_HEAD_REQUESTS = "head-requests";
-    protected static final String NAME_PUT_REQUESTS = "put-requests";
-    protected static final String NAME_DELETE_REQUESTS = "delete-requests";
-    protected static final String NAME_OPTIONS_REQUESTS = "options-requests";
-    protected static final String NAME_TRACE_REQUESTS = "trace-requests";
-    protected static final String NAME_CONNECT_REQUESTS = "connect-requests";
-    protected static final String NAME_MOVE_REQUESTS = "move-requests";
-    protected static final String NAME_OTHER_REQUESTS = "other-requests";
-    protected static final String NAME_PERCENT_4XX_1M = "percent-4xx-1m";
-    protected static final String NAME_PERCENT_4XX_5M = "percent-4xx-5m";
-    protected static final String NAME_PERCENT_4XX_15M = "percent-4xx-15m";
-    protected static final String NAME_PERCENT_5XX_1M = "percent-5xx-1m";
-    protected static final String NAME_PERCENT_5XX_5M = "percent-5xx-5m";
-    protected static final String NAME_PERCENT_5XX_15M = "percent-5xx-15m";
-    protected static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
-    protected static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);
-
-    protected final MetricRegistry metricRegistry;
-
-    private String name;
-    protected final String prefix;
-
-    // the requests handled by this handler, excluding active
-    protected Timer requests;
-
-    // the number of dispatches seen by this handler, excluding active
-    protected Timer dispatches;
-
-    // the number of active requests
-    protected Counter activeRequests;
-
-    // the number of active dispatches
-    protected Counter activeDispatches;
-
-    // the number of requests currently suspended.
-    protected Counter activeSuspended;
-
-    // the number of requests that have been asynchronously dispatched
-    protected Meter asyncDispatches;
-
-    // the number of requests that expired while suspended
-    protected Meter asyncTimeouts;
-
-    protected final ResponseMeteredLevel responseMeteredLevel;
-    protected List<Meter> responses;
-    protected Map<Integer, Meter> responseCodeMeters;
-
-    protected Timer getRequests;
-    protected Timer postRequests;
-    protected Timer headRequests;
-    protected Timer putRequests;
-    protected Timer deleteRequests;
-    protected Timer optionsRequests;
-    protected Timer traceRequests;
-    protected Timer connectRequests;
-    protected Timer moveRequests;
-    protected Timer otherRequests;
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     */
-    protected AbstractInstrumentedHandler(MetricRegistry registry) {
-        this(registry, null);
-    }
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param prefix   the prefix to use for the metrics names
-     */
-    protected AbstractInstrumentedHandler(MetricRegistry registry, String prefix) {
-        this(registry, prefix, COARSE);
-    }
-
-    /**
-     * Create a new instrumented handler using a given metrics registry.
-     *
-     * @param registry the registry for the metrics
-     * @param prefix   the prefix to use for the metrics names
-     * @param responseMeteredLevel the level to determine individual/aggregate response codes that are instrumented
-     */
-    protected AbstractInstrumentedHandler(MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
-        this.responseMeteredLevel = responseMeteredLevel;
-        this.metricRegistry = registry;
-        this.prefix = prefix;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
+  protected static final String NAME_REQUESTS = "requests";
+  protected static final String NAME_DISPATCHES = "dispatches";
+  protected static final String NAME_ACTIVE_REQUESTS = "active-requests";
+  protected static final String NAME_ACTIVE_DISPATCHES = "active-dispatches";
+  protected static final String NAME_ACTIVE_SUSPENDED = "active-suspended";
+  protected static final String NAME_ASYNC_DISPATCHES = "async-dispatches";
+  protected static final String NAME_ASYNC_TIMEOUTS = "async-timeouts";
+  protected static final String NAME_1XX_RESPONSES = "1xx-responses";
+  protected static final String NAME_2XX_RESPONSES = "2xx-responses";
+  protected static final String NAME_3XX_RESPONSES = "3xx-responses";
+  protected static final String NAME_4XX_RESPONSES = "4xx-responses";
+  protected static final String NAME_5XX_RESPONSES = "5xx-responses";
+  protected static final String NAME_GET_REQUESTS = "get-requests";
+  protected static final String NAME_POST_REQUESTS = "post-requests";
+  protected static final String NAME_HEAD_REQUESTS = "head-requests";
+  protected static final String NAME_PUT_REQUESTS = "put-requests";
+  protected static final String NAME_DELETE_REQUESTS = "delete-requests";
+  protected static final String NAME_OPTIONS_REQUESTS = "options-requests";
+  protected static final String NAME_TRACE_REQUESTS = "trace-requests";
+  protected static final String NAME_CONNECT_REQUESTS = "connect-requests";
+  protected static final String NAME_MOVE_REQUESTS = "move-requests";
+  protected static final String NAME_OTHER_REQUESTS = "other-requests";
+  protected static final String NAME_PERCENT_4XX_1M = "percent-4xx-1m";
+  protected static final String NAME_PERCENT_4XX_5M = "percent-4xx-5m";
+  protected static final String NAME_PERCENT_4XX_15M = "percent-4xx-15m";
+  protected static final String NAME_PERCENT_5XX_1M = "percent-5xx-1m";
+  protected static final String NAME_PERCENT_5XX_5M = "percent-5xx-5m";
+  protected static final String NAME_PERCENT_5XX_15M = "percent-5xx-15m";
+  protected static final Set<ResponseMeteredLevel> COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);
+  protected static final Set<ResponseMeteredLevel> DETAILED_METER_LEVELS =
+      EnumSet.of(DETAILED, ALL);
+
+  protected final MetricRegistry metricRegistry;
+
+  private String name;
+  protected final String prefix;
+
+  // the requests handled by this handler, excluding active
+  protected Timer requests;
+
+  // the number of dispatches seen by this handler, excluding active
+  protected Timer dispatches;
+
+  // the number of active requests
+  protected Counter activeRequests;
+
+  // the number of active dispatches
+  protected Counter activeDispatches;
+
+  // the number of requests currently suspended.
+  protected Counter activeSuspended;
+
+  // the number of requests that have been asynchronously dispatched
+  protected Meter asyncDispatches;
+
+  // the number of requests that expired while suspended
+  protected Meter asyncTimeouts;
+
+  protected final ResponseMeteredLevel responseMeteredLevel;
+  protected List<Meter> responses;
+  protected Map<Integer, Meter> responseCodeMeters;
+
+  protected Timer getRequests;
+  protected Timer postRequests;
+  protected Timer headRequests;
+  protected Timer putRequests;
+  protected Timer deleteRequests;
+  protected Timer optionsRequests;
+  protected Timer traceRequests;
+  protected Timer connectRequests;
+  protected Timer moveRequests;
+  protected Timer otherRequests;
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   */
+  protected AbstractInstrumentedHandler(MetricRegistry registry) {
+    this(registry, null);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param prefix the prefix to use for the metrics names
+   */
+  protected AbstractInstrumentedHandler(MetricRegistry registry, String prefix) {
+    this(registry, prefix, COARSE);
+  }
+
+  /**
+   * Create a new instrumented handler using a given metrics registry.
+   *
+   * @param registry the registry for the metrics
+   * @param prefix the prefix to use for the metrics names
+   * @param responseMeteredLevel the level to determine individual/aggregate response codes that are
+   *     instrumented
+   */
+  protected AbstractInstrumentedHandler(
+      MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
+    this.responseMeteredLevel = responseMeteredLevel;
+    this.metricRegistry = registry;
+    this.prefix = prefix;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  @Override
+  protected void doStart() throws Exception {
+    super.doStart();
+
+    final MetricName prefix = getMetricPrefix();
+
+    this.requests = metricRegistry.timer(prefix.resolve(NAME_REQUESTS));
+    this.dispatches = metricRegistry.timer(prefix.resolve(NAME_DISPATCHES));
+
+    this.activeRequests = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_REQUESTS));
+    this.activeDispatches = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_DISPATCHES));
+    this.activeSuspended = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_SUSPENDED));
+
+    this.asyncDispatches = metricRegistry.meter(prefix.resolve(NAME_ASYNC_DISPATCHES));
+    this.asyncTimeouts = metricRegistry.meter(prefix.resolve(NAME_ASYNC_TIMEOUTS));
+
+    this.responseCodeMeters =
+        DETAILED_METER_LEVELS.contains(responseMeteredLevel)
+            ? new ConcurrentHashMap<>()
+            : ImmutableMap.of();
+
+    this.getRequests = metricRegistry.timer(prefix.resolve(NAME_GET_REQUESTS));
+    this.postRequests = metricRegistry.timer(prefix.resolve(NAME_POST_REQUESTS));
+    this.headRequests = metricRegistry.timer(prefix.resolve(NAME_HEAD_REQUESTS));
+    this.putRequests = metricRegistry.timer(prefix.resolve(NAME_PUT_REQUESTS));
+    this.deleteRequests = metricRegistry.timer(prefix.resolve(NAME_DELETE_REQUESTS));
+    this.optionsRequests = metricRegistry.timer(prefix.resolve(NAME_OPTIONS_REQUESTS));
+    this.traceRequests = metricRegistry.timer(prefix.resolve(NAME_TRACE_REQUESTS));
+    this.connectRequests = metricRegistry.timer(prefix.resolve(NAME_CONNECT_REQUESTS));
+    this.moveRequests = metricRegistry.timer(prefix.resolve(NAME_MOVE_REQUESTS));
+    this.otherRequests = metricRegistry.timer(prefix.resolve(NAME_OTHER_REQUESTS));
+
+    if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
+      this.responses =
+          unmodifiableList(
+              Arrays.asList(
+                  metricRegistry.meter(prefix.resolve(NAME_1XX_RESPONSES)), // 1xx
+                  metricRegistry.meter(prefix.resolve(NAME_2XX_RESPONSES)), // 2xx
+                  metricRegistry.meter(prefix.resolve(NAME_3XX_RESPONSES)), // 3xx
+                  metricRegistry.meter(prefix.resolve(NAME_4XX_RESPONSES)), // 4xx
+                  metricRegistry.meter(prefix.resolve(NAME_5XX_RESPONSES)) // 5xx
+                  ));
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_1M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(3).getOneMinuteRate(), requests.getOneMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_5M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(3).getFiveMinuteRate(), requests.getFiveMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_4XX_15M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(
+                  responses.get(3).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_1M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(4).getOneMinuteRate(), requests.getOneMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_5M),
+          new RatioGauge() {
+            @Override
+            protected Ratio getRatio() {
+              return Ratio.of(responses.get(4).getFiveMinuteRate(), requests.getFiveMinuteRate());
+            }
+          });
+
+      metricRegistry.register(
+          prefix.resolve(NAME_PERCENT_5XX_15M),
+          new RatioGauge() {
+            @Override
+            public Ratio getRatio() {
+              return Ratio.of(
+                  responses.get(4).getFifteenMinuteRate(), requests.getFifteenMinuteRate());
+            }
+          });
+    } else {
+      this.responses = ImmutableList.of();
     }
-
-    @Override
-    protected void doStart() throws Exception {
-        super.doStart();
-
-        final MetricName prefix = getMetricPrefix();
-
-        this.requests = metricRegistry.timer(prefix.resolve(NAME_REQUESTS));
-        this.dispatches = metricRegistry.timer(prefix.resolve(NAME_DISPATCHES));
-
-        this.activeRequests = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_REQUESTS));
-        this.activeDispatches = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_DISPATCHES));
-        this.activeSuspended = metricRegistry.counter(prefix.resolve(NAME_ACTIVE_SUSPENDED));
-
-        this.asyncDispatches = metricRegistry.meter(prefix.resolve(NAME_ASYNC_DISPATCHES));
-        this.asyncTimeouts = metricRegistry.meter(prefix.resolve(NAME_ASYNC_TIMEOUTS));
-
-        this.responseCodeMeters = DETAILED_METER_LEVELS.contains(responseMeteredLevel) ? new ConcurrentHashMap<>() : Collections.emptyMap();
-
-        this.getRequests = metricRegistry.timer(prefix.resolve(NAME_GET_REQUESTS));
-        this.postRequests = metricRegistry.timer(prefix.resolve(NAME_POST_REQUESTS));
-        this.headRequests = metricRegistry.timer(prefix.resolve(NAME_HEAD_REQUESTS));
-        this.putRequests = metricRegistry.timer(prefix.resolve(NAME_PUT_REQUESTS));
-        this.deleteRequests = metricRegistry.timer(prefix.resolve(NAME_DELETE_REQUESTS));
-        this.optionsRequests = metricRegistry.timer(prefix.resolve(NAME_OPTIONS_REQUESTS));
-        this.traceRequests = metricRegistry.timer(prefix.resolve(NAME_TRACE_REQUESTS));
-        this.connectRequests = metricRegistry.timer(prefix.resolve(NAME_CONNECT_REQUESTS));
-        this.moveRequests = metricRegistry.timer(prefix.resolve(NAME_MOVE_REQUESTS));
-        this.otherRequests = metricRegistry.timer(prefix.resolve(NAME_OTHER_REQUESTS));
-
-        if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
-            this.responses = Collections.unmodifiableList(Arrays.asList(
-                            metricRegistry.meter(prefix.resolve(NAME_1XX_RESPONSES)), // 1xx
-                            metricRegistry.meter(prefix.resolve(NAME_2XX_RESPONSES)), // 2xx
-                            metricRegistry.meter(prefix.resolve(NAME_3XX_RESPONSES)), // 3xx
-                            metricRegistry.meter(prefix.resolve(NAME_4XX_RESPONSES)), // 4xx
-                            metricRegistry.meter(prefix.resolve(NAME_5XX_RESPONSES))  // 5xx
-                    ));
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_1M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getOneMinuteRate(),
-                            requests.getOneMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_5M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getFiveMinuteRate(),
-                            requests.getFiveMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_4XX_15M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(3).getFifteenMinuteRate(),
-                            requests.getFifteenMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_1M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getOneMinuteRate(),
-                            requests.getOneMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_5M), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getFiveMinuteRate(),
-                            requests.getFiveMinuteRate());
-                }
-            });
-
-            metricRegistry.register(prefix.resolve(NAME_PERCENT_5XX_15M), new RatioGauge() {
-                @Override
-                public Ratio getRatio() {
-                    return Ratio.of(responses.get(4).getFifteenMinuteRate(),
-                            requests.getFifteenMinuteRate());
-                }
-            });
-        } else {
-             this.responses = Collections.emptyList();
-        }
+  }
+
+  @Override
+  protected void doStop() throws Exception {
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.remove(prefix.resolve(NAME_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ACTIVE_SUSPENDED));
+    metricRegistry.remove(prefix.resolve(NAME_ASYNC_DISPATCHES));
+    metricRegistry.remove(prefix.resolve(NAME_ASYNC_TIMEOUTS));
+    metricRegistry.remove(prefix.resolve(NAME_1XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_2XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_3XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_4XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_5XX_RESPONSES));
+    metricRegistry.remove(prefix.resolve(NAME_GET_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_POST_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_HEAD_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_PUT_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_DELETE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_OPTIONS_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_TRACE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_CONNECT_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_MOVE_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_OTHER_REQUESTS));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_1M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_5M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_15M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_1M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_5M));
+    metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_15M));
+
+    if (responseCodeMeters != null) {
+      responseCodeMeters.keySet().stream()
+          .map(sc -> getMetricPrefix().resolve(String.format("%d-responses", sc)))
+          .forEach(metricRegistry::remove);
     }
-
-    @Override
-    protected void doStop() throws Exception {
-        final MetricName prefix = getMetricPrefix();
-
-        metricRegistry.remove(prefix.resolve(NAME_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ACTIVE_SUSPENDED));
-        metricRegistry.remove(prefix.resolve(NAME_ASYNC_DISPATCHES));
-        metricRegistry.remove(prefix.resolve(NAME_ASYNC_TIMEOUTS));
-        metricRegistry.remove(prefix.resolve(NAME_1XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_2XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_3XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_4XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_5XX_RESPONSES));
-        metricRegistry.remove(prefix.resolve(NAME_GET_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_POST_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_HEAD_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_PUT_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_DELETE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_OPTIONS_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_TRACE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_CONNECT_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_MOVE_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_OTHER_REQUESTS));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_1M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_5M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_4XX_15M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_1M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_5M));
-        metricRegistry.remove(prefix.resolve(NAME_PERCENT_5XX_15M));
-
-        if (responseCodeMeters != null) {
-            responseCodeMeters.keySet().stream()
-                    .map(sc -> getMetricPrefix().resolve(String.format("%d-responses", sc)))
-                    .forEach(metricRegistry::remove);
-        }
-        super.doStop();
+    super.doStop();
+  }
+
+  protected Timer requestTimer(String method) {
+    final HttpMethod m = HttpMethod.fromString(method);
+    if (m == null) {
+      return otherRequests;
+    } else {
+      switch (m) {
+        case GET:
+          return getRequests;
+        case POST:
+          return postRequests;
+        case PUT:
+          return putRequests;
+        case HEAD:
+          return headRequests;
+        case DELETE:
+          return deleteRequests;
+        case OPTIONS:
+          return optionsRequests;
+        case TRACE:
+          return traceRequests;
+        case CONNECT:
+          return connectRequests;
+        case MOVE:
+          return moveRequests;
+        default:
+          return otherRequests;
+      }
     }
-
-    protected Timer requestTimer(String method) {
-        final HttpMethod m = HttpMethod.fromString(method);
-        if (m == null) {
-            return otherRequests;
-        } else {
-            switch (m) {
-                case GET:
-                    return getRequests;
-                case POST:
-                    return postRequests;
-                case PUT:
-                    return putRequests;
-                case HEAD:
-                    return headRequests;
-                case DELETE:
-                    return deleteRequests;
-                case OPTIONS:
-                    return optionsRequests;
-                case TRACE:
-                    return traceRequests;
-                case CONNECT:
-                    return connectRequests;
-                case MOVE:
-                    return moveRequests;
-                default:
-                    return otherRequests;
-            }
-        }
+  }
+
+  protected void updateResponses(
+      Request request, Response response, long start, boolean isHandled) {
+    if (isHandled) {
+      mark(response.getStatus());
+    } else {
+      mark(404); // will end up with a 404 response sent by HttpChannel.handle
     }
-
-    protected void updateResponses(Request request, Response response, long start, boolean isHandled) {
-        if (isHandled) {
-            mark(response.getStatus());
-        } else {
-            mark(404); // will end up with a 404 response sent by HttpChannel.handle
-        }
-        activeRequests.dec();
-        final long elapsedTime = System.currentTimeMillis() - start;
-        requests.update(elapsedTime, TimeUnit.MILLISECONDS);
-        requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
+    activeRequests.dec();
+    final long elapsedTime = System.currentTimeMillis() - start;
+    requests.update(elapsedTime, TimeUnit.MILLISECONDS);
+    requestTimer(request.getMethod()).update(elapsedTime, TimeUnit.MILLISECONDS);
+  }
+
+  protected void mark(int statusCode) {
+    if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
+      getResponseCodeMeter(statusCode).mark();
     }
 
-    protected void mark(int statusCode) {
-        if (DETAILED_METER_LEVELS.contains(responseMeteredLevel)) {
-            getResponseCodeMeter(statusCode).mark();
-        }
-
-        if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
-            final int responseStatus = statusCode / 100;
-            if (responseStatus >= 1 && responseStatus <= 5) {
-                responses.get(responseStatus - 1).mark();
-            }
-        }
+    if (COARSE_METER_LEVELS.contains(responseMeteredLevel)) {
+      final int responseStatus = statusCode / 100;
+      if (responseStatus >= 1 && responseStatus <= 5) {
+        responses.get(responseStatus - 1).mark();
+      }
     }
+  }
 
-    protected Meter getResponseCodeMeter(int statusCode) {
-        return responseCodeMeters
-                .computeIfAbsent(statusCode, sc -> metricRegistry
-                        .meter(getMetricPrefix().resolve(String.format("%d-responses", sc))));
-    }
+  protected Meter getResponseCodeMeter(int statusCode) {
+    return responseCodeMeters.computeIfAbsent(
+        statusCode,
+        sc -> metricRegistry.meter(getMetricPrefix().resolve(String.format("%d-responses", sc))));
+  }
 
-    protected MetricName getMetricPrefix() {
-        return this.prefix == null ? name(getHandler().getClass(), name) : name(this.prefix, name);
-    }
+  protected MetricName getMetricPrefix() {
+    return this.prefix == null ? name(getHandler().getClass(), name) : name(this.prefix, name);
+  }
 }
--- a/metrics-jetty12/src/main/java/io/dropwizard/metrics/jetty12/InstrumentedConnectionFactory.java
+++ b/metrics-jetty12/src/main/java/io/dropwizard/metrics/jetty12/InstrumentedConnectionFactory.java
@@ -2,62 +2,63 @@ package io.dropwizard.metrics.jetty12;
 
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Timer;
+import java.util.List;
 import org.eclipse.jetty.io.Connection;
 import org.eclipse.jetty.io.EndPoint;
 import org.eclipse.jetty.server.ConnectionFactory;
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.util.component.ContainerLifeCycle;
 
-import java.util.List;
-
 public class InstrumentedConnectionFactory extends ContainerLifeCycle implements ConnectionFactory {
-    private final ConnectionFactory connectionFactory;
-    private final Timer timer;
-    private final Counter counter;
-
-    public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer) {
-        this(connectionFactory, timer, null);
-    }
-
-    public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer, Counter counter) {
-        this.connectionFactory = connectionFactory;
-        this.timer = timer;
-        this.counter = counter;
-        addBean(connectionFactory);
-    }
-
-    @Override
-    public String getProtocol() {
-        return connectionFactory.getProtocol();
-    }
-
-    @Override
-    public List<String> getProtocols() {
-        return connectionFactory.getProtocols();
-    }
-
-    @Override
-    public Connection newConnection(Connector connector, EndPoint endPoint) {
-        final Connection connection = connectionFactory.newConnection(connector, endPoint);
-        connection.addEventListener(new Connection.Listener() {
-            private Timer.Context context;
-
-            @Override
-            public void onOpened(Connection connection) {
-                this.context = timer.time();
-                if (counter != null) {
-                    counter.inc();
-                }
+  private final ConnectionFactory connectionFactory;
+  private final Timer timer;
+  private final Counter counter;
+
+  public InstrumentedConnectionFactory(ConnectionFactory connectionFactory, Timer timer) {
+    this(connectionFactory, timer, null);
+  }
+
+  public InstrumentedConnectionFactory(
+      ConnectionFactory connectionFactory, Timer timer, Counter counter) {
+    this.connectionFactory = connectionFactory;
+    this.timer = timer;
+    this.counter = counter;
+    addBean(connectionFactory);
+  }
+
+  @Override
+  public String getProtocol() {
+    return connectionFactory.getProtocol();
+  }
+
+  @Override
+  public List<String> getProtocols() {
+    return connectionFactory.getProtocols();
+  }
+
+  @Override
+  public Connection newConnection(Connector connector, EndPoint endPoint) {
+    final Connection connection = connectionFactory.newConnection(connector, endPoint);
+    connection.addEventListener(
+        new Connection.Listener() {
+          private Timer.Context context;
+
+          @Override
+          public void onOpened(Connection connection) {
+            this.context = timer.time();
+            if (counter != null) {
+              counter.inc();
             }
+          }
 
-            @Override
-            public void onClosed(Connection connection) {
-                context.stop();
-                if (counter != null) {
-                    counter.dec();
-                }
+          @Override
+          public void onClosed(Connection connection) {
+            context.stop();
+            if (counter != null) {
+              counter.dec();
             }
+          }
         });
-        return connection;
-    }
+    return connection;
+  }
 }
--- a/metrics-jetty12/src/main/java/io/dropwizard/metrics/jetty12/InstrumentedQueuedThreadPool.java
+++ b/metrics-jetty12/src/main/java/io/dropwizard/metrics/jetty12/InstrumentedQueuedThreadPool.java
@@ -1,164 +1,187 @@
 package io.dropwizard.metrics.jetty12;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.RatioGauge;
-import org.eclipse.jetty.util.annotation.Name;
-import org.eclipse.jetty.util.thread.QueuedThreadPool;
-
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ThreadFactory;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
+import org.eclipse.jetty.util.annotation.Name;
+import org.eclipse.jetty.util.thread.QueuedThreadPool;
 
 public class InstrumentedQueuedThreadPool extends QueuedThreadPool {
-    private static final String NAME_UTILIZATION = "utilization";
-    private static final String NAME_UTILIZATION_MAX = "utilization-max";
-    private static final String NAME_SIZE = "size";
-    private static final String NAME_JOBS = "jobs";
-    private static final String NAME_JOBS_QUEUE_UTILIZATION = "jobs-queue-utilization";
-
-    private final MetricRegistry metricRegistry;
-    private String prefix;
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry) {
-        this(registry, 200);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads) {
-        this(registry, maxThreads, 8);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads) {
-        this(registry, maxThreads, minThreads, 60000);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("queue") BlockingQueue<Runnable> queue) {
-        this(registry, maxThreads, minThreads, 60000, queue);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout) {
-        this(registry, maxThreads, minThreads, idleTimeout, null);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("queue") BlockingQueue<Runnable> queue) {
-        this(registry, maxThreads, minThreads, idleTimeout, queue, (ThreadGroup) null);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("queue") BlockingQueue<Runnable> queue,
-                                        @Name("threadFactory") ThreadFactory threadFactory) {
-        this(registry, maxThreads, minThreads, idleTimeout, -1, queue, null, threadFactory);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("queue") BlockingQueue<Runnable> queue,
-                                        @Name("threadGroup") ThreadGroup threadGroup) {
-        this(registry, maxThreads, minThreads, idleTimeout, -1, queue, threadGroup);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("reservedThreads") int reservedThreads,
-                                        @Name("queue") BlockingQueue<Runnable> queue,
-                                        @Name("threadGroup") ThreadGroup threadGroup) {
-        this(registry, maxThreads, minThreads, idleTimeout, reservedThreads, queue, threadGroup, null);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("reservedThreads") int reservedThreads,
-                                        @Name("queue") BlockingQueue<Runnable> queue,
-                                        @Name("threadGroup") ThreadGroup threadGroup,
-                                        @Name("threadFactory") ThreadFactory threadFactory) {
-        this(registry, maxThreads, minThreads, idleTimeout, reservedThreads, queue, threadGroup, threadFactory, null);
-    }
-
-    public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry,
-                                        @Name("maxThreads") int maxThreads,
-                                        @Name("minThreads") int minThreads,
-                                        @Name("idleTimeout") int idleTimeout,
-                                        @Name("reservedThreads") int reservedThreads,
-                                        @Name("queue") BlockingQueue<Runnable> queue,
-                                        @Name("threadGroup") ThreadGroup threadGroup,
-                                        @Name("threadFactory") ThreadFactory threadFactory,
-                                        @Name("prefix") String prefix) {
-        super(maxThreads, minThreads, idleTimeout, reservedThreads, queue, threadGroup, threadFactory);
-        this.metricRegistry = registry;
-        this.prefix = prefix;
-    }
-
-    public String getPrefix() {
-        return prefix;
-    }
-
-    public void setPrefix(String prefix) {
-        this.prefix = prefix;
-    }
-
-    @Override
-    protected void doStart() throws Exception {
-        super.doStart();
-
-        final MetricName prefix = getMetricPrefix();
-
-        metricRegistry.register(prefix.resolve(NAME_UTILIZATION), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return  Ratio.of(getUtilizedThreads(), getThreads() - getLeasedThreads());
-            }
+  private static final String NAME_UTILIZATION = "utilization";
+  private static final String NAME_UTILIZATION_MAX = "utilization-max";
+  private static final String NAME_SIZE = "size";
+  private static final String NAME_JOBS = "jobs";
+  private static final String NAME_JOBS_QUEUE_UTILIZATION = "jobs-queue-utilization";
+
+  private final MetricRegistry metricRegistry;
+  private String prefix;
+
+  public InstrumentedQueuedThreadPool(@Name("registry") MetricRegistry registry) {
+    this(registry, 200);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry, @Name("maxThreads") int maxThreads) {
+    this(registry, maxThreads, 8);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads) {
+    this(registry, maxThreads, minThreads, 60000);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("queue") BlockingQueue<Runnable> queue) {
+    this(registry, maxThreads, minThreads, 60000, queue);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout) {
+    this(registry, maxThreads, minThreads, idleTimeout, null);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("queue") BlockingQueue<Runnable> queue) {
+    this(registry, maxThreads, minThreads, idleTimeout, queue, (ThreadGroup) null);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("queue") BlockingQueue<Runnable> queue,
+      @Name("threadFactory") ThreadFactory threadFactory) {
+    this(registry, maxThreads, minThreads, idleTimeout, -1, queue, null, threadFactory);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("queue") BlockingQueue<Runnable> queue,
+      @Name("threadGroup") ThreadGroup threadGroup) {
+    this(registry, maxThreads, minThreads, idleTimeout, -1, queue, threadGroup);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("reservedThreads") int reservedThreads,
+      @Name("queue") BlockingQueue<Runnable> queue,
+      @Name("threadGroup") ThreadGroup threadGroup) {
+    this(registry, maxThreads, minThreads, idleTimeout, reservedThreads, queue, threadGroup, null);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("reservedThreads") int reservedThreads,
+      @Name("queue") BlockingQueue<Runnable> queue,
+      @Name("threadGroup") ThreadGroup threadGroup,
+      @Name("threadFactory") ThreadFactory threadFactory) {
+    this(
+        registry,
+        maxThreads,
+        minThreads,
+        idleTimeout,
+        reservedThreads,
+        queue,
+        threadGroup,
+        threadFactory,
+        null);
+  }
+
+  public InstrumentedQueuedThreadPool(
+      @Name("registry") MetricRegistry registry,
+      @Name("maxThreads") int maxThreads,
+      @Name("minThreads") int minThreads,
+      @Name("idleTimeout") int idleTimeout,
+      @Name("reservedThreads") int reservedThreads,
+      @Name("queue") BlockingQueue<Runnable> queue,
+      @Name("threadGroup") ThreadGroup threadGroup,
+      @Name("threadFactory") ThreadFactory threadFactory,
+      @Name("prefix") String prefix) {
+    super(maxThreads, minThreads, idleTimeout, reservedThreads, queue, threadGroup, threadFactory);
+    this.metricRegistry = registry;
+    this.prefix = prefix;
+  }
+
+  public String getPrefix() {
+    return prefix;
+  }
+
+  public void setPrefix(String prefix) {
+    this.prefix = prefix;
+  }
+
+  @Override
+  protected void doStart() throws Exception {
+    super.doStart();
+
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.register(
+        prefix.resolve(NAME_UTILIZATION),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(getUtilizedThreads(), getThreads() - getLeasedThreads());
+          }
         });
-        metricRegistry.registerGauge(prefix.resolve(NAME_UTILIZATION_MAX), this::getUtilizationRate);
-        metricRegistry.registerGauge(prefix.resolve(NAME_SIZE), this::getThreads);
-        // This assumes the QueuedThreadPool is using a BlockingArrayQueue or
-        // ArrayBlockingQueue for its queue, and is therefore a constant-time operation.
-        metricRegistry.registerGauge(prefix.resolve(NAME_JOBS), () -> getQueue().size());
-        metricRegistry.register(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                BlockingQueue<Runnable> queue = getQueue();
-                return Ratio.of(queue.size(), queue.size() + queue.remainingCapacity());
-            }
+    metricRegistry.registerGauge(prefix.resolve(NAME_UTILIZATION_MAX), this::getUtilizationRate);
+    metricRegistry.registerGauge(prefix.resolve(NAME_SIZE), this::getThreads);
+    // This assumes the QueuedThreadPool is using a BlockingArrayQueue or
+    // ArrayBlockingQueue for its queue, and is therefore a constant-time operation.
+    metricRegistry.registerGauge(prefix.resolve(NAME_JOBS), () -> getQueue().size());
+    metricRegistry.register(
+        prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            BlockingQueue<Runnable> queue = getQueue();
+            return Ratio.of(queue.size(), queue.size() + queue.remainingCapacity());
+          }
         });
-    }
-
-    @Override
-    protected void doStop() throws Exception {
-        final MetricName prefix = getMetricPrefix();
-
-        metricRegistry.remove(prefix.resolve(NAME_UTILIZATION));
-        metricRegistry.remove(prefix.resolve(NAME_UTILIZATION_MAX));
-        metricRegistry.remove(prefix.resolve(NAME_SIZE));
-        metricRegistry.remove(prefix.resolve(NAME_JOBS));
-        metricRegistry.remove(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION));
-
-        super.doStop();
-    }
-
-    private MetricName getMetricPrefix() {
-        return this.prefix == null ? name(QueuedThreadPool.class, getName()) : name(this.prefix, getName());
-    }
+  }
+
+  @Override
+  protected void doStop() throws Exception {
+    final MetricName prefix = getMetricPrefix();
+
+    metricRegistry.remove(prefix.resolve(NAME_UTILIZATION));
+    metricRegistry.remove(prefix.resolve(NAME_UTILIZATION_MAX));
+    metricRegistry.remove(prefix.resolve(NAME_SIZE));
+    metricRegistry.remove(prefix.resolve(NAME_JOBS));
+    metricRegistry.remove(prefix.resolve(NAME_JOBS_QUEUE_UTILIZATION));
+
+    super.doStop();
+  }
+
+  private MetricName getMetricPrefix() {
+    return this.prefix == null
+        ? name(QueuedThreadPool.class, getName())
+        : name(this.prefix, getName());
+  }
 }
--- a/metrics-jetty12/src/test/java/io/dropwizard/metrics/jetty12/InstrumentedConnectionFactoryTest.java
+++ b/metrics-jetty12/src/test/java/io/dropwizard/metrics/jetty12/InstrumentedConnectionFactoryTest.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics.jetty12;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
@@ -17,70 +19,70 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class InstrumentedConnectionFactoryTest {
-    private final MetricRegistry registry = new MetricRegistry();
-    private final Server server = new Server();
-    private final ServerConnector connector =
-            new ServerConnector(server, new InstrumentedConnectionFactory(new HttpConnectionFactory(),
-                    registry.timer("http.connections"),
-                    registry.counter("http.active-connections")));
-    private final HttpClient client = new HttpClient();
-
-    @BeforeEach
-    public void setUp() throws Exception {
-        server.setHandler(new Handler.Abstract() {
-            @Override
-            public boolean handle(Request request, Response response, Callback callback) throws Exception {
-                Content.Sink.write(response, true, "OK", callback);
-                return true;
-            }
+final class InstrumentedConnectionFactoryTest {
+  private final MetricRegistry registry = new MetricRegistry();
+  private final Server server = new Server();
+  private final ServerConnector connector =
+      new ServerConnector(
+          server,
+          new InstrumentedConnectionFactory(
+              new HttpConnectionFactory(),
+              registry.timer("http.connections"),
+              registry.counter("http.active-connections")));
+  private final HttpClient client = new HttpClient();
+
+  @BeforeEach
+  void setUp() throws Exception {
+    server.setHandler(
+        new Handler.Abstract() {
+          @Override
+          public boolean handle(Request request, Response response, Callback callback)
+              throws Exception {
+            Content.Sink.write(response, true, "OK", callback);
+            return true;
+          }
         });
 
-        server.addConnector(connector);
-        server.start();
+    server.addConnector(connector);
+    server.start();
 
-        client.start();
-    }
+    client.start();
+  }
 
-    @AfterEach
-    public void tearDown() throws Exception {
-        server.stop();
-        client.stop();
-    }
+  @AfterEach
+  void tearDown() throws Exception {
+    server.stop();
+    client.stop();
+  }
 
-    @Test
-    public void instrumentsConnectionTimes() throws Exception {
-        final ContentResponse response = client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
-        assertThat(response.getStatus())
-                .isEqualTo(200);
+  @Test
+  void instrumentsConnectionTimes() throws Exception {
+    final ContentResponse response =
+        client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
+    assertThat(response.getStatus()).isEqualTo(200);
 
-        client.stop(); // close the connection
+    client.stop(); // close the connection
 
-        Thread.sleep(100); // make sure the connection is closed
+    Thread.sleep(100); // make sure the connection is closed
 
-        final Timer timer = registry.timer(MetricRegistry.name("http.connections"));
-        assertThat(timer.getCount())
-                .isEqualTo(1);
-    }
+    final Timer timer = registry.timer(MetricRegistry.name("http.connections"));
+    assertThat(timer.getCount()).isEqualTo(1);
+  }
 
-    @Test
-    public void instrumentsActiveConnections() throws Exception {
-        final Counter counter = registry.counter("http.active-connections");
+  @Test
+  void instrumentsActiveConnections() throws Exception {
+    final Counter counter = registry.counter("http.active-connections");
 
-        final ContentResponse response = client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
-        assertThat(response.getStatus())
-                .isEqualTo(200);
+    final ContentResponse response =
+        client.GET("http://localhost:" + connector.getLocalPort() + "/hello");
+    assertThat(response.getStatus()).isEqualTo(200);
 
-        assertThat(counter.getCount())
-                .isEqualTo(1);
+    assertThat(counter.getCount()).isEqualTo(1);
 
-        client.stop(); // close the connection
+    client.stop(); // close the connection
 
-        Thread.sleep(100); // make sure the connection is closed
+    Thread.sleep(100); // make sure the connection is closed
 
-        assertThat(counter.getCount())
-                .isEqualTo(0);
-    }
+    assertThat(counter.getCount()).isEqualTo(0);
+  }
 }
--- a/metrics-jetty12/src/test/java/io/dropwizard/metrics/jetty12/InstrumentedQueuedThreadPoolTest.java
+++ b/metrics-jetty12/src/test/java/io/dropwizard/metrics/jetty12/InstrumentedQueuedThreadPoolTest.java
@@ -1,49 +1,49 @@
 package io.dropwizard.metrics.jetty12;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import org.eclipse.jetty.util.thread.QueuedThreadPool;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class InstrumentedQueuedThreadPoolTest {
-    private static final String PREFIX = "prefix";
-
-    private MetricRegistry metricRegistry;
-    private InstrumentedQueuedThreadPool iqtp;
-
-    @BeforeEach
-    public void setUp() {
-        metricRegistry = new MetricRegistry();
-        iqtp = new InstrumentedQueuedThreadPool(metricRegistry);
-    }
-
-    @Test
-    public void customMetricsPrefix() throws Exception {
-        iqtp.setPrefix(PREFIX);
-        iqtp.start();
-
-        assertThat(metricRegistry.getNames())
-                .overridingErrorMessage("Custom metrics prefix doesn't match")
-                .allSatisfy(name -> assertThat(name.getKey()).startsWith(PREFIX));
-
-        iqtp.stop();
-        assertThat(metricRegistry.getMetrics())
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .isEmpty();
-    }
-
-    @Test
-    public void metricsPrefixBackwardCompatible() throws Exception {
-        iqtp.start();
-        assertThat(metricRegistry.getNames())
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .allSatisfy(name -> assertThat(name.getKey()).startsWith(QueuedThreadPool.class.getName()));
-
-        iqtp.stop();
-        assertThat(metricRegistry.getMetrics())
-                .overridingErrorMessage("The default metrics prefix was changed")
-                .isEmpty();
-    }
+final class InstrumentedQueuedThreadPoolTest {
+  private static final String PREFIX = "prefix";
+
+  private MetricRegistry metricRegistry;
+  private InstrumentedQueuedThreadPool iqtp;
+
+  @BeforeEach
+  void setUp() {
+    metricRegistry = new MetricRegistry();
+    iqtp = new InstrumentedQueuedThreadPool(metricRegistry);
+  }
+
+  @Test
+  void customMetricsPrefix() throws Exception {
+    iqtp.setPrefix(PREFIX);
+    iqtp.start();
+
+    assertThat(metricRegistry.getNames())
+        .overridingErrorMessage("Custom metrics prefix doesn't match")
+        .allSatisfy(name -> assertThat(name.getKey()).startsWith(PREFIX));
+
+    iqtp.stop();
+    assertThat(metricRegistry.getMetrics())
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .isEmpty();
+  }
+
+  @Test
+  void metricsPrefixBackwardCompatible() throws Exception {
+    iqtp.start();
+    assertThat(metricRegistry.getNames())
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .allSatisfy(name -> assertThat(name.getKey()).startsWith(QueuedThreadPool.class.getName()));
+
+    iqtp.stop();
+    assertThat(metricRegistry.getMetrics())
+        .overridingErrorMessage("The default metrics prefix was changed")
+        .isEmpty();
+  }
 }
--- a/metrics-jmx/src/main/java/io/dropwizard/metrics5/jmx/DefaultObjectNameFactory.java
+++ b/metrics-jmx/src/main/java/io/dropwizard/metrics5/jmx/DefaultObjectNameFactory.java
@@ -2,70 +2,68 @@ package io.dropwizard.metrics5.jmx;
 
 import io.dropwizard.metrics5.MetricName;
 import java.util.Hashtable;
-
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class DefaultObjectNameFactory implements ObjectNameFactory {
 
-    private static final char[] QUOTABLE_CHARS = new char[] {',', '=', ':', '"'};
-    private static final Logger LOGGER = LoggerFactory.getLogger(JmxReporter.class);
+  private static final char[] QUOTABLE_CHARS = new char[] {',', '=', ':', '"'};
+  private static final Logger LOG = LoggerFactory.getLogger(DefaultObjectNameFactory.class);
 
-    @Override
-    public ObjectName createName(String type, String domain, MetricName name) {
-        try {
-            ObjectName objectName;
-            Hashtable<String, String> properties = new Hashtable<>();
+  @Override
+  public ObjectName createName(String type, String domain, MetricName name) {
+    try {
+      ObjectName objectName;
+      Hashtable<String, String> properties = new Hashtable<>();
 
-            properties.put("name", name.getKey());
-            properties.put("type", type);
-            properties.putAll(name.getTags());
-            objectName = new ObjectName(domain, properties);
+      properties.put("name", name.getKey());
+      properties.put("type", type);
+      properties.putAll(name.getTags());
+      objectName = new ObjectName(domain, properties);
 
-            /*
-             * The only way we can find out if we need to quote the properties is by
-             * checking an ObjectName that we've constructed.
-             */
-            if (objectName.isDomainPattern()) {
-                domain = ObjectName.quote(domain);
-            }
-            if (objectName.isPropertyValuePattern("name") || shouldQuote(objectName.getKeyProperty("name"))) {
-                properties.put("name", ObjectName.quote(name.getKey()));
-            }
-            if (objectName.isPropertyValuePattern("type") || shouldQuote(objectName.getKeyProperty("type"))) {
-                properties.put("type", ObjectName.quote(type));
-            }
-            objectName = new ObjectName(domain, properties);
+      /*
+       * The only way we can find out if we need to quote the properties is by
+       * checking an ObjectName that we've constructed.
+       */
+      if (objectName.isDomainPattern()) {
+        domain = ObjectName.quote(domain);
+      }
+      if (objectName.isPropertyValuePattern("name")
+          || shouldQuote(objectName.getKeyProperty("name"))) {
+        properties.put("name", ObjectName.quote(name.getKey()));
+      }
+      if (objectName.isPropertyValuePattern("type")
+          || shouldQuote(objectName.getKeyProperty("type"))) {
+        properties.put("type", ObjectName.quote(type));
+      }
+      return new ObjectName(domain, properties);
 
-            return objectName;
-        } catch (MalformedObjectNameException e) {
-            try {
-                return new ObjectName(domain, "name", ObjectName.quote(name.getKey()));
-            } catch (MalformedObjectNameException e1) {
-                LOGGER.warn("Unable to register {} {}", type, name, e1);
-                throw new RuntimeException(e1);
-            }
-        }
+    } catch (MalformedObjectNameException e) {
+      try {
+        return new ObjectName(domain, "name", ObjectName.quote(name.getKey()));
+      } catch (MalformedObjectNameException e1) {
+        LOG.warn("Unable to register {} {}", type, name, e1);
+        throw new RuntimeException(e1);
+      }
     }
+  }
 
-    /**
-     * Determines whether the value requires quoting.
-     * According to the {@link ObjectName} documentation, values can be quoted or unquoted. Unquoted
-     * values may not contain any of the characters comma, equals, colon, or quote.
-     *
-     * @param value a value to test
-     * @return true when it requires quoting, false otherwise
-     */
-    private boolean shouldQuote(final String value) {
-        for (char quotableChar : QUOTABLE_CHARS) {
-            if (value.indexOf(quotableChar) != -1) {
-                return true;
-            }
-        }
-        return false;
+  /**
+   * Determines whether the value requires quoting. According to the {@link ObjectName}
+   * documentation, values can be quoted or unquoted. Unquoted values may not contain any of the
+   * characters comma, equals, colon, or quote.
+   *
+   * @param value a value to test
+   * @return true when it requires quoting, false otherwise
+   */
+  private boolean shouldQuote(final String value) {
+    for (char quotableChar : QUOTABLE_CHARS) {
+      if (value.indexOf(quotableChar) != -1) {
+        return true;
+      }
     }
-
+    return false;
+  }
 }
--- a/metrics-jmx/src/main/java/io/dropwizard/metrics5/jmx/JmxReporter.java
+++ b/metrics-jmx/src/main/java/io/dropwizard/metrics5/jmx/JmxReporter.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.jmx;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Collections.unmodifiableMap;
+
+import com.google.common.collect.ImmutableMap;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.Histogram;
@@ -11,9 +15,12 @@ import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricRegistryListener;
 import io.dropwizard.metrics5.Reporter;
 import io.dropwizard.metrics5.Timer;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
+import java.io.Closeable;
+import java.lang.management.ManagementFactory;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
 import javax.management.InstanceAlreadyExistsException;
 import javax.management.InstanceNotFoundException;
 import javax.management.JMException;
@@ -21,758 +28,755 @@ import javax.management.MBeanRegistrationException;
 import javax.management.MBeanServer;
 import javax.management.ObjectInstance;
 import javax.management.ObjectName;
-import java.io.Closeable;
-import java.lang.management.ManagementFactory;
-import java.util.Collections;
-import java.util.Locale;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.TimeUnit;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-/**
- * A reporter which listens for new metrics and exposes them as namespaced MBeans.
- */
+/** A reporter which listens for new metrics and exposes them as namespaced MBeans. */
 public class JmxReporter implements Reporter, Closeable {
+  /**
+   * Returns a new {@link Builder} for {@link JmxReporter}.
+   *
+   * @param registry the registry to report
+   * @return a {@link Builder} instance for a {@link JmxReporter}
+   */
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
+
+  /**
+   * A builder for {@link JmxReporter} instances. Defaults to using the default MBean server and not
+   * filtering metrics.
+   */
+  public static class Builder {
+    private final MetricRegistry registry;
+    private MBeanServer mBeanServer;
+    private TimeUnit rateUnit;
+    private TimeUnit durationUnit;
+    private ObjectNameFactory objectNameFactory;
+    private MetricFilter filter = MetricFilter.ALL;
+    private String domain;
+    private Map<String, TimeUnit> specificDurationUnits;
+    private Map<String, TimeUnit> specificRateUnits;
+
+    private Builder(MetricRegistry registry) {
+      this.registry = registry;
+      this.rateUnit = TimeUnit.SECONDS;
+      this.durationUnit = TimeUnit.MILLISECONDS;
+      this.domain = "metrics";
+      this.objectNameFactory = new DefaultObjectNameFactory();
+      this.specificDurationUnits = ImmutableMap.of();
+      this.specificRateUnits = ImmutableMap.of();
+    }
+
     /**
-     * Returns a new {@link Builder} for {@link JmxReporter}.
+     * Register MBeans with the given {@link MBeanServer}.
      *
-     * @param registry the registry to report
-     * @return a {@link Builder} instance for a {@link JmxReporter}
+     * @param mBeanServer an {@link MBeanServer}
+     * @return {@code this}
      */
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
+    public Builder registerWith(MBeanServer mBeanServer) {
+      this.mBeanServer = mBeanServer;
+      return this;
     }
 
     /**
-     * A builder for {@link JmxReporter} instances. Defaults to using the default MBean server and
-     * not filtering metrics.
+     * Convert rates to the given time unit.
+     *
+     * @param rateUnit a unit of time
+     * @return {@code this}
      */
-    public static class Builder {
-        private final MetricRegistry registry;
-        private MBeanServer mBeanServer;
-        private TimeUnit rateUnit;
-        private TimeUnit durationUnit;
-        private ObjectNameFactory objectNameFactory;
-        private MetricFilter filter = MetricFilter.ALL;
-        private String domain;
-        private Map<String, TimeUnit> specificDurationUnits;
-        private Map<String, TimeUnit> specificRateUnits;
-
-        private Builder(MetricRegistry registry) {
-            this.registry = registry;
-            this.rateUnit = TimeUnit.SECONDS;
-            this.durationUnit = TimeUnit.MILLISECONDS;
-            this.domain = "metrics";
-            this.objectNameFactory = new DefaultObjectNameFactory();
-            this.specificDurationUnits = Collections.emptyMap();
-            this.specificRateUnits = Collections.emptyMap();
-        }
-
-        /**
-         * Register MBeans with the given {@link MBeanServer}.
-         *
-         * @param mBeanServer an {@link MBeanServer}
-         * @return {@code this}
-         */
-        public Builder registerWith(MBeanServer mBeanServer) {
-            this.mBeanServer = mBeanServer;
-            return this;
-        }
-
-        /**
-         * Convert rates to the given time unit.
-         *
-         * @param rateUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertRatesTo(TimeUnit rateUnit) {
-            this.rateUnit = rateUnit;
-            return this;
-        }
-
-        public Builder createsObjectNamesWith(ObjectNameFactory onFactory) {
-            if (onFactory == null) {
-                throw new IllegalArgumentException("null objectNameFactory");
-            }
-            this.objectNameFactory = onFactory;
-            return this;
-        }
-
-        /**
-         * Convert durations to the given time unit.
-         *
-         * @param durationUnit a unit of time
-         * @return {@code this}
-         */
-        public Builder convertDurationsTo(TimeUnit durationUnit) {
-            this.durationUnit = durationUnit;
-            return this;
-        }
-
-        /**
-         * Only report metrics which match the given filter.
-         *
-         * @param filter a {@link MetricFilter}
-         * @return {@code this}
-         */
-        public Builder filter(MetricFilter filter) {
-            this.filter = filter;
-            return this;
-        }
-
-        public Builder inDomain(String domain) {
-            this.domain = domain;
-            return this;
-        }
-
-        /**
-         * Use specific {@link TimeUnit}s for the duration of the metrics with these names.
-         *
-         * @param specificDurationUnits a map of metric names and specific {@link TimeUnit}s
-         * @return {@code this}
-         */
-        public Builder specificDurationUnits(Map<String, TimeUnit> specificDurationUnits) {
-            this.specificDurationUnits = Collections.unmodifiableMap(specificDurationUnits);
-            return this;
-        }
-
-
-        /**
-         * Use specific {@link TimeUnit}s for the rate of the metrics with these names.
-         *
-         * @param specificRateUnits a map of metric names and specific {@link TimeUnit}s
-         * @return {@code this}
-         */
-        public Builder specificRateUnits(Map<String, TimeUnit> specificRateUnits) {
-            this.specificRateUnits = Collections.unmodifiableMap(specificRateUnits);
-            return this;
-        }
+    public Builder convertRatesTo(TimeUnit rateUnit) {
+      this.rateUnit = rateUnit;
+      return this;
+    }
 
-        /**
-         * Builds a {@link JmxReporter} with the given properties.
-         *
-         * @return a {@link JmxReporter}
-         */
-        public JmxReporter build() {
-            final MetricTimeUnits timeUnits = new MetricTimeUnits(rateUnit, durationUnit, specificRateUnits, specificDurationUnits);
-            if (mBeanServer == null) {
-                mBeanServer = ManagementFactory.getPlatformMBeanServer();
-            }
-            return new JmxReporter(mBeanServer, domain, registry, filter, timeUnits, objectNameFactory);
-        }
+    public Builder createsObjectNamesWith(ObjectNameFactory onFactory) {
+      checkArgument(onFactory != null, "null objectNameFactory");
+      this.objectNameFactory = onFactory;
+      return this;
     }
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(JmxReporter.class);
+    /**
+     * Convert durations to the given time unit.
+     *
+     * @param durationUnit a unit of time
+     * @return {@code this}
+     */
+    public Builder convertDurationsTo(TimeUnit durationUnit) {
+      this.durationUnit = durationUnit;
+      return this;
+    }
 
-    @SuppressWarnings("UnusedDeclaration")
-    public interface MetricMBean {
-        ObjectName objectName();
+    /**
+     * Only report metrics which match the given filter.
+     *
+     * @param filter a {@link MetricFilter}
+     * @return {@code this}
+     */
+    public Builder filter(MetricFilter filter) {
+      this.filter = filter;
+      return this;
     }
 
-    private abstract static class AbstractBean implements MetricMBean {
-        private final ObjectName objectName;
+    public Builder inDomain(String domain) {
+      this.domain = domain;
+      return this;
+    }
 
-        AbstractBean(ObjectName objectName) {
-            this.objectName = objectName;
-        }
+    /**
+     * Use specific {@link TimeUnit}s for the duration of the metrics with these names.
+     *
+     * @param specificDurationUnits a map of metric names and specific {@link TimeUnit}s
+     * @return {@code this}
+     */
+    public Builder specificDurationUnits(Map<String, TimeUnit> specificDurationUnits) {
+      this.specificDurationUnits = unmodifiableMap(specificDurationUnits);
+      return this;
+    }
 
-        @Override
-        public ObjectName objectName() {
-            return objectName;
-        }
+    /**
+     * Use specific {@link TimeUnit}s for the rate of the metrics with these names.
+     *
+     * @param specificRateUnits a map of metric names and specific {@link TimeUnit}s
+     * @return {@code this}
+     */
+    public Builder specificRateUnits(Map<String, TimeUnit> specificRateUnits) {
+      this.specificRateUnits = unmodifiableMap(specificRateUnits);
+      return this;
     }
 
-    @SuppressWarnings("UnusedDeclaration")
-    public interface JmxGaugeMBean extends MetricMBean {
-        Object getValue();
-        Number getNumber();
+    /**
+     * Builds a {@link JmxReporter} with the given properties.
+     *
+     * @return a {@link JmxReporter}
+     */
+    public JmxReporter build() {
+      final MetricTimeUnits timeUnits =
+          new MetricTimeUnits(rateUnit, durationUnit, specificRateUnits, specificDurationUnits);
+      if (mBeanServer == null) {
+        mBeanServer = ManagementFactory.getPlatformMBeanServer();
+      }
+      return new JmxReporter(mBeanServer, domain, registry, filter, timeUnits, objectNameFactory);
     }
+  }
 
-    private static class JmxGauge extends AbstractBean implements JmxGaugeMBean {
-        private final Gauge<?> metric;
+  private static final Logger LOG = LoggerFactory.getLogger(JmxReporter.class);
 
-        private JmxGauge(Gauge<?> metric, ObjectName objectName) {
-            super(objectName);
-            this.metric = metric;
-        }
+  @SuppressWarnings("UnusedDeclaration")
+  public interface MetricMBean {
+    ObjectName objectName();
+  }
 
-        @Override
-        public Object getValue() {
-            return metric.getValue();
-        }
+  private abstract static class AbstractBean implements MetricMBean {
+    private final ObjectName objectName;
 
-        @Override
-        public Number getNumber() {
-            Object value = metric.getValue();
-            return value instanceof Number ? (Number) value : 0;
-        }
+    AbstractBean(ObjectName objectName) {
+      this.objectName = objectName;
     }
 
-    @SuppressWarnings("UnusedDeclaration")
-    public interface JmxCounterMBean extends MetricMBean {
-        long getCount();
+    @Override
+    public ObjectName objectName() {
+      return objectName;
     }
+  }
 
-    private static class JmxCounter extends AbstractBean implements JmxCounterMBean {
-        private final Counter metric;
+  @SuppressWarnings("UnusedDeclaration")
+  public interface JmxGaugeMBean extends MetricMBean {
+    Object getValue();
 
-        private JmxCounter(Counter metric, ObjectName objectName) {
-            super(objectName);
-            this.metric = metric;
-        }
+    Number getNumber();
+  }
 
-        @Override
-        public long getCount() {
-            return metric.getCount();
-        }
-    }
-
-    @SuppressWarnings("UnusedDeclaration")
-    public interface JmxHistogramMBean extends MetricMBean {
-        long getCount();
+  private static class JmxGauge extends AbstractBean implements JmxGaugeMBean {
+    private final Gauge<?> metric;
 
-        long getSum();
+    private JmxGauge(Gauge<?> metric, ObjectName objectName) {
+      super(objectName);
+      this.metric = metric;
+    }
 
-        long getMin();
+    @Override
+    public Object getValue() {
+      return metric.getValue();
+    }
 
-        long getMax();
+    @Override
+    public Number getNumber() {
+      Object value = metric.getValue();
+      return value instanceof Number ? (Number) value : 0;
+    }
+  }
 
-        double getMean();
+  @SuppressWarnings("UnusedDeclaration")
+  public interface JmxCounterMBean extends MetricMBean {
+    long getCount();
+  }
 
-        double getStdDev();
+  private static class JmxCounter extends AbstractBean implements JmxCounterMBean {
+    private final Counter metric;
 
-        double get50thPercentile();
+    private JmxCounter(Counter metric, ObjectName objectName) {
+      super(objectName);
+      this.metric = metric;
+    }
 
-        double get75thPercentile();
+    @Override
+    public long getCount() {
+      return metric.getCount();
+    }
+  }
 
-        double get95thPercentile();
+  @SuppressWarnings("UnusedDeclaration")
+  public interface JmxHistogramMBean extends MetricMBean {
+    long getCount();
 
-        double get98thPercentile();
+    long getSum();
 
-        double get99thPercentile();
+    long getMin();
 
-        double get999thPercentile();
+    long getMax();
 
-        long[] values();
+    double getMean();
 
-        long getSnapshotSize();
-    }
+    double getStdDev();
 
-    private static class JmxHistogram implements JmxHistogramMBean {
-        private final ObjectName objectName;
-        private final Histogram metric;
+    double get50thPercentile();
 
-        private JmxHistogram(Histogram metric, ObjectName objectName) {
-            this.metric = metric;
-            this.objectName = objectName;
-        }
+    double get75thPercentile();
 
-        @Override
-        public ObjectName objectName() {
-            return objectName;
-        }
+    double get95thPercentile();
 
-        @Override
-        public double get50thPercentile() {
-            return metric.getSnapshot().getMedian();
-        }
+    double get98thPercentile();
 
-        @Override
-        public long getCount() {
-            return metric.getCount();
-        }
+    double get99thPercentile();
 
-        @Override
-        public long getSum() {
-            return metric.getSum();
-        }
+    double get999thPercentile();
 
-        @Override
-        public long getMin() {
-            return metric.getSnapshot().getMin();
-        }
+    long[] values();
 
-        @Override
-        public long getMax() {
-            return metric.getSnapshot().getMax();
-        }
+    long getSnapshotSize();
+  }
 
-        @Override
-        public double getMean() {
-            return metric.getSnapshot().getMean();
-        }
+  private static class JmxHistogram implements JmxHistogramMBean {
+    private final ObjectName objectName;
+    private final Histogram metric;
 
-        @Override
-        public double getStdDev() {
-            return metric.getSnapshot().getStdDev();
-        }
+    private JmxHistogram(Histogram metric, ObjectName objectName) {
+      this.metric = metric;
+      this.objectName = objectName;
+    }
 
-        @Override
-        public double get75thPercentile() {
-            return metric.getSnapshot().get75thPercentile();
-        }
+    @Override
+    public ObjectName objectName() {
+      return objectName;
+    }
 
-        @Override
-        public double get95thPercentile() {
-            return metric.getSnapshot().get95thPercentile();
-        }
+    @Override
+    public double get50thPercentile() {
+      return metric.getSnapshot().getMedian();
+    }
 
-        @Override
-        public double get98thPercentile() {
-            return metric.getSnapshot().get98thPercentile();
-        }
+    @Override
+    public long getCount() {
+      return metric.getCount();
+    }
 
-        @Override
-        public double get99thPercentile() {
-            return metric.getSnapshot().get99thPercentile();
-        }
+    @Override
+    public long getSum() {
+      return metric.getSum();
+    }
 
-        @Override
-        public double get999thPercentile() {
-            return metric.getSnapshot().get999thPercentile();
-        }
+    @Override
+    public long getMin() {
+      return metric.getSnapshot().getMin();
+    }
 
-        @Override
-        public long[] values() {
-            return metric.getSnapshot().getValues();
-        }
+    @Override
+    public long getMax() {
+      return metric.getSnapshot().getMax();
+    }
 
-        @Override
-        public long getSnapshotSize() {
-            return metric.getSnapshot().size();
-        }
+    @Override
+    public double getMean() {
+      return metric.getSnapshot().getMean();
     }
 
-    @SuppressWarnings("UnusedDeclaration")
-    public interface JmxMeterMBean extends MetricMBean {
-        long getCount();
+    @Override
+    public double getStdDev() {
+      return metric.getSnapshot().getStdDev();
+    }
 
-        double getSum();
+    @Override
+    public double get75thPercentile() {
+      return metric.getSnapshot().get75thPercentile();
+    }
 
-        double getMeanRate();
+    @Override
+    public double get95thPercentile() {
+      return metric.getSnapshot().get95thPercentile();
+    }
 
-        double getOneMinuteRate();
+    @Override
+    public double get98thPercentile() {
+      return metric.getSnapshot().get98thPercentile();
+    }
 
-        double getFiveMinuteRate();
+    @Override
+    public double get99thPercentile() {
+      return metric.getSnapshot().get99thPercentile();
+    }
 
-        double getFifteenMinuteRate();
+    @Override
+    public double get999thPercentile() {
+      return metric.getSnapshot().get999thPercentile();
+    }
 
-        String getRateUnit();
+    @Override
+    public long[] values() {
+      return metric.getSnapshot().getValues();
     }
 
-    private static class JmxMeter extends AbstractBean implements JmxMeterMBean {
-        private final Metered metric;
-        private final double rateFactor;
-        private final String rateUnit;
+    @Override
+    public long getSnapshotSize() {
+      return metric.getSnapshot().size();
+    }
+  }
 
-        private JmxMeter(Metered metric, ObjectName objectName, TimeUnit rateUnit) {
-            super(objectName);
-            this.metric = metric;
-            this.rateFactor = rateUnit.toSeconds(1);
-            this.rateUnit = ("events/" + calculateRateUnit(rateUnit)).intern();
-        }
+  @SuppressWarnings("UnusedDeclaration")
+  public interface JmxMeterMBean extends MetricMBean {
+    long getCount();
 
-        @Override
-        public long getCount() {
-            return metric.getCount();
-        }
+    double getSum();
 
-        @Override
-        public double getSum() {
-            return metric.getSum();
-        }
+    double getMeanRate();
 
-        @Override
-        public double getMeanRate() {
-            return metric.getMeanRate() * rateFactor;
-        }
+    double getOneMinuteRate();
 
-        @Override
-        public double getOneMinuteRate() {
-            return metric.getOneMinuteRate() * rateFactor;
-        }
+    double getFiveMinuteRate();
 
-        @Override
-        public double getFiveMinuteRate() {
-            return metric.getFiveMinuteRate() * rateFactor;
-        }
+    double getFifteenMinuteRate();
 
-        @Override
-        public double getFifteenMinuteRate() {
-            return metric.getFifteenMinuteRate() * rateFactor;
-        }
+    String getRateUnit();
+  }
 
-        @Override
-        public String getRateUnit() {
-            return rateUnit;
-        }
+  private static class JmxMeter extends AbstractBean implements JmxMeterMBean {
+    private final Metered metric;
+    private final double rateFactor;
+    private final String rateUnit;
 
-        private String calculateRateUnit(TimeUnit unit) {
-            final String s = unit.toString().toLowerCase(Locale.US);
-            return s.substring(0, s.length() - 1);
-        }
+    private JmxMeter(Metered metric, ObjectName objectName, TimeUnit rateUnit) {
+      super(objectName);
+      this.metric = metric;
+      this.rateFactor = rateUnit.toSeconds(1);
+      this.rateUnit = ("events/" + calculateRateUnit(rateUnit)).intern();
     }
 
-    @SuppressWarnings("UnusedDeclaration")
-    public interface JmxTimerMBean extends JmxMeterMBean {
-        double getMin();
+    @Override
+    public long getCount() {
+      return metric.getCount();
+    }
 
-        double getMax();
+    @Override
+    public double getSum() {
+      return metric.getSum();
+    }
 
-        double getMean();
+    @Override
+    public double getMeanRate() {
+      return metric.getMeanRate() * rateFactor;
+    }
 
-        double getStdDev();
+    @Override
+    public double getOneMinuteRate() {
+      return metric.getOneMinuteRate() * rateFactor;
+    }
 
-        double get50thPercentile();
+    @Override
+    public double getFiveMinuteRate() {
+      return metric.getFiveMinuteRate() * rateFactor;
+    }
 
-        double get75thPercentile();
+    @Override
+    public double getFifteenMinuteRate() {
+      return metric.getFifteenMinuteRate() * rateFactor;
+    }
 
-        double get95thPercentile();
+    @Override
+    public String getRateUnit() {
+      return rateUnit;
+    }
 
-        double get98thPercentile();
+    private String calculateRateUnit(TimeUnit unit) {
+      final String s = unit.toString().toLowerCase(Locale.US);
+      return s.substring(0, s.length() - 1);
+    }
+  }
 
-        double get99thPercentile();
+  @SuppressWarnings("UnusedDeclaration")
+  public interface JmxTimerMBean extends JmxMeterMBean {
+    double getMin();
 
-        double get999thPercentile();
+    double getMax();
 
-        long[] values();
+    double getMean();
 
-        String getDurationUnit();
-    }
+    double getStdDev();
 
-    static class JmxTimer extends JmxMeter implements JmxTimerMBean {
-        private final Timer metric;
-        private final double durationFactor;
-        private final String durationUnit;
+    double get50thPercentile();
 
-        private JmxTimer(Timer metric,
-                         ObjectName objectName,
-                         TimeUnit rateUnit,
-                         TimeUnit durationUnit) {
-            super(metric, objectName, rateUnit);
-            this.metric = metric;
-            this.durationFactor = 1.0 / durationUnit.toNanos(1);
-            this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);
-        }
+    double get75thPercentile();
 
-        @Override
-        public double get50thPercentile() {
-            return metric.getSnapshot().getMedian() * durationFactor;
-        }
+    double get95thPercentile();
 
-        @Override
-        public double getMin() {
-            return metric.getSnapshot().getMin() * durationFactor;
-        }
+    double get98thPercentile();
 
-        @Override
-        public double getMax() {
-            return metric.getSnapshot().getMax() * durationFactor;
-        }
+    double get99thPercentile();
 
-        @Override
-        public double getMean() {
-            return metric.getSnapshot().getMean() * durationFactor;
-        }
+    double get999thPercentile();
 
-        @Override
-        public double getStdDev() {
-            return metric.getSnapshot().getStdDev() * durationFactor;
-        }
+    long[] values();
 
-        @Override
-        public double get75thPercentile() {
-            return metric.getSnapshot().get75thPercentile() * durationFactor;
-        }
+    String getDurationUnit();
+  }
 
-        @Override
-        public double get95thPercentile() {
-            return metric.getSnapshot().get95thPercentile() * durationFactor;
-        }
+  static class JmxTimer extends JmxMeter implements JmxTimerMBean {
+    private final Timer metric;
+    private final double durationFactor;
+    private final String durationUnit;
 
-        @Override
-        public double get98thPercentile() {
-            return metric.getSnapshot().get98thPercentile() * durationFactor;
-        }
+    private JmxTimer(
+        Timer metric, ObjectName objectName, TimeUnit rateUnit, TimeUnit durationUnit) {
+      super(metric, objectName, rateUnit);
+      this.metric = metric;
+      this.durationFactor = 1.0 / durationUnit.toNanos(1);
+      this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);
+    }
 
-        @Override
-        public double get99thPercentile() {
-            return metric.getSnapshot().get99thPercentile() * durationFactor;
-        }
+    @Override
+    public double get50thPercentile() {
+      return metric.getSnapshot().getMedian() * durationFactor;
+    }
 
-        @Override
-        public double get999thPercentile() {
-            return metric.getSnapshot().get999thPercentile() * durationFactor;
-        }
-        
-        @Override
-        public double getSum() {
-        	return super.getSum() * durationFactor;
-        }
+    @Override
+    public double getMin() {
+      return metric.getSnapshot().getMin() * durationFactor;
+    }
 
-        @Override
-        public long[] values() {
-            return metric.getSnapshot().getValues();
-        }
+    @Override
+    public double getMax() {
+      return metric.getSnapshot().getMax() * durationFactor;
+    }
 
-        @Override
-        public String getDurationUnit() {
-            return durationUnit;
-        }
+    @Override
+    public double getMean() {
+      return metric.getSnapshot().getMean() * durationFactor;
     }
 
-    private static class JmxListener implements MetricRegistryListener {
-        private final String name;
-        private final MBeanServer mBeanServer;
-        private final MetricFilter filter;
-        private final MetricTimeUnits timeUnits;
-        private final Map<ObjectName, ObjectName> registered;
-        private final ObjectNameFactory objectNameFactory;
-
-        private JmxListener(MBeanServer mBeanServer, String name, MetricFilter filter, MetricTimeUnits timeUnits, ObjectNameFactory objectNameFactory) {
-            this.mBeanServer = mBeanServer;
-            this.name = name;
-            this.filter = filter;
-            this.timeUnits = timeUnits;
-            this.registered = new ConcurrentHashMap<>();
-            this.objectNameFactory = objectNameFactory;
-        }
+    @Override
+    public double getStdDev() {
+      return metric.getSnapshot().getStdDev() * durationFactor;
+    }
 
-        private void registerMBean(Object mBean, ObjectName objectName) throws InstanceAlreadyExistsException, JMException {
-            ObjectInstance objectInstance = mBeanServer.registerMBean(mBean, objectName);
-            if (objectInstance != null) {
-                // the websphere mbeanserver rewrites the objectname to include
-                // cell, node & server info
-                // make sure we capture the new objectName for unregistration
-                registered.put(objectName, objectInstance.getObjectName());
-            } else {
-                registered.put(objectName, objectName);
-            }
-        }
+    @Override
+    public double get75thPercentile() {
+      return metric.getSnapshot().get75thPercentile() * durationFactor;
+    }
 
-        private void unregisterMBean(ObjectName originalObjectName) throws InstanceNotFoundException, MBeanRegistrationException {
-            ObjectName storedObjectName = registered.remove(originalObjectName);
-            if (storedObjectName != null) {
-                mBeanServer.unregisterMBean(storedObjectName);
-            } else {
-                mBeanServer.unregisterMBean(originalObjectName);
-            }
-        }
+    @Override
+    public double get95thPercentile() {
+      return metric.getSnapshot().get95thPercentile() * durationFactor;
+    }
 
-        @Override
-        public void onGaugeAdded(MetricName name, Gauge<?> gauge) {
-            try {
-                if (filter.matches(name, gauge)) {
-                    final ObjectName objectName = createName("gauges", name);
-                    registerMBean(new JmxGauge(gauge, objectName), objectName);
-                }
-            } catch (InstanceAlreadyExistsException e) {
-                LOGGER.debug("Unable to register gauge", e);
-            } catch (JMException e) {
-                LOGGER.warn("Unable to register gauge", e);
-            }
-        }
+    @Override
+    public double get98thPercentile() {
+      return metric.getSnapshot().get98thPercentile() * durationFactor;
+    }
 
-        @Override
-        public void onGaugeRemoved(MetricName name) {
-            try {
-                final ObjectName objectName = createName("gauges", name);
-                unregisterMBean(objectName);
-            } catch (InstanceNotFoundException e) {
-                LOGGER.debug("Unable to unregister gauge", e);
-            } catch (MBeanRegistrationException e) {
-                LOGGER.warn("Unable to unregister gauge", e);
-            }
-        }
+    @Override
+    public double get99thPercentile() {
+      return metric.getSnapshot().get99thPercentile() * durationFactor;
+    }
 
-        @Override
-        public void onCounterAdded(MetricName name, Counter counter) {
-            try {
-                if (filter.matches(name, counter)) {
-                    final ObjectName objectName = createName("counters", name);
-                    registerMBean(new JmxCounter(counter, objectName), objectName);
-                }
-            } catch (InstanceAlreadyExistsException e) {
-                LOGGER.debug("Unable to register counter", e);
-            } catch (JMException e) {
-                LOGGER.warn("Unable to register counter", e);
-            }
-        }
+    @Override
+    public double get999thPercentile() {
+      return metric.getSnapshot().get999thPercentile() * durationFactor;
+    }
 
-        @Override
-        public void onCounterRemoved(MetricName name) {
-            try {
-                final ObjectName objectName = createName("counters", name);
-                unregisterMBean(objectName);
-            } catch (InstanceNotFoundException e) {
-                LOGGER.debug("Unable to unregister counter", e);
-            } catch (MBeanRegistrationException e) {
-                LOGGER.warn("Unable to unregister counter", e);
-            }
-        }
+    @Override
+    public double getSum() {
+      return super.getSum() * durationFactor;
+    }
 
-        @Override
-        public void onHistogramAdded(MetricName name, Histogram histogram) {
-            try {
-                if (filter.matches(name, histogram)) {
-                    final ObjectName objectName = createName("histograms", name);
-                    registerMBean(new JmxHistogram(histogram, objectName), objectName);
-                }
-            } catch (InstanceAlreadyExistsException e) {
-                LOGGER.debug("Unable to register histogram", e);
-            } catch (JMException e) {
-                LOGGER.warn("Unable to register histogram", e);
-            }
-        }
+    @Override
+    public long[] values() {
+      return metric.getSnapshot().getValues();
+    }
 
-        @Override
-        public void onHistogramRemoved(MetricName name) {
-            try {
-                final ObjectName objectName = createName("histograms", name);
-                unregisterMBean(objectName);
-            } catch (InstanceNotFoundException e) {
-                LOGGER.debug("Unable to unregister histogram", e);
-            } catch (MBeanRegistrationException e) {
-                LOGGER.warn("Unable to unregister histogram", e);
-            }
-        }
+    @Override
+    public String getDurationUnit() {
+      return durationUnit;
+    }
+  }
+
+  private static class JmxListener implements MetricRegistryListener {
+    private final String name;
+    private final MBeanServer mBeanServer;
+    private final MetricFilter filter;
+    private final MetricTimeUnits timeUnits;
+    private final Map<ObjectName, ObjectName> registered;
+    private final ObjectNameFactory objectNameFactory;
+
+    private JmxListener(
+        MBeanServer mBeanServer,
+        String name,
+        MetricFilter filter,
+        MetricTimeUnits timeUnits,
+        ObjectNameFactory objectNameFactory) {
+      this.mBeanServer = mBeanServer;
+      this.name = name;
+      this.filter = filter;
+      this.timeUnits = timeUnits;
+      this.registered = new ConcurrentHashMap<>();
+      this.objectNameFactory = objectNameFactory;
+    }
 
-        @Override
-        public void onMeterAdded(MetricName name, Meter meter) {
-            try {
-                if (filter.matches(name, meter)) {
-                    final ObjectName objectName = createName("meters", name);
-                    registerMBean(new JmxMeter(meter, objectName, timeUnits.rateFor(name.getKey())), objectName);
-                }
-            } catch (InstanceAlreadyExistsException e) {
-                LOGGER.debug("Unable to register meter", e);
-            } catch (JMException e) {
-                LOGGER.warn("Unable to register meter", e);
-            }
-        }
+    private void registerMBean(Object mBean, ObjectName objectName)
+        throws InstanceAlreadyExistsException, JMException {
+      ObjectInstance objectInstance = mBeanServer.registerMBean(mBean, objectName);
+      if (objectInstance != null) {
+        // the websphere mbeanserver rewrites the objectname to include
+        // cell, node & server info
+        // make sure we capture the new objectName for unregistration
+        registered.put(objectName, objectInstance.getObjectName());
+      } else {
+        registered.put(objectName, objectName);
+      }
+    }
 
-        @Override
-        public void onMeterRemoved(MetricName name) {
-            try {
-                final ObjectName objectName = createName("meters", name);
-                unregisterMBean(objectName);
-            } catch (InstanceNotFoundException e) {
-                LOGGER.debug("Unable to unregister meter", e);
-            } catch (MBeanRegistrationException e) {
-                LOGGER.warn("Unable to unregister meter", e);
-            }
-        }
+    private void unregisterMBean(ObjectName originalObjectName)
+        throws InstanceNotFoundException, MBeanRegistrationException {
+      ObjectName storedObjectName = registered.remove(originalObjectName);
+      if (storedObjectName != null) {
+        mBeanServer.unregisterMBean(storedObjectName);
+      } else {
+        mBeanServer.unregisterMBean(originalObjectName);
+      }
+    }
 
-        @Override
-        public void onTimerAdded(MetricName name, Timer timer) {
-            try {
-                if (filter.matches(name, timer)) {
-                    final ObjectName objectName = createName("timers", name);
-                    registerMBean(new JmxTimer(timer, objectName, timeUnits.rateFor(name.getKey()), timeUnits.durationFor(name.getKey())), objectName);
-                }
-            } catch (InstanceAlreadyExistsException e) {
-                LOGGER.debug("Unable to register timer", e);
-            } catch (JMException e) {
-                LOGGER.warn("Unable to register timer", e);
-            }
-        }
+    @Override
+    public void onGaugeAdded(MetricName name, Gauge<?> gauge) {
+      try {
+        if (filter.matches(name, gauge)) {
+          final ObjectName objectName = createName("gauges", name);
+          registerMBean(new JmxGauge(gauge, objectName), objectName);
+        }
+      } catch (InstanceAlreadyExistsException e) {
+        LOG.debug("Unable to register gauge", e);
+      } catch (JMException e) {
+        LOG.warn("Unable to register gauge", e);
+      }
+    }
 
-        @Override
-        public void onTimerRemoved(MetricName name) {
-            try {
-                final ObjectName objectName = createName("timers", name);
-                unregisterMBean(objectName);
-            } catch (InstanceNotFoundException e) {
-                LOGGER.debug("Unable to unregister timer", e);
-            } catch (MBeanRegistrationException e) {
-                LOGGER.warn("Unable to unregister timer", e);
-            }
-        }
+    @Override
+    public void onGaugeRemoved(MetricName name) {
+      try {
+        final ObjectName objectName = createName("gauges", name);
+        unregisterMBean(objectName);
+      } catch (InstanceNotFoundException e) {
+        LOG.debug("Unable to unregister gauge", e);
+      } catch (MBeanRegistrationException e) {
+        LOG.warn("Unable to unregister gauge", e);
+      }
+    }
 
-        private ObjectName createName(String type, MetricName name) {
-            return objectNameFactory.createName(type, this.name, name);
-        }
+    @Override
+    public void onCounterAdded(MetricName name, Counter counter) {
+      try {
+        if (filter.matches(name, counter)) {
+          final ObjectName objectName = createName("counters", name);
+          registerMBean(new JmxCounter(counter, objectName), objectName);
+        }
+      } catch (InstanceAlreadyExistsException e) {
+        LOG.debug("Unable to register counter", e);
+      } catch (JMException e) {
+        LOG.warn("Unable to register counter", e);
+      }
+    }
 
-        void unregisterAll() {
-            for (ObjectName name : registered.keySet()) {
-                try {
-                    unregisterMBean(name);
-                } catch (InstanceNotFoundException e) {
-                    LOGGER.debug("Unable to unregister metric", e);
-                } catch (MBeanRegistrationException e) {
-                    LOGGER.warn("Unable to unregister metric", e);
-                }
-            }
-            registered.clear();
-        }
+    @Override
+    public void onCounterRemoved(MetricName name) {
+      try {
+        final ObjectName objectName = createName("counters", name);
+        unregisterMBean(objectName);
+      } catch (InstanceNotFoundException e) {
+        LOG.debug("Unable to unregister counter", e);
+      } catch (MBeanRegistrationException e) {
+        LOG.warn("Unable to unregister counter", e);
+      }
     }
 
-    private static class MetricTimeUnits {
-        private final TimeUnit defaultRate;
-        private final TimeUnit defaultDuration;
-        private final Map<String, TimeUnit> rateOverrides;
-        private final Map<String, TimeUnit> durationOverrides;
-
-        MetricTimeUnits(TimeUnit defaultRate,
-                        TimeUnit defaultDuration,
-                        Map<String, TimeUnit> rateOverrides,
-                        Map<String, TimeUnit> durationOverrides) {
-            this.defaultRate = defaultRate;
-            this.defaultDuration = defaultDuration;
-            this.rateOverrides = rateOverrides;
-            this.durationOverrides = durationOverrides;
-        }
+    @Override
+    public void onHistogramAdded(MetricName name, Histogram histogram) {
+      try {
+        if (filter.matches(name, histogram)) {
+          final ObjectName objectName = createName("histograms", name);
+          registerMBean(new JmxHistogram(histogram, objectName), objectName);
+        }
+      } catch (InstanceAlreadyExistsException e) {
+        LOG.debug("Unable to register histogram", e);
+      } catch (JMException e) {
+        LOG.warn("Unable to register histogram", e);
+      }
+    }
 
-        public TimeUnit durationFor(String name) {
-            return durationOverrides.getOrDefault(name, defaultDuration);
-        }
+    @Override
+    public void onHistogramRemoved(MetricName name) {
+      try {
+        final ObjectName objectName = createName("histograms", name);
+        unregisterMBean(objectName);
+      } catch (InstanceNotFoundException e) {
+        LOG.debug("Unable to unregister histogram", e);
+      } catch (MBeanRegistrationException e) {
+        LOG.warn("Unable to unregister histogram", e);
+      }
+    }
 
-        public TimeUnit rateFor(String name) {
-            return rateOverrides.getOrDefault(name, defaultRate);
-        }
+    @Override
+    public void onMeterAdded(MetricName name, Meter meter) {
+      try {
+        if (filter.matches(name, meter)) {
+          final ObjectName objectName = createName("meters", name);
+          registerMBean(
+              new JmxMeter(meter, objectName, timeUnits.rateFor(name.getKey())), objectName);
+        }
+      } catch (InstanceAlreadyExistsException e) {
+        LOG.debug("Unable to register meter", e);
+      } catch (JMException e) {
+        LOG.warn("Unable to register meter", e);
+      }
     }
 
-    private final MetricRegistry registry;
-    private final JmxListener listener;
+    @Override
+    public void onMeterRemoved(MetricName name) {
+      try {
+        final ObjectName objectName = createName("meters", name);
+        unregisterMBean(objectName);
+      } catch (InstanceNotFoundException e) {
+        LOG.debug("Unable to unregister meter", e);
+      } catch (MBeanRegistrationException e) {
+        LOG.warn("Unable to unregister meter", e);
+      }
+    }
 
-    private JmxReporter(MBeanServer mBeanServer,
-                        String domain,
-                        MetricRegistry registry,
-                        MetricFilter filter,
-                        MetricTimeUnits timeUnits,
-                        ObjectNameFactory objectNameFactory) {
-        this.registry = registry;
-        this.listener = new JmxListener(mBeanServer, domain, filter, timeUnits, objectNameFactory);
+    @Override
+    public void onTimerAdded(MetricName name, Timer timer) {
+      try {
+        if (filter.matches(name, timer)) {
+          final ObjectName objectName = createName("timers", name);
+          registerMBean(
+              new JmxTimer(
+                  timer,
+                  objectName,
+                  timeUnits.rateFor(name.getKey()),
+                  timeUnits.durationFor(name.getKey())),
+              objectName);
+        }
+      } catch (InstanceAlreadyExistsException e) {
+        LOG.debug("Unable to register timer", e);
+      } catch (JMException e) {
+        LOG.warn("Unable to register timer", e);
+      }
     }
 
-    /**
-     * Starts the reporter.
-     */
-    public void start() {
-        registry.addListener(listener);
+    @Override
+    public void onTimerRemoved(MetricName name) {
+      try {
+        final ObjectName objectName = createName("timers", name);
+        unregisterMBean(objectName);
+      } catch (InstanceNotFoundException e) {
+        LOG.debug("Unable to unregister timer", e);
+      } catch (MBeanRegistrationException e) {
+        LOG.warn("Unable to unregister timer", e);
+      }
     }
 
-    /**
-     * Stops the reporter.
-     */
-    public void stop() {
-        registry.removeListener(listener);
-        listener.unregisterAll();
+    private ObjectName createName(String type, MetricName name) {
+      return objectNameFactory.createName(type, this.name, name);
     }
 
-    /**
-     * Stops the reporter.
-     */
-    @Override
-    public void close() {
-        stop();
+    void unregisterAll() {
+      for (ObjectName name : registered.keySet()) {
+        try {
+          unregisterMBean(name);
+        } catch (InstanceNotFoundException e) {
+          LOG.debug("Unable to unregister metric", e);
+        } catch (MBeanRegistrationException e) {
+          LOG.warn("Unable to unregister metric", e);
+        }
+      }
+      registered.clear();
+    }
+  }
+
+  private static class MetricTimeUnits {
+    private final TimeUnit defaultRate;
+    private final TimeUnit defaultDuration;
+    private final Map<String, TimeUnit> rateOverrides;
+    private final Map<String, TimeUnit> durationOverrides;
+
+    MetricTimeUnits(
+        TimeUnit defaultRate,
+        TimeUnit defaultDuration,
+        Map<String, TimeUnit> rateOverrides,
+        Map<String, TimeUnit> durationOverrides) {
+      this.defaultRate = defaultRate;
+      this.defaultDuration = defaultDuration;
+      this.rateOverrides = rateOverrides;
+      this.durationOverrides = durationOverrides;
     }
 
-    /**
-     * Visible for testing
-     */
-    ObjectNameFactory getObjectNameFactory() {
-        return listener.objectNameFactory;
+    public TimeUnit durationFor(String name) {
+      return durationOverrides.getOrDefault(name, defaultDuration);
     }
 
+    public TimeUnit rateFor(String name) {
+      return rateOverrides.getOrDefault(name, defaultRate);
+    }
+  }
+
+  private final MetricRegistry registry;
+  private final JmxListener listener;
+
+  private JmxReporter(
+      MBeanServer mBeanServer,
+      String domain,
+      MetricRegistry registry,
+      MetricFilter filter,
+      MetricTimeUnits timeUnits,
+      ObjectNameFactory objectNameFactory) {
+    this.registry = registry;
+    this.listener = new JmxListener(mBeanServer, domain, filter, timeUnits, objectNameFactory);
+  }
+
+  /** Starts the reporter. */
+  public void start() {
+    registry.addListener(listener);
+  }
+
+  /** Stops the reporter. */
+  public void stop() {
+    registry.removeListener(listener);
+    listener.unregisterAll();
+  }
+
+  /** Stops the reporter. */
+  @Override
+  public void close() {
+    stop();
+  }
+
+  /** Visible for testing */
+  ObjectNameFactory getObjectNameFactory() {
+    return listener.objectNameFactory;
+  }
 }
--- a/metrics-jmx/src/main/java/io/dropwizard/metrics5/jmx/ObjectNameFactory.java
+++ b/metrics-jmx/src/main/java/io/dropwizard/metrics5/jmx/ObjectNameFactory.java
@@ -1,10 +1,9 @@
 package io.dropwizard.metrics5.jmx;
 
 import io.dropwizard.metrics5.MetricName;
-
 import javax.management.ObjectName;
 
 public interface ObjectNameFactory {
 
-    ObjectName createName(String type, String domain, MetricName name);
+  ObjectName createName(String type, String domain, MetricName name);
 }
--- a/metrics-jmx/src/test/java/io/dropwizard/metrics5/jmx/DefaultObjectNameFactoryTest.java
+++ b/metrics-jmx/src/test/java/io/dropwizard/metrics5/jmx/DefaultObjectNameFactoryTest.java
@@ -1,41 +1,51 @@
 package io.dropwizard.metrics5.jmx;
 
-import io.dropwizard.metrics5.MetricName;
-import org.junit.jupiter.api.Test;
-
-import javax.management.ObjectName;
-
-import static org.assertj.core.api.Assertions.assertThatCode;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatCode;
 
-class DefaultObjectNameFactoryTest {
-
-    @Test
-    void createsObjectNameWithDomainInInput() {
-        DefaultObjectNameFactory f = new DefaultObjectNameFactory();
-        ObjectName on = f.createName("type", "com.domain", MetricName.build("something.with.dots").tagged("foo", "bar", "baz", "biz"));
-        assertThat(on.getDomain()).isEqualTo("com.domain");
-        assertThat(on.getKeyProperty("foo")).isEqualTo("bar");
-        assertThat(on.getKeyProperty("baz")).isEqualTo("biz");
-    }
-
-    @Test
-    void createsObjectNameWithNameAsKeyPropertyName() {
-        DefaultObjectNameFactory f = new DefaultObjectNameFactory();
-        ObjectName on = f.createName("type", "com.domain", MetricName.build("something.with.dots").tagged("foo", "bar", "baz", "biz"));
-        assertThat(on.getKeyProperty("name")).isEqualTo("something.with.dots");
-        assertThat(on.getKeyProperty("foo")).isEqualTo("bar");
-        assertThat(on.getKeyProperty("baz")).isEqualTo("biz");
-
-    }
+import io.dropwizard.metrics5.MetricName;
+import javax.management.ObjectName;
+import org.junit.jupiter.api.Test;
 
-    @Test
-    void createsObjectNameWithNameWithDisallowedUnquotedCharacters() {
-        DefaultObjectNameFactory f = new DefaultObjectNameFactory();
-        ObjectName on = f.createName("type", "com.domain", MetricName.build("something.with.quotes(\"ABcd\")").tagged("foo", "bar", "baz", "biz"));
-        assertThatCode(() -> new ObjectName(on.toString())).doesNotThrowAnyException();
-        assertThat(on.getKeyProperty("name")).isEqualTo("\"something.with.quotes(\\\"ABcd\\\")\"");
-        assertThat(on.getKeyProperty("foo")).isEqualTo("bar");
-        assertThat(on.getKeyProperty("baz")).isEqualTo("biz");
-    }
+final class DefaultObjectNameFactoryTest {
+
+  @Test
+  void createsObjectNameWithDomainInInput() {
+    DefaultObjectNameFactory f = new DefaultObjectNameFactory();
+    ObjectName on =
+        f.createName(
+            "type",
+            "com.domain",
+            MetricName.build("something.with.dots").tagged("foo", "bar", "baz", "biz"));
+    assertThat(on.getDomain()).isEqualTo("com.domain");
+    assertThat(on.getKeyProperty("foo")).isEqualTo("bar");
+    assertThat(on.getKeyProperty("baz")).isEqualTo("biz");
+  }
+
+  @Test
+  void createsObjectNameWithNameAsKeyPropertyName() {
+    DefaultObjectNameFactory f = new DefaultObjectNameFactory();
+    ObjectName on =
+        f.createName(
+            "type",
+            "com.domain",
+            MetricName.build("something.with.dots").tagged("foo", "bar", "baz", "biz"));
+    assertThat(on.getKeyProperty("name")).isEqualTo("something.with.dots");
+    assertThat(on.getKeyProperty("foo")).isEqualTo("bar");
+    assertThat(on.getKeyProperty("baz")).isEqualTo("biz");
+  }
+
+  @Test
+  void createsObjectNameWithNameWithDisallowedUnquotedCharacters() {
+    DefaultObjectNameFactory f = new DefaultObjectNameFactory();
+    ObjectName on =
+        f.createName(
+            "type",
+            "com.domain",
+            MetricName.build("something.with.quotes(\"ABcd\")").tagged("foo", "bar", "baz", "biz"));
+    assertThatCode(() -> new ObjectName(on.toString())).doesNotThrowAnyException();
+    assertThat(on.getKeyProperty("name")).isEqualTo("\"something.with.quotes(\\\"ABcd\\\")\"");
+    assertThat(on.getKeyProperty("foo")).isEqualTo("bar");
+    assertThat(on.getKeyProperty("baz")).isEqualTo("biz");
+  }
 }
--- a/metrics-jmx/src/test/java/io/dropwizard/metrics5/jmx/JmxReporterTest.java
+++ b/metrics-jmx/src/test/java/io/dropwizard/metrics5/jmx/JmxReporterTest.java
@@ -1,5 +1,15 @@
 package io.dropwizard.metrics5.jmx;
 
+import static java.util.UUID.randomUUID;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.entry;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.Histogram;
@@ -9,10 +19,10 @@ import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
+import java.lang.management.ManagementFactory;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.concurrent.TimeUnit;
 import javax.management.Attribute;
 import javax.management.AttributeList;
 import javax.management.InstanceNotFoundException;
@@ -20,301 +30,304 @@ import javax.management.JMException;
 import javax.management.MBeanServer;
 import javax.management.ObjectInstance;
 import javax.management.ObjectName;
-import java.lang.management.ManagementFactory;
-import java.util.SortedMap;
-import java.util.TreeMap;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.entry;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("rawtypes")
-class JmxReporterTest {
-    private final MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
-    private final String name = UUID.randomUUID().toString().replaceAll("[{\\-}]", "");
-    private final MetricRegistry registry = new MetricRegistry();
-
-    private final JmxReporter reporter = JmxReporter.forRegistry(registry)
-            .registerWith(mBeanServer)
-            .inDomain(name)
-            .convertDurationsTo(TimeUnit.MILLISECONDS)
-            .convertRatesTo(TimeUnit.SECONDS)
-            .filter(MetricFilter.ALL)
-            .build();
-
-    private final Gauge gauge = mock(Gauge.class);
-    private final Counter counter = mock(Counter.class);
-    private final Histogram histogram = mock(Histogram.class);
-    private final Meter meter = mock(Meter.class);
-    private final Timer timer = mock(Timer.class);
-    private final ObjectNameFactory mockObjectNameFactory = mock(ObjectNameFactory.class);
-    private final ObjectNameFactory concreteObjectNameFactory = reporter.getObjectNameFactory();
-
-    @BeforeEach
-    void setUp() throws Exception {
-        when(gauge.getValue()).thenReturn(1);
-
-        when(counter.getCount()).thenReturn(100L);
-
-        when(histogram.getCount()).thenReturn(1L);
-        when(histogram.getSum()).thenReturn(12L);
-
-        final Snapshot hSnapshot = mock(Snapshot.class);
-        when(hSnapshot.getMax()).thenReturn(2L);
-        when(hSnapshot.getMean()).thenReturn(3.0);
-        when(hSnapshot.getMin()).thenReturn(4L);
-        when(hSnapshot.getStdDev()).thenReturn(5.0);
-        when(hSnapshot.getMedian()).thenReturn(6.0);
-        when(hSnapshot.get75thPercentile()).thenReturn(7.0);
-        when(hSnapshot.get95thPercentile()).thenReturn(8.0);
-        when(hSnapshot.get98thPercentile()).thenReturn(9.0);
-        when(hSnapshot.get99thPercentile()).thenReturn(10.0);
-        when(hSnapshot.get999thPercentile()).thenReturn(11.0);
-        when(hSnapshot.size()).thenReturn(1);
-
-        when(histogram.getSnapshot()).thenReturn(hSnapshot);
-
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getSum()).thenReturn(6L);
-        when(meter.getMeanRate()).thenReturn(2.0);
-        when(meter.getOneMinuteRate()).thenReturn(3.0);
-        when(meter.getFiveMinuteRate()).thenReturn(4.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(5.0);
-
-        when(timer.getCount()).thenReturn(1L);
-        when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(6));
-        when(timer.getMeanRate()).thenReturn(2.0);
-        when(timer.getOneMinuteRate()).thenReturn(3.0);
-        when(timer.getFiveMinuteRate()).thenReturn(4.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(5.0);
-
-        final Snapshot tSnapshot = mock(Snapshot.class);
-        when(tSnapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
-        when(tSnapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
-        when(tSnapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
-        when(tSnapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
-        when(tSnapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
-        when(tSnapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
-        when(tSnapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
-        when(tSnapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
-        when(tSnapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
-        when(tSnapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
-        when(tSnapshot.size()).thenReturn(1);
-
-        when(timer.getSnapshot()).thenReturn(tSnapshot);
-
-        registry.register(MetricName.build("gauge"), gauge);
-        registry.register(MetricName.build("test", "counter"), counter);
-        registry.register(MetricName.build("test", "histogram"), histogram);
-        registry.register(MetricName.build("test", "meter"), meter);
-        registry.register(MetricName.build("test", "another", "timer"), timer);
-
-        reporter.start();
-    }
-
-    @AfterEach
-    void tearDown() {
-        reporter.stop();
-    }
-
-    @Test
-    void registersMBeansForMetricObjectsUsingProvidedObjectNameFactory() throws Exception {
-        ObjectName n = new ObjectName(name + ":name=dummy");
-        try {
-            String widgetName = "something";
-            when(mockObjectNameFactory.createName(any(String.class), any(String.class), any(MetricName.class))).thenReturn(n);
-            JmxReporter reporter = JmxReporter.forRegistry(registry)
-                    .registerWith(mBeanServer)
-                    .inDomain(name)
-                    .createsObjectNamesWith(mockObjectNameFactory)
-                    .build();
-            registry.registerGauge(widgetName, () -> 1);
-            reporter.start();
-            verify(mockObjectNameFactory).createName(eq("gauges"), any(String.class), eq(MetricName.build("something")));
-            //verifyNoMoreInteractions(mockObjectNameFactory);
-        } finally {
-            reporter.stop();
-            if (mBeanServer.isRegistered(n)) {
-                mBeanServer.unregisterMBean(n);
-            }
-        }
-    }
-
-    @Test
-    void registersMBeansForGauges() throws Exception {
-        final AttributeList attributes = getAttributes("gauges", "gauge", "Value", "Number");
-
-        assertThat(values(attributes))
-                .contains(entry("Value", 1), entry("Number", 1));
-    }
-
-    @Test
-    void registersMBeansForCounters() throws Exception {
-        final AttributeList attributes = getAttributes("counters", "test.counter", "Count");
-
-        assertThat(values(attributes))
-                .contains(entry("Count", 100L));
-    }
-
-    @Test
-    void registersMBeansForHistograms() throws Exception {
-        final AttributeList attributes = getAttributes("histograms", "test.histogram",
-                "Count",
-                "Sum",
-                "Max",
-                "Mean",
-                "Min",
-                "StdDev",
-                "50thPercentile",
-                "75thPercentile",
-                "95thPercentile",
-                "98thPercentile",
-                "99thPercentile",
-                "999thPercentile",
-                "SnapshotSize");
-
-        assertThat(values(attributes))
-                .contains(entry("Count", 1L))
-                .contains(entry("Sum", 12L))
-                .contains(entry("Max", 2L))
-                .contains(entry("Mean", 3.0))
-                .contains(entry("Min", 4L))
-                .contains(entry("StdDev", 5.0))
-                .contains(entry("50thPercentile", 6.0))
-                .contains(entry("75thPercentile", 7.0))
-                .contains(entry("95thPercentile", 8.0))
-                .contains(entry("98thPercentile", 9.0))
-                .contains(entry("99thPercentile", 10.0))
-                .contains(entry("999thPercentile", 11.0))
-                .contains(entry("SnapshotSize", 1L));
-    }
-
-    @Test
-    void registersMBeansForMeters() throws Exception {
-        final AttributeList attributes = getAttributes("meters", "test.meter",
-                "Count",
-                "Sum",
-                "MeanRate",
-                "OneMinuteRate",
-                "FiveMinuteRate",
-                "FifteenMinuteRate",
-                "RateUnit");
-
-        assertThat(values(attributes))
-                .contains(entry("Count", 1L))
-                .contains(entry("Sum", 6.0))
-                .contains(entry("MeanRate", 2.0))
-                .contains(entry("OneMinuteRate", 3.0))
-                .contains(entry("FiveMinuteRate", 4.0))
-                .contains(entry("FifteenMinuteRate", 5.0))
-                .contains(entry("RateUnit", "events/second"));
+final class JmxReporterTest {
+  private final MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
+  private final String name = randomUUID().toString().replaceAll("[{\\-}]", "");
+  private final MetricRegistry registry = new MetricRegistry();
+
+  private final JmxReporter reporter =
+      JmxReporter.forRegistry(registry)
+          .registerWith(mBeanServer)
+          .inDomain(name)
+          .convertDurationsTo(TimeUnit.MILLISECONDS)
+          .convertRatesTo(TimeUnit.SECONDS)
+          .filter(MetricFilter.ALL)
+          .build();
+
+  private final Gauge gauge = mock();
+  private final Counter counter = mock();
+  private final Histogram histogram = mock();
+  private final Meter meter = mock();
+  private final Timer timer = mock();
+  private final ObjectNameFactory mockObjectNameFactory = mock();
+  private final ObjectNameFactory concreteObjectNameFactory = reporter.getObjectNameFactory();
+
+  @BeforeEach
+  void setUp() throws Exception {
+    when(gauge.getValue()).thenReturn(1);
+
+    when(counter.getCount()).thenReturn(100L);
+
+    when(histogram.getCount()).thenReturn(1L);
+    when(histogram.getSum()).thenReturn(12L);
+
+    final Snapshot hSnapshot = mock();
+    when(hSnapshot.getMax()).thenReturn(2L);
+    when(hSnapshot.getMean()).thenReturn(3.0);
+    when(hSnapshot.getMin()).thenReturn(4L);
+    when(hSnapshot.getStdDev()).thenReturn(5.0);
+    when(hSnapshot.getMedian()).thenReturn(6.0);
+    when(hSnapshot.get75thPercentile()).thenReturn(7.0);
+    when(hSnapshot.get95thPercentile()).thenReturn(8.0);
+    when(hSnapshot.get98thPercentile()).thenReturn(9.0);
+    when(hSnapshot.get99thPercentile()).thenReturn(10.0);
+    when(hSnapshot.get999thPercentile()).thenReturn(11.0);
+    when(hSnapshot.size()).thenReturn(1);
+
+    when(histogram.getSnapshot()).thenReturn(hSnapshot);
+
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getSum()).thenReturn(6L);
+    when(meter.getMeanRate()).thenReturn(2.0);
+    when(meter.getOneMinuteRate()).thenReturn(3.0);
+    when(meter.getFiveMinuteRate()).thenReturn(4.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(5.0);
+
+    when(timer.getCount()).thenReturn(1L);
+    when(timer.getSum()).thenReturn(TimeUnit.MILLISECONDS.toNanos(6));
+    when(timer.getMeanRate()).thenReturn(2.0);
+    when(timer.getOneMinuteRate()).thenReturn(3.0);
+    when(timer.getFiveMinuteRate()).thenReturn(4.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(5.0);
+
+    final Snapshot tSnapshot = mock();
+    when(tSnapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
+    when(tSnapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
+    when(tSnapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
+    when(tSnapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
+    when(tSnapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
+    when(tSnapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
+    when(tSnapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
+    when(tSnapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
+    when(tSnapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
+    when(tSnapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
+    when(tSnapshot.size()).thenReturn(1);
+
+    when(timer.getSnapshot()).thenReturn(tSnapshot);
+
+    registry.register(MetricName.build("gauge"), gauge);
+    registry.register(MetricName.build("test", "counter"), counter);
+    registry.register(MetricName.build("test", "histogram"), histogram);
+    registry.register(MetricName.build("test", "meter"), meter);
+    registry.register(MetricName.build("test", "another", "timer"), timer);
+
+    reporter.start();
+  }
+
+  @AfterEach
+  void tearDown() {
+    reporter.stop();
+  }
+
+  @Test
+  void registersMBeansForMetricObjectsUsingProvidedObjectNameFactory() throws Exception {
+    ObjectName n = new ObjectName(name + ":name=dummy");
+    try {
+      String widgetName = "something";
+      when(mockObjectNameFactory.createName(
+              any(String.class), any(String.class), any(MetricName.class)))
+          .thenReturn(n);
+      JmxReporter reporter =
+          JmxReporter.forRegistry(registry)
+              .registerWith(mBeanServer)
+              .inDomain(name)
+              .createsObjectNamesWith(mockObjectNameFactory)
+              .build();
+      registry.registerGauge(widgetName, () -> 1);
+      reporter.start();
+      verify(mockObjectNameFactory)
+          .createName(eq("gauges"), any(String.class), eq(MetricName.build("something")));
+      // verifyNoMoreInteractions(mockObjectNameFactory);
+    } finally {
+      reporter.stop();
+      if (mBeanServer.isRegistered(n)) {
+        mBeanServer.unregisterMBean(n);
+      }
     }
+  }
+
+  @Test
+  void registersMBeansForGauges() throws Exception {
+    final AttributeList attributes = getAttributes("gauges", "gauge", "Value", "Number");
+
+    assertThat(values(attributes)).contains(entry("Value", 1), entry("Number", 1));
+  }
+
+  @Test
+  void registersMBeansForCounters() throws Exception {
+    final AttributeList attributes = getAttributes("counters", "test.counter", "Count");
+
+    assertThat(values(attributes)).contains(entry("Count", 100L));
+  }
+
+  @Test
+  void registersMBeansForHistograms() throws Exception {
+    final AttributeList attributes =
+        getAttributes(
+            "histograms",
+            "test.histogram",
+            "Count",
+            "Sum",
+            "Max",
+            "Mean",
+            "Min",
+            "StdDev",
+            "50thPercentile",
+            "75thPercentile",
+            "95thPercentile",
+            "98thPercentile",
+            "99thPercentile",
+            "999thPercentile",
+            "SnapshotSize");
+
+    assertThat(values(attributes))
+        .contains(entry("Count", 1L))
+        .contains(entry("Sum", 12L))
+        .contains(entry("Max", 2L))
+        .contains(entry("Mean", 3.0))
+        .contains(entry("Min", 4L))
+        .contains(entry("StdDev", 5.0))
+        .contains(entry("50thPercentile", 6.0))
+        .contains(entry("75thPercentile", 7.0))
+        .contains(entry("95thPercentile", 8.0))
+        .contains(entry("98thPercentile", 9.0))
+        .contains(entry("99thPercentile", 10.0))
+        .contains(entry("999thPercentile", 11.0))
+        .contains(entry("SnapshotSize", 1L));
+  }
+
+  @Test
+  void registersMBeansForMeters() throws Exception {
+    final AttributeList attributes =
+        getAttributes(
+            "meters",
+            "test.meter",
+            "Count",
+            "Sum",
+            "MeanRate",
+            "OneMinuteRate",
+            "FiveMinuteRate",
+            "FifteenMinuteRate",
+            "RateUnit");
+
+    assertThat(values(attributes))
+        .contains(entry("Count", 1L))
+        .contains(entry("Sum", 6.0))
+        .contains(entry("MeanRate", 2.0))
+        .contains(entry("OneMinuteRate", 3.0))
+        .contains(entry("FiveMinuteRate", 4.0))
+        .contains(entry("FifteenMinuteRate", 5.0))
+        .contains(entry("RateUnit", "events/second"));
+  }
+
+  @Test
+  void registersMBeansForTimers() throws Exception {
+    final AttributeList attributes =
+        getAttributes(
+            "timers",
+            "test.another.timer",
+            "Count",
+            "Sum",
+            "MeanRate",
+            "OneMinuteRate",
+            "FiveMinuteRate",
+            "FifteenMinuteRate",
+            "Max",
+            "Mean",
+            "Min",
+            "StdDev",
+            "50thPercentile",
+            "75thPercentile",
+            "95thPercentile",
+            "98thPercentile",
+            "99thPercentile",
+            "999thPercentile",
+            "RateUnit",
+            "DurationUnit");
+
+    assertThat(values(attributes))
+        .contains(entry("Count", 1L))
+        .contains(entry("Sum", 6.0))
+        .contains(entry("MeanRate", 2.0))
+        .contains(entry("OneMinuteRate", 3.0))
+        .contains(entry("FiveMinuteRate", 4.0))
+        .contains(entry("FifteenMinuteRate", 5.0))
+        .contains(entry("Max", 100.0))
+        .contains(entry("Mean", 200.0))
+        .contains(entry("Min", 300.0))
+        .contains(entry("StdDev", 400.0))
+        .contains(entry("50thPercentile", 500.0))
+        .contains(entry("75thPercentile", 600.0))
+        .contains(entry("95thPercentile", 700.0))
+        .contains(entry("98thPercentile", 800.0))
+        .contains(entry("99thPercentile", 900.0))
+        .contains(entry("999thPercentile", 1000.0))
+        .contains(entry("RateUnit", "events/second"))
+        .contains(entry("DurationUnit", "milliseconds"));
+  }
+
+  @Test
+  void cleansUpAfterItselfWhenStopped() throws Exception {
+    reporter.stop();
+
+    try {
+      getAttributes("gauges", "gauge", "Value", "Number");
+      failBecauseExceptionWasNotThrown(InstanceNotFoundException.class);
+    } catch (InstanceNotFoundException e) {
 
-    @Test
-    void registersMBeansForTimers() throws Exception {
-        final AttributeList attributes = getAttributes("timers", "test.another.timer",
-                "Count",
-                "Sum",
-                "MeanRate",
-                "OneMinuteRate",
-                "FiveMinuteRate",
-                "FifteenMinuteRate",
-                "Max",
-                "Mean",
-                "Min",
-                "StdDev",
-                "50thPercentile",
-                "75thPercentile",
-                "95thPercentile",
-                "98thPercentile",
-                "99thPercentile",
-                "999thPercentile",
-                "RateUnit",
-                "DurationUnit");
-
-        assertThat(values(attributes))
-                .contains(entry("Count", 1L))
-                .contains(entry("Sum", 6.0))
-                .contains(entry("MeanRate", 2.0))
-                .contains(entry("OneMinuteRate", 3.0))
-                .contains(entry("FiveMinuteRate", 4.0))
-                .contains(entry("FifteenMinuteRate", 5.0))
-                .contains(entry("Max", 100.0))
-                .contains(entry("Mean", 200.0))
-                .contains(entry("Min", 300.0))
-                .contains(entry("StdDev", 400.0))
-                .contains(entry("50thPercentile", 500.0))
-                .contains(entry("75thPercentile", 600.0))
-                .contains(entry("95thPercentile", 700.0))
-                .contains(entry("98thPercentile", 800.0))
-                .contains(entry("99thPercentile", 900.0))
-                .contains(entry("999thPercentile", 1000.0))
-                .contains(entry("RateUnit", "events/second"))
-                .contains(entry("DurationUnit", "milliseconds"));
     }
+  }
 
-    @Test
-    void cleansUpAfterItselfWhenStopped() throws Exception {
-        reporter.stop();
-
-        try {
-            getAttributes("gauges", "gauge", "Value", "Number");
-            failBecauseExceptionWasNotThrown(InstanceNotFoundException.class);
-        } catch (InstanceNotFoundException e) {
-
-        }
-    }
+  @Test
+  void objectNameModifyingMBeanServer() throws Exception {
+    MBeanServer mockedMBeanServer = mock();
 
-    @Test
-    void objectNameModifyingMBeanServer() throws Exception {
-        MBeanServer mockedMBeanServer = mock(MBeanServer.class);
+    // overwrite the objectName
+    when(mockedMBeanServer.registerMBean(any(Object.class), any(ObjectName.class)))
+        .thenReturn(new ObjectInstance("DOMAIN:key=value", "className"));
 
-        // overwrite the objectName
-        when(mockedMBeanServer.registerMBean(any(Object.class), any(ObjectName.class))).thenReturn(new ObjectInstance("DOMAIN:key=value", "className"));
-
-        MetricRegistry testRegistry = new MetricRegistry();
-        JmxReporter testJmxReporter = JmxReporter.forRegistry(testRegistry)
-                .registerWith(mockedMBeanServer)
-                .inDomain(name)
-                .build();
+    MetricRegistry testRegistry = new MetricRegistry();
+    JmxReporter testJmxReporter =
+        JmxReporter.forRegistry(testRegistry)
+            .registerWith(mockedMBeanServer)
+            .inDomain(name)
+            .build();
 
-        testJmxReporter.start();
+    testJmxReporter.start();
 
-        // should trigger a registerMBean
-        testRegistry.timer("test");
+    // should trigger a registerMBean
+    testRegistry.timer("test");
 
-        // should trigger an unregisterMBean with the overwritten objectName = "DOMAIN:key=value"
-        testJmxReporter.stop();
+    // should trigger an unregisterMBean with the overwritten objectName = "DOMAIN:key=value"
+    testJmxReporter.stop();
 
-        verify(mockedMBeanServer).unregisterMBean(new ObjectName("DOMAIN:key=value"));
+    verify(mockedMBeanServer).unregisterMBean(new ObjectName("DOMAIN:key=value"));
+  }
 
-    }
+  @Test
+  void jmxMetricNameWithAsterisk() {
+    MetricRegistry metricRegistry = new MetricRegistry();
+    JmxReporter.forRegistry(metricRegistry).build().start();
+    metricRegistry.counter("test*");
+  }
 
-    @Test
-    void testJmxMetricNameWithAsterisk() {
-        MetricRegistry metricRegistry = new MetricRegistry();
-        JmxReporter.forRegistry(metricRegistry).build().start();
-        metricRegistry.counter("test*");
-    }
-
-    private AttributeList getAttributes(String type, String name, String... attributeNames) throws JMException {
-        ObjectName n = concreteObjectNameFactory.createName(type, this.name, MetricName.build(name));
-        return mBeanServer.getAttributes(n, attributeNames);
-    }
+  private AttributeList getAttributes(String type, String name, String... attributeNames)
+      throws JMException {
+    ObjectName n = concreteObjectNameFactory.createName(type, this.name, MetricName.build(name));
+    return mBeanServer.getAttributes(n, attributeNames);
+  }
 
-    private SortedMap<String, Object> values(AttributeList attributes) {
-        final SortedMap<String, Object> values = new TreeMap<>();
-        for (Object o : attributes) {
-            final Attribute attribute = (Attribute) o;
-            values.put(attribute.getName(), attribute.getValue());
-        }
-        return values;
+  private SortedMap<String, Object> values(AttributeList attributes) {
+    final SortedMap<String, Object> values = new TreeMap<>();
+    for (Object o : attributes) {
+      final Attribute attribute = (Attribute) o;
+      values.put(attribute.getName(), attribute.getValue());
     }
+    return values;
+  }
 }
--- a/metrics-json/src/main/java/io/dropwizard/metrics5/json/HealthCheckModule.java
+++ b/metrics-json/src/main/java/io/dropwizard/metrics5/json/HealthCheckModule.java
@@ -6,79 +6,80 @@ import com.fasterxml.jackson.databind.Module;
 import com.fasterxml.jackson.databind.SerializerProvider;
 import com.fasterxml.jackson.databind.module.SimpleSerializers;
 import com.fasterxml.jackson.databind.ser.std.StdSerializer;
+import com.google.common.collect.ImmutableList;
 import io.dropwizard.metrics5.health.HealthCheck;
-
 import java.io.IOException;
-import java.util.Collections;
 import java.util.Map;
 
 public class HealthCheckModule extends Module {
-    private static class HealthCheckResultSerializer extends StdSerializer<HealthCheck.Result> {
-
-        private static final long serialVersionUID = 1L;
-
-        private HealthCheckResultSerializer() {
-            super(HealthCheck.Result.class);
-        }
-
-        @Override
-        public void serialize(HealthCheck.Result result,
-                              JsonGenerator json,
-                              SerializerProvider provider) throws IOException {
-            json.writeStartObject();
-            json.writeBooleanField("healthy", result.isHealthy());
+  private static class HealthCheckResultSerializer extends StdSerializer<HealthCheck.Result> {
 
-            final String message = result.getMessage();
-            if (message != null) {
-                json.writeStringField("message", message);
-            }
+    private static final long serialVersionUID = 1L;
 
-            serializeThrowable(json, result.getError(), "error");
-            json.writeNumberField("duration", result.getDuration());
-
-            Map<String, Object> details = result.getDetails();
-            if (details != null && !details.isEmpty()) {
-                for (Map.Entry<String, Object> e : details.entrySet()) {
-                    json.writeObjectField(e.getKey(), e.getValue());
-                }
-            }
+    private HealthCheckResultSerializer() {
+      super(HealthCheck.Result.class);
+    }
 
-            json.writeStringField("timestamp", result.getTimestamp());
-            json.writeEndObject();
+    @Override
+    public void serialize(
+        HealthCheck.Result result, JsonGenerator json, SerializerProvider provider)
+        throws IOException {
+      json.writeStartObject();
+      json.writeBooleanField("healthy", result.isHealthy());
+
+      final String message = result.getMessage();
+      if (message != null) {
+        json.writeStringField("message", message);
+      }
+
+      serializeThrowable(json, result.getError(), "error");
+      json.writeNumberField("duration", result.getDuration());
+
+      Map<String, Object> details = result.getDetails();
+      if (details != null && !details.isEmpty()) {
+        for (Map.Entry<String, Object> e : details.entrySet()) {
+          json.writeObjectField(e.getKey(), e.getValue());
         }
+      }
 
-        private void serializeThrowable(JsonGenerator json, Throwable error, String name) throws IOException {
-            if (error != null) {
-                json.writeObjectFieldStart(name);
-                json.writeStringField("type", error.getClass().getTypeName());
-                json.writeStringField("message", error.getMessage());
-                json.writeArrayFieldStart("stack");
-                for (StackTraceElement element : error.getStackTrace()) {
-                    json.writeString(element.toString());
-                }
-                json.writeEndArray();
-
-                if (error.getCause() != null) {
-                    serializeThrowable(json, error.getCause(), "cause");
-                }
-
-                json.writeEndObject();
-            }
-        }
+      json.writeStringField("timestamp", result.getTimestamp());
+      json.writeEndObject();
     }
 
-    @Override
-    public String getModuleName() {
-        return "healthchecks";
-    }
+    private void serializeThrowable(JsonGenerator json, Throwable error, String name)
+        throws IOException {
+      if (error != null) {
+        json.writeObjectFieldStart(name);
+        json.writeStringField("type", error.getClass().getTypeName());
+        json.writeStringField("message", error.getMessage());
+        json.writeArrayFieldStart("stack");
+        for (StackTraceElement element : error.getStackTrace()) {
+          json.writeString(element.toString());
+        }
+        json.writeEndArray();
 
-    @Override
-    public Version version() {
-        return MetricsModule.VERSION;
-    }
+        if (error.getCause() != null) {
+          serializeThrowable(json, error.getCause(), "cause");
+        }
 
-    @Override
-    public void setupModule(SetupContext context) {
-        context.addSerializers(new SimpleSerializers(Collections.singletonList(new HealthCheckResultSerializer())));
+        json.writeEndObject();
+      }
     }
+  }
+
+  @Override
+  public String getModuleName() {
+    return "healthchecks";
+  }
+
+  @Override
+  public Version version() {
+    return MetricsModule.VERSION;
+  }
+
+  @Override
+  public void setupModule(SetupContext context) {
+    context.addSerializers(
+        new SimpleSerializers(ImmutableList.of(new HealthCheckResultSerializer())));
+  }
 }
--- a/metrics-json/src/main/java/io/dropwizard/metrics5/json/MetricsModule.java
+++ b/metrics-json/src/main/java/io/dropwizard/metrics5/json/MetricsModule.java
@@ -14,248 +14,241 @@ import io.dropwizard.metrics5.MetricFilter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 
 public class MetricsModule extends Module {
-    static final Version VERSION = new Version(5, 0, 0, "", "io.dropwizard.metrics5", "metrics-json");
-
-    @SuppressWarnings("rawtypes")
-    private static class GaugeSerializer extends StdSerializer<Gauge> {
+  static final Version VERSION = new Version(5, 0, 0, "", "io.dropwizard.metrics5", "metrics-json");
 
-        private static final long serialVersionUID = 1L;
+  @SuppressWarnings("rawtypes")
+  private static class GaugeSerializer extends StdSerializer<Gauge> {
 
-        private GaugeSerializer() {
-            super(Gauge.class);
-        }
+    private static final long serialVersionUID = 1L;
 
-        @Override
-        public void serialize(Gauge gauge,
-                              JsonGenerator json,
-                              SerializerProvider provider) throws IOException {
-            json.writeStartObject();
-            final Object value;
-            try {
-                value = gauge.getValue();
-                json.writeObjectField("value", value);
-            } catch (RuntimeException e) {
-                json.writeObjectField("error", e.toString());
-            }
-            json.writeEndObject();
-        }
+    private GaugeSerializer() {
+      super(Gauge.class);
     }
 
-    private static class CounterSerializer extends StdSerializer<Counter> {
+    @Override
+    public void serialize(Gauge gauge, JsonGenerator json, SerializerProvider provider)
+        throws IOException {
+      json.writeStartObject();
+      final Object value;
+      try {
+        value = gauge.getValue();
+        json.writeObjectField("value", value);
+      } catch (RuntimeException e) {
+        json.writeObjectField("error", e.toString());
+      }
+      json.writeEndObject();
+    }
+  }
 
-        private static final long serialVersionUID = 1L;
+  private static class CounterSerializer extends StdSerializer<Counter> {
 
-        private CounterSerializer() {
-            super(Counter.class);
-        }
+    private static final long serialVersionUID = 1L;
 
-        @Override
-        public void serialize(Counter counter,
-                              JsonGenerator json,
-                              SerializerProvider provider) throws IOException {
-            json.writeStartObject();
-            json.writeNumberField("count", counter.getCount());
-            json.writeEndObject();
-        }
+    private CounterSerializer() {
+      super(Counter.class);
     }
 
-    private static class HistogramSerializer extends StdSerializer<Histogram> {
+    @Override
+    public void serialize(Counter counter, JsonGenerator json, SerializerProvider provider)
+        throws IOException {
+      json.writeStartObject();
+      json.writeNumberField("count", counter.getCount());
+      json.writeEndObject();
+    }
+  }
 
-        private static final long serialVersionUID = 1L;
+  private static class HistogramSerializer extends StdSerializer<Histogram> {
 
-        private final boolean showSamples;
+    private static final long serialVersionUID = 1L;
 
-        private HistogramSerializer(boolean showSamples) {
-            super(Histogram.class);
-            this.showSamples = showSamples;
-        }
+    private final boolean showSamples;
 
-        @Override
-        public void serialize(Histogram histogram,
-                              JsonGenerator json,
-                              SerializerProvider provider) throws IOException {
-            json.writeStartObject();
-            final Snapshot snapshot = histogram.getSnapshot();
-            json.writeNumberField("count", histogram.getCount());
-            json.writeNumberField("max", snapshot.getMax());
-            json.writeNumberField("mean", snapshot.getMean());
-            json.writeNumberField("min", snapshot.getMin());
-            json.writeNumberField("p50", snapshot.getMedian());
-            json.writeNumberField("p75", snapshot.get75thPercentile());
-            json.writeNumberField("p95", snapshot.get95thPercentile());
-            json.writeNumberField("p98", snapshot.get98thPercentile());
-            json.writeNumberField("p99", snapshot.get99thPercentile());
-            json.writeNumberField("p999", snapshot.get999thPercentile());
-
-            if (showSamples) {
-                json.writeObjectField("values", snapshot.getValues());
-            }
-
-            json.writeNumberField("stddev", snapshot.getStdDev());
-            json.writeEndObject();
-        }
+    private HistogramSerializer(boolean showSamples) {
+      super(Histogram.class);
+      this.showSamples = showSamples;
     }
 
-    private static class MeterSerializer extends StdSerializer<Meter> {
+    @Override
+    public void serialize(Histogram histogram, JsonGenerator json, SerializerProvider provider)
+        throws IOException {
+      json.writeStartObject();
+      final Snapshot snapshot = histogram.getSnapshot();
+      json.writeNumberField("count", histogram.getCount());
+      json.writeNumberField("max", snapshot.getMax());
+      json.writeNumberField("mean", snapshot.getMean());
+      json.writeNumberField("min", snapshot.getMin());
+      json.writeNumberField("p50", snapshot.getMedian());
+      json.writeNumberField("p75", snapshot.get75thPercentile());
+      json.writeNumberField("p95", snapshot.get95thPercentile());
+      json.writeNumberField("p98", snapshot.get98thPercentile());
+      json.writeNumberField("p99", snapshot.get99thPercentile());
+      json.writeNumberField("p999", snapshot.get999thPercentile());
+
+      if (showSamples) {
+        json.writeObjectField("values", snapshot.getValues());
+      }
+
+      json.writeNumberField("stddev", snapshot.getStdDev());
+      json.writeEndObject();
+    }
+  }
 
-        private static final long serialVersionUID = 1L;
+  private static class MeterSerializer extends StdSerializer<Meter> {
 
-        private final String rateUnit;
-        private final double rateFactor;
+    private static final long serialVersionUID = 1L;
 
-        public MeterSerializer(TimeUnit rateUnit) {
-            super(Meter.class);
-            this.rateFactor = rateUnit.toSeconds(1);
-            this.rateUnit = calculateRateUnit(rateUnit, "events");
-        }
+    private final String rateUnit;
+    private final double rateFactor;
 
-        @Override
-        public void serialize(Meter meter,
-                              JsonGenerator json,
-                              SerializerProvider provider) throws IOException {
-            json.writeStartObject();
-            json.writeNumberField("count", meter.getCount());
-            json.writeNumberField("m15_rate", meter.getFifteenMinuteRate() * rateFactor);
-            json.writeNumberField("m1_rate", meter.getOneMinuteRate() * rateFactor);
-            json.writeNumberField("m5_rate", meter.getFiveMinuteRate() * rateFactor);
-            json.writeNumberField("mean_rate", meter.getMeanRate() * rateFactor);
-            json.writeStringField("units", rateUnit);
-            json.writeEndObject();
-        }
+    public MeterSerializer(TimeUnit rateUnit) {
+      super(Meter.class);
+      this.rateFactor = rateUnit.toSeconds(1);
+      this.rateUnit = calculateRateUnit(rateUnit, "events");
     }
 
-    private static class TimerSerializer extends StdSerializer<Timer> {
-
-        private static final long serialVersionUID = 1L;
-
-        private final String rateUnit;
-        private final double rateFactor;
-        private final String durationUnit;
-        private final double durationFactor;
-        private final boolean showSamples;
-
-        private TimerSerializer(TimeUnit rateUnit,
-                                TimeUnit durationUnit,
-                                boolean showSamples) {
-            super(Timer.class);
-            this.rateUnit = calculateRateUnit(rateUnit, "calls");
-            this.rateFactor = rateUnit.toSeconds(1);
-            this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);
-            this.durationFactor = 1.0 / durationUnit.toNanos(1);
-            this.showSamples = showSamples;
-        }
-
-        @Override
-        public void serialize(Timer timer,
-                              JsonGenerator json,
-                              SerializerProvider provider) throws IOException {
-            json.writeStartObject();
-            final Snapshot snapshot = timer.getSnapshot();
-            json.writeNumberField("count", timer.getCount());
-            json.writeNumberField("max", snapshot.getMax() * durationFactor);
-            json.writeNumberField("mean", snapshot.getMean() * durationFactor);
-            json.writeNumberField("min", snapshot.getMin() * durationFactor);
-
-            json.writeNumberField("p50", snapshot.getMedian() * durationFactor);
-            json.writeNumberField("p75", snapshot.get75thPercentile() * durationFactor);
-            json.writeNumberField("p95", snapshot.get95thPercentile() * durationFactor);
-            json.writeNumberField("p98", snapshot.get98thPercentile() * durationFactor);
-            json.writeNumberField("p99", snapshot.get99thPercentile() * durationFactor);
-            json.writeNumberField("p999", snapshot.get999thPercentile() * durationFactor);
-
-            if (showSamples) {
-                final long[] values = snapshot.getValues();
-                final double[] scaledValues = new double[values.length];
-                for (int i = 0; i < values.length; i++) {
-                    scaledValues[i] = values[i] * durationFactor;
-                }
-                json.writeObjectField("values", scaledValues);
-            }
-
-            json.writeNumberField("stddev", snapshot.getStdDev() * durationFactor);
-            json.writeNumberField("m15_rate", timer.getFifteenMinuteRate() * rateFactor);
-            json.writeNumberField("m1_rate", timer.getOneMinuteRate() * rateFactor);
-            json.writeNumberField("m5_rate", timer.getFiveMinuteRate() * rateFactor);
-            json.writeNumberField("mean_rate", timer.getMeanRate() * rateFactor);
-            json.writeStringField("duration_units", durationUnit);
-            json.writeStringField("rate_units", rateUnit);
-            json.writeEndObject();
-        }
+    @Override
+    public void serialize(Meter meter, JsonGenerator json, SerializerProvider provider)
+        throws IOException {
+      json.writeStartObject();
+      json.writeNumberField("count", meter.getCount());
+      json.writeNumberField("m15_rate", meter.getFifteenMinuteRate() * rateFactor);
+      json.writeNumberField("m1_rate", meter.getOneMinuteRate() * rateFactor);
+      json.writeNumberField("m5_rate", meter.getFiveMinuteRate() * rateFactor);
+      json.writeNumberField("mean_rate", meter.getMeanRate() * rateFactor);
+      json.writeStringField("units", rateUnit);
+      json.writeEndObject();
     }
+  }
 
-    private static class MetricRegistrySerializer extends StdSerializer<MetricRegistry> {
+  private static class TimerSerializer extends StdSerializer<Timer> {
 
-        private static final long serialVersionUID = 1L;
+    private static final long serialVersionUID = 1L;
 
-        private final MetricFilter filter;
+    private final String rateUnit;
+    private final double rateFactor;
+    private final String durationUnit;
+    private final double durationFactor;
+    private final boolean showSamples;
 
-        private MetricRegistrySerializer(MetricFilter filter) {
-            super(MetricRegistry.class);
-            this.filter = filter;
-        }
+    private TimerSerializer(TimeUnit rateUnit, TimeUnit durationUnit, boolean showSamples) {
+      super(Timer.class);
+      this.rateUnit = calculateRateUnit(rateUnit, "calls");
+      this.rateFactor = rateUnit.toSeconds(1);
+      this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);
+      this.durationFactor = 1.0 / durationUnit.toNanos(1);
+      this.showSamples = showSamples;
+    }
 
-        @Override
-        public void serialize(MetricRegistry registry,
-                              JsonGenerator json,
-                              SerializerProvider provider) throws IOException {
-            json.writeStartObject();
-            json.writeStringField("version", VERSION.toString());
-            json.writeObjectField("gauges", registry.getGauges(filter));
-            json.writeObjectField("counters", registry.getCounters(filter));
-            json.writeObjectField("histograms", registry.getHistograms(filter));
-            json.writeObjectField("meters", registry.getMeters(filter));
-            json.writeObjectField("timers", registry.getTimers(filter));
-            json.writeEndObject();
+    @Override
+    public void serialize(Timer timer, JsonGenerator json, SerializerProvider provider)
+        throws IOException {
+      json.writeStartObject();
+      final Snapshot snapshot = timer.getSnapshot();
+      json.writeNumberField("count", timer.getCount());
+      json.writeNumberField("max", snapshot.getMax() * durationFactor);
+      json.writeNumberField("mean", snapshot.getMean() * durationFactor);
+      json.writeNumberField("min", snapshot.getMin() * durationFactor);
+
+      json.writeNumberField("p50", snapshot.getMedian() * durationFactor);
+      json.writeNumberField("p75", snapshot.get75thPercentile() * durationFactor);
+      json.writeNumberField("p95", snapshot.get95thPercentile() * durationFactor);
+      json.writeNumberField("p98", snapshot.get98thPercentile() * durationFactor);
+      json.writeNumberField("p99", snapshot.get99thPercentile() * durationFactor);
+      json.writeNumberField("p999", snapshot.get999thPercentile() * durationFactor);
+
+      if (showSamples) {
+        final long[] values = snapshot.getValues();
+        final double[] scaledValues = new double[values.length];
+        for (int i = 0; i < values.length; i++) {
+          scaledValues[i] = values[i] * durationFactor;
         }
+        json.writeObjectField("values", scaledValues);
+      }
+
+      json.writeNumberField("stddev", snapshot.getStdDev() * durationFactor);
+      json.writeNumberField("m15_rate", timer.getFifteenMinuteRate() * rateFactor);
+      json.writeNumberField("m1_rate", timer.getOneMinuteRate() * rateFactor);
+      json.writeNumberField("m5_rate", timer.getFiveMinuteRate() * rateFactor);
+      json.writeNumberField("mean_rate", timer.getMeanRate() * rateFactor);
+      json.writeStringField("duration_units", durationUnit);
+      json.writeStringField("rate_units", rateUnit);
+      json.writeEndObject();
     }
+  }
 
-    protected final TimeUnit rateUnit;
-    protected final TimeUnit durationUnit;
-    protected final boolean showSamples;
-    protected final MetricFilter filter;
+  private static class MetricRegistrySerializer extends StdSerializer<MetricRegistry> {
 
-    public MetricsModule(TimeUnit rateUnit, TimeUnit durationUnit, boolean showSamples) {
-        this(rateUnit, durationUnit, showSamples, MetricFilter.ALL);
-    }
+    private static final long serialVersionUID = 1L;
 
-    public MetricsModule(TimeUnit rateUnit, TimeUnit durationUnit, boolean showSamples, MetricFilter filter) {
-        this.rateUnit = rateUnit;
-        this.durationUnit = durationUnit;
-        this.showSamples = showSamples;
-        this.filter = filter;
-    }
+    private final MetricFilter filter;
 
-    @Override
-    public String getModuleName() {
-        return "metrics";
+    private MetricRegistrySerializer(MetricFilter filter) {
+      super(MetricRegistry.class);
+      this.filter = filter;
     }
 
     @Override
-    public Version version() {
-        return VERSION;
+    public void serialize(MetricRegistry registry, JsonGenerator json, SerializerProvider provider)
+        throws IOException {
+      json.writeStartObject();
+      json.writeStringField("version", VERSION.toString());
+      json.writeObjectField("gauges", registry.getGauges(filter));
+      json.writeObjectField("counters", registry.getCounters(filter));
+      json.writeObjectField("histograms", registry.getHistograms(filter));
+      json.writeObjectField("meters", registry.getMeters(filter));
+      json.writeObjectField("timers", registry.getTimers(filter));
+      json.writeEndObject();
     }
-
-    @Override
-    public void setupModule(SetupContext context) {
-        context.addSerializers(new SimpleSerializers(Arrays.asList(
+  }
+
+  protected final TimeUnit rateUnit;
+  protected final TimeUnit durationUnit;
+  protected final boolean showSamples;
+  protected final MetricFilter filter;
+
+  public MetricsModule(TimeUnit rateUnit, TimeUnit durationUnit, boolean showSamples) {
+    this(rateUnit, durationUnit, showSamples, MetricFilter.ALL);
+  }
+
+  public MetricsModule(
+      TimeUnit rateUnit, TimeUnit durationUnit, boolean showSamples, MetricFilter filter) {
+    this.rateUnit = rateUnit;
+    this.durationUnit = durationUnit;
+    this.showSamples = showSamples;
+    this.filter = filter;
+  }
+
+  @Override
+  public String getModuleName() {
+    return "metrics";
+  }
+
+  @Override
+  public Version version() {
+    return VERSION;
+  }
+
+  @Override
+  public void setupModule(SetupContext context) {
+    context.addSerializers(
+        new SimpleSerializers(
+            Arrays.asList(
                 new GaugeSerializer(),
                 new CounterSerializer(),
                 new HistogramSerializer(showSamples),
                 new MeterSerializer(rateUnit),
                 new TimerSerializer(rateUnit, durationUnit, showSamples),
-                new MetricRegistrySerializer(filter)
-        )));
-    }
+                new MetricRegistrySerializer(filter))));
+  }
 
-    private static String calculateRateUnit(TimeUnit unit, String name) {
-        final String s = unit.toString().toLowerCase(Locale.US);
-        return name + '/' + s.substring(0, s.length() - 1);
-    }
+  private static String calculateRateUnit(TimeUnit unit, String name) {
+    final String s = unit.toString().toLowerCase(Locale.US);
+    return name + '/' + s.substring(0, s.length() - 1);
+  }
 }
--- a/metrics-json/src/test/java/io/dropwizard/metrics5/json/HealthCheckModuleTest.java
+++ b/metrics-json/src/test/java/io/dropwizard/metrics5/json/HealthCheckModuleTest.java
@@ -1,138 +1,95 @@
 package io.dropwizard.metrics5.json;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import com.fasterxml.jackson.databind.ObjectMapper;
 import io.dropwizard.metrics5.health.HealthCheck;
-import org.junit.jupiter.api.Test;
-
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class HealthCheckModuleTest {
-    private final ObjectMapper mapper = new ObjectMapper().registerModule(new HealthCheckModule());
+final class HealthCheckModuleTest {
+  private final ObjectMapper mapper = new ObjectMapper().registerModule(new HealthCheckModule());
 
-    @Test
-    void serializesAHealthyResult() throws Exception {
-        HealthCheck.Result result = HealthCheck.Result.healthy();
-        assertThat(mapper.writeValueAsString(result))
-                .isEqualTo("{\"healthy\":true,\"duration\":0,\"timestamp\":\"" + result.getTimestamp() + "\"}");
-    }
+  @Test
+  void serializesAHealthyResult() throws Exception {
+    HealthCheck.Result result = HealthCheck.Result.healthy();
+    assertThat(mapper.writeValueAsString(result))
+        .isEqualTo("{\"healthy\":true,\"duration\":0,\"timestamp\":\"%s\"}", result.getTimestamp());
+  }
 
-    @Test
-    void serializesAHealthyResultWithAMessage() throws Exception {
-        HealthCheck.Result result = HealthCheck.Result.healthy("yay for %s", "me");
-        assertThat(mapper.writeValueAsString(result))
-                .isEqualTo("{" +
-                        "\"healthy\":true," +
-                        "\"message\":\"yay for me\"," +
-                        "\"duration\":0," +
-                        "\"timestamp\":\"" + result.getTimestamp() + "\"" +
-                        "}");
-    }
+  @Test
+  void serializesAHealthyResultWithAMessage() throws Exception {
+    HealthCheck.Result result = HealthCheck.Result.healthy("yay for %s", "me");
+    assertThat(mapper.writeValueAsString(result))
+        .isEqualTo(
+            "{\"healthy\":true,\"message\":\"yay for me\",\"duration\":0,\"timestamp\":\"%s\"}",
+            result.getTimestamp());
+  }
 
-    @Test
-    void serializesAnUnhealthyResult() throws Exception {
-        HealthCheck.Result result = HealthCheck.Result.unhealthy("boo");
-        assertThat(mapper.writeValueAsString(result))
-                .isEqualTo("{" +
-                        "\"healthy\":false," +
-                        "\"message\":\"boo\"," +
-                        "\"duration\":0," +
-                        "\"timestamp\":\"" + result.getTimestamp() + "\"" +
-                        "}");
-    }
+  @Test
+  void serializesAnUnhealthyResult() throws Exception {
+    HealthCheck.Result result = HealthCheck.Result.unhealthy("boo");
+    assertThat(mapper.writeValueAsString(result))
+        .isEqualTo(
+            "{\"healthy\":false,\"message\":\"boo\",\"duration\":0,\"timestamp\":\"%s\"}",
+            result.getTimestamp());
+  }
 
-    @Test
-    void serializesAnUnhealthyResultWithAnException() throws Exception {
-        final RuntimeException e = new RuntimeException("oh no");
-        e.setStackTrace(new StackTraceElement[]{
-                new StackTraceElement("Blah", "bloo", "Blah.java", 100)
-        });
+  @Test
+  void serializesAnUnhealthyResultWithAnException() throws Exception {
+    final RuntimeException e = new RuntimeException("oh no");
+    e.setStackTrace(
+        new StackTraceElement[] {new StackTraceElement("Blah", "bloo", "Blah.java", 100)});
 
-        HealthCheck.Result result = HealthCheck.Result.unhealthy(e);
-        assertThat(mapper.writeValueAsString(result))
-                .isEqualTo("{" +
-                        "\"healthy\":false," +
-                        "\"message\":\"oh no\"," +
-                        "\"error\":{" +
-                        "\"type\":\"java.lang.RuntimeException\"," +
-                        "\"message\":\"oh no\"," +
-                        "\"stack\":[\"Blah.bloo(Blah.java:100)\"]" +
-                        "}," +
-                        "\"duration\":0," +
-                        "\"timestamp\":\"" + result.getTimestamp() + "\"" +
-                        "}");
-    }
+    HealthCheck.Result result = HealthCheck.Result.unhealthy(e);
+    assertThat(mapper.writeValueAsString(result))
+        .isEqualTo(
+            "{\"healthy\":false,\"message\":\"oh no\",\"error\":{\"type\":\"java.lang.RuntimeException\",\"message\":\"oh no\",\"stack\":[\"Blah.bloo(Blah.java:100)\"]},\"duration\":0,\"timestamp\":\"%s\"}",
+            result.getTimestamp());
+  }
 
-    @Test
-    void serializesAnUnhealthyResultWithNestedExceptions() throws Exception {
-        final RuntimeException a = new RuntimeException("oh no");
-        a.setStackTrace(new StackTraceElement[]{
-                new StackTraceElement("Blah", "bloo", "Blah.java", 100)
-        });
+  @Test
+  void serializesAnUnhealthyResultWithNestedExceptions() throws Exception {
+    final RuntimeException a = new RuntimeException("oh no");
+    a.setStackTrace(
+        new StackTraceElement[] {new StackTraceElement("Blah", "bloo", "Blah.java", 100)});
 
-        final RuntimeException b = new RuntimeException("oh well", a);
-        b.setStackTrace(new StackTraceElement[]{
-                new StackTraceElement("Blah", "blee", "Blah.java", 150)
-        });
+    final RuntimeException b = new RuntimeException("oh well", a);
+    b.setStackTrace(
+        new StackTraceElement[] {new StackTraceElement("Blah", "blee", "Blah.java", 150)});
 
-        HealthCheck.Result result = HealthCheck.Result.unhealthy(b);
-        assertThat(mapper.writeValueAsString(result))
-                .isEqualTo("{" +
-                        "\"healthy\":false," +
-                        "\"message\":\"oh well\"," +
-                        "\"error\":{" +
-                        "\"type\":\"java.lang.RuntimeException\"," +
-                        "\"message\":\"oh well\"," +
-                        "\"stack\":[\"Blah.blee(Blah.java:150)\"]," +
-                        "\"cause\":{" +
-                        "\"type\":\"java.lang.RuntimeException\"," +
-                        "\"message\":\"oh no\"," +
-                        "\"stack\":[\"Blah.bloo(Blah.java:100)\"]" +
-                        "}" +
-                        "}," +
-                        "\"duration\":0," +
-                        "\"timestamp\":\"" + result.getTimestamp() + "\"" +
-                        "}");
-    }
+    HealthCheck.Result result = HealthCheck.Result.unhealthy(b);
+    assertThat(mapper.writeValueAsString(result))
+        .isEqualTo(
+            "{\"healthy\":false,\"message\":\"oh well\",\"error\":{\"type\":\"java.lang.RuntimeException\",\"message\":\"oh well\",\"stack\":[\"Blah.blee(Blah.java:150)\"],\"cause\":{\"type\":\"java.lang.RuntimeException\",\"message\":\"oh no\",\"stack\":[\"Blah.bloo(Blah.java:100)\"]}},\"duration\":0,\"timestamp\":\"%s\"}",
+            result.getTimestamp());
+  }
 
-    @Test
-    void serializeResultWithDetail() throws Exception {
-        Map<String, Object> complex = new LinkedHashMap<>();
-        complex.put("field", "value");
+  @Test
+  void serializeResultWithDetail() throws Exception {
+    Map<String, Object> complex = new LinkedHashMap<>();
+    complex.put("field", "value");
 
-        HealthCheck.Result result = HealthCheck.Result.builder()
-                .healthy()
-                .withDetail("boolean", true)
-                .withDetail("integer", 1)
-                .withDetail("long", 2L)
-                .withDetail("float", 3.546F)
-                .withDetail("double", 4.567D)
-                .withDetail("BigInteger", new BigInteger("12345"))
-                .withDetail("BigDecimal", new BigDecimal("12345.56789"))
-                .withDetail("String", "string")
-                .withDetail("complex", complex)
-                .build();
+    HealthCheck.Result result =
+        HealthCheck.Result.builder()
+            .healthy()
+            .withDetail("boolean", true)
+            .withDetail("integer", 1)
+            .withDetail("long", 2L)
+            .withDetail("float", 3.546F)
+            .withDetail("double", 4.567D)
+            .withDetail("BigInteger", new BigInteger("12345"))
+            .withDetail("BigDecimal", new BigDecimal("12345.56789"))
+            .withDetail("String", "string")
+            .withDetail("complex", complex)
+            .build();
 
-        assertThat(mapper.writeValueAsString(result))
-                .isEqualTo("{" +
-                        "\"healthy\":true," +
-                        "\"duration\":0," +
-                        "\"boolean\":true," +
-                        "\"integer\":1," +
-                        "\"long\":2," +
-                        "\"float\":3.546," +
-                        "\"double\":4.567," +
-                        "\"BigInteger\":12345," +
-                        "\"BigDecimal\":12345.56789," +
-                        "\"String\":\"string\"," +
-                        "\"complex\":{" +
-                        "\"field\":\"value\"" +
-                        "}," +
-                        "\"timestamp\":\"" + result.getTimestamp() + "\"" +
-                        "}");
-    }
+    assertThat(mapper.writeValueAsString(result))
+        .isEqualTo(
+            "{\"healthy\":true,\"duration\":0,\"boolean\":true,\"integer\":1,\"long\":2,\"float\":3.546,\"double\":4.567,\"BigInteger\":12345,\"BigDecimal\":12345.56789,\"String\":\"string\",\"complex\":{\"field\":\"value\"},\"timestamp\":\"%s\"}",
+            result.getTimestamp());
+  }
 }
--- a/metrics-json/src/test/java/io/dropwizard/metrics5/json/MetricsModuleTest.java
+++ b/metrics-json/src/test/java/io/dropwizard/metrics5/json/MetricsModuleTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.json;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import com.fasterxml.jackson.databind.ObjectMapper;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
@@ -9,202 +13,210 @@ import io.dropwizard.metrics5.MetricFilter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Snapshot;
 import io.dropwizard.metrics5.Timer;
-import org.junit.jupiter.api.Test;
-
 import java.util.concurrent.TimeUnit;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-class MetricsModuleTest {
-    private final ObjectMapper mapper = new ObjectMapper().registerModule(
-            new MetricsModule(TimeUnit.SECONDS, TimeUnit.MILLISECONDS, false, MetricFilter.ALL));
+final class MetricsModuleTest {
+  private final ObjectMapper mapper =
+      new ObjectMapper()
+          .registerModule(
+              new MetricsModule(TimeUnit.SECONDS, TimeUnit.MILLISECONDS, false, MetricFilter.ALL));
 
-    @Test
-    void serializesGauges() throws Exception {
-        final Gauge<Integer> gauge = () -> 100;
+  @Test
+  void serializesGauges() throws Exception {
+    final Gauge<Integer> gauge = () -> 100;
 
-        assertThat(mapper.writeValueAsString(gauge))
-                .isEqualTo("{\"value\":100}");
-    }
+    assertThat(mapper.writeValueAsString(gauge)).isEqualTo("{\"value\":100}");
+  }
 
-    @Test
-    void serializesGaugesThatThrowExceptions() throws Exception {
-        final Gauge<Integer> gauge = () -> {
-            throw new IllegalArgumentException("poops");
+  @Test
+  void serializesGaugesThatThrowExceptions() throws Exception {
+    final Gauge<Integer> gauge =
+        () -> {
+          throw new IllegalArgumentException("poops");
         };
 
-        assertThat(mapper.writeValueAsString(gauge))
-                .isEqualTo("{\"error\":\"java.lang.IllegalArgumentException: poops\"}");
-    }
-
-    @Test
-    void serializesCounters() throws Exception {
-        final Counter counter = mock(Counter.class);
-        when(counter.getCount()).thenReturn(100L);
-
-        assertThat(mapper.writeValueAsString(counter))
-                .isEqualTo("{\"count\":100}");
-    }
-
-    @Test
-    void serializesHistograms() throws Exception {
-        final Histogram histogram = mock(Histogram.class);
-        when(histogram.getCount()).thenReturn(1L);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(2L);
-        when(snapshot.getMean()).thenReturn(3.0);
-        when(snapshot.getMin()).thenReturn(4L);
-        when(snapshot.getStdDev()).thenReturn(5.0);
-        when(snapshot.getMedian()).thenReturn(6.0);
-        when(snapshot.get75thPercentile()).thenReturn(7.0);
-        when(snapshot.get95thPercentile()).thenReturn(8.0);
-        when(snapshot.get98thPercentile()).thenReturn(9.0);
-        when(snapshot.get99thPercentile()).thenReturn(10.0);
-        when(snapshot.get999thPercentile()).thenReturn(11.0);
-        when(snapshot.getValues()).thenReturn(new long[]{1, 2, 3});
-
-        when(histogram.getSnapshot()).thenReturn(snapshot);
-
-        assertThat(mapper.writeValueAsString(histogram))
-                .isEqualTo("{" +
-                        "\"count\":1," +
-                        "\"max\":2," +
-                        "\"mean\":3.0," +
-                        "\"min\":4," +
-                        "\"p50\":6.0," +
-                        "\"p75\":7.0," +
-                        "\"p95\":8.0," +
-                        "\"p98\":9.0," +
-                        "\"p99\":10.0," +
-                        "\"p999\":11.0," +
-                        "\"stddev\":5.0}");
-
-        final ObjectMapper fullMapper = new ObjectMapper().registerModule(
+    assertThat(mapper.writeValueAsString(gauge))
+        .isEqualTo("{\"error\":\"java.lang.IllegalArgumentException: poops\"}");
+  }
+
+  @Test
+  void serializesCounters() throws Exception {
+    final Counter counter = mock();
+    when(counter.getCount()).thenReturn(100L);
+
+    assertThat(mapper.writeValueAsString(counter)).isEqualTo("{\"count\":100}");
+  }
+
+  @Test
+  void serializesHistograms() throws Exception {
+    final Histogram histogram = mock();
+    when(histogram.getCount()).thenReturn(1L);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(2L);
+    when(snapshot.getMean()).thenReturn(3.0);
+    when(snapshot.getMin()).thenReturn(4L);
+    when(snapshot.getStdDev()).thenReturn(5.0);
+    when(snapshot.getMedian()).thenReturn(6.0);
+    when(snapshot.get75thPercentile()).thenReturn(7.0);
+    when(snapshot.get95thPercentile()).thenReturn(8.0);
+    when(snapshot.get98thPercentile()).thenReturn(9.0);
+    when(snapshot.get99thPercentile()).thenReturn(10.0);
+    when(snapshot.get999thPercentile()).thenReturn(11.0);
+    when(snapshot.getValues()).thenReturn(new long[] {1, 2, 3});
+
+    when(histogram.getSnapshot()).thenReturn(snapshot);
+
+    assertThat(mapper.writeValueAsString(histogram))
+        .isEqualTo(
+            "{"
+                + "\"count\":1,"
+                + "\"max\":2,"
+                + "\"mean\":3.0,"
+                + "\"min\":4,"
+                + "\"p50\":6.0,"
+                + "\"p75\":7.0,"
+                + "\"p95\":8.0,"
+                + "\"p98\":9.0,"
+                + "\"p99\":10.0,"
+                + "\"p999\":11.0,"
+                + "\"stddev\":5.0}");
+
+    final ObjectMapper fullMapper =
+        new ObjectMapper()
+            .registerModule(
                 new MetricsModule(TimeUnit.SECONDS, TimeUnit.MILLISECONDS, true, MetricFilter.ALL));
 
-        assertThat(fullMapper.writeValueAsString(histogram))
-                .isEqualTo("{" +
-                        "\"count\":1," +
-                        "\"max\":2," +
-                        "\"mean\":3.0," +
-                        "\"min\":4," +
-                        "\"p50\":6.0," +
-                        "\"p75\":7.0," +
-                        "\"p95\":8.0," +
-                        "\"p98\":9.0," +
-                        "\"p99\":10.0," +
-                        "\"p999\":11.0," +
-                        "\"values\":[1,2,3]," +
-                        "\"stddev\":5.0}");
-    }
-
-    @Test
-    void serializesMeters() throws Exception {
-        final Meter meter = mock(Meter.class);
-        when(meter.getCount()).thenReturn(1L);
-        when(meter.getMeanRate()).thenReturn(2.0);
-        when(meter.getOneMinuteRate()).thenReturn(5.0);
-        when(meter.getFiveMinuteRate()).thenReturn(4.0);
-        when(meter.getFifteenMinuteRate()).thenReturn(3.0);
-
-        assertThat(mapper.writeValueAsString(meter))
-                .isEqualTo("{" +
-                        "\"count\":1," +
-                        "\"m15_rate\":3.0," +
-                        "\"m1_rate\":5.0," +
-                        "\"m5_rate\":4.0," +
-                        "\"mean_rate\":2.0," +
-                        "\"units\":\"events/second\"}");
-    }
-
-    @Test
-    void serializesTimers() throws Exception {
-        final Timer timer = mock(Timer.class);
-        when(timer.getCount()).thenReturn(1L);
-        when(timer.getMeanRate()).thenReturn(2.0);
-        when(timer.getOneMinuteRate()).thenReturn(3.0);
-        when(timer.getFiveMinuteRate()).thenReturn(4.0);
-        when(timer.getFifteenMinuteRate()).thenReturn(5.0);
-
-        final Snapshot snapshot = mock(Snapshot.class);
-        when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
-        when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
-        when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
-        when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
-        when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
-        when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
-        when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
-        when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
-        when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
-        when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
-
-        when(snapshot.getValues()).thenReturn(new long[]{
-                TimeUnit.MILLISECONDS.toNanos(1),
-                TimeUnit.MILLISECONDS.toNanos(2),
-                TimeUnit.MILLISECONDS.toNanos(3)
-        });
-
-        when(timer.getSnapshot()).thenReturn(snapshot);
-
-        assertThat(mapper.writeValueAsString(timer))
-                .isEqualTo("{" +
-                        "\"count\":1," +
-                        "\"max\":100.0," +
-                        "\"mean\":200.0," +
-                        "\"min\":300.0," +
-                        "\"p50\":500.0," +
-                        "\"p75\":600.0," +
-                        "\"p95\":700.0," +
-                        "\"p98\":800.0," +
-                        "\"p99\":900.0," +
-                        "\"p999\":1000.0," +
-                        "\"stddev\":400.0," +
-                        "\"m15_rate\":5.0," +
-                        "\"m1_rate\":3.0," +
-                        "\"m5_rate\":4.0," +
-                        "\"mean_rate\":2.0," +
-                        "\"duration_units\":\"milliseconds\"," +
-                        "\"rate_units\":\"calls/second\"}");
-
-        final ObjectMapper fullMapper = new ObjectMapper().registerModule(
+    assertThat(fullMapper.writeValueAsString(histogram))
+        .isEqualTo(
+            "{"
+                + "\"count\":1,"
+                + "\"max\":2,"
+                + "\"mean\":3.0,"
+                + "\"min\":4,"
+                + "\"p50\":6.0,"
+                + "\"p75\":7.0,"
+                + "\"p95\":8.0,"
+                + "\"p98\":9.0,"
+                + "\"p99\":10.0,"
+                + "\"p999\":11.0,"
+                + "\"values\":[1,2,3],"
+                + "\"stddev\":5.0}");
+  }
+
+  @Test
+  void serializesMeters() throws Exception {
+    final Meter meter = mock();
+    when(meter.getCount()).thenReturn(1L);
+    when(meter.getMeanRate()).thenReturn(2.0);
+    when(meter.getOneMinuteRate()).thenReturn(5.0);
+    when(meter.getFiveMinuteRate()).thenReturn(4.0);
+    when(meter.getFifteenMinuteRate()).thenReturn(3.0);
+
+    assertThat(mapper.writeValueAsString(meter))
+        .isEqualTo(
+            "{"
+                + "\"count\":1,"
+                + "\"m15_rate\":3.0,"
+                + "\"m1_rate\":5.0,"
+                + "\"m5_rate\":4.0,"
+                + "\"mean_rate\":2.0,"
+                + "\"units\":\"events/second\"}");
+  }
+
+  @Test
+  void serializesTimers() throws Exception {
+    final Timer timer = mock();
+    when(timer.getCount()).thenReturn(1L);
+    when(timer.getMeanRate()).thenReturn(2.0);
+    when(timer.getOneMinuteRate()).thenReturn(3.0);
+    when(timer.getFiveMinuteRate()).thenReturn(4.0);
+    when(timer.getFifteenMinuteRate()).thenReturn(5.0);
+
+    final Snapshot snapshot = mock();
+    when(snapshot.getMax()).thenReturn(TimeUnit.MILLISECONDS.toNanos(100));
+    when(snapshot.getMean()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(200));
+    when(snapshot.getMin()).thenReturn(TimeUnit.MILLISECONDS.toNanos(300));
+    when(snapshot.getStdDev()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(400));
+    when(snapshot.getMedian()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(500));
+    when(snapshot.get75thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(600));
+    when(snapshot.get95thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(700));
+    when(snapshot.get98thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(800));
+    when(snapshot.get99thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(900));
+    when(snapshot.get999thPercentile()).thenReturn((double) TimeUnit.MILLISECONDS.toNanos(1000));
+
+    when(snapshot.getValues())
+        .thenReturn(
+            new long[] {
+              TimeUnit.MILLISECONDS.toNanos(1),
+              TimeUnit.MILLISECONDS.toNanos(2),
+              TimeUnit.MILLISECONDS.toNanos(3)
+            });
+
+    when(timer.getSnapshot()).thenReturn(snapshot);
+
+    assertThat(mapper.writeValueAsString(timer))
+        .isEqualTo(
+            "{"
+                + "\"count\":1,"
+                + "\"max\":100.0,"
+                + "\"mean\":200.0,"
+                + "\"min\":300.0,"
+                + "\"p50\":500.0,"
+                + "\"p75\":600.0,"
+                + "\"p95\":700.0,"
+                + "\"p98\":800.0,"
+                + "\"p99\":900.0,"
+                + "\"p999\":1000.0,"
+                + "\"stddev\":400.0,"
+                + "\"m15_rate\":5.0,"
+                + "\"m1_rate\":3.0,"
+                + "\"m5_rate\":4.0,"
+                + "\"mean_rate\":2.0,"
+                + "\"duration_units\":\"milliseconds\","
+                + "\"rate_units\":\"calls/second\"}");
+
+    final ObjectMapper fullMapper =
+        new ObjectMapper()
+            .registerModule(
                 new MetricsModule(TimeUnit.SECONDS, TimeUnit.MILLISECONDS, true, MetricFilter.ALL));
 
-        assertThat(fullMapper.writeValueAsString(timer))
-                .isEqualTo("{" +
-                        "\"count\":1," +
-                        "\"max\":100.0," +
-                        "\"mean\":200.0," +
-                        "\"min\":300.0," +
-                        "\"p50\":500.0," +
-                        "\"p75\":600.0," +
-                        "\"p95\":700.0," +
-                        "\"p98\":800.0," +
-                        "\"p99\":900.0," +
-                        "\"p999\":1000.0," +
-                        "\"values\":[1.0,2.0,3.0]," +
-                        "\"stddev\":400.0," +
-                        "\"m15_rate\":5.0," +
-                        "\"m1_rate\":3.0," +
-                        "\"m5_rate\":4.0," +
-                        "\"mean_rate\":2.0," +
-                        "\"duration_units\":\"milliseconds\"," +
-                        "\"rate_units\":\"calls/second\"}");
-    }
-
-    @Test
-    void serializesMetricRegistries() throws Exception {
-        final MetricRegistry registry = new MetricRegistry();
-
-        assertThat(mapper.writeValueAsString(registry))
-                .isEqualTo("{" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{}," +
-                        "\"counters\":{}," +
-                        "\"histograms\":{}," +
-                        "\"meters\":{}," +
-                        "\"timers\":{}}");
-    }
+    assertThat(fullMapper.writeValueAsString(timer))
+        .isEqualTo(
+            "{"
+                + "\"count\":1,"
+                + "\"max\":100.0,"
+                + "\"mean\":200.0,"
+                + "\"min\":300.0,"
+                + "\"p50\":500.0,"
+                + "\"p75\":600.0,"
+                + "\"p95\":700.0,"
+                + "\"p98\":800.0,"
+                + "\"p99\":900.0,"
+                + "\"p999\":1000.0,"
+                + "\"values\":[1.0,2.0,3.0],"
+                + "\"stddev\":400.0,"
+                + "\"m15_rate\":5.0,"
+                + "\"m1_rate\":3.0,"
+                + "\"m5_rate\":4.0,"
+                + "\"mean_rate\":2.0,"
+                + "\"duration_units\":\"milliseconds\","
+                + "\"rate_units\":\"calls/second\"}");
+  }
+
+  @Test
+  void serializesMetricRegistries() throws Exception {
+    final MetricRegistry registry = new MetricRegistry();
+
+    assertThat(mapper.writeValueAsString(registry))
+        .isEqualTo(
+            "{"
+                + "\"version\":\"5.0.0\","
+                + "\"gauges\":{},"
+                + "\"counters\":{},"
+                + "\"histograms\":{},"
+                + "\"meters\":{},"
+                + "\"timers\":{}}");
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/BufferPoolMetricSet.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/BufferPoolMetricSet.java
@@ -1,52 +1,53 @@
 package io.dropwizard.metrics5.jvm;
 
+import static java.util.Collections.unmodifiableMap;
+
 import io.dropwizard.metrics5.Metric;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricSet;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
+import java.util.HashMap;
+import java.util.Map;
 import javax.management.JMException;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A set of gauges for the count, usage, and capacity of the JVM's direct and mapped buffer pools.
- * <p>
- * These JMX objects are only available on Java 7 and above.
+ *
+ * <p>These JMX objects are only available on Java 7 and above.
  */
 public class BufferPoolMetricSet implements MetricSet {
-    private static final Logger LOGGER = LoggerFactory.getLogger(BufferPoolMetricSet.class);
-    private static final String[] ATTRIBUTES = {"Count", "MemoryUsed", "TotalCapacity"};
-    private static final String[] NAMES = {"count", "used", "capacity"};
-    private static final String[] POOLS = {"direct", "mapped"};
+  private static final Logger LOG = LoggerFactory.getLogger(BufferPoolMetricSet.class);
+  private static final String[] ATTRIBUTES = {"Count", "MemoryUsed", "TotalCapacity"};
+  private static final String[] NAMES = {"count", "used", "capacity"};
+  private static final String[] POOLS = {"direct", "mapped"};
 
-    private final MBeanServer mBeanServer;
+  private final MBeanServer mBeanServer;
 
-    public BufferPoolMetricSet(MBeanServer mBeanServer) {
-        this.mBeanServer = mBeanServer;
-    }
+  public BufferPoolMetricSet(MBeanServer mBeanServer) {
+    this.mBeanServer = mBeanServer;
+  }
 
-    @Override
-    public Map<MetricName, Metric> getMetrics() {
-        final Map<MetricName, Metric> gauges = new HashMap<>();
-        for (String pool : POOLS) {
-            for (int i = 0; i < ATTRIBUTES.length; i++) {
-                final String attribute = ATTRIBUTES[i];
-                final String name = NAMES[i];
-                try {
-                    final ObjectName on = new ObjectName("java.nio:type=BufferPool,name=" + pool);
-                    mBeanServer.getMBeanInfo(on);
-                    gauges.put(MetricRegistry.name(pool, name), new JmxAttributeGauge(mBeanServer, on, attribute));
-                } catch (JMException ignored) {
-                    LOGGER.debug("Unable to load buffer pool MBeans, possibly running on Java 6");
-                }
-            }
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    final Map<MetricName, Metric> gauges = new HashMap<>();
+    for (String pool : POOLS) {
+      for (int i = 0; i < ATTRIBUTES.length; i++) {
+        final String attribute = ATTRIBUTES[i];
+        final String name = NAMES[i];
+        try {
+          final ObjectName on = new ObjectName("java.nio:type=BufferPool,name=" + pool);
+          mBeanServer.getMBeanInfo(on);
+          gauges.put(
+              MetricRegistry.name(pool, name), new JmxAttributeGauge(mBeanServer, on, attribute));
+        } catch (JMException ignored) {
+          LOG.debug("Unable to load buffer pool MBeans, possibly running on Java 6");
         }
-        return Collections.unmodifiableMap(gauges);
+      }
     }
+    return unmodifiableMap(gauges);
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/CachedThreadStatesGaugeSet.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/CachedThreadStatesGaugeSet.java
@@ -1,54 +1,55 @@
 package io.dropwizard.metrics5.jvm;
 
 import io.dropwizard.metrics5.CachedGauge;
-
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
 import java.util.concurrent.TimeUnit;
 
 /**
- * A variation of ThreadStatesGaugeSet that caches the ThreadInfo[] objects for
- * a given interval.
+ * A variation of ThreadStatesGaugeSet that caches the ThreadInfo[] objects for a given interval.
  */
 public class CachedThreadStatesGaugeSet extends ThreadStatesGaugeSet {
 
-    private final CachedGauge<ThreadInfo[]> threadInfo;
-
-    /**
-     * Creates a new set of gauges using the given MXBean and detector.
-     * Caches the information for the given interval and time unit.
-     *
-     * @param threadMXBean     a thread MXBean
-     * @param deadlockDetector a deadlock detector
-     * @param interval         cache interval
-     * @param unit             cache interval time unit
-     */
-    public CachedThreadStatesGaugeSet(final ThreadMXBean threadMXBean, ThreadDeadlockDetector deadlockDetector,
-                                      long interval, TimeUnit unit) {
-        super(threadMXBean, deadlockDetector);
-        threadInfo = new CachedGauge<ThreadInfo[]>(interval, unit) {
-            @Override
-            protected ThreadInfo[] loadValue() {
-                return CachedThreadStatesGaugeSet.super.getThreadInfo();
-            }
+  private final CachedGauge<ThreadInfo[]> threadInfo;
+
+  /**
+   * Creates a new set of gauges using the given MXBean and detector. Caches the information for the
+   * given interval and time unit.
+   *
+   * @param threadMXBean a thread MXBean
+   * @param deadlockDetector a deadlock detector
+   * @param interval cache interval
+   * @param unit cache interval time unit
+   */
+  public CachedThreadStatesGaugeSet(
+      final ThreadMXBean threadMXBean,
+      ThreadDeadlockDetector deadlockDetector,
+      long interval,
+      TimeUnit unit) {
+    super(threadMXBean, deadlockDetector);
+    threadInfo =
+        new CachedGauge<ThreadInfo[]>(interval, unit) {
+          @Override
+          protected ThreadInfo[] loadValue() {
+            return CachedThreadStatesGaugeSet.super.getThreadInfo();
+          }
         };
-    }
-
-    /**
-     * Creates a new set of gauges using the default MXBeans.
-     * Caches the information for the given interval and time unit.
-     *
-     * @param interval cache interval
-     * @param unit     cache interval time unit
-     */
-    public CachedThreadStatesGaugeSet(long interval, TimeUnit unit) {
-        this(ManagementFactory.getThreadMXBean(), new ThreadDeadlockDetector(), interval, unit);
-    }
-
-    @Override
-    ThreadInfo[] getThreadInfo() {
-        return threadInfo.getValue();
-    }
-
+  }
+
+  /**
+   * Creates a new set of gauges using the default MXBeans. Caches the information for the given
+   * interval and time unit.
+   *
+   * @param interval cache interval
+   * @param unit cache interval time unit
+   */
+  public CachedThreadStatesGaugeSet(long interval, TimeUnit unit) {
+    this(ManagementFactory.getThreadMXBean(), new ThreadDeadlockDetector(), interval, unit);
+  }
+
+  @Override
+  ThreadInfo[] getThreadInfo() {
+    return threadInfo.getValue();
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/ClassLoadingGaugeSet.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/ClassLoadingGaugeSet.java
@@ -4,33 +4,30 @@ import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.Metric;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricSet;
-
 import java.lang.management.ClassLoadingMXBean;
 import java.lang.management.ManagementFactory;
 import java.util.HashMap;
 import java.util.Map;
 
-/**
- * A set of gauges for JVM classloader usage.
- */
+/** A set of gauges for JVM classloader usage. */
 public class ClassLoadingGaugeSet implements MetricSet {
 
-    private final ClassLoadingMXBean mxBean;
+  private final ClassLoadingMXBean mxBean;
 
-    public ClassLoadingGaugeSet() {
-        this(ManagementFactory.getClassLoadingMXBean());
-    }
+  public ClassLoadingGaugeSet() {
+    this(ManagementFactory.getClassLoadingMXBean());
+  }
 
-    public ClassLoadingGaugeSet(ClassLoadingMXBean mxBean) {
-        this.mxBean = mxBean;
-    }
+  public ClassLoadingGaugeSet(ClassLoadingMXBean mxBean) {
+    this.mxBean = mxBean;
+  }
 
-    @Override
-    public Map<MetricName, Metric> getMetrics() {
-        final Map<MetricName, Metric> gauges = new HashMap<>();
-        gauges.put(MetricName.build("loaded"), (Gauge<Long>) mxBean::getTotalLoadedClassCount);
-        gauges.put(MetricName.build("unloaded"), (Gauge<Long>) mxBean::getUnloadedClassCount);
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    final Map<MetricName, Metric> gauges = new HashMap<>();
+    gauges.put(MetricName.build("loaded"), (Gauge<Long>) mxBean::getTotalLoadedClassCount);
+    gauges.put(MetricName.build("unloaded"), (Gauge<Long>) mxBean::getUnloadedClassCount);
 
-        return gauges;
-    }
+    return gauges;
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/CpuTimeClock.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/CpuTimeClock.java
@@ -1,19 +1,16 @@
 package io.dropwizard.metrics5.jvm;
 
 import io.dropwizard.metrics5.Clock;
-
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadMXBean;
 
-/**
- * A clock implementation which returns the current thread's CPU time.
- */
+/** A clock implementation which returns the current thread's CPU time. */
 public class CpuTimeClock extends Clock {
 
-    private static final ThreadMXBean THREAD_MX_BEAN = ManagementFactory.getThreadMXBean();
+  private static final ThreadMXBean THREAD_MX_BEAN = ManagementFactory.getThreadMXBean();
 
-    @Override
-    public long getTick() {
-        return THREAD_MX_BEAN.getCurrentThreadCpuTime();
-    }
+  @Override
+  public long getTick() {
+    return THREAD_MX_BEAN.getCurrentThreadCpuTime();
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/FileDescriptorRatioGauge.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/FileDescriptorRatioGauge.java
@@ -1,50 +1,47 @@
 package io.dropwizard.metrics5.jvm;
 
 import io.dropwizard.metrics5.RatioGauge;
-
 import java.lang.management.ManagementFactory;
 import java.lang.management.OperatingSystemMXBean;
 
-/**
- * A gauge for the ratio of used to total file descriptors.
- */
+/** A gauge for the ratio of used to total file descriptors. */
 public class FileDescriptorRatioGauge extends RatioGauge {
-    private static boolean unixOperatingSystemMXBeanExists = false;
-
-    private final OperatingSystemMXBean os;
-
-    static {
-        try {
-            Class.forName("com.sun.management.UnixOperatingSystemMXBean");
-            unixOperatingSystemMXBeanExists = true;
-        } catch (ClassNotFoundException e) {
-            // do nothing
-        }
-    }
+  private static boolean unixOperatingSystemMXBeanExists = false;
 
-    /**
-     * Creates a new gauge using the platform OS bean.
-     */
-    public FileDescriptorRatioGauge() {
-        this(ManagementFactory.getOperatingSystemMXBean());
-    }
+  private final OperatingSystemMXBean os;
 
-    /**
-     * Creates a new gauge using the given OS bean.
-     *
-     * @param os an {@link OperatingSystemMXBean}
-     */
-    public FileDescriptorRatioGauge(OperatingSystemMXBean os) {
-        this.os = os;
+  static {
+    try {
+      Class.forName("com.sun.management.UnixOperatingSystemMXBean");
+      unixOperatingSystemMXBeanExists = true;
+    } catch (ClassNotFoundException e) {
+      // do nothing
     }
-
-    @Override
-    protected Ratio getRatio() {
-        if (unixOperatingSystemMXBeanExists && os instanceof com.sun.management.UnixOperatingSystemMXBean) {
-            final com.sun.management.UnixOperatingSystemMXBean unixOs = (com.sun.management.UnixOperatingSystemMXBean) os;
-            return Ratio.of(unixOs.getOpenFileDescriptorCount(), unixOs.getMaxFileDescriptorCount());
-        } else {
-            return Ratio.of(Double.NaN, Double.NaN);
-        }
+  }
+
+  /** Creates a new gauge using the platform OS bean. */
+  public FileDescriptorRatioGauge() {
+    this(ManagementFactory.getOperatingSystemMXBean());
+  }
+
+  /**
+   * Creates a new gauge using the given OS bean.
+   *
+   * @param os an {@link OperatingSystemMXBean}
+   */
+  public FileDescriptorRatioGauge(OperatingSystemMXBean os) {
+    this.os = os;
+  }
+
+  @Override
+  protected Ratio getRatio() {
+    if (unixOperatingSystemMXBeanExists
+        && os instanceof com.sun.management.UnixOperatingSystemMXBean) {
+      final com.sun.management.UnixOperatingSystemMXBean unixOs =
+          (com.sun.management.UnixOperatingSystemMXBean) os;
+      return Ratio.of(unixOs.getOpenFileDescriptorCount(), unixOs.getMaxFileDescriptorCount());
+    } else {
+      return Ratio.of(Double.NaN, Double.NaN);
     }
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/GarbageCollectorMetricSet.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/GarbageCollectorMetricSet.java
@@ -1,53 +1,49 @@
 package io.dropwizard.metrics5.jvm;
 
+import static java.util.Collections.unmodifiableMap;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.Metric;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricSet;
-
 import java.lang.management.GarbageCollectorMXBean;
 import java.lang.management.ManagementFactory;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Pattern;
 
-/**
- * A set of gauges for the counts and elapsed times of garbage collections.
- */
+/** A set of gauges for the counts and elapsed times of garbage collections. */
 public class GarbageCollectorMetricSet implements MetricSet {
-    private static final Pattern WHITESPACE = Pattern.compile("[\\s]+");
+  private static final Pattern WHITESPACE = Pattern.compile("[\\s]+");
 
-    private final List<GarbageCollectorMXBean> garbageCollectors;
+  private final List<GarbageCollectorMXBean> garbageCollectors;
 
-    /**
-     * Creates a new set of gauges for all discoverable garbage collectors.
-     */
-    public GarbageCollectorMetricSet() {
-        this(ManagementFactory.getGarbageCollectorMXBeans());
-    }
+  /** Creates a new set of gauges for all discoverable garbage collectors. */
+  public GarbageCollectorMetricSet() {
+    this(ManagementFactory.getGarbageCollectorMXBeans());
+  }
 
-    /**
-     * Creates a new set of gauges for the given collection of garbage collectors.
-     *
-     * @param garbageCollectors the garbage collectors
-     */
-    public GarbageCollectorMetricSet(Collection<GarbageCollectorMXBean> garbageCollectors) {
-        this.garbageCollectors = new ArrayList<>(garbageCollectors);
-    }
+  /**
+   * Creates a new set of gauges for the given collection of garbage collectors.
+   *
+   * @param garbageCollectors the garbage collectors
+   */
+  public GarbageCollectorMetricSet(Collection<GarbageCollectorMXBean> garbageCollectors) {
+    this.garbageCollectors = new ArrayList<>(garbageCollectors);
+  }
 
-    @Override
-    public Map<MetricName, Metric> getMetrics() {
-        final Map<MetricName, Metric> gauges = new HashMap<>();
-        for (final GarbageCollectorMXBean gc : garbageCollectors) {
-            final String name = WHITESPACE.matcher(gc.getName()).replaceAll("-");
-            gauges.put(MetricRegistry.name(name, "count"), (Gauge<Long>) gc::getCollectionCount);
-            gauges.put(MetricRegistry.name(name, "time"), (Gauge<Long>) gc::getCollectionTime);
-        }
-        return Collections.unmodifiableMap(gauges);
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    final Map<MetricName, Metric> gauges = new HashMap<>();
+    for (final GarbageCollectorMXBean gc : garbageCollectors) {
+      final String name = WHITESPACE.matcher(gc.getName()).replaceAll("-");
+      gauges.put(MetricRegistry.name(name, "count"), (Gauge<Long>) gc::getCollectionCount);
+      gauges.put(MetricRegistry.name(name, "time"), (Gauge<Long>) gc::getCollectionTime);
     }
+    return unmodifiableMap(gauges);
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/JmxAttributeGauge.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/JmxAttributeGauge.java
@@ -1,61 +1,62 @@
 package io.dropwizard.metrics5.jvm;
 
 import io.dropwizard.metrics5.Gauge;
-
-import javax.management.JMException;
-import javax.management.MBeanServerConnection;
-import javax.management.ObjectName;
 import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.util.Set;
+import javax.management.JMException;
+import javax.management.MBeanServerConnection;
+import javax.management.ObjectName;
 
 /**
- * A {@link Gauge} implementation which queries an {@link MBeanServerConnection} for an attribute of an object.
+ * A {@link Gauge} implementation which queries an {@link MBeanServerConnection} for an attribute of
+ * an object.
  */
 public class JmxAttributeGauge implements Gauge<Object> {
-    private final MBeanServerConnection mBeanServerConn;
-    private final ObjectName objectName;
-    private final String attributeName;
+  private final MBeanServerConnection mBeanServerConn;
+  private final ObjectName objectName;
+  private final String attributeName;
 
-    /**
-     * Creates a new JmxAttributeGauge.
-     *
-     * @param objectName    the name of the object
-     * @param attributeName the name of the object's attribute
-     */
-    public JmxAttributeGauge(ObjectName objectName, String attributeName) {
-        this(ManagementFactory.getPlatformMBeanServer(), objectName, attributeName);
-    }
+  /**
+   * Creates a new JmxAttributeGauge.
+   *
+   * @param objectName the name of the object
+   * @param attributeName the name of the object's attribute
+   */
+  public JmxAttributeGauge(ObjectName objectName, String attributeName) {
+    this(ManagementFactory.getPlatformMBeanServer(), objectName, attributeName);
+  }
 
-    /**
-     * Creates a new JmxAttributeGauge.
-     *
-     * @param mBeanServerConn the {@link MBeanServerConnection}
-     * @param objectName      the name of the object
-     * @param attributeName   the name of the object's attribute
-     */
-    public JmxAttributeGauge(MBeanServerConnection mBeanServerConn, ObjectName objectName, String attributeName) {
-        this.mBeanServerConn = mBeanServerConn;
-        this.objectName = objectName;
-        this.attributeName = attributeName;
-    }
+  /**
+   * Creates a new JmxAttributeGauge.
+   *
+   * @param mBeanServerConn the {@link MBeanServerConnection}
+   * @param objectName the name of the object
+   * @param attributeName the name of the object's attribute
+   */
+  public JmxAttributeGauge(
+      MBeanServerConnection mBeanServerConn, ObjectName objectName, String attributeName) {
+    this.mBeanServerConn = mBeanServerConn;
+    this.objectName = objectName;
+    this.attributeName = attributeName;
+  }
 
-    @Override
-    public Object getValue() {
-        try {
-            return mBeanServerConn.getAttribute(getObjectName(), attributeName);
-        } catch (IOException | JMException e) {
-            return null;
-        }
+  @Override
+  public Object getValue() {
+    try {
+      return mBeanServerConn.getAttribute(getObjectName(), attributeName);
+    } catch (IOException | JMException e) {
+      return null;
     }
+  }
 
-    private ObjectName getObjectName() throws IOException {
-        if (objectName.isPattern()) {
-            Set<ObjectName> foundNames = mBeanServerConn.queryNames(objectName, null);
-            if (foundNames.size() == 1) {
-                return foundNames.iterator().next();
-            }
-        }
-        return objectName;
+  private ObjectName getObjectName() throws IOException {
+    if (objectName.isPattern()) {
+      Set<ObjectName> foundNames = mBeanServerConn.queryNames(objectName, null);
+      if (foundNames.size() == 1) {
+        return foundNames.iterator().next();
+      }
     }
+    return objectName;
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/JvmAttributeGaugeSet.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/JvmAttributeGaugeSet.java
@@ -1,52 +1,53 @@
 package io.dropwizard.metrics5.jvm;
 
+import static java.util.Collections.unmodifiableMap;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.Metric;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricSet;
-
 import java.lang.management.ManagementFactory;
 import java.lang.management.RuntimeMXBean;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 
-/**
- * A set of gauges for the JVM name, vendor, and uptime.
- */
+/** A set of gauges for the JVM name, vendor, and uptime. */
 public class JvmAttributeGaugeSet implements MetricSet {
-    private final RuntimeMXBean runtime;
-
-    /**
-     * Creates a new set of gauges.
-     */
-    public JvmAttributeGaugeSet() {
-        this(ManagementFactory.getRuntimeMXBean());
-    }
-
-    /**
-     * Creates a new set of gauges with the given {@link RuntimeMXBean}.
-     *
-     * @param runtime JVM management interface with access to system properties
-     */
-    public JvmAttributeGaugeSet(RuntimeMXBean runtime) {
-        this.runtime = runtime;
-    }
-
-    @Override
-    public Map<MetricName, Metric> getMetrics() {
-        final Map<MetricName, Metric> gauges = new HashMap<>();
-
-        gauges.put(MetricName.build("name"), (Gauge<String>) runtime::getName);
-        gauges.put(MetricName.build("vendor"), (Gauge<String>) () -> String.format(Locale.US,
-                "%s %s %s (%s)",
-                runtime.getVmVendor(),
-                runtime.getVmName(),
-                runtime.getVmVersion(),
-                runtime.getSpecVersion()));
-        gauges.put(MetricName.build("uptime"), (Gauge<Long>) runtime::getUptime);
-
-        return Collections.unmodifiableMap(gauges);
-    }
+  private final RuntimeMXBean runtime;
+
+  /** Creates a new set of gauges. */
+  public JvmAttributeGaugeSet() {
+    this(ManagementFactory.getRuntimeMXBean());
+  }
+
+  /**
+   * Creates a new set of gauges with the given {@link RuntimeMXBean}.
+   *
+   * @param runtime JVM management interface with access to system properties
+   */
+  public JvmAttributeGaugeSet(RuntimeMXBean runtime) {
+    this.runtime = runtime;
+  }
+
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    final Map<MetricName, Metric> gauges = new HashMap<>();
+
+    gauges.put(MetricName.build("name"), (Gauge<String>) runtime::getName);
+    gauges.put(
+        MetricName.build("vendor"),
+        (Gauge<String>)
+            () ->
+                String.format(
+                    Locale.US,
+                    "%s %s %s (%s)",
+                    runtime.getVmVendor(),
+                    runtime.getVmName(),
+                    runtime.getVmVersion(),
+                    runtime.getSpecVersion()));
+    gauges.put(MetricName.build("uptime"), (Gauge<Long>) runtime::getUptime);
+
+    return unmodifiableMap(gauges);
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/MemoryUsageGaugeSet.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/MemoryUsageGaugeSet.java
@@ -1,19 +1,19 @@
 package io.dropwizard.metrics5.jvm;
 
+import static java.util.Collections.unmodifiableMap;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.Metric;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricSet;
 import io.dropwizard.metrics5.RatioGauge;
-
 import java.lang.management.ManagementFactory;
 import java.lang.management.MemoryMXBean;
 import java.lang.management.MemoryPoolMXBean;
 import java.lang.management.MemoryUsage;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -24,83 +24,122 @@ import java.util.regex.Pattern;
  * GC-specific memory pools.
  */
 public class MemoryUsageGaugeSet implements MetricSet {
-    private static final Pattern WHITESPACE = Pattern.compile("[\\s]+");
-
-    private final MemoryMXBean mxBean;
-    private final List<MemoryPoolMXBean> memoryPools;
-
-    public MemoryUsageGaugeSet() {
-        this(ManagementFactory.getMemoryMXBean(), ManagementFactory.getMemoryPoolMXBeans());
-    }
-
-    public MemoryUsageGaugeSet(MemoryMXBean mxBean,
-                               Collection<MemoryPoolMXBean> memoryPools) {
-        this.mxBean = mxBean;
-        this.memoryPools = new ArrayList<>(memoryPools);
-    }
+  private static final Pattern WHITESPACE = Pattern.compile("[\\s]+");
+
+  private final MemoryMXBean mxBean;
+  private final List<MemoryPoolMXBean> memoryPools;
+
+  public MemoryUsageGaugeSet() {
+    this(ManagementFactory.getMemoryMXBean(), ManagementFactory.getMemoryPoolMXBeans());
+  }
+
+  public MemoryUsageGaugeSet(MemoryMXBean mxBean, Collection<MemoryPoolMXBean> memoryPools) {
+    this.mxBean = mxBean;
+    this.memoryPools = new ArrayList<>(memoryPools);
+  }
+
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    final Map<MetricName, Metric> gauges = new HashMap<>();
+
+    gauges.put(
+        MetricName.build("total.init"),
+        (Gauge<Long>)
+            () -> mxBean.getHeapMemoryUsage().getInit() + mxBean.getNonHeapMemoryUsage().getInit());
+    gauges.put(
+        MetricName.build("total.used"),
+        (Gauge<Long>)
+            () -> mxBean.getHeapMemoryUsage().getUsed() + mxBean.getNonHeapMemoryUsage().getUsed());
+    gauges.put(
+        MetricName.build("total.max"),
+        (Gauge<Long>)
+            () ->
+                mxBean.getNonHeapMemoryUsage().getMax() == -1
+                    ? -1
+                    : mxBean.getHeapMemoryUsage().getMax()
+                        + mxBean.getNonHeapMemoryUsage().getMax());
+    gauges.put(
+        MetricName.build("total.committed"),
+        (Gauge<Long>)
+            () ->
+                mxBean.getHeapMemoryUsage().getCommitted()
+                    + mxBean.getNonHeapMemoryUsage().getCommitted());
+
+    gauges.put(
+        MetricName.build("heap.init"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getInit());
+    gauges.put(
+        MetricName.build("heap.used"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getUsed());
+    gauges.put(
+        MetricName.build("heap.max"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getMax());
+    gauges.put(
+        MetricName.build("heap.committed"),
+        (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getCommitted());
+    gauges.put(
+        MetricName.build("heap.usage"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            final MemoryUsage usage = mxBean.getHeapMemoryUsage();
+            return Ratio.of(usage.getUsed(), usage.getMax());
+          }
+        });
 
-    @Override
-    public Map<MetricName, Metric> getMetrics() {
-        final Map<MetricName, Metric> gauges = new HashMap<>();
-
-        gauges.put(MetricName.build("total.init"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getInit() +
-                mxBean.getNonHeapMemoryUsage().getInit());
-        gauges.put(MetricName.build("total.used"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getUsed() +
-                mxBean.getNonHeapMemoryUsage().getUsed());
-        gauges.put(MetricName.build("total.max"), (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getMax() == -1 ?
-                -1 : mxBean.getHeapMemoryUsage().getMax() + mxBean.getNonHeapMemoryUsage().getMax());
-        gauges.put(MetricName.build("total.committed"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getCommitted() +
-                mxBean.getNonHeapMemoryUsage().getCommitted());
-
-        gauges.put(MetricName.build("heap.init"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getInit());
-        gauges.put(MetricName.build("heap.used"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getUsed());
-        gauges.put(MetricName.build("heap.max"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getMax());
-        gauges.put(MetricName.build("heap.committed"), (Gauge<Long>) () -> mxBean.getHeapMemoryUsage().getCommitted());
-        gauges.put(MetricName.build("heap.usage"), new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                final MemoryUsage usage = mxBean.getHeapMemoryUsage();
-                return Ratio.of(usage.getUsed(), usage.getMax());
-            }
+    gauges.put(
+        MetricName.build("non-heap.init"),
+        (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getInit());
+    gauges.put(
+        MetricName.build("non-heap.used"),
+        (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getUsed());
+    gauges.put(
+        MetricName.build("non-heap.max"),
+        (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getMax());
+    gauges.put(
+        MetricName.build("non-heap.committed"),
+        (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getCommitted());
+    gauges.put(
+        MetricName.build("non-heap.usage"),
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            final MemoryUsage usage = mxBean.getNonHeapMemoryUsage();
+            return Ratio.of(
+                usage.getUsed(), usage.getMax() == -1 ? usage.getCommitted() : usage.getMax());
+          }
         });
 
-        gauges.put(MetricName.build("non-heap.init"), (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getInit());
-        gauges.put(MetricName.build("non-heap.used"), (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getUsed());
-        gauges.put(MetricName.build("non-heap.max"), (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getMax());
-        gauges.put(MetricName.build("non-heap.committed"), (Gauge<Long>) () -> mxBean.getNonHeapMemoryUsage().getCommitted());
-        gauges.put(MetricName.build("non-heap.usage"), new RatioGauge() {
+    for (final MemoryPoolMXBean pool : memoryPools) {
+      final String poolName = "pools." + WHITESPACE.matcher(pool.getName()).replaceAll("-");
+
+      gauges.put(
+          MetricRegistry.name(poolName, "usage"),
+          new RatioGauge() {
             @Override
             protected Ratio getRatio() {
-                final MemoryUsage usage = mxBean.getNonHeapMemoryUsage();
-                return Ratio.of(usage.getUsed(), usage.getMax() == -1 ? usage.getCommitted() : usage.getMax());
+              MemoryUsage usage = pool.getUsage();
+              return Ratio.of(
+                  usage.getUsed(), usage.getMax() == -1 ? usage.getCommitted() : usage.getMax());
             }
-        });
-
-        for (final MemoryPoolMXBean pool : memoryPools) {
-            final String poolName = "pools." + WHITESPACE.matcher(pool.getName()).replaceAll("-");
-
-            gauges.put(MetricRegistry.name(poolName, "usage"), new RatioGauge() {
-                @Override
-                protected Ratio getRatio() {
-                    MemoryUsage usage = pool.getUsage();
-                    return Ratio.of(usage.getUsed(),
-                            usage.getMax() == -1 ? usage.getCommitted() : usage.getMax());
-                }
-            });
-
-            gauges.put(MetricRegistry.name(poolName, "max"), (Gauge<Long>) () -> pool.getUsage().getMax());
-            gauges.put(MetricRegistry.name(poolName, "used"), (Gauge<Long>) () -> pool.getUsage().getUsed());
-            gauges.put(MetricRegistry.name(poolName, "committed"), (Gauge<Long>) () -> pool.getUsage().getCommitted());
-
-            // Only register GC usage metrics if the memory pool supports usage statistics.
-            if (pool.getCollectionUsage() != null) {
-                gauges.put(MetricRegistry.name(poolName, "used-after-gc"), (Gauge<Long>) () ->
-                        pool.getCollectionUsage().getUsed());
-            }
-
-            gauges.put(MetricRegistry.name(poolName, "init"), (Gauge<Long>) () -> pool.getUsage().getInit());
-        }
-
-        return Collections.unmodifiableMap(gauges);
+          });
+
+      gauges.put(
+          MetricRegistry.name(poolName, "max"), (Gauge<Long>) () -> pool.getUsage().getMax());
+      gauges.put(
+          MetricRegistry.name(poolName, "used"), (Gauge<Long>) () -> pool.getUsage().getUsed());
+      gauges.put(
+          MetricRegistry.name(poolName, "committed"),
+          (Gauge<Long>) () -> pool.getUsage().getCommitted());
+
+      // Only register GC usage metrics if the memory pool supports usage statistics.
+      if (pool.getCollectionUsage() != null) {
+        gauges.put(
+            MetricRegistry.name(poolName, "used-after-gc"),
+            (Gauge<Long>) () -> pool.getCollectionUsage().getUsed());
+      }
+
+      gauges.put(
+          MetricRegistry.name(poolName, "init"), (Gauge<Long>) () -> pool.getUsage().getInit());
     }
+
+    return unmodifiableMap(gauges);
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/ThreadDeadlockDetector.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/ThreadDeadlockDetector.java
@@ -1,65 +1,57 @@
 package io.dropwizard.metrics5.jvm;
 
+import static java.util.Collections.unmodifiableSet;
+
+import com.google.common.collect.ImmutableSet;
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
-/**
- * A utility class for detecting deadlocked threads.
- */
+/** A utility class for detecting deadlocked threads. */
 public class ThreadDeadlockDetector {
-    private static final int MAX_STACK_TRACE_DEPTH = 100;
+  private static final int MAX_STACK_TRACE_DEPTH = 100;
 
-    private final ThreadMXBean threads;
+  private final ThreadMXBean threads;
 
-    /**
-     * Creates a new detector.
-     */
-    public ThreadDeadlockDetector() {
-        this(ManagementFactory.getThreadMXBean());
-    }
+  /** Creates a new detector. */
+  public ThreadDeadlockDetector() {
+    this(ManagementFactory.getThreadMXBean());
+  }
 
-    /**
-     * Creates a new detector using the given {@link ThreadMXBean}.
-     *
-     * @param threads a {@link ThreadMXBean}
-     */
-    public ThreadDeadlockDetector(ThreadMXBean threads) {
-        this.threads = threads;
-    }
+  /**
+   * Creates a new detector using the given {@link ThreadMXBean}.
+   *
+   * @param threads a {@link ThreadMXBean}
+   */
+  public ThreadDeadlockDetector(ThreadMXBean threads) {
+    this.threads = threads;
+  }
 
-    /**
-     * Returns a set of diagnostic stack traces for any deadlocked threads. If no threads are
-     * deadlocked, returns an empty set.
-     *
-     * @return stack traces for deadlocked threads or an empty set
-     */
-    public Set<String> getDeadlockedThreads() {
-        final long[] ids = threads.findDeadlockedThreads();
-        if (ids != null) {
-            final Set<String> deadlocks = new HashSet<>();
-            for (ThreadInfo info : threads.getThreadInfo(ids, MAX_STACK_TRACE_DEPTH)) {
-                final StringBuilder stackTrace = new StringBuilder();
-                for (StackTraceElement element : info.getStackTrace()) {
-                    stackTrace.append("\t at ")
-                            .append(element.toString())
-                            .append(String.format("%n"));
-                }
-
-                deadlocks.add(
-                        String.format("%s locked on %s (owned by %s):%n%s",
-                                info.getThreadName(),
-                                info.getLockName(),
-                                info.getLockOwnerName(),
-                                stackTrace.toString()
-                        )
-                );
-            }
-            return Collections.unmodifiableSet(deadlocks);
+  /**
+   * Returns a set of diagnostic stack traces for any deadlocked threads. If no threads are
+   * deadlocked, returns an empty set.
+   *
+   * @return stack traces for deadlocked threads or an empty set
+   */
+  public Set<String> getDeadlockedThreads() {
+    final long[] ids = threads.findDeadlockedThreads();
+    if (ids != null) {
+      final Set<String> deadlocks = new HashSet<>();
+      for (ThreadInfo info : threads.getThreadInfo(ids, MAX_STACK_TRACE_DEPTH)) {
+        final StringBuilder stackTrace = new StringBuilder();
+        for (StackTraceElement element : info.getStackTrace()) {
+          stackTrace.append("\t at ").append(element).append(String.format("%n"));
         }
-        return Collections.emptySet();
+
+        deadlocks.add(
+            String.format(
+                "%s locked on %s (owned by %s):%n%s",
+                info.getThreadName(), info.getLockName(), info.getLockOwnerName(), stackTrace));
+      }
+      return unmodifiableSet(deadlocks);
     }
+    return ImmutableSet.of();
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/ThreadDump.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/ThreadDump.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.jvm;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
@@ -8,106 +10,98 @@ import java.lang.management.MonitorInfo;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-
-/**
- * A convenience class for getting a thread dump.
- */
+/** A convenience class for getting a thread dump. */
 public class ThreadDump {
 
-    private final ThreadMXBean threadMXBean;
-
-    public ThreadDump(ThreadMXBean threadMXBean) {
-        this.threadMXBean = threadMXBean;
-    }
-
-    /**
-     * Dumps all of the threads' current information, including synchronization, to an output stream.
-     *
-     * @param out an output stream
-     */
-    public void dump(OutputStream out) {
-        dump(true, true, out);
-    }
-
-    /**
-     * Dumps all of the threads' current information, optionally including synchronization, to an output stream.
-     *
-     * Having control over including synchronization info allows using this method (and its wrappers, i.e.
-     * ThreadDumpServlet) in environments where getting object monitor and/or ownable synchronizer usage is not
-     * supported. It can also speed things up.
-     *
-     * See {@link ThreadMXBean#dumpAllThreads(boolean, boolean)}
-     *
-     * @param lockedMonitors dump all locked monitors if true
-     * @param lockedSynchronizers dump all locked ownable synchronizers if true
-     * @param out an output stream
-     */
-    public void dump(boolean lockedMonitors, boolean lockedSynchronizers, OutputStream out) {
-        final ThreadInfo[] threads = this.threadMXBean.dumpAllThreads(lockedMonitors, lockedSynchronizers);
-        final PrintWriter writer = new PrintWriter(new OutputStreamWriter(out, UTF_8));
-
-        for (int ti = threads.length - 1; ti >= 0; ti--) {
-            final ThreadInfo t = threads[ti];
-            writer.printf("\"%s\" id=%d state=%s",
-                    t.getThreadName(),
-                    t.getThreadId(),
-                    t.getThreadState());
-            final LockInfo lock = t.getLockInfo();
-            if (lock != null && t.getThreadState() != Thread.State.BLOCKED) {
-                writer.printf("%n    - waiting on <0x%08x> (a %s)",
-                        lock.getIdentityHashCode(),
-                        lock.getClassName());
-                writer.printf("%n    - locked <0x%08x> (a %s)",
-                        lock.getIdentityHashCode(),
-                        lock.getClassName());
-            } else if (lock != null && t.getThreadState() == Thread.State.BLOCKED) {
-                writer.printf("%n    - waiting to lock <0x%08x> (a %s)",
-                        lock.getIdentityHashCode(),
-                        lock.getClassName());
-            }
-
-            if (t.isSuspended()) {
-                writer.print(" (suspended)");
-            }
-
-            if (t.isInNative()) {
-                writer.print(" (running in native)");
-            }
-
-            writer.println();
-            if (t.getLockOwnerName() != null) {
-                writer.printf("     owned by %s id=%d%n", t.getLockOwnerName(), t.getLockOwnerId());
-            }
-
-            final StackTraceElement[] elements = t.getStackTrace();
-            final MonitorInfo[] monitors = t.getLockedMonitors();
-
-            for (int i = 0; i < elements.length; i++) {
-                final StackTraceElement element = elements[i];
-                writer.printf("    at %s%n", element);
-                for (int j = 1; j < monitors.length; j++) {
-                    final MonitorInfo monitor = monitors[j];
-                    if (monitor.getLockedStackDepth() == i) {
-                        writer.printf("      - locked %s%n", monitor);
-                    }
-                }
-            }
-            writer.println();
-
-            final LockInfo[] locks = t.getLockedSynchronizers();
-            if (locks.length > 0) {
-                writer.printf("    Locked synchronizers: count = %d%n", locks.length);
-                for (LockInfo l : locks) {
-                    writer.printf("      - %s%n", l);
-                }
-                writer.println();
-            }
+  private final ThreadMXBean threadMXBean;
+
+  public ThreadDump(ThreadMXBean threadMXBean) {
+    this.threadMXBean = threadMXBean;
+  }
+
+  /**
+   * Dumps all of the threads' current information, including synchronization, to an output stream.
+   *
+   * @param out an output stream
+   */
+  public void dump(OutputStream out) {
+    dump(true, true, out);
+  }
+
+  /**
+   * Dumps all of the threads' current information, optionally including synchronization, to an
+   * output stream.
+   *
+   * <p>Having control over including synchronization info allows using this method (and its
+   * wrappers, i.e. ThreadDumpServlet) in environments where getting object monitor and/or ownable
+   * synchronizer usage is not supported. It can also speed things up.
+   *
+   * <p>See {@link ThreadMXBean#dumpAllThreads(boolean, boolean)}
+   *
+   * @param lockedMonitors dump all locked monitors if true
+   * @param lockedSynchronizers dump all locked ownable synchronizers if true
+   * @param out an output stream
+   */
+  public void dump(boolean lockedMonitors, boolean lockedSynchronizers, OutputStream out) {
+    final ThreadInfo[] threads =
+        this.threadMXBean.dumpAllThreads(lockedMonitors, lockedSynchronizers);
+    final PrintWriter writer = new PrintWriter(new OutputStreamWriter(out, UTF_8));
+
+    for (int ti = threads.length - 1; ti >= 0; ti--) {
+      final ThreadInfo t = threads[ti];
+      writer.printf(
+          "\"%s\" id=%d state=%s", t.getThreadName(), t.getThreadId(), t.getThreadState());
+      final LockInfo lock = t.getLockInfo();
+      if (lock != null && t.getThreadState() != Thread.State.BLOCKED) {
+        writer.printf(
+            "%n    - waiting on <0x%08x> (a %s)", lock.getIdentityHashCode(), lock.getClassName());
+        writer.printf(
+            "%n    - locked <0x%08x> (a %s)", lock.getIdentityHashCode(), lock.getClassName());
+      } else if (lock != null && t.getThreadState() == Thread.State.BLOCKED) {
+        writer.printf(
+            "%n    - waiting to lock <0x%08x> (a %s)",
+            lock.getIdentityHashCode(), lock.getClassName());
+      }
+
+      if (t.isSuspended()) {
+        writer.print(" (suspended)");
+      }
+
+      if (t.isInNative()) {
+        writer.print(" (running in native)");
+      }
+
+      writer.println();
+      if (t.getLockOwnerName() != null) {
+        writer.printf("     owned by %s id=%d%n", t.getLockOwnerName(), t.getLockOwnerId());
+      }
+
+      final StackTraceElement[] elements = t.getStackTrace();
+      final MonitorInfo[] monitors = t.getLockedMonitors();
+
+      for (int i = 0; i < elements.length; i++) {
+        final StackTraceElement element = elements[i];
+        writer.printf("    at %s%n", element);
+        for (int j = 1; j < monitors.length; j++) {
+          final MonitorInfo monitor = monitors[j];
+          if (monitor.getLockedStackDepth() == i) {
+            writer.printf("      - locked %s%n", monitor);
+          }
+        }
+      }
+      writer.println();
+
+      final LockInfo[] locks = t.getLockedSynchronizers();
+      if (locks.length > 0) {
+        writer.printf("    Locked synchronizers: count = %d%n", locks.length);
+        for (LockInfo l : locks) {
+          writer.printf("      - %s%n", l);
         }
-
         writer.println();
-        writer.flush();
+      }
     }
 
+    writer.println();
+    writer.flush();
+  }
 }
--- a/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/ThreadStatesGaugeSet.java
+++ b/metrics-jvm/src/main/java/io/dropwizard/metrics5/jvm/ThreadStatesGaugeSet.java
@@ -1,81 +1,80 @@
 package io.dropwizard.metrics5.jvm;
 
+import static java.util.Collections.unmodifiableMap;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.Metric;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.MetricSet;
-
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 
-/**
- * A set of gauges for the number of threads in their various states and deadlock detection.
- */
+/** A set of gauges for the number of threads in their various states and deadlock detection. */
 public class ThreadStatesGaugeSet implements MetricSet {
 
-    // do not compute stack traces.
-    private final static int STACK_TRACE_DEPTH = 0;
-
-    private final ThreadMXBean threads;
-    private final ThreadDeadlockDetector deadlockDetector;
-
-    /**
-     * Creates a new set of gauges using the default MXBeans.
-     */
-    public ThreadStatesGaugeSet() {
-        this(ManagementFactory.getThreadMXBean(), new ThreadDeadlockDetector());
-    }
+  // do not compute stack traces.
+  private static final int STACK_TRACE_DEPTH = 0;
 
-    /**
-     * Creates a new set of gauges using the given MXBean and detector.
-     *
-     * @param threads          a thread MXBean
-     * @param deadlockDetector a deadlock detector
-     */
-    public ThreadStatesGaugeSet(ThreadMXBean threads,
-                                ThreadDeadlockDetector deadlockDetector) {
-        this.threads = threads;
-        this.deadlockDetector = deadlockDetector;
-    }
+  private final ThreadMXBean threads;
+  private final ThreadDeadlockDetector deadlockDetector;
 
-    @Override
-    public Map<MetricName, Metric> getMetrics() {
-        final Map<MetricName, Metric> gauges = new HashMap<>();
+  /** Creates a new set of gauges using the default MXBeans. */
+  public ThreadStatesGaugeSet() {
+    this(ManagementFactory.getThreadMXBean(), new ThreadDeadlockDetector());
+  }
 
-        for (final Thread.State state : Thread.State.values()) {
-            gauges.put(MetricRegistry.name(state.toString().toLowerCase(), "count"),
-                    (Gauge<Object>) () -> getThreadCount(state));
-        }
+  /**
+   * Creates a new set of gauges using the given MXBean and detector.
+   *
+   * @param threads a thread MXBean
+   * @param deadlockDetector a deadlock detector
+   */
+  public ThreadStatesGaugeSet(ThreadMXBean threads, ThreadDeadlockDetector deadlockDetector) {
+    this.threads = threads;
+    this.deadlockDetector = deadlockDetector;
+  }
 
-        gauges.put(MetricName.build("count"), (Gauge<Integer>) threads::getThreadCount);
-        gauges.put(MetricName.build("daemon.count"), (Gauge<Integer>) threads::getDaemonThreadCount);
-        gauges.put(MetricName.build("peak.count"), (Gauge<Integer>) threads::getPeakThreadCount);
-        gauges.put(MetricName.build("total_started.count"), (Gauge<Long>) threads::getTotalStartedThreadCount);
-        gauges.put(MetricName.build("deadlock.count"), (Gauge<Integer>) () -> deadlockDetector.getDeadlockedThreads().size());
-        gauges.put(MetricName.build("deadlocks"), (Gauge<Set<String>>) deadlockDetector::getDeadlockedThreads);
+  @Override
+  public Map<MetricName, Metric> getMetrics() {
+    final Map<MetricName, Metric> gauges = new HashMap<>();
 
-        return Collections.unmodifiableMap(gauges);
+    for (final Thread.State state : Thread.State.values()) {
+      gauges.put(
+          MetricRegistry.name(state.toString().toLowerCase(), "count"),
+          (Gauge<Object>) () -> getThreadCount(state));
     }
 
-    private int getThreadCount(Thread.State state) {
-        final ThreadInfo[] allThreads = getThreadInfo();
-        int count = 0;
-        for (ThreadInfo info : allThreads) {
-            if (info != null && info.getThreadState() == state) {
-                count++;
-            }
-        }
-        return count;
-    }
+    gauges.put(MetricName.build("count"), (Gauge<Integer>) threads::getThreadCount);
+    gauges.put(MetricName.build("daemon.count"), (Gauge<Integer>) threads::getDaemonThreadCount);
+    gauges.put(MetricName.build("peak.count"), (Gauge<Integer>) threads::getPeakThreadCount);
+    gauges.put(
+        MetricName.build("total_started.count"), (Gauge<Long>) threads::getTotalStartedThreadCount);
+    gauges.put(
+        MetricName.build("deadlock.count"),
+        (Gauge<Integer>) () -> deadlockDetector.getDeadlockedThreads().size());
+    gauges.put(
+        MetricName.build("deadlocks"), (Gauge<Set<String>>) deadlockDetector::getDeadlockedThreads);
+
+    return unmodifiableMap(gauges);
+  }
 
-    ThreadInfo[] getThreadInfo() {
-        return threads.getThreadInfo(threads.getAllThreadIds(), STACK_TRACE_DEPTH);
+  private int getThreadCount(Thread.State state) {
+    final ThreadInfo[] allThreads = getThreadInfo();
+    int count = 0;
+    for (ThreadInfo info : allThreads) {
+      if (info != null && info.getThreadState() == state) {
+        count++;
+      }
     }
+    return count;
+  }
 
+  ThreadInfo[] getThreadInfo() {
+    return threads.getThreadInfo(threads.getAllThreadIds(), STACK_TRACE_DEPTH);
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/BufferPoolMetricSetTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/BufferPoolMetricSetTest.java
@@ -1,121 +1,107 @@
 package io.dropwizard.metrics5.jvm;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.MetricName;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
 import javax.management.InstanceNotFoundException;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("rawtypes")
-class BufferPoolMetricSetTest {
-
-    private static final MetricName DIRECT = MetricName.build("direct");
-    private static final MetricName MAPPED = MetricName.build("mapped");
-    private static final MetricName DIRECT_COUNT = DIRECT.resolve("count");
-    private static final MetricName DIRECT_CAPACITY = DIRECT.resolve("capacity");
-    private static final MetricName DIRECT_USED = DIRECT.resolve("used");
-    private static final MetricName MAPPED_COUNT = MAPPED.resolve("count");
-    private static final MetricName MAPPED_CAPACITY = MAPPED.resolve("capacity");
-    private static final MetricName MAPPED_USED = MAPPED.resolve("used");
+final class BufferPoolMetricSetTest {
 
-    private final MBeanServer mBeanServer = mock(MBeanServer.class);
-    private final BufferPoolMetricSet buffers = new BufferPoolMetricSet(mBeanServer);
+  private static final MetricName DIRECT = MetricName.build("direct");
+  private static final MetricName MAPPED = MetricName.build("mapped");
+  private static final MetricName DIRECT_COUNT = DIRECT.resolve("count");
+  private static final MetricName DIRECT_CAPACITY = DIRECT.resolve("capacity");
+  private static final MetricName DIRECT_USED = DIRECT.resolve("used");
+  private static final MetricName MAPPED_COUNT = MAPPED.resolve("count");
+  private static final MetricName MAPPED_CAPACITY = MAPPED.resolve("capacity");
+  private static final MetricName MAPPED_USED = MAPPED.resolve("used");
 
-    private ObjectName mapped;
-    private ObjectName direct;
+  private final MBeanServer mBeanServer = mock();
+  private final BufferPoolMetricSet buffers = new BufferPoolMetricSet(mBeanServer);
 
-    @BeforeEach
-    void setUp() throws Exception {
-        this.mapped = new ObjectName("java.nio:type=BufferPool,name=mapped");
-        this.direct = new ObjectName("java.nio:type=BufferPool,name=direct");
+  private ObjectName mapped;
+  private ObjectName direct;
 
-    }
+  @BeforeEach
+  void setUp() throws Exception {
+    this.mapped = new ObjectName("java.nio:type=BufferPool,name=mapped");
+    this.direct = new ObjectName("java.nio:type=BufferPool,name=direct");
+  }
 
-    @Test
-    void includesGaugesForDirectAndMappedPools() {
-        assertThat(buffers.getMetrics().keySet())
-                .containsOnly(DIRECT_COUNT,
-                        DIRECT_USED,
-                        DIRECT_CAPACITY,
-                        MAPPED_COUNT,
-                        MAPPED_USED,
-                        MAPPED_CAPACITY);
-    }
+  @Test
+  void includesGaugesForDirectAndMappedPools() {
+    assertThat(buffers.getMetrics().keySet())
+        .containsOnly(
+            DIRECT_COUNT, DIRECT_USED, DIRECT_CAPACITY, MAPPED_COUNT, MAPPED_USED, MAPPED_CAPACITY);
+  }
 
-    @Test
-    void ignoresGaugesForObjectsWhichCannotBeFound() throws Exception {
-        when(mBeanServer.getMBeanInfo(mapped)).thenThrow(new InstanceNotFoundException());
+  @Test
+  void ignoresGaugesForObjectsWhichCannotBeFound() throws Exception {
+    when(mBeanServer.getMBeanInfo(mapped)).thenThrow(new InstanceNotFoundException());
 
-        assertThat(buffers.getMetrics().keySet())
-                .containsOnly(DIRECT_COUNT,
-                        DIRECT_USED,
-                        DIRECT_CAPACITY);
-    }
+    assertThat(buffers.getMetrics().keySet())
+        .containsOnly(DIRECT_COUNT, DIRECT_USED, DIRECT_CAPACITY);
+  }
 
-    @Test
-    void includesAGaugeForDirectCount() throws Exception {
-        final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(DIRECT_COUNT);
+  @Test
+  void includesAGaugeForDirectCount() throws Exception {
+    final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(DIRECT_COUNT);
 
-        when(mBeanServer.getAttribute(direct, "Count")).thenReturn(100);
+    when(mBeanServer.getAttribute(direct, "Count")).thenReturn(100);
 
-        assertThat(gauge.getValue())
-                .isEqualTo(100);
-    }
+    assertThat(gauge.getValue()).isEqualTo(100);
+  }
 
-    @Test
-    void includesAGaugeForDirectMemoryUsed() throws Exception {
-        final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(DIRECT_USED);
+  @Test
+  void includesAGaugeForDirectMemoryUsed() throws Exception {
+    final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(DIRECT_USED);
 
-        when(mBeanServer.getAttribute(direct, "MemoryUsed")).thenReturn(100);
+    when(mBeanServer.getAttribute(direct, "MemoryUsed")).thenReturn(100);
 
-        assertThat(gauge.getValue())
-                .isEqualTo(100);
-    }
+    assertThat(gauge.getValue()).isEqualTo(100);
+  }
 
-    @Test
-    void includesAGaugeForDirectCapacity() throws Exception {
-        final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(DIRECT_CAPACITY);
+  @Test
+  void includesAGaugeForDirectCapacity() throws Exception {
+    final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(DIRECT_CAPACITY);
 
-        when(mBeanServer.getAttribute(direct, "TotalCapacity")).thenReturn(100);
+    when(mBeanServer.getAttribute(direct, "TotalCapacity")).thenReturn(100);
 
-        assertThat(gauge.getValue())
-                .isEqualTo(100);
-    }
+    assertThat(gauge.getValue()).isEqualTo(100);
+  }
 
-    @Test
-    void includesAGaugeForMappedCount() throws Exception {
-        final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(MAPPED_COUNT);
+  @Test
+  void includesAGaugeForMappedCount() throws Exception {
+    final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(MAPPED_COUNT);
 
-        when(mBeanServer.getAttribute(mapped, "Count")).thenReturn(100);
+    when(mBeanServer.getAttribute(mapped, "Count")).thenReturn(100);
 
-        assertThat(gauge.getValue())
-                .isEqualTo(100);
-    }
+    assertThat(gauge.getValue()).isEqualTo(100);
+  }
 
-    @Test
-    void includesAGaugeForMappedMemoryUsed() throws Exception {
-        final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(MAPPED_USED);
+  @Test
+  void includesAGaugeForMappedMemoryUsed() throws Exception {
+    final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(MAPPED_USED);
 
-        when(mBeanServer.getAttribute(mapped, "MemoryUsed")).thenReturn(100);
+    when(mBeanServer.getAttribute(mapped, "MemoryUsed")).thenReturn(100);
 
-        assertThat(gauge.getValue())
-                .isEqualTo(100);
-    }
+    assertThat(gauge.getValue()).isEqualTo(100);
+  }
 
-    @Test
-    void includesAGaugeForMappedCapacity() throws Exception {
-        final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(MAPPED_CAPACITY);
+  @Test
+  void includesAGaugeForMappedCapacity() throws Exception {
+    final Gauge<Integer> gauge = (Gauge<Integer>) buffers.getMetrics().get(MAPPED_CAPACITY);
 
-        when(mBeanServer.getAttribute(mapped, "TotalCapacity")).thenReturn(100);
+    when(mBeanServer.getAttribute(mapped, "TotalCapacity")).thenReturn(100);
 
-        assertThat(gauge.getValue())
-                .isEqualTo(100);
-    }
+    assertThat(gauge.getValue()).isEqualTo(100);
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/ClassLoadingGaugeSetTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/ClassLoadingGaugeSetTest.java
@@ -1,38 +1,36 @@
 package io.dropwizard.metrics5.jvm;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.MetricName;
+import java.lang.management.ClassLoadingMXBean;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.lang.management.ClassLoadingMXBean;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @SuppressWarnings("rawtypes")
-class ClassLoadingGaugeSetTest {
-
-    private final ClassLoadingMXBean cl = mock(ClassLoadingMXBean.class);
-    private final ClassLoadingGaugeSet gauges = new ClassLoadingGaugeSet(cl);
-
-    @BeforeEach
-    void setUp() {
-        when(cl.getTotalLoadedClassCount()).thenReturn(2L);
-        when(cl.getUnloadedClassCount()).thenReturn(1L);
-    }
-
-    @Test
-    void loadedGauge() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(MetricName.build("loaded"));
-        assertThat(gauge.getValue()).isEqualTo(2L);
-    }
-
-    @Test
-    void unLoadedGauge() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(MetricName.build("unloaded"));
-        assertThat(gauge.getValue()).isEqualTo(1L);
-    }
-
+final class ClassLoadingGaugeSetTest {
+
+  private final ClassLoadingMXBean cl = mock();
+  private final ClassLoadingGaugeSet gauges = new ClassLoadingGaugeSet(cl);
+
+  @BeforeEach
+  void setUp() {
+    when(cl.getTotalLoadedClassCount()).thenReturn(2L);
+    when(cl.getUnloadedClassCount()).thenReturn(1L);
+  }
+
+  @Test
+  void loadedGauge() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(MetricName.build("loaded"));
+    assertThat(gauge.getValue()).isEqualTo(2L);
+  }
+
+  @Test
+  void unLoadedGauge() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(MetricName.build("unloaded"));
+    assertThat(gauge.getValue()).isEqualTo(1L);
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/CpuTimeClockTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/CpuTimeClockTest.java
@@ -1,24 +1,23 @@
 package io.dropwizard.metrics5.jvm;
 
-import org.junit.jupiter.api.Test;
-
-import java.lang.management.ManagementFactory;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.offset;
 
-class CpuTimeClockTest {
+import java.lang.management.ManagementFactory;
+import org.junit.jupiter.api.Test;
+
+final class CpuTimeClockTest {
 
-    @Test
-    void cpuTimeClock() {
-        final CpuTimeClock clock = new CpuTimeClock();
+  @Test
+  void cpuTimeClock() {
+    final CpuTimeClock clock = new CpuTimeClock();
 
-        final long clockTime = clock.getTime();
-        final long systemTime = System.currentTimeMillis();
-        assertThat((double) clockTime).isEqualTo(systemTime, offset(200.0));
+    final long clockTime = clock.getTime();
+    final long systemTime = System.currentTimeMillis();
+    assertThat((double) clockTime).isCloseTo(systemTime, offset(200.0));
 
-        final long clockTick = clock.getTick();
-        final long systemTick = ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();
-        assertThat((double) clockTick).isEqualTo(systemTick, offset(1000000.0));
-    }
-}
\ No newline at end of file
+    final long clockTick = clock.getTick();
+    final long systemTick = ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();
+    assertThat((double) clockTick).isCloseTo(systemTick, offset(1000000.0));
+  }
+}
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/FileDescriptorRatioGaugeTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/FileDescriptorRatioGaugeTest.java
@@ -1,48 +1,43 @@
 package io.dropwizard.metrics5.jvm;
 
-import com.sun.management.UnixOperatingSystemMXBean;
-import org.assertj.core.api.Assertions;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import java.lang.management.ManagementFactory;
-import java.lang.management.OperatingSystemMXBean;
-
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import com.sun.management.UnixOperatingSystemMXBean;
+import java.lang.management.ManagementFactory;
+import java.lang.management.OperatingSystemMXBean;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
 @SuppressWarnings("UnusedDeclaration")
-class FileDescriptorRatioGaugeTest {
-    private final UnixOperatingSystemMXBean os = mock(UnixOperatingSystemMXBean.class);
-
-    private final FileDescriptorRatioGauge gauge = new FileDescriptorRatioGauge(os);
-
-    @BeforeEach
-    void setUp() throws Exception {
-        when(os.getOpenFileDescriptorCount()).thenReturn(10L);
-        when(os.getMaxFileDescriptorCount()).thenReturn(100L);
-    }
-
-    @Test
-    void calculatesTheRatioOfUsedToTotalFileDescriptors() {
-        Assertions.assertThat(gauge.getValue())
-                .isEqualTo(0.1);
-    }
-
-    @Test
-    void validateFileDescriptorRatioPresenceOnNixPlatforms() {
-        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
-        assumeTrue(osBean instanceof com.sun.management.UnixOperatingSystemMXBean);
-
-        Assertions.assertThat(new FileDescriptorRatioGauge().getValue())
-                .isGreaterThanOrEqualTo(0.0)
-                .isLessThanOrEqualTo(1.0);
-    }
-
-    @Test
-    void returnsNaNWhenTheInformationIsUnavailable() {
-        Assertions.assertThat(new FileDescriptorRatioGauge(mock(OperatingSystemMXBean.class)).getValue())
-                .isNaN();
-    }
+final class FileDescriptorRatioGaugeTest {
+  private final UnixOperatingSystemMXBean os = mock();
+
+  private final FileDescriptorRatioGauge gauge = new FileDescriptorRatioGauge(os);
+
+  @BeforeEach
+  void setUp() throws Exception {
+    when(os.getOpenFileDescriptorCount()).thenReturn(10L);
+    when(os.getMaxFileDescriptorCount()).thenReturn(100L);
+  }
+
+  @Test
+  void calculatesTheRatioOfUsedToTotalFileDescriptors() {
+    assertThat(gauge.getValue()).isEqualTo(0.1);
+  }
+
+  @Test
+  void validateFileDescriptorRatioPresenceOnNixPlatforms() {
+    OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
+    assumeTrue(osBean instanceof com.sun.management.UnixOperatingSystemMXBean);
+
+    assertThat(new FileDescriptorRatioGauge().getValue()).isNotNegative().isLessThanOrEqualTo(1.0);
+  }
+
+  @Test
+  void returnsNaNWhenTheInformationIsUnavailable() {
+    assertThat(new FileDescriptorRatioGauge(mock(OperatingSystemMXBean.class)).getValue()).isNaN();
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/GarbageCollectorMetricSetTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/GarbageCollectorMetricSetTest.java
@@ -1,55 +1,51 @@
 package io.dropwizard.metrics5.jvm;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.ImmutableList;
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.MetricName;
+import java.lang.management.GarbageCollectorMXBean;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.lang.management.GarbageCollectorMXBean;
-import java.util.Collections;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @SuppressWarnings("unchecked")
-class GarbageCollectorMetricSetTest {
-    private final GarbageCollectorMXBean gc = mock(GarbageCollectorMXBean.class);
-    private final GarbageCollectorMetricSet metrics = new GarbageCollectorMetricSet(Collections.singletonList(gc));
-
-    private static final MetricName PS_OLDGEN_TIME = MetricName.build("PS-OldGen.time");
-    private static final MetricName PS_OLDGEN_COUNT = MetricName.build("PS-OldGen.count");
-
-    @BeforeEach
-    void setUp() {
-        when(gc.getName()).thenReturn("PS OldGen");
-        when(gc.getCollectionCount()).thenReturn(1L);
-        when(gc.getCollectionTime()).thenReturn(2L);
-    }
-
-    @Test
-    void hasGaugesForGcCountsAndElapsedTimes() {
-        assertThat(metrics.getMetrics().keySet())
-                .containsOnly(PS_OLDGEN_TIME, PS_OLDGEN_COUNT);
-    }
-
-    @Test
-    void hasAGaugeForGcCounts() {
-        final Gauge<Long> gauge = (Gauge<Long>) metrics.getMetrics().get(PS_OLDGEN_COUNT);
-        assertThat(gauge.getValue())
-                .isEqualTo(1L);
-    }
-
-    @Test
-    void hasAGaugeForGcTimes() {
-        final Gauge<Long> gauge = (Gauge<Long>) metrics.getMetrics().get(PS_OLDGEN_TIME);
-        assertThat(gauge.getValue())
-                .isEqualTo(2L);
-    }
-
-    @Test
-    void autoDiscoversGCs() {
-        assertThat(new GarbageCollectorMetricSet().getMetrics().keySet())
-                .isNotEmpty();
-    }
+final class GarbageCollectorMetricSetTest {
+  private final GarbageCollectorMXBean gc = mock();
+  private final GarbageCollectorMetricSet metrics =
+      new GarbageCollectorMetricSet(ImmutableList.of(gc));
+
+  private static final MetricName PS_OLDGEN_TIME = MetricName.build("PS-OldGen.time");
+  private static final MetricName PS_OLDGEN_COUNT = MetricName.build("PS-OldGen.count");
+
+  @BeforeEach
+  void setUp() {
+    when(gc.getName()).thenReturn("PS OldGen");
+    when(gc.getCollectionCount()).thenReturn(1L);
+    when(gc.getCollectionTime()).thenReturn(2L);
+  }
+
+  @Test
+  void hasGaugesForGcCountsAndElapsedTimes() {
+    assertThat(metrics.getMetrics().keySet()).containsOnly(PS_OLDGEN_TIME, PS_OLDGEN_COUNT);
+  }
+
+  @Test
+  void hasAGaugeForGcCounts() {
+    final Gauge<Long> gauge = (Gauge<Long>) metrics.getMetrics().get(PS_OLDGEN_COUNT);
+    assertThat(gauge.getValue()).isEqualTo(1L);
+  }
+
+  @Test
+  void hasAGaugeForGcTimes() {
+    final Gauge<Long> gauge = (Gauge<Long>) metrics.getMetrics().get(PS_OLDGEN_TIME);
+    assertThat(gauge.getValue()).isEqualTo(2L);
+  }
+
+  @Test
+  void autoDiscoversGCs() {
+    assertThat(new GarbageCollectorMetricSet().getMetrics()).isNotEmpty();
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/JmxAttributeGaugeTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/JmxAttributeGaugeTest.java
@@ -5,95 +5,92 @@ import static org.assertj.core.api.Assertions.assertThat;
 import java.lang.management.ManagementFactory;
 import java.util.ArrayList;
 import java.util.List;
-
 import javax.management.JMException;
 import javax.management.MBeanServer;
 import javax.management.ObjectInstance;
 import javax.management.ObjectName;
-
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
 
-class JmxAttributeGaugeTest {
-
-    private static MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
-
-    private static List<ObjectName> registeredMBeans = new ArrayList<>();
-
-    public interface JmxTestMBean {
-        Long getValue();
-    }
-
-    private static class JmxTest implements JmxTestMBean {
-        @Override
-        public Long getValue() {
-            return Long.MAX_VALUE;
-        }
-    }
-
-    @BeforeAll
-    static void setUp() throws Exception {
-        registerMBean(new ObjectName("JmxAttributeGaugeTest:type=test,name=test1"));
-        registerMBean(new ObjectName("JmxAttributeGaugeTest:type=test,name=test2"));
-    }
-
-    @AfterAll
-    static void tearDown() {
-        for (ObjectName objectName : registeredMBeans) {
-            try {
-                mBeanServer.unregisterMBean(objectName);
-            } catch (Exception e) {
-                // ignore
-            }
-        }
-    }
-
-    @Test
-    void returnsJmxAttribute() throws Exception {
-        ObjectName objectName = new ObjectName("java.lang:type=ClassLoading");
-        JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "LoadedClassCount");
-
-        assertThat(gauge.getValue()).isInstanceOf(Integer.class);
-        assertThat((Integer) gauge.getValue()).isGreaterThan(0);
-    }
-
-    @Test
-    void returnsNullIfAttributeDoesNotExist() throws Exception {
-        ObjectName objectName = new ObjectName("java.lang:type=ClassLoading");
-        JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "DoesNotExist");
-
-        assertThat(gauge.getValue()).isNull();
-    }
-
-    @Test
-    void returnsNullIfMBeanNotFound() throws Exception {
-        ObjectName objectName = new ObjectName("foo.bar:type=NoSuchMBean");
-        JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "LoadedClassCount");
-
-        assertThat(gauge.getValue()).isNull();
-    }
+final class JmxAttributeGaugeTest {
 
-    @Test
-    void returnsAttributeForObjectNamePattern() throws Exception {
-        ObjectName objectName = new ObjectName("JmxAttributeGaugeTest:name=test1,*");
-        JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "Value");
+  private static MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
 
-        assertThat(gauge.getValue()).isInstanceOf(Long.class);
-        assertThat((Long) gauge.getValue()).isEqualTo(Long.MAX_VALUE);
-    }
+  private static List<ObjectName> registeredMBeans = new ArrayList<>();
 
-    @Test
-    void returnsNullIfObjectNamePatternAmbiguous() throws Exception {
-        ObjectName objectName = new ObjectName("JmxAttributeGaugeTest:type=test,*");
-        JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "Value");
+  public interface JmxTestMBean {
+    Long getValue();
+  }
 
-        assertThat(gauge.getValue()).isNull();
+  private static class JmxTest implements JmxTestMBean {
+    @Override
+    public Long getValue() {
+      return Long.MAX_VALUE;
     }
-
-    private static void registerMBean(ObjectName objectName) throws JMException {
-        ObjectInstance objectInstance = mBeanServer.registerMBean(new JmxTest(), objectName);
-        registeredMBeans.add(objectInstance.getObjectName());
+  }
+
+  @BeforeAll
+  static void setUp() throws Exception {
+    registerMBean(new ObjectName("JmxAttributeGaugeTest:type=test,name=test1"));
+    registerMBean(new ObjectName("JmxAttributeGaugeTest:type=test,name=test2"));
+  }
+
+  @AfterAll
+  static void tearDown() {
+    for (ObjectName objectName : registeredMBeans) {
+      try {
+        mBeanServer.unregisterMBean(objectName);
+      } catch (Exception e) {
+        // ignore
+      }
     }
-
+  }
+
+  @Test
+  void returnsJmxAttribute() throws Exception {
+    ObjectName objectName = new ObjectName("java.lang:type=ClassLoading");
+    JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "LoadedClassCount");
+
+    assertThat(gauge.getValue()).isInstanceOf(Integer.class);
+    assertThat((Integer) gauge.getValue()).isPositive();
+  }
+
+  @Test
+  void returnsNullIfAttributeDoesNotExist() throws Exception {
+    ObjectName objectName = new ObjectName("java.lang:type=ClassLoading");
+    JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "DoesNotExist");
+
+    assertThat(gauge.getValue()).isNull();
+  }
+
+  @Test
+  void returnsNullIfMBeanNotFound() throws Exception {
+    ObjectName objectName = new ObjectName("foo.bar:type=NoSuchMBean");
+    JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "LoadedClassCount");
+
+    assertThat(gauge.getValue()).isNull();
+  }
+
+  @Test
+  void returnsAttributeForObjectNamePattern() throws Exception {
+    ObjectName objectName = new ObjectName("JmxAttributeGaugeTest:name=test1,*");
+    JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "Value");
+
+    assertThat(gauge.getValue()).isInstanceOf(Long.class);
+    assertThat((Long) gauge.getValue()).isEqualTo(Long.MAX_VALUE);
+  }
+
+  @Test
+  void returnsNullIfObjectNamePatternAmbiguous() throws Exception {
+    ObjectName objectName = new ObjectName("JmxAttributeGaugeTest:type=test,*");
+    JmxAttributeGauge gauge = new JmxAttributeGauge(mBeanServer, objectName, "Value");
+
+    assertThat(gauge.getValue()).isNull();
+  }
+
+  private static void registerMBean(ObjectName objectName) throws JMException {
+    ObjectInstance objectInstance = mBeanServer.registerMBean(new JmxTest(), objectName);
+    registeredMBeans.add(objectInstance.getObjectName());
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/JvmAttributeGaugeSetTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/JvmAttributeGaugeSetTest.java
@@ -1,68 +1,65 @@
 package io.dropwizard.metrics5.jvm;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.MetricName;
+import java.lang.management.RuntimeMXBean;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.lang.management.RuntimeMXBean;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
 @SuppressWarnings("unchecked")
-class JvmAttributeGaugeSetTest {
-    private final RuntimeMXBean runtime = mock(RuntimeMXBean.class);
-    private final JvmAttributeGaugeSet gauges = new JvmAttributeGaugeSet(runtime);
+final class JvmAttributeGaugeSetTest {
+  private final RuntimeMXBean runtime = mock();
+  private final JvmAttributeGaugeSet gauges = new JvmAttributeGaugeSet(runtime);
 
-    @BeforeEach
-    void setUp() {
-        when(runtime.getName()).thenReturn("9928@example.com");
+  @BeforeEach
+  void setUp() {
+    when(runtime.getName()).thenReturn("9928@example.com");
 
-        when(runtime.getVmVendor()).thenReturn("Oracle Corporation");
-        when(runtime.getVmName()).thenReturn("Java HotSpot(TM) 64-Bit Server VM");
-        when(runtime.getVmVersion()).thenReturn("23.7-b01");
-        when(runtime.getSpecVersion()).thenReturn("1.7");
-        when(runtime.getUptime()).thenReturn(100L);
-    }
+    when(runtime.getVmVendor()).thenReturn("Oracle Corporation");
+    when(runtime.getVmName()).thenReturn("Java HotSpot(TM) 64-Bit Server VM");
+    when(runtime.getVmVersion()).thenReturn("23.7-b01");
+    when(runtime.getSpecVersion()).thenReturn("1.7");
+    when(runtime.getUptime()).thenReturn(100L);
+  }
 
-    @Test
-    void hasASetOfGauges() {
-        assertThat(gauges.getMetrics().keySet())
-                .containsOnly(MetricName.build("vendor"),
-                        MetricName.build("name"),
-                        MetricName.build("uptime"));
-    }
+  @Test
+  void hasASetOfGauges() {
+    assertThat(gauges.getMetrics().keySet())
+        .containsOnly(
+            MetricName.build("vendor"), MetricName.build("name"), MetricName.build("uptime"));
+  }
 
-    @Test
-    void hasAGaugeForTheJVMName() {
-        final Gauge<String> gauge = (Gauge<String>) gauges.getMetrics().get(MetricName.build("name"));
+  @Test
+  void hasAGaugeForTheJVMName() {
+    final Gauge<String> gauge = (Gauge<String>) gauges.getMetrics().get(MetricName.build("name"));
 
-        assertThat(gauge.getValue())
-                .isEqualTo("9928@example.com");
-    }
+    assertThat(gauge.getValue()).isEqualTo("9928@example.com");
+  }
 
-    @Test
-    void hasAGaugeForTheJVMVendor() {
-        final Gauge<String> gauge = (Gauge<String>) gauges.getMetrics().get(MetricName.build("vendor"));
+  @Test
+  void hasAGaugeForTheJVMVendor() {
+    final Gauge<String> gauge = (Gauge<String>) gauges.getMetrics().get(MetricName.build("vendor"));
 
-        assertThat(gauge.getValue())
-                .isEqualTo("Oracle Corporation Java HotSpot(TM) 64-Bit Server VM 23.7-b01 (1.7)");
-    }
+    assertThat(gauge.getValue())
+        .isEqualTo("Oracle Corporation Java HotSpot(TM) 64-Bit Server VM 23.7-b01 (1.7)");
+  }
 
-    @Test
-    void hasAGaugeForTheJVMUptime() {
-        final Gauge<Long> gauge = (Gauge<Long>) gauges.getMetrics().get(MetricName.build("uptime"));
+  @Test
+  void hasAGaugeForTheJVMUptime() {
+    final Gauge<Long> gauge = (Gauge<Long>) gauges.getMetrics().get(MetricName.build("uptime"));
 
-        assertThat(gauge.getValue())
-                .isEqualTo(100L);
-    }
+    assertThat(gauge.getValue()).isEqualTo(100L);
+  }
 
-    @Test
-    void autoDiscoversTheRuntimeBean() {
-        final Gauge<Long> gauge = (Gauge<Long>) new JvmAttributeGaugeSet().getMetrics().get(MetricName.build("uptime"));
+  @Test
+  void autoDiscoversTheRuntimeBean() {
+    final Gauge<Long> gauge =
+        (Gauge<Long>) new JvmAttributeGaugeSet().getMetrics().get(MetricName.build("uptime"));
 
-        assertThat(gauge.getValue()).isPositive();
-    }
+    assertThat(gauge.getValue()).isPositive();
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/MemoryUsageGaugeSetTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/MemoryUsageGaugeSetTest.java
@@ -1,325 +1,301 @@
 package io.dropwizard.metrics5.jvm;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.MetricName;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
 import java.lang.management.MemoryMXBean;
 import java.lang.management.MemoryPoolMXBean;
 import java.lang.management.MemoryUsage;
 import java.util.Arrays;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("rawtypes")
-class MemoryUsageGaugeSetTest {
-    private final MemoryUsage heap = mock(MemoryUsage.class);
-    private final MemoryUsage nonHeap = mock(MemoryUsage.class);
-    private final MemoryUsage pool = mock(MemoryUsage.class);
-    private final MemoryUsage weirdPool = mock(MemoryUsage.class);
-    private final MemoryUsage weirdCollection = mock(MemoryUsage.class);
-    private final MemoryMXBean mxBean = mock(MemoryMXBean.class);
-    private final MemoryPoolMXBean memoryPool = mock(MemoryPoolMXBean.class);
-    private final MemoryPoolMXBean weirdMemoryPool = mock(MemoryPoolMXBean.class);
-
-    private final MemoryUsageGaugeSet gauges = new MemoryUsageGaugeSet(mxBean,
-            Arrays.asList(memoryPool,
-                    weirdMemoryPool));
-
-    private static final MetricName TOTAL = MetricName.build("total");
-    private static final MetricName HEAP = MetricName.build("heap");
-    private static final MetricName NON_HEAP = MetricName.build("non-heap");
-    private static final MetricName POOLS = MetricName.build("pools");
-
-    private static final MetricName TOTAL_MAX = TOTAL.resolve("max");
-    private static final MetricName TOTAL_INIT = TOTAL.resolve("init");
-    private static final MetricName TOTAL_USED = TOTAL.resolve("used");
-    private static final MetricName TOTAL_COMMITTED = TOTAL.resolve("committed");
-    private static final MetricName POOLS_BIG_POOL_USAGE = POOLS.resolve("Big-Pool.usage");
-    private static final MetricName POOLS_BIG_POOL_USED = POOLS.resolve("Big-Pool.used");
-    private static final MetricName POOLS_BIG_POOL_INIT = POOLS.resolve("Big-Pool.init");
-    private static final MetricName POOLS_BIG_POOL_COMMITED = POOLS.resolve("Big-Pool.committed");
-    private static final MetricName POOLS_BIG_POOL_MAX = POOLS.resolve("Big-Pool.max");
-    private static final MetricName POOLS_WEIRD_POOL_USAGE = POOLS.resolve("Weird-Pool.usage");
-    private static final MetricName POOLS_WEIRD_POOL_INIT = POOLS.resolve("Weird-Pool.init");
-    private static final MetricName POOLS_WEIRD_POOL_MAX = POOLS.resolve("Weird-Pool.max");
-    private static final MetricName POOLS_WEIRD_POOL_USED = POOLS.resolve("Weird-Pool.used");
-    private static final MetricName POOLS_WEIRD_POOL_USED_AFTER_GC = POOLS.resolve("Weird-Pool.used-after-gc");
-    private static final MetricName POOLS_WEIRD_POOL_COMMITTED = POOLS.resolve("Weird-Pool.committed");
-    private static final MetricName HEAP_INIT = HEAP.resolve("init");
-    private static final MetricName HEAP_COMMITTED = HEAP.resolve("committed");
-    private static final MetricName HEAP_USAGE = HEAP.resolve("usage");
-    private static final MetricName HEAP_USED = HEAP.resolve("used");
-    private static final MetricName HEAP_MAX = HEAP.resolve("max");
-    private static final MetricName NON_HEAP_USAGE = NON_HEAP.resolve("usage");
-    private static final MetricName NON_HEAP_MAX = NON_HEAP.resolve("max");
-    private static final MetricName NON_HEAP_USED = NON_HEAP.resolve("used");
-    private static final MetricName NON_HEAP_INIT = NON_HEAP.resolve("init");
-    private static final MetricName NON_HEAP_COMMITTED = NON_HEAP.resolve("committed");
-
-    @BeforeEach
-    void setUp() {
-        when(heap.getCommitted()).thenReturn(10L);
-        when(heap.getInit()).thenReturn(20L);
-        when(heap.getUsed()).thenReturn(30L);
-        when(heap.getMax()).thenReturn(40L);
-
-        when(nonHeap.getCommitted()).thenReturn(1L);
-        when(nonHeap.getInit()).thenReturn(2L);
-        when(nonHeap.getUsed()).thenReturn(3L);
-        when(nonHeap.getMax()).thenReturn(4L);
-
-        when(pool.getCommitted()).thenReturn(100L);
-        when(pool.getInit()).thenReturn(200L);
-        when(pool.getUsed()).thenReturn(300L);
-        when(pool.getMax()).thenReturn(400L);
-
-        when(weirdPool.getCommitted()).thenReturn(100L);
-        when(weirdPool.getInit()).thenReturn(200L);
-        when(weirdPool.getUsed()).thenReturn(300L);
-        when(weirdPool.getMax()).thenReturn(-1L);
-
-        when(weirdCollection.getUsed()).thenReturn(290L);
-
-        when(mxBean.getHeapMemoryUsage()).thenReturn(heap);
-        when(mxBean.getNonHeapMemoryUsage()).thenReturn(nonHeap);
-
-        when(memoryPool.getUsage()).thenReturn(pool);
-        // Mock that "Big Pool" is a non-collected pool therefore doesn't
-        // have collection usage statistics.
-        when(memoryPool.getCollectionUsage()).thenReturn(null);
-        when(memoryPool.getName()).thenReturn("Big Pool");
-
-        when(weirdMemoryPool.getUsage()).thenReturn(weirdPool);
-        when(weirdMemoryPool.getCollectionUsage()).thenReturn(weirdCollection);
-        when(weirdMemoryPool.getName()).thenReturn("Weird Pool");
-    }
-
-    @Test
-    void hasASetOfGauges() {
-        assertThat(gauges.getMetrics().keySet())
-                .containsOnly(
-                        TOTAL_MAX,
-                        TOTAL_INIT,
-                        TOTAL_USED,
-                        TOTAL_COMMITTED,
-                        HEAP_INIT,
-                        HEAP_COMMITTED,
-                        HEAP_USAGE,
-                        HEAP_USED,
-                        HEAP_MAX,
-                        NON_HEAP_USAGE,
-                        NON_HEAP_MAX,
-                        NON_HEAP_USED,
-                        NON_HEAP_INIT,
-                        NON_HEAP_COMMITTED,
-                        POOLS_BIG_POOL_INIT,
-                        POOLS_BIG_POOL_COMMITED,
-                        POOLS_BIG_POOL_USED,
-                        POOLS_BIG_POOL_USAGE,
-                        POOLS_BIG_POOL_MAX,
-                        // skip in non-collected pools - "pools.Big-Pool.used-after-gc",
-                        POOLS_WEIRD_POOL_USAGE,
-                        POOLS_WEIRD_POOL_USED,
-                        POOLS_WEIRD_POOL_INIT,
-                        POOLS_WEIRD_POOL_MAX,
-                        POOLS_WEIRD_POOL_COMMITTED,
-                        POOLS_WEIRD_POOL_USED_AFTER_GC);
-    }
-
-    @Test
-    void hasAGaugeForTotalCommitted() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_COMMITTED);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(11L);
-    }
-
-    @Test
-    void hasAGaugeForTotalInit() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_INIT);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(22L);
-    }
-
-    @Test
-    void hasAGaugeForTotalUsed() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_USED);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(33L);
-    }
-
-    @Test
-    void hasAGaugeForTotalMax() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_MAX);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(44L);
-    }
-
-    @Test
-    public void hasAGaugeForTotalMaxWhenNonHeapMaxUndefined() {
-        when(nonHeap.getMax()).thenReturn(-1L);
-
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_MAX);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(-1L);
-    }
-
-    @Test
-    void hasAGaugeForHeapCommitted() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_COMMITTED);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(10L);
-    }
-
-    @Test
-    void hasAGaugeForHeapInit() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_INIT);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(20L);
-    }
-
-    @Test
-    void hasAGaugeForHeapUsed() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_USED);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(30L);
-    }
-
-    @Test
-    void hasAGaugeForHeapMax() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_MAX);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(40L);
-    }
-
-    @Test
-    void hasAGaugeForHeapUsage() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_USAGE);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(0.75);
-    }
-
-    @Test
-    void hasAGaugeForNonHeapCommitted() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_COMMITTED);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(1L);
-    }
-
-    @Test
-    void hasAGaugeForNonHeapInit() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_INIT);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(2L);
-    }
+final class MemoryUsageGaugeSetTest {
+  private final MemoryUsage heap = mock();
+  private final MemoryUsage nonHeap = mock();
+  private final MemoryUsage pool = mock();
+  private final MemoryUsage weirdPool = mock();
+  private final MemoryUsage weirdCollection = mock();
+  private final MemoryMXBean mxBean = mock();
+  private final MemoryPoolMXBean memoryPool = mock();
+  private final MemoryPoolMXBean weirdMemoryPool = mock();
+
+  private final MemoryUsageGaugeSet gauges =
+      new MemoryUsageGaugeSet(mxBean, Arrays.asList(memoryPool, weirdMemoryPool));
+
+  private static final MetricName TOTAL = MetricName.build("total");
+  private static final MetricName HEAP = MetricName.build("heap");
+  private static final MetricName NON_HEAP = MetricName.build("non-heap");
+  private static final MetricName POOLS = MetricName.build("pools");
+
+  private static final MetricName TOTAL_MAX = TOTAL.resolve("max");
+  private static final MetricName TOTAL_INIT = TOTAL.resolve("init");
+  private static final MetricName TOTAL_USED = TOTAL.resolve("used");
+  private static final MetricName TOTAL_COMMITTED = TOTAL.resolve("committed");
+  private static final MetricName POOLS_BIG_POOL_USAGE = POOLS.resolve("Big-Pool.usage");
+  private static final MetricName POOLS_BIG_POOL_USED = POOLS.resolve("Big-Pool.used");
+  private static final MetricName POOLS_BIG_POOL_INIT = POOLS.resolve("Big-Pool.init");
+  private static final MetricName POOLS_BIG_POOL_COMMITED = POOLS.resolve("Big-Pool.committed");
+  private static final MetricName POOLS_BIG_POOL_MAX = POOLS.resolve("Big-Pool.max");
+  private static final MetricName POOLS_WEIRD_POOL_USAGE = POOLS.resolve("Weird-Pool.usage");
+  private static final MetricName POOLS_WEIRD_POOL_INIT = POOLS.resolve("Weird-Pool.init");
+  private static final MetricName POOLS_WEIRD_POOL_MAX = POOLS.resolve("Weird-Pool.max");
+  private static final MetricName POOLS_WEIRD_POOL_USED = POOLS.resolve("Weird-Pool.used");
+  private static final MetricName POOLS_WEIRD_POOL_USED_AFTER_GC =
+      POOLS.resolve("Weird-Pool.used-after-gc");
+  private static final MetricName POOLS_WEIRD_POOL_COMMITTED =
+      POOLS.resolve("Weird-Pool.committed");
+  private static final MetricName HEAP_INIT = HEAP.resolve("init");
+  private static final MetricName HEAP_COMMITTED = HEAP.resolve("committed");
+  private static final MetricName HEAP_USAGE = HEAP.resolve("usage");
+  private static final MetricName HEAP_USED = HEAP.resolve("used");
+  private static final MetricName HEAP_MAX = HEAP.resolve("max");
+  private static final MetricName NON_HEAP_USAGE = NON_HEAP.resolve("usage");
+  private static final MetricName NON_HEAP_MAX = NON_HEAP.resolve("max");
+  private static final MetricName NON_HEAP_USED = NON_HEAP.resolve("used");
+  private static final MetricName NON_HEAP_INIT = NON_HEAP.resolve("init");
+  private static final MetricName NON_HEAP_COMMITTED = NON_HEAP.resolve("committed");
+
+  @BeforeEach
+  void setUp() {
+    when(heap.getCommitted()).thenReturn(10L);
+    when(heap.getInit()).thenReturn(20L);
+    when(heap.getUsed()).thenReturn(30L);
+    when(heap.getMax()).thenReturn(40L);
+
+    when(nonHeap.getCommitted()).thenReturn(1L);
+    when(nonHeap.getInit()).thenReturn(2L);
+    when(nonHeap.getUsed()).thenReturn(3L);
+    when(nonHeap.getMax()).thenReturn(4L);
+
+    when(pool.getCommitted()).thenReturn(100L);
+    when(pool.getInit()).thenReturn(200L);
+    when(pool.getUsed()).thenReturn(300L);
+    when(pool.getMax()).thenReturn(400L);
+
+    when(weirdPool.getCommitted()).thenReturn(100L);
+    when(weirdPool.getInit()).thenReturn(200L);
+    when(weirdPool.getUsed()).thenReturn(300L);
+    when(weirdPool.getMax()).thenReturn(-1L);
+
+    when(weirdCollection.getUsed()).thenReturn(290L);
+
+    when(mxBean.getHeapMemoryUsage()).thenReturn(heap);
+    when(mxBean.getNonHeapMemoryUsage()).thenReturn(nonHeap);
+
+    when(memoryPool.getUsage()).thenReturn(pool);
+    // Mock that "Big Pool" is a non-collected pool therefore doesn't
+    // have collection usage statistics.
+    when(memoryPool.getCollectionUsage()).thenReturn(null);
+    when(memoryPool.getName()).thenReturn("Big Pool");
+
+    when(weirdMemoryPool.getUsage()).thenReturn(weirdPool);
+    when(weirdMemoryPool.getCollectionUsage()).thenReturn(weirdCollection);
+    when(weirdMemoryPool.getName()).thenReturn("Weird Pool");
+  }
+
+  @Test
+  void hasASetOfGauges() {
+    assertThat(gauges.getMetrics().keySet())
+        .containsOnly(
+            TOTAL_MAX,
+            TOTAL_INIT,
+            TOTAL_USED,
+            TOTAL_COMMITTED,
+            HEAP_INIT,
+            HEAP_COMMITTED,
+            HEAP_USAGE,
+            HEAP_USED,
+            HEAP_MAX,
+            NON_HEAP_USAGE,
+            NON_HEAP_MAX,
+            NON_HEAP_USED,
+            NON_HEAP_INIT,
+            NON_HEAP_COMMITTED,
+            POOLS_BIG_POOL_INIT,
+            POOLS_BIG_POOL_COMMITED,
+            POOLS_BIG_POOL_USED,
+            POOLS_BIG_POOL_USAGE,
+            POOLS_BIG_POOL_MAX,
+            // skip in non-collected pools - "pools.Big-Pool.used-after-gc",
+            POOLS_WEIRD_POOL_USAGE,
+            POOLS_WEIRD_POOL_USED,
+            POOLS_WEIRD_POOL_INIT,
+            POOLS_WEIRD_POOL_MAX,
+            POOLS_WEIRD_POOL_COMMITTED,
+            POOLS_WEIRD_POOL_USED_AFTER_GC);
+  }
+
+  @Test
+  void hasAGaugeForTotalCommitted() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_COMMITTED);
+
+    assertThat(gauge.getValue()).isEqualTo(11L);
+  }
+
+  @Test
+  void hasAGaugeForTotalInit() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_INIT);
+
+    assertThat(gauge.getValue()).isEqualTo(22L);
+  }
+
+  @Test
+  void hasAGaugeForTotalUsed() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_USED);
+
+    assertThat(gauge.getValue()).isEqualTo(33L);
+  }
+
+  @Test
+  void hasAGaugeForTotalMax() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_MAX);
+
+    assertThat(gauge.getValue()).isEqualTo(44L);
+  }
+
+  @Test
+  void hasAGaugeForTotalMaxWhenNonHeapMaxUndefined() {
+    when(nonHeap.getMax()).thenReturn(-1L);
+
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(TOTAL_MAX);
+
+    assertThat(gauge.getValue()).isEqualTo(-1L);
+  }
+
+  @Test
+  void hasAGaugeForHeapCommitted() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_COMMITTED);
+
+    assertThat(gauge.getValue()).isEqualTo(10L);
+  }
+
+  @Test
+  void hasAGaugeForHeapInit() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_INIT);
+
+    assertThat(gauge.getValue()).isEqualTo(20L);
+  }
+
+  @Test
+  void hasAGaugeForHeapUsed() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_USED);
+
+    assertThat(gauge.getValue()).isEqualTo(30L);
+  }
+
+  @Test
+  void hasAGaugeForHeapMax() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_MAX);
+
+    assertThat(gauge.getValue()).isEqualTo(40L);
+  }
+
+  @Test
+  void hasAGaugeForHeapUsage() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(HEAP_USAGE);
+
+    assertThat(gauge.getValue()).isEqualTo(0.75);
+  }
+
+  @Test
+  void hasAGaugeForNonHeapCommitted() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_COMMITTED);
+
+    assertThat(gauge.getValue()).isEqualTo(1L);
+  }
+
+  @Test
+  void hasAGaugeForNonHeapInit() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_INIT);
+
+    assertThat(gauge.getValue()).isEqualTo(2L);
+  }
+
+  @Test
+  void hasAGaugeForNonHeapUsed() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_USED);
+
+    assertThat(gauge.getValue()).isEqualTo(3L);
+  }
+
+  @Test
+  void hasAGaugeForNonHeapMax() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_MAX);
+
+    assertThat(gauge.getValue()).isEqualTo(4L);
+  }
+
+  @Test
+  void hasAGaugeForNonHeapUsage() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_USAGE);
+
+    assertThat(gauge.getValue()).isEqualTo(0.75);
+  }
+
+  @Test
+  void hasAGaugeForNonHeapUsageWhenNonHeapMaxUndefined() {
+    when(nonHeap.getMax()).thenReturn(-1L);
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_USAGE);
+
+    assertThat(gauge.getValue()).isEqualTo(3.0);
+  }
+
+  @Test
+  void hasAGaugeForMemoryPoolUsage() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_BIG_POOL_USAGE);
+
+    assertThat(gauge.getValue()).isEqualTo(0.75);
+  }
+
+  @Test
+  void hasAGaugeForWeirdMemoryPoolInit() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_INIT);
+
+    assertThat(gauge.getValue()).isEqualTo(200L);
+  }
+
+  @Test
+  void hasAGaugeForWeirdMemoryPoolCommitted() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_COMMITTED);
 
-    @Test
-    void hasAGaugeForNonHeapUsed() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_USED);
+    assertThat(gauge.getValue()).isEqualTo(100L);
+  }
 
-        assertThat(gauge.getValue())
-                .isEqualTo(3L);
-    }
+  @Test
+  void hasAGaugeForWeirdMemoryPoolUsed() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_USED);
 
-    @Test
-    void hasAGaugeForNonHeapMax() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_MAX);
+    assertThat(gauge.getValue()).isEqualTo(300L);
+  }
 
-        assertThat(gauge.getValue())
-                .isEqualTo(4L);
-    }
+  @Test
+  void hasAGaugeForWeirdMemoryPoolUsage() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_USAGE);
 
-    @Test
-    void hasAGaugeForNonHeapUsage() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_USAGE);
+    assertThat(gauge.getValue()).isEqualTo(3.0);
+  }
 
-        assertThat(gauge.getValue())
-                .isEqualTo(0.75);
-    }
+  @Test
+  void hasAGaugeForWeirdMemoryPoolMax() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_MAX);
 
-    @Test
-    public void hasAGaugeForNonHeapUsageWhenNonHeapMaxUndefined() {
-        when(nonHeap.getMax()).thenReturn(-1L);
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(NON_HEAP_USAGE);
+    assertThat(gauge.getValue()).isEqualTo(-1L);
+  }
 
-        assertThat(gauge.getValue())
-                .isEqualTo(3.0);
-    }
+  @Test
+  void hasAGaugeForWeirdCollectionPoolUsed() {
+    final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_USED_AFTER_GC);
 
-    @Test
-    void hasAGaugeForMemoryPoolUsage() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_BIG_POOL_USAGE);
+    assertThat(gauge.getValue()).isEqualTo(290L);
+  }
 
-        assertThat(gauge.getValue())
-                .isEqualTo(0.75);
-    }
-
-    @Test
-    void hasAGaugeForWeirdMemoryPoolInit() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_INIT);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(200L);
-    }
-
-    @Test
-    void hasAGaugeForWeirdMemoryPoolCommitted() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_COMMITTED);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(100L);
-    }
-
-    @Test
-    void hasAGaugeForWeirdMemoryPoolUsed() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_USED);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(300L);
-    }
-
-    @Test
-    void hasAGaugeForWeirdMemoryPoolUsage() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_USAGE);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(3.0);
-    }
-
-    @Test
-    void hasAGaugeForWeirdMemoryPoolMax() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_MAX);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(-1L);
-    }
-
-    @Test
-    void hasAGaugeForWeirdCollectionPoolUsed() {
-        final Gauge gauge = (Gauge) gauges.getMetrics().get(POOLS_WEIRD_POOL_USED_AFTER_GC);
-
-        assertThat(gauge.getValue())
-                .isEqualTo(290L);
-    }
-
-    @Test
-    void autoDetectsMemoryUsageBeanAndMemoryPools() {
-        assertThat(new MemoryUsageGaugeSet().getMetrics().keySet())
-                .isNotEmpty();
-    }
+  @Test
+  void autoDetectsMemoryUsageBeanAndMemoryPools() {
+    assertThat(new MemoryUsageGaugeSet().getMetrics()).isNotEmpty();
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/ThreadDeadlockDetectorTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/ThreadDeadlockDetectorTest.java
@@ -1,68 +1,71 @@
 package io.dropwizard.metrics5.jvm;
 
-import org.junit.jupiter.api.Test;
-
-import java.lang.management.ThreadInfo;
-import java.lang.management.ThreadMXBean;
-import java.util.Locale;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-class ThreadDeadlockDetectorTest {
-    private final ThreadMXBean threads = mock(ThreadMXBean.class);
-    private final ThreadDeadlockDetector detector = new ThreadDeadlockDetector(threads);
+import java.lang.management.ThreadInfo;
+import java.lang.management.ThreadMXBean;
+import java.util.Locale;
+import org.junit.jupiter.api.Test;
+
+final class ThreadDeadlockDetectorTest {
+  private final ThreadMXBean threads = mock();
+  private final ThreadDeadlockDetector detector = new ThreadDeadlockDetector(threads);
 
-    @Test
-    void returnsAnEmptySetIfNoThreadsAreDeadlocked() {
-        when(threads.findDeadlockedThreads()).thenReturn(null);
+  @Test
+  void returnsAnEmptySetIfNoThreadsAreDeadlocked() {
+    when(threads.findDeadlockedThreads()).thenReturn(null);
 
-        assertThat(detector.getDeadlockedThreads())
-                .isEmpty();
-    }
+    assertThat(detector.getDeadlockedThreads()).isEmpty();
+  }
 
-    @Test
-    void returnsASetOfThreadsIfAnyAreDeadlocked() {
-        final ThreadInfo thread1 = mock(ThreadInfo.class);
-        when(thread1.getThreadName()).thenReturn("thread1");
-        when(thread1.getLockName()).thenReturn("lock2");
-        when(thread1.getLockOwnerName()).thenReturn("thread2");
-        when(thread1.getStackTrace()).thenReturn(new StackTraceElement[]{
-                new StackTraceElement("Blah", "bloo", "Blah.java", 150),
-                new StackTraceElement("Blah", "blee", "Blah.java", 100)
-        });
+  @Test
+  void returnsASetOfThreadsIfAnyAreDeadlocked() {
+    final ThreadInfo thread1 = mock();
+    when(thread1.getThreadName()).thenReturn("thread1");
+    when(thread1.getLockName()).thenReturn("lock2");
+    when(thread1.getLockOwnerName()).thenReturn("thread2");
+    when(thread1.getStackTrace())
+        .thenReturn(
+            new StackTraceElement[] {
+              new StackTraceElement("Blah", "bloo", "Blah.java", 150),
+              new StackTraceElement("Blah", "blee", "Blah.java", 100)
+            });
 
-        final ThreadInfo thread2 = mock(ThreadInfo.class);
-        when(thread2.getThreadName()).thenReturn("thread2");
-        when(thread2.getLockName()).thenReturn("lock1");
-        when(thread2.getLockOwnerName()).thenReturn("thread1");
-        when(thread2.getStackTrace()).thenReturn(new StackTraceElement[]{
-                new StackTraceElement("Blah", "blee", "Blah.java", 100),
-                new StackTraceElement("Blah", "bloo", "Blah.java", 150)
-        });
+    final ThreadInfo thread2 = mock();
+    when(thread2.getThreadName()).thenReturn("thread2");
+    when(thread2.getLockName()).thenReturn("lock1");
+    when(thread2.getLockOwnerName()).thenReturn("thread1");
+    when(thread2.getStackTrace())
+        .thenReturn(
+            new StackTraceElement[] {
+              new StackTraceElement("Blah", "blee", "Blah.java", 100),
+              new StackTraceElement("Blah", "bloo", "Blah.java", 150)
+            });
 
-        final long[] ids = {1, 2};
-        when(threads.findDeadlockedThreads()).thenReturn(ids);
-        when(threads.getThreadInfo(eq(ids), anyInt()))
-                .thenReturn(new ThreadInfo[]{thread1, thread2});
+    final long[] ids = {1, 2};
+    when(threads.findDeadlockedThreads()).thenReturn(ids);
+    when(threads.getThreadInfo(eq(ids), anyInt())).thenReturn(new ThreadInfo[] {thread1, thread2});
 
-        assertThat(detector.getDeadlockedThreads())
-                .containsOnly(String.format(Locale.US,
-                                "thread1 locked on lock2 (owned by thread2):%n" +
-                                        "\t at Blah.bloo(Blah.java:150)%n" +
-                                        "\t at Blah.blee(Blah.java:100)%n"),
-                        String.format(Locale.US,
-                                "thread2 locked on lock1 (owned by thread1):%n" +
-                                        "\t at Blah.blee(Blah.java:100)%n" +
-                                        "\t at Blah.bloo(Blah.java:150)%n"));
-    }
+    assertThat(detector.getDeadlockedThreads())
+        .containsOnly(
+            String.format(
+                Locale.US,
+                "thread1 locked on lock2 (owned by thread2):%n"
+                    + "\t at Blah.bloo(Blah.java:150)%n"
+                    + "\t at Blah.blee(Blah.java:100)%n"),
+            String.format(
+                Locale.US,
+                "thread2 locked on lock1 (owned by thread1):%n"
+                    + "\t at Blah.blee(Blah.java:100)%n"
+                    + "\t at Blah.bloo(Blah.java:150)%n"));
+  }
 
-    @Test
-    void autoDiscoversTheThreadMXBean() {
-        assertThat(new ThreadDeadlockDetector().getDeadlockedThreads())
-                .isNotNull();
-    }
+  @Test
+  void autoDiscoversTheThreadMXBean() {
+    assertThat(new ThreadDeadlockDetector().getDeadlockedThreads()).isNotNull();
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/ThreadDumpTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/ThreadDumpTest.java
@@ -1,51 +1,50 @@
 package io.dropwizard.metrics5.jvm;
 
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import java.io.ByteArrayOutputStream;
 import java.lang.management.LockInfo;
 import java.lang.management.MonitorInfo;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 // TODO: 3/12/13 <coda> -- improve test coverage for ThreadDump
 
-class ThreadDumpTest {
-    private final ThreadMXBean threadMXBean = mock(ThreadMXBean.class);
-    private final ThreadDump threadDump = new ThreadDump(threadMXBean);
-
-    private final ThreadInfo runnable = mock(ThreadInfo.class);
-
-    @BeforeEach
-    void setUp() {
-        final StackTraceElement rLine1 = new StackTraceElement("Blah", "blee", "Blah.java", 100);
-
-        when(runnable.getThreadName()).thenReturn("runnable");
-        when(runnable.getThreadId()).thenReturn(100L);
-        when(runnable.getThreadState()).thenReturn(Thread.State.RUNNABLE);
-        when(runnable.getStackTrace()).thenReturn(new StackTraceElement[]{rLine1});
-        when(runnable.getLockedMonitors()).thenReturn(new MonitorInfo[]{});
-        when(runnable.getLockedSynchronizers()).thenReturn(new LockInfo[]{});
-
-        when(threadMXBean.dumpAllThreads(true, true)).thenReturn(new ThreadInfo[]{
-                runnable
-        });
-    }
-
-    @Test
-    void dumpsAllThreads() {
-        final ByteArrayOutputStream output = new ByteArrayOutputStream();
-        threadDump.dump(output);
-
-        assertThat(output.toString())
-                .isEqualTo(String.format("\"runnable\" id=100 state=RUNNABLE%n" +
-                        "    at Blah.blee(Blah.java:100)%n" +
-                        "%n" +
-                        "%n"));
-    }
+final class ThreadDumpTest {
+  private final ThreadMXBean threadMXBean = mock();
+  private final ThreadDump threadDump = new ThreadDump(threadMXBean);
+
+  private final ThreadInfo runnable = mock();
+
+  @BeforeEach
+  void setUp() {
+    final StackTraceElement rLine1 = new StackTraceElement("Blah", "blee", "Blah.java", 100);
+
+    when(runnable.getThreadName()).thenReturn("runnable");
+    when(runnable.getThreadId()).thenReturn(100L);
+    when(runnable.getThreadState()).thenReturn(Thread.State.RUNNABLE);
+    when(runnable.getStackTrace()).thenReturn(new StackTraceElement[] {rLine1});
+    when(runnable.getLockedMonitors()).thenReturn(new MonitorInfo[] {});
+    when(runnable.getLockedSynchronizers()).thenReturn(new LockInfo[] {});
+
+    when(threadMXBean.dumpAllThreads(true, true)).thenReturn(new ThreadInfo[] {runnable});
+  }
+
+  @Test
+  void dumpsAllThreads() {
+    final ByteArrayOutputStream output = new ByteArrayOutputStream();
+    threadDump.dump(output);
+
+    assertThat(output)
+        .hasToString(
+            String.format(
+                "\"runnable\" id=100 state=RUNNABLE%n"
+                    + "    at Blah.blee(Blah.java:100)%n"
+                    + "%n"
+                    + "%n"));
+  }
 }
--- a/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/ThreadStatesGaugeSetTest.java
+++ b/metrics-jvm/src/test/java/io/dropwizard/metrics5/jvm/ThreadStatesGaugeSetTest.java
@@ -1,151 +1,142 @@
 package io.dropwizard.metrics5.jvm;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.MetricName;
-import org.assertj.core.api.Assertions;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
 import java.util.HashSet;
 import java.util.Set;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-class ThreadStatesGaugeSetTest {
-    private final ThreadMXBean threads = mock(ThreadMXBean.class);
-    private final ThreadDeadlockDetector detector = mock(ThreadDeadlockDetector.class);
-    private final ThreadStatesGaugeSet gauges = new ThreadStatesGaugeSet(threads, detector);
-    private final long[] ids = new long[]{1, 2, 3};
-
-    private final ThreadInfo newThread = mock(ThreadInfo.class);
-    private final ThreadInfo runnableThread = mock(ThreadInfo.class);
-    private final ThreadInfo blockedThread = mock(ThreadInfo.class);
-    private final ThreadInfo waitingThread = mock(ThreadInfo.class);
-    private final ThreadInfo timedWaitingThread = mock(ThreadInfo.class);
-    private final ThreadInfo terminatedThread = mock(ThreadInfo.class);
-
-    private final Set<String> deadlocks = new HashSet<>();
-
-    private static final MetricName TERMINATED_COUNT = MetricName.build("terminated.count");
-    private static final MetricName NEW_COUNT = MetricName.build("new.count");
-    private static final MetricName COUNT = MetricName.build("count");
-    private static final MetricName TIMED_WAITING_COUNT = MetricName.build("timed_waiting.count");
-    private static final MetricName DEADLOCKS = MetricName.build("deadlocks");
-    private static final MetricName BLOCKED_COUNT = MetricName.build("blocked.count");
-    private static final MetricName WAITING_COUNT = MetricName.build("waiting.count");
-    private static final MetricName DAEMON_COUNT = MetricName.build("daemon.count");
-    private static final MetricName RUNNABLE_COUNT = MetricName.build("runnable.count");
-    private static final MetricName DEADLOCK_COUNT = MetricName.build("deadlock.count");
-
-    @BeforeEach
-    void setUp() {
-        deadlocks.add("yay");
-
-        when(newThread.getThreadState()).thenReturn(Thread.State.NEW);
-        when(runnableThread.getThreadState()).thenReturn(Thread.State.RUNNABLE);
-        when(blockedThread.getThreadState()).thenReturn(Thread.State.BLOCKED);
-        when(waitingThread.getThreadState()).thenReturn(Thread.State.WAITING);
-        when(timedWaitingThread.getThreadState()).thenReturn(Thread.State.TIMED_WAITING);
-        when(terminatedThread.getThreadState()).thenReturn(Thread.State.TERMINATED);
-
-        when(threads.getAllThreadIds()).thenReturn(ids);
-        when(threads.getThreadInfo(ids, 0)).thenReturn(new ThreadInfo[]{
-                newThread, runnableThread, blockedThread,
-                waitingThread, timedWaitingThread, terminatedThread
-        });
-
-        when(threads.getThreadCount()).thenReturn(12);
-        when(threads.getDaemonThreadCount()).thenReturn(10);
-        when(threads.getPeakThreadCount()).thenReturn(30);
-        when(threads.getTotalStartedThreadCount()).thenReturn(42L);
-
-        when(detector.getDeadlockedThreads()).thenReturn(deadlocks);
-    }
-
-    @Test
-    void hasASetOfGauges() {
-        assertThat(gauges.getMetrics().keySet())
-                .containsOnly(TERMINATED_COUNT,
-                        NEW_COUNT,
-                        COUNT,
-                        TIMED_WAITING_COUNT,
-                        DEADLOCKS,
-                        BLOCKED_COUNT,
-                        WAITING_COUNT,
-                        DAEMON_COUNT,
-                        RUNNABLE_COUNT,
-                        DEADLOCK_COUNT,
-                        MetricName.build("total_started.count"),
-                        MetricName.build("peak.count"));
-    }
-
-    @Test
-    void hasAGaugeForEachThreadState() {
-        Assertions.assertThat(((Gauge<?>) gauges.getMetrics().get(NEW_COUNT)).getValue())
-                .isEqualTo(1);
-
-        assertThat(((Gauge<?>) gauges.getMetrics().get(RUNNABLE_COUNT)).getValue())
-                .isEqualTo(1);
-
-        assertThat(((Gauge<?>) gauges.getMetrics().get(BLOCKED_COUNT)).getValue())
-                .isEqualTo(1);
-
-        assertThat(((Gauge<?>) gauges.getMetrics().get(WAITING_COUNT)).getValue())
-                .isEqualTo(1);
-
-        assertThat(((Gauge<?>) gauges.getMetrics().get(TIMED_WAITING_COUNT)).getValue())
-                .isEqualTo(1);
-
-        assertThat(((Gauge<?>) gauges.getMetrics().get(TERMINATED_COUNT)).getValue())
-                .isEqualTo(1);
-    }
-
-    @Test
-    void hasAGaugeForTheNumberOfThreads() {
-        assertThat(((Gauge<?>) gauges.getMetrics().get(COUNT)).getValue())
-                .isEqualTo(12);
-    }
-
-    @Test
-    void hasAGaugeForTheNumberOfDaemonThreads() {
-        assertThat(((Gauge<?>) gauges.getMetrics().get(DAEMON_COUNT)).getValue())
-                .isEqualTo(10);
-    }
-
-    @Test
-    void hasAGaugeForAnyDeadlocks() {
-        assertThat(((Gauge<?>) gauges.getMetrics().get(DEADLOCKS)).getValue())
-                .isEqualTo(deadlocks);
-    }
-
-    @Test
-    void hasAGaugeForAnyDeadlockCount() {
-        assertThat(((Gauge<?>) gauges.getMetrics().get(DEADLOCK_COUNT)).getValue())
-                .isEqualTo(1);
-    }
-
-    @Test
-    void hasAGaugeForPeakThreadCount() {
-        assertThat(((Gauge<?>) gauges.getMetrics().get(MetricName.build("peak.count"))).getValue())
-                .isEqualTo(30);
-    }
-
-    @Test
-    void hasAGaugeForTotalStartedThreadsCount() {
-        assertThat(((Gauge<?>) gauges.getMetrics().get(MetricName.build("total_started.count"))).getValue())
-                .isEqualTo(42L);
-    }
-
-    @Test
-    void autoDiscoversTheMXBeans() {
-        final ThreadStatesGaugeSet set = new ThreadStatesGaugeSet();
-        assertThat(((Gauge<?>) set.getMetrics().get(COUNT)).getValue())
-                .isNotNull();
-        assertThat(((Gauge<?>) set.getMetrics().get(DEADLOCKS)).getValue())
-                .isNotNull();
-    }
+final class ThreadStatesGaugeSetTest {
+  private final ThreadMXBean threads = mock();
+  private final ThreadDeadlockDetector detector = mock();
+  private final ThreadStatesGaugeSet gauges = new ThreadStatesGaugeSet(threads, detector);
+  private final long[] ids = new long[] {1, 2, 3};
+
+  private final ThreadInfo newThread = mock();
+  private final ThreadInfo runnableThread = mock();
+  private final ThreadInfo blockedThread = mock();
+  private final ThreadInfo waitingThread = mock();
+  private final ThreadInfo timedWaitingThread = mock();
+  private final ThreadInfo terminatedThread = mock();
+
+  private final Set<String> deadlocks = new HashSet<>();
+
+  private static final MetricName TERMINATED_COUNT = MetricName.build("terminated.count");
+  private static final MetricName NEW_COUNT = MetricName.build("new.count");
+  private static final MetricName COUNT = MetricName.build("count");
+  private static final MetricName TIMED_WAITING_COUNT = MetricName.build("timed_waiting.count");
+  private static final MetricName DEADLOCKS = MetricName.build("deadlocks");
+  private static final MetricName BLOCKED_COUNT = MetricName.build("blocked.count");
+  private static final MetricName WAITING_COUNT = MetricName.build("waiting.count");
+  private static final MetricName DAEMON_COUNT = MetricName.build("daemon.count");
+  private static final MetricName RUNNABLE_COUNT = MetricName.build("runnable.count");
+  private static final MetricName DEADLOCK_COUNT = MetricName.build("deadlock.count");
+
+  @BeforeEach
+  void setUp() {
+    deadlocks.add("yay");
+
+    when(newThread.getThreadState()).thenReturn(Thread.State.NEW);
+    when(runnableThread.getThreadState()).thenReturn(Thread.State.RUNNABLE);
+    when(blockedThread.getThreadState()).thenReturn(Thread.State.BLOCKED);
+    when(waitingThread.getThreadState()).thenReturn(Thread.State.WAITING);
+    when(timedWaitingThread.getThreadState()).thenReturn(Thread.State.TIMED_WAITING);
+    when(terminatedThread.getThreadState()).thenReturn(Thread.State.TERMINATED);
+
+    when(threads.getAllThreadIds()).thenReturn(ids);
+    when(threads.getThreadInfo(ids, 0))
+        .thenReturn(
+            new ThreadInfo[] {
+              newThread, runnableThread, blockedThread,
+              waitingThread, timedWaitingThread, terminatedThread
+            });
+
+    when(threads.getThreadCount()).thenReturn(12);
+    when(threads.getDaemonThreadCount()).thenReturn(10);
+    when(threads.getPeakThreadCount()).thenReturn(30);
+    when(threads.getTotalStartedThreadCount()).thenReturn(42L);
+
+    when(detector.getDeadlockedThreads()).thenReturn(deadlocks);
+  }
+
+  @Test
+  void hasASetOfGauges() {
+    assertThat(gauges.getMetrics().keySet())
+        .containsOnly(
+            TERMINATED_COUNT,
+            NEW_COUNT,
+            COUNT,
+            TIMED_WAITING_COUNT,
+            DEADLOCKS,
+            BLOCKED_COUNT,
+            WAITING_COUNT,
+            DAEMON_COUNT,
+            RUNNABLE_COUNT,
+            DEADLOCK_COUNT,
+            MetricName.build("total_started.count"),
+            MetricName.build("peak.count"));
+  }
+
+  @Test
+  void hasAGaugeForEachThreadState() {
+    assertThat(((Gauge<?>) gauges.getMetrics().get(NEW_COUNT)).getValue()).isEqualTo(1);
+
+    assertThat(((Gauge<?>) gauges.getMetrics().get(RUNNABLE_COUNT)).getValue()).isEqualTo(1);
+
+    assertThat(((Gauge<?>) gauges.getMetrics().get(BLOCKED_COUNT)).getValue()).isEqualTo(1);
+
+    assertThat(((Gauge<?>) gauges.getMetrics().get(WAITING_COUNT)).getValue()).isEqualTo(1);
+
+    assertThat(((Gauge<?>) gauges.getMetrics().get(TIMED_WAITING_COUNT)).getValue()).isEqualTo(1);
+
+    assertThat(((Gauge<?>) gauges.getMetrics().get(TERMINATED_COUNT)).getValue()).isEqualTo(1);
+  }
+
+  @Test
+  void hasAGaugeForTheNumberOfThreads() {
+    assertThat(((Gauge<?>) gauges.getMetrics().get(COUNT)).getValue()).isEqualTo(12);
+  }
+
+  @Test
+  void hasAGaugeForTheNumberOfDaemonThreads() {
+    assertThat(((Gauge<?>) gauges.getMetrics().get(DAEMON_COUNT)).getValue()).isEqualTo(10);
+  }
+
+  @Test
+  void hasAGaugeForAnyDeadlocks() {
+    assertThat(((Gauge<?>) gauges.getMetrics().get(DEADLOCKS)).getValue()).isEqualTo(deadlocks);
+  }
+
+  @Test
+  void hasAGaugeForAnyDeadlockCount() {
+    assertThat(((Gauge<?>) gauges.getMetrics().get(DEADLOCK_COUNT)).getValue()).isEqualTo(1);
+  }
+
+  @Test
+  void hasAGaugeForPeakThreadCount() {
+    assertThat(((Gauge<?>) gauges.getMetrics().get(MetricName.build("peak.count"))).getValue())
+        .isEqualTo(30);
+  }
+
+  @Test
+  void hasAGaugeForTotalStartedThreadsCount() {
+    assertThat(
+            ((Gauge<?>) gauges.getMetrics().get(MetricName.build("total_started.count")))
+                .getValue())
+        .isEqualTo(42L);
+  }
+
+  @Test
+  void autoDiscoversTheMXBeans() {
+    final ThreadStatesGaugeSet set = new ThreadStatesGaugeSet();
+    assertThat(((Gauge<?>) set.getMetrics().get(COUNT)).getValue()).isNotNull();
+    assertThat(((Gauge<?>) set.getMetrics().get(DEADLOCKS)).getValue()).isNotNull();
+  }
 }
--- a/metrics-legacy-adapter-healthchecks/src/main/java/com/codahale/metrics/health/HealthCheck.java
+++ b/metrics-legacy-adapter-healthchecks/src/main/java/com/codahale/metrics/health/HealthCheck.java
@@ -6,158 +6,158 @@ import java.util.Objects;
 @Deprecated
 public abstract class HealthCheck {
 
-    public static class Result {
+  public static class Result {
 
-        public static HealthCheck.Result healthy() {
-            return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.healthy());
-        }
-
-        public static HealthCheck.Result healthy(String message) {
-            return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.healthy(message));
-        }
-
-        public static HealthCheck.Result healthy(String message, Object... args) {
-            return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.healthy(message, args));
-        }
-
-        public static HealthCheck.Result unhealthy(String message) {
-            return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.unhealthy(message));
-        }
+    public static HealthCheck.Result healthy() {
+      return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.healthy());
+    }
 
-        public static HealthCheck.Result unhealthy(String message, Object... args) {
-            return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.unhealthy(message, args));
-        }
+    public static HealthCheck.Result healthy(String message) {
+      return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.healthy(message));
+    }
 
-        public static HealthCheck.Result unhealthy(Throwable error) {
-            return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.unhealthy(error));
-        }
+    public static HealthCheck.Result healthy(String message, Object... args) {
+      return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.healthy(message, args));
+    }
 
-        public static HealthCheck.Result of(io.dropwizard.metrics5.health.HealthCheck.Result delegate) {
-            return new Result(delegate);
-        }
+    public static HealthCheck.Result unhealthy(String message) {
+      return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.unhealthy(message));
+    }
 
-        public static HealthCheck.ResultBuilder builder() {
-            return new HealthCheck.ResultBuilder();
-        }
+    public static HealthCheck.Result unhealthy(String message, Object... args) {
+      return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.unhealthy(message, args));
+    }
 
-        private final io.dropwizard.metrics5.health.HealthCheck.Result delegate;
+    public static HealthCheck.Result unhealthy(Throwable error) {
+      return new Result(io.dropwizard.metrics5.health.HealthCheck.Result.unhealthy(error));
+    }
 
-        private Result(io.dropwizard.metrics5.health.HealthCheck.Result delegate) {
-            this.delegate = delegate;
-        }
+    public static HealthCheck.Result of(io.dropwizard.metrics5.health.HealthCheck.Result delegate) {
+      return new Result(delegate);
+    }
 
-        private Result(io.dropwizard.metrics5.health.HealthCheck.ResultBuilder builder) {
-            this.delegate = builder.build();
-        }
+    public static HealthCheck.ResultBuilder builder() {
+      return new HealthCheck.ResultBuilder();
+    }
 
-        public boolean isHealthy() {
-            return delegate.isHealthy();
-        }
+    private final io.dropwizard.metrics5.health.HealthCheck.Result delegate;
 
-        public String getMessage() {
-            return delegate.getMessage();
-        }
+    private Result(io.dropwizard.metrics5.health.HealthCheck.Result delegate) {
+      this.delegate = delegate;
+    }
 
-        public Throwable getError() {
-            return delegate.getError();
-        }
+    private Result(io.dropwizard.metrics5.health.HealthCheck.ResultBuilder builder) {
+      this.delegate = builder.build();
+    }
 
-        public String getTimestamp() {
-            return delegate.getTimestamp();
-        }
+    public boolean isHealthy() {
+      return delegate.isHealthy();
+    }
 
-        public Map<String, Object> getDetails() {
-            return delegate.getDetails();
-        }
+    public String getMessage() {
+      return delegate.getMessage();
+    }
 
-        public io.dropwizard.metrics5.health.HealthCheck.Result getDelegate() {
-            return delegate;
-        }
+    public Throwable getError() {
+      return delegate.getError();
+    }
 
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Result) {
-                final Result that = (Result) o;
-                return Objects.equals(delegate, that.delegate);
-            }
-            return false;
-        }
+    public String getTimestamp() {
+      return delegate.getTimestamp();
+    }
 
-        @Override
-        public int hashCode() {
-            return Objects.hash(delegate);
-        }
+    public Map<String, Object> getDetails() {
+      return delegate.getDetails();
+    }
 
-        @Override
-        public String toString() {
-            return delegate.toString();
-        }
+    public io.dropwizard.metrics5.health.HealthCheck.Result getDelegate() {
+      return delegate;
     }
 
-    public static class ResultBuilder {
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Result) {
+        final Result that = (Result) o;
+        return Objects.equals(delegate, that.delegate);
+      }
+      return false;
+    }
 
-        private io.dropwizard.metrics5.health.HealthCheck.ResultBuilder delegate;
+    @Override
+    public int hashCode() {
+      return Objects.hash(delegate);
+    }
 
-        protected ResultBuilder() {
-            delegate = io.dropwizard.metrics5.health.HealthCheck.Result.builder();
-        }
+    @Override
+    public String toString() {
+      return delegate.toString();
+    }
+  }
 
-        public HealthCheck.ResultBuilder healthy() {
-            delegate.healthy();
-            return this;
-        }
+  public static class ResultBuilder {
 
-        public HealthCheck.ResultBuilder unhealthy() {
-            delegate.unhealthy();
-            return this;
-        }
+    private io.dropwizard.metrics5.health.HealthCheck.ResultBuilder delegate;
 
-        public HealthCheck.ResultBuilder unhealthy(Throwable error) {
-            delegate.unhealthy(error);
-            return this;
-        }
+    protected ResultBuilder() {
+      delegate = io.dropwizard.metrics5.health.HealthCheck.Result.builder();
+    }
 
-        public HealthCheck.ResultBuilder withMessage(String message) {
-            delegate.withMessage(message);
-            return this;
-        }
+    public HealthCheck.ResultBuilder healthy() {
+      delegate.healthy();
+      return this;
+    }
 
-        public HealthCheck.ResultBuilder withMessage(String message, Object... args) {
-            delegate.withMessage(message, args);
-            return this;
-        }
+    public HealthCheck.ResultBuilder unhealthy() {
+      delegate.unhealthy();
+      return this;
+    }
 
-        public HealthCheck.ResultBuilder withDetail(String key, Object data) {
-            delegate.withDetail(key, data);
-            return this;
-        }
+    public HealthCheck.ResultBuilder unhealthy(Throwable error) {
+      delegate.unhealthy(error);
+      return this;
+    }
 
-        public HealthCheck.Result build() {
-            return new HealthCheck.Result(delegate);
-        }
+    public HealthCheck.ResultBuilder withMessage(String message) {
+      delegate.withMessage(message);
+      return this;
     }
 
-    protected abstract HealthCheck.Result check() throws Exception;
+    public HealthCheck.ResultBuilder withMessage(String message, Object... args) {
+      delegate.withMessage(message, args);
+      return this;
+    }
 
-    public HealthCheck.Result execute() {
-        try {
-            return check();
-        } catch (Exception e) {
-            return HealthCheck.Result.unhealthy(e);
-        }
+    public HealthCheck.ResultBuilder withDetail(String key, Object data) {
+      delegate.withDetail(key, data);
+      return this;
     }
 
-    public io.dropwizard.metrics5.health.HealthCheck transform() {
-        final HealthCheck original = this;
-        return () -> original.check().delegate;
+    public HealthCheck.Result build() {
+      return new HealthCheck.Result(delegate);
     }
+  }
+
+  protected abstract HealthCheck.Result check() throws Exception;
 
-    public static HealthCheck of(io.dropwizard.metrics5.health.HealthCheck delegate) {
-        return new HealthCheck() {
-            @Override
-            protected Result check() throws Exception {
-                return new Result(delegate.execute());
-            }
-        };
+  public HealthCheck.Result execute() {
+    try {
+      return check();
+    } catch (Exception e) {
+      return HealthCheck.Result.unhealthy(e);
     }
+  }
+
+  public io.dropwizard.metrics5.health.HealthCheck transform() {
+    final HealthCheck original = this;
+    return () -> original.check().delegate;
+  }
+
+  public static HealthCheck of(io.dropwizard.metrics5.health.HealthCheck delegate) {
+    return new HealthCheck() {
+      @Override
+      protected Result check() throws Exception {
+        return new Result(delegate.execute());
+      }
+    };
+  }
 }
--- a/metrics-legacy-adapter-healthchecks/src/main/java/com/codahale/metrics/health/HealthCheckFilter.java
+++ b/metrics-legacy-adapter-healthchecks/src/main/java/com/codahale/metrics/health/HealthCheckFilter.java
@@ -3,12 +3,12 @@ package com.codahale.metrics.health;
 @Deprecated
 public interface HealthCheckFilter {
 
-    HealthCheckFilter ALL = (name, healthCheck) -> true;
+  HealthCheckFilter ALL = (name, healthCheck) -> true;
 
-    boolean matches(String name, HealthCheck healthCheck);
+  boolean matches(String name, HealthCheck healthCheck);
 
-    default io.dropwizard.metrics5.health.HealthCheckFilter transform() {
-        final HealthCheckFilter origin = this;
-        return (name, healthCheck) -> origin.matches(name, HealthCheck.of(healthCheck));
-    }
+  default io.dropwizard.metrics5.health.HealthCheckFilter transform() {
+    final HealthCheckFilter origin = this;
+    return (name, healthCheck) -> origin.matches(name, HealthCheck.of(healthCheck));
+  }
 }
--- a/metrics-legacy-adapter-healthchecks/src/main/java/com/codahale/metrics/health/HealthCheckRegistry.java
+++ b/metrics-legacy-adapter-healthchecks/src/main/java/com/codahale/metrics/health/HealthCheckRegistry.java
@@ -11,79 +11,80 @@ import java.util.concurrent.ScheduledExecutorService;
 @Deprecated
 public class HealthCheckRegistry {
 
-    private final io.dropwizard.metrics5.health.HealthCheckRegistry delegate;
-
-    public HealthCheckRegistry() {
-        this(new io.dropwizard.metrics5.health.HealthCheckRegistry());
-    }
-
-    public HealthCheckRegistry(int asyncExecutorPoolSize) {
-        this(new io.dropwizard.metrics5.health.HealthCheckRegistry(asyncExecutorPoolSize));
-    }
-
-    public HealthCheckRegistry(ScheduledExecutorService asyncExecutorService) {
-        this(new io.dropwizard.metrics5.health.HealthCheckRegistry(asyncExecutorService));
-    }
-
-    private HealthCheckRegistry(io.dropwizard.metrics5.health.HealthCheckRegistry delegate) {
-        this.delegate = delegate;
-    }
-
-    public static HealthCheckRegistry of(io.dropwizard.metrics5.health.HealthCheckRegistry reg) {
-        return new HealthCheckRegistry(reg);
-    }
-
-    public void addListener(HealthCheckRegistryListener listener) {
-        delegate.addListener(listener.transform());
-    }
-
-    public void removeListener(HealthCheckRegistryListener listener) {
-        delegate.removeListener(listener.transform());
-    }
-
-    public void register(String name, HealthCheck healthCheck) {
-        delegate.register(name, healthCheck.transform());
-    }
-
-    public void unregister(String name) {
-        delegate.unregister(name);
-    }
-
-    public SortedSet<String> getNames() {
-        return delegate.getNames();
-    }
-
-    public HealthCheck.Result runHealthCheck(String name) throws NoSuchElementException {
-        return HealthCheck.Result.of(delegate.runHealthCheck(name));
-    }
-
-    public SortedMap<String, HealthCheck.Result> runHealthChecks() {
-        return convertHealthChecks(delegate.runHealthChecks());
-    }
-
-    public SortedMap<String, HealthCheck.Result> runHealthChecks(HealthCheckFilter filter) {
-        return convertHealthChecks(delegate.runHealthChecks(filter.transform()));
-    }
-
-    public SortedMap<String, HealthCheck.Result> runHealthChecks(ExecutorService executor) {
-        return convertHealthChecks(delegate.runHealthChecks(executor));
-    }
-
-    public SortedMap<String, HealthCheck.Result> runHealthChecks(ExecutorService executor,
-                                                                 HealthCheckFilter filter) {
-        return convertHealthChecks(delegate.runHealthChecks(executor, filter.transform()));
-    }
-
-    private SortedMap<String, HealthCheck.Result> convertHealthChecks(
-            SortedMap<String, io.dropwizard.metrics5.health.HealthCheck.Result> originResults) {
-        final SortedMap<String, HealthCheck.Result> results = new TreeMap<>();
-        for (Map.Entry<String, io.dropwizard.metrics5.health.HealthCheck.Result> entry : originResults.entrySet()) {
-            results.put(entry.getKey(), HealthCheck.Result.of(entry.getValue()));
-        }
-        return results;
-    }
-
-    public void shutdown() {
-        delegate.shutdown();
-    }
+  private final io.dropwizard.metrics5.health.HealthCheckRegistry delegate;
+
+  public HealthCheckRegistry() {
+    this(new io.dropwizard.metrics5.health.HealthCheckRegistry());
+  }
+
+  public HealthCheckRegistry(int asyncExecutorPoolSize) {
+    this(new io.dropwizard.metrics5.health.HealthCheckRegistry(asyncExecutorPoolSize));
+  }
+
+  public HealthCheckRegistry(ScheduledExecutorService asyncExecutorService) {
+    this(new io.dropwizard.metrics5.health.HealthCheckRegistry(asyncExecutorService));
+  }
+
+  private HealthCheckRegistry(io.dropwizard.metrics5.health.HealthCheckRegistry delegate) {
+    this.delegate = delegate;
+  }
+
+  public static HealthCheckRegistry of(io.dropwizard.metrics5.health.HealthCheckRegistry reg) {
+    return new HealthCheckRegistry(reg);
+  }
+
+  public void addListener(HealthCheckRegistryListener listener) {
+    delegate.addListener(listener.transform());
+  }
+
+  public void removeListener(HealthCheckRegistryListener listener) {
+    delegate.removeListener(listener.transform());
+  }
+
+  public void register(String name, HealthCheck healthCheck) {
+    delegate.register(name, healthCheck.transform());
+  }
+
+  public void unregister(String name) {
+    delegate.unregister(name);
+  }
+
+  public SortedSet<String> getNames() {
+    return delegate.getNames();
+  }
+
+  public HealthCheck.Result runHealthCheck(String name) throws NoSuchElementException {
+    return HealthCheck.Result.of(delegate.runHealthCheck(name));
+  }
+
+  public SortedMap<String, HealthCheck.Result> runHealthChecks() {
+    return convertHealthChecks(delegate.runHealthChecks());
+  }
+
+  public SortedMap<String, HealthCheck.Result> runHealthChecks(HealthCheckFilter filter) {
+    return convertHealthChecks(delegate.runHealthChecks(filter.transform()));
+  }
+
+  public SortedMap<String, HealthCheck.Result> runHealthChecks(ExecutorService executor) {
+    return convertHealthChecks(delegate.runHealthChecks(executor));
+  }
+
+  public SortedMap<String, HealthCheck.Result> runHealthChecks(
+      ExecutorService executor, HealthCheckFilter filter) {
+    return convertHealthChecks(delegate.runHealthChecks(executor, filter.transform()));
+  }
+
+  private SortedMap<String, HealthCheck.Result> convertHealthChecks(
+      SortedMap<String, io.dropwizard.metrics5.health.HealthCheck.Result> originResults) {
+    final SortedMap<String, HealthCheck.Result> results = new TreeMap<>();
+    for (Map.Entry<String, io.dropwizard.metrics5.health.HealthCheck.Result> entry :
+        originResults.entrySet()) {
+      results.put(entry.getKey(), HealthCheck.Result.of(entry.getValue()));
+    }
+    return results;
+  }
+
+  public void shutdown() {
+    delegate.shutdown();
+  }
 }
--- a/metrics-legacy-adapter-healthchecks/src/main/java/com/codahale/metrics/health/HealthCheckRegistryListener.java
+++ b/metrics-legacy-adapter-healthchecks/src/main/java/com/codahale/metrics/health/HealthCheckRegistryListener.java
@@ -6,44 +6,46 @@ import java.util.Objects;
 @Deprecated
 public interface HealthCheckRegistryListener extends EventListener {
 
-    void onHealthCheckAdded(String name, HealthCheck healthCheck);
+  void onHealthCheckAdded(String name, HealthCheck healthCheck);
 
-    void onHealthCheckRemoved(String name, HealthCheck healthCheck);
+  void onHealthCheckRemoved(String name, HealthCheck healthCheck);
 
-    default io.dropwizard.metrics5.health.HealthCheckRegistryListener transform() {
-        return new Adapter(this);
+  default io.dropwizard.metrics5.health.HealthCheckRegistryListener transform() {
+    return new Adapter(this);
+  }
+
+  class Adapter implements io.dropwizard.metrics5.health.HealthCheckRegistryListener {
+
+    private final HealthCheckRegistryListener delegate;
+
+    public Adapter(HealthCheckRegistryListener delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void onHealthCheckAdded(
+        String name, io.dropwizard.metrics5.health.HealthCheck healthCheck) {
+      delegate.onHealthCheckAdded(name, HealthCheck.of(healthCheck));
+    }
+
+    @Override
+    public void onHealthCheckRemoved(
+        String name, io.dropwizard.metrics5.health.HealthCheck healthCheck) {
+      delegate.onHealthCheckRemoved(name, HealthCheck.of(healthCheck));
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Adapter) {
+        final Adapter that = (Adapter) o;
+        return Objects.equals(delegate, that.delegate);
+      }
+      return false;
     }
 
-    class Adapter implements io.dropwizard.metrics5.health.HealthCheckRegistryListener {
-
-        private final HealthCheckRegistryListener delegate;
-
-        public Adapter(HealthCheckRegistryListener delegate) {
-            this.delegate = delegate;
-        }
-
-        @Override
-        public void onHealthCheckAdded(String name, io.dropwizard.metrics5.health.HealthCheck healthCheck) {
-            delegate.onHealthCheckAdded(name, HealthCheck.of(healthCheck));
-        }
-
-        @Override
-        public void onHealthCheckRemoved(String name, io.dropwizard.metrics5.health.HealthCheck healthCheck) {
-            delegate.onHealthCheckRemoved(name, HealthCheck.of(healthCheck));
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Adapter) {
-                final Adapter that = (Adapter) o;
-                return Objects.equals(delegate, that.delegate);
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(delegate);
-        }
+    @Override
+    public int hashCode() {
+      return Objects.hash(delegate);
     }
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/CachedGauge.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/CachedGauge.java
@@ -1,42 +1,43 @@
 package com.codahale.metrics;
 
-import java.util.concurrent.TimeUnit;
-
 import static java.util.Objects.requireNonNull;
 
+import java.util.concurrent.TimeUnit;
+
 @Deprecated
 public abstract class CachedGauge<T> implements Gauge<T> {
 
-    private final io.dropwizard.metrics5.CachedGauge<T> gauge;
+  private final io.dropwizard.metrics5.CachedGauge<T> gauge;
 
-    public CachedGauge(io.dropwizard.metrics5.CachedGauge<T> gauge) {
-        this.gauge = requireNonNull(gauge);
-    }
+  public CachedGauge(io.dropwizard.metrics5.CachedGauge<T> gauge) {
+    this.gauge = requireNonNull(gauge);
+  }
 
-    protected CachedGauge(long timeout, TimeUnit timeoutUnit) {
-        final CachedGauge<T> original = this;
-        gauge = new io.dropwizard.metrics5.CachedGauge<T>(timeout, timeoutUnit) {
-            @Override
-            protected T loadValue() {
-                return original.loadValue();
-            }
+  protected CachedGauge(long timeout, TimeUnit timeoutUnit) {
+    final CachedGauge<T> original = this;
+    gauge =
+        new io.dropwizard.metrics5.CachedGauge<T>(timeout, timeoutUnit) {
+          @Override
+          protected T loadValue() {
+            return original.loadValue();
+          }
         };
-    }
-
-    protected CachedGauge(Clock clock, long timeout, TimeUnit timeoutUnit) {
-        final CachedGauge<T> original = this;
-        gauge = new io.dropwizard.metrics5.CachedGauge<T>(clock.getDelegate(), timeout, timeoutUnit) {
-            @Override
-            protected T loadValue() {
-                return original.loadValue();
-            }
+  }
+
+  protected CachedGauge(Clock clock, long timeout, TimeUnit timeoutUnit) {
+    final CachedGauge<T> original = this;
+    gauge =
+        new io.dropwizard.metrics5.CachedGauge<T>(clock.getDelegate(), timeout, timeoutUnit) {
+          @Override
+          protected T loadValue() {
+            return original.loadValue();
+          }
         };
-    }
-
-    protected abstract T loadValue();
+  }
 
-    public T getValue() {
-        return gauge.getValue();
-    }
+  protected abstract T loadValue();
 
+  public T getValue() {
+    return gauge.getValue();
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Clock.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Clock.java
@@ -3,64 +3,65 @@ package com.codahale.metrics;
 @Deprecated
 public abstract class Clock {
 
-    public abstract long getTick();
+  public abstract long getTick();
 
-    public long getTime() {
-        return System.currentTimeMillis();
-    }
-
-    public io.dropwizard.metrics5.Clock getDelegate() {
-        if (this instanceof DelegateClock) {
-            return ((DelegateClock) this).delegate;
-        }
-        final Clock original = this;
-        return new io.dropwizard.metrics5.Clock() {
-            @Override
-            public long getTick() {
-                return original.getTick();
-            }
+  public long getTime() {
+    return System.currentTimeMillis();
+  }
 
-            @Override
-            public long getTime() {
-                return original.getTime();
-            }
-        };
+  public io.dropwizard.metrics5.Clock getDelegate() {
+    if (this instanceof DelegateClock) {
+      return ((DelegateClock) this).delegate;
     }
+    final Clock original = this;
+    return new io.dropwizard.metrics5.Clock() {
+      @Override
+      public long getTick() {
+        return original.getTick();
+      }
 
-    public static Clock of(io.dropwizard.metrics5.Clock delegate) {
-        return new DelegateClock(delegate);
-    }
+      @Override
+      public long getTime() {
+        return original.getTime();
+      }
+    };
+  }
 
-    public static Clock defaultClock() {
-        return of(io.dropwizard.metrics5.Clock.defaultClock());
-    }
+  public static Clock of(io.dropwizard.metrics5.Clock delegate) {
+    return new DelegateClock(delegate);
+  }
 
-    public static class UserTimeClock extends Clock {
+  public static Clock defaultClock() {
+    return of(io.dropwizard.metrics5.Clock.defaultClock());
+  }
 
-        private final io.dropwizard.metrics5.Clock delegate = new io.dropwizard.metrics5.Clock.UserTimeClock();
+  public static class UserTimeClock extends Clock {
 
-        @Override
-        public long getTick() {
-            return delegate.getTick();
-        }
+    private final io.dropwizard.metrics5.Clock delegate =
+        new io.dropwizard.metrics5.Clock.UserTimeClock();
 
-        @Override
-        public long getTime() {
-            return delegate.getTime();
-        }
+    @Override
+    public long getTick() {
+      return delegate.getTick();
     }
 
-    private static class DelegateClock extends Clock {
+    @Override
+    public long getTime() {
+      return delegate.getTime();
+    }
+  }
 
-        private final io.dropwizard.metrics5.Clock delegate;
+  private static class DelegateClock extends Clock {
 
-        private DelegateClock(io.dropwizard.metrics5.Clock delegate) {
-            this.delegate = delegate;
-        }
+    private final io.dropwizard.metrics5.Clock delegate;
+
+    private DelegateClock(io.dropwizard.metrics5.Clock delegate) {
+      this.delegate = delegate;
+    }
 
-        @Override
-        public long getTick() {
-            return delegate.getTick();
-        }
+    @Override
+    public long getTick() {
+      return delegate.getTick();
     }
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/ConsoleReporter.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/ConsoleReporter.java
@@ -11,83 +11,91 @@ import java.util.concurrent.TimeUnit;
 @Deprecated
 public class ConsoleReporter extends ScheduledReporter {
 
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
+
+  public static class Builder {
+
+    private io.dropwizard.metrics5.ConsoleReporter.Builder delegate;
+
+    private Builder(MetricRegistry metricRegistry) {
+      delegate = io.dropwizard.metrics5.ConsoleReporter.forRegistry(metricRegistry.getDelegate());
+    }
+
+    public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      delegate.shutdownExecutorOnStop(shutdownExecutorOnStop);
+      return this;
+    }
+
+    public Builder scheduleOn(ScheduledExecutorService executor) {
+      delegate.scheduleOn(executor);
+      return this;
+    }
+
+    public Builder outputTo(PrintStream output) {
+      delegate.outputTo(output);
+      return this;
+    }
+
+    public Builder formattedFor(Locale locale) {
+      delegate.formattedFor(locale);
+      return this;
+    }
+
+    public Builder withClock(Clock clock) {
+      delegate.withClock(clock.getDelegate());
+      return this;
+    }
+
+    public Builder formattedFor(TimeZone timeZone) {
+      delegate.formattedFor(timeZone);
+      return this;
+    }
+
+    public Builder convertRatesTo(TimeUnit rateUnit) {
+      delegate.convertRatesTo(rateUnit);
+      return this;
+    }
+
+    public Builder convertDurationsTo(TimeUnit durationUnit) {
+      delegate.convertDurationsTo(durationUnit);
+      return this;
     }
 
-    public static class Builder {
-
-        private io.dropwizard.metrics5.ConsoleReporter.Builder delegate;
-
-        private Builder(MetricRegistry metricRegistry) {
-            delegate = io.dropwizard.metrics5.ConsoleReporter.forRegistry(metricRegistry.getDelegate());
-        }
-
-        public Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            delegate.shutdownExecutorOnStop(shutdownExecutorOnStop);
-            return this;
-        }
-
-        public Builder scheduleOn(ScheduledExecutorService executor) {
-            delegate.scheduleOn(executor);
-            return this;
-        }
-
-        public Builder outputTo(PrintStream output) {
-            delegate.outputTo(output);
-            return this;
-        }
-
-        public Builder formattedFor(Locale locale) {
-            delegate.formattedFor(locale);
-            return this;
-        }
-
-        public Builder withClock(Clock clock) {
-            delegate.withClock(clock.getDelegate());
-            return this;
-        }
-
-        public Builder formattedFor(TimeZone timeZone) {
-            delegate.formattedFor(timeZone);
-            return this;
-        }
-
-        public Builder convertRatesTo(TimeUnit rateUnit) {
-            delegate.convertRatesTo(rateUnit);
-            return this;
-        }
-
-        public Builder convertDurationsTo(TimeUnit durationUnit) {
-            delegate.convertDurationsTo(durationUnit);
-            return this;
-        }
-
-        public Builder filter(MetricFilter filter) {
-            delegate.filter(filter.transform());
-            return this;
-        }
-
-        public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
-            delegate.disabledMetricAttributes(MetricAttribute.transform(disabledMetricAttributes));
-            return this;
-        }
-
-        public ConsoleReporter build() {
-            return new ConsoleReporter(delegate.build());
-        }
+    public Builder filter(MetricFilter filter) {
+      delegate.filter(filter.transform());
+      return this;
     }
 
-    private ConsoleReporter(io.dropwizard.metrics5.ScheduledReporter delegate) {
-        super(delegate);
+    public Builder disabledMetricAttributes(Set<MetricAttribute> disabledMetricAttributes) {
+      delegate.disabledMetricAttributes(MetricAttribute.transform(disabledMetricAttributes));
+      return this;
     }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters,
-                       SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters,
-                       SortedMap<String, Timer> timers) {
-        getDelegate().report(transform(gauges), transform(counters), transform(histograms), transform(meters),
-                transform(timers));
+    public ConsoleReporter build() {
+      return new ConsoleReporter(delegate.build());
     }
+  }
+
+  private ConsoleReporter(io.dropwizard.metrics5.ScheduledReporter delegate) {
+    super(delegate);
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report(
+      SortedMap<String, Gauge> gauges,
+      SortedMap<String, Counter> counters,
+      SortedMap<String, Histogram> histograms,
+      SortedMap<String, Meter> meters,
+      SortedMap<String, Timer> timers) {
+    getDelegate()
+        .report(
+            transform(gauges),
+            transform(counters),
+            transform(histograms),
+            transform(meters),
+            transform(timers));
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Counter.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Counter.java
@@ -5,40 +5,39 @@ import static java.util.Objects.requireNonNull;
 @Deprecated
 public class Counter implements Metric, Counting {
 
-    private final io.dropwizard.metrics5.Counter counter;
+  private final io.dropwizard.metrics5.Counter counter;
 
-    public Counter() {
-        this(new io.dropwizard.metrics5.Counter());
-    }
+  public Counter() {
+    this(new io.dropwizard.metrics5.Counter());
+  }
 
-    public Counter(io.dropwizard.metrics5.Counter counter) {
-        this.counter = requireNonNull(counter);
-    }
+  public Counter(io.dropwizard.metrics5.Counter counter) {
+    this.counter = requireNonNull(counter);
+  }
 
-    public void inc() {
-        counter.inc();
-    }
+  public void inc() {
+    counter.inc();
+  }
 
-    public void inc(long n) {
-        counter.inc(n);
-    }
+  public void inc(long n) {
+    counter.inc(n);
+  }
 
-    public void dec() {
-        counter.dec();
-    }
+  public void dec() {
+    counter.dec();
+  }
 
-    public void dec(long n) {
-        counter.dec(n);
-    }
+  public void dec(long n) {
+    counter.dec(n);
+  }
 
-    @Override
-    public long getCount() {
-        return counter.getCount();
-    }
-
-    @Override
-    public io.dropwizard.metrics5.Counter getDelegate() {
-        return counter;
-    }
+  @Override
+  public long getCount() {
+    return counter.getCount();
+  }
 
+  @Override
+  public io.dropwizard.metrics5.Counter getDelegate() {
+    return counter;
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Counting.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Counting.java
@@ -3,5 +3,5 @@ package com.codahale.metrics;
 @Deprecated
 public interface Counting {
 
-    long getCount();
+  long getCount();
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/CsvFileProvider.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/CsvFileProvider.java
@@ -5,5 +5,5 @@ import java.io.File;
 @Deprecated
 public interface CsvFileProvider {
 
-    File getFile(File directory, String metricName);
+  File getFile(File directory, String metricName);
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/CsvReporter.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/CsvReporter.java
@@ -9,80 +9,86 @@ import java.util.concurrent.TimeUnit;
 @Deprecated
 public class CsvReporter extends ScheduledReporter {
 
-    public static Builder forRegistry(MetricRegistry registry) {
-        return new Builder(registry);
-    }
-
-    public static class Builder {
-
-        private io.dropwizard.metrics5.CsvReporter.Builder delegate;
-
-        private Builder(MetricRegistry metricRegistry) {
-            delegate = io.dropwizard.metrics5.CsvReporter.forRegistry(metricRegistry.getDelegate());
-        }
+  public static Builder forRegistry(MetricRegistry registry) {
+    return new Builder(registry);
+  }
 
-        public CsvReporter.Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            delegate.shutdownExecutorOnStop(shutdownExecutorOnStop);
-            return this;
-        }
+  public static class Builder {
 
+    private io.dropwizard.metrics5.CsvReporter.Builder delegate;
 
-        public CsvReporter.Builder scheduleOn(ScheduledExecutorService executor) {
-            delegate.scheduleOn(executor);
-            return this;
-        }
-
-        public CsvReporter.Builder formatFor(Locale locale) {
-            delegate.formatFor(locale);
-            return this;
-        }
+    private Builder(MetricRegistry metricRegistry) {
+      delegate = io.dropwizard.metrics5.CsvReporter.forRegistry(metricRegistry.getDelegate());
+    }
 
+    public CsvReporter.Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      delegate.shutdownExecutorOnStop(shutdownExecutorOnStop);
+      return this;
+    }
 
-        public CsvReporter.Builder convertRatesTo(TimeUnit rateUnit) {
-            delegate.convertRatesTo(rateUnit);
-            return this;
-        }
+    public CsvReporter.Builder scheduleOn(ScheduledExecutorService executor) {
+      delegate.scheduleOn(executor);
+      return this;
+    }
 
-        public CsvReporter.Builder convertDurationsTo(TimeUnit durationUnit) {
-            delegate.convertDurationsTo(durationUnit);
-            return this;
-        }
+    public CsvReporter.Builder formatFor(Locale locale) {
+      delegate.formatFor(locale);
+      return this;
+    }
 
-        public CsvReporter.Builder withSeparator(String separator) {
-            delegate.withSeparator(separator);
-            return this;
-        }
+    public CsvReporter.Builder convertRatesTo(TimeUnit rateUnit) {
+      delegate.convertRatesTo(rateUnit);
+      return this;
+    }
 
-        public CsvReporter.Builder withClock(Clock clock) {
-            delegate.withClock(clock.getDelegate());
-            return this;
-        }
+    public CsvReporter.Builder convertDurationsTo(TimeUnit durationUnit) {
+      delegate.convertDurationsTo(durationUnit);
+      return this;
+    }
 
-        public CsvReporter.Builder filter(MetricFilter filter) {
-            delegate.filter(filter.transform());
-            return this;
-        }
+    public CsvReporter.Builder withSeparator(String separator) {
+      delegate.withSeparator(separator);
+      return this;
+    }
 
-        public Builder withCsvFileProvider(CsvFileProvider csvFileProvider) {
-            delegate.withCsvFileProvider(csvFileProvider::getFile);
-            return this;
-        }
+    public CsvReporter.Builder withClock(Clock clock) {
+      delegate.withClock(clock.getDelegate());
+      return this;
+    }
 
-        public CsvReporter build(File directory) {
-            return new CsvReporter(delegate.build(directory));
-        }
+    public CsvReporter.Builder filter(MetricFilter filter) {
+      delegate.filter(filter.transform());
+      return this;
     }
-    
-    public CsvReporter(io.dropwizard.metrics5.CsvReporter delegate) {
-        super(delegate);
+
+    public Builder withCsvFileProvider(CsvFileProvider csvFileProvider) {
+      delegate.withCsvFileProvider(csvFileProvider::getFile);
+      return this;
     }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters,
-                       SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters,
-                       SortedMap<String, Timer> timers) {
-        getDelegate().report(transform(gauges), transform(counters), transform(histograms), transform(meters),
-                transform(timers));
+    public CsvReporter build(File directory) {
+      return new CsvReporter(delegate.build(directory));
     }
+  }
+
+  public CsvReporter(io.dropwizard.metrics5.CsvReporter delegate) {
+    super(delegate);
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report(
+      SortedMap<String, Gauge> gauges,
+      SortedMap<String, Counter> counters,
+      SortedMap<String, Histogram> histograms,
+      SortedMap<String, Meter> meters,
+      SortedMap<String, Timer> timers) {
+    getDelegate()
+        .report(
+            transform(gauges),
+            transform(counters),
+            transform(histograms),
+            transform(meters),
+            transform(timers));
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/DerivativeGauge.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/DerivativeGauge.java
@@ -3,22 +3,23 @@ package com.codahale.metrics;
 @Deprecated
 public abstract class DerivativeGauge<F, T> implements Gauge<T> {
 
-    private final io.dropwizard.metrics5.DerivativeGauge<F, T> delegate;
+  private final io.dropwizard.metrics5.DerivativeGauge<F, T> delegate;
 
-    protected DerivativeGauge(Gauge<F> base) {
-        DerivativeGauge<F, T> original = this;
-        delegate = new io.dropwizard.metrics5.DerivativeGauge<F, T>(base.getDelegate()) {
-            @Override
-            protected T transform(F value) {
-                return original.transform(base.getValue());
-            }
+  protected DerivativeGauge(Gauge<F> base) {
+    DerivativeGauge<F, T> original = this;
+    delegate =
+        new io.dropwizard.metrics5.DerivativeGauge<F, T>(base.getDelegate()) {
+          @Override
+          protected T transform(F value) {
+            return original.transform(base.getValue());
+          }
         };
-    }
+  }
 
-    protected abstract T transform(F value);
+  protected abstract T transform(F value);
 
-    @Override
-    public T getValue() {
-        return delegate.getValue();
-    }
+  @Override
+  public T getValue() {
+    return delegate.getValue();
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/ExponentiallyDecayingReservoir.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/ExponentiallyDecayingReservoir.java
@@ -5,41 +5,44 @@ import static java.util.Objects.requireNonNull;
 @Deprecated
 public class ExponentiallyDecayingReservoir implements Reservoir {
 
-    private final io.dropwizard.metrics5.ExponentiallyDecayingReservoir delegate;
-
-    public ExponentiallyDecayingReservoir() {
-        this(new io.dropwizard.metrics5.ExponentiallyDecayingReservoir());
-    }
-
-    public ExponentiallyDecayingReservoir(int size, double alpha) {
-        this(new io.dropwizard.metrics5.ExponentiallyDecayingReservoir(size, alpha));
-    }
-
-    public ExponentiallyDecayingReservoir(int size, double alpha, Clock clock) {
-        this(new io.dropwizard.metrics5.ExponentiallyDecayingReservoir(size, alpha, clock.getDelegate()));
-    }
-
-    public ExponentiallyDecayingReservoir(io.dropwizard.metrics5.ExponentiallyDecayingReservoir delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    @Override
-    public io.dropwizard.metrics5.Reservoir getDelegate() {
-        return delegate;
-    }
-
-    @Override
-    public int size() {
-        return delegate.size();
-    }
-
-    @Override
-    public void update(long value) {
-        delegate.update(value);
-    }
-
-    @Override
-    public Snapshot getSnapshot() {
-        return Snapshot.of(delegate.getSnapshot());
-    }
+  private final io.dropwizard.metrics5.ExponentiallyDecayingReservoir delegate;
+
+  public ExponentiallyDecayingReservoir() {
+    this(new io.dropwizard.metrics5.ExponentiallyDecayingReservoir());
+  }
+
+  public ExponentiallyDecayingReservoir(int size, double alpha) {
+    this(new io.dropwizard.metrics5.ExponentiallyDecayingReservoir(size, alpha));
+  }
+
+  public ExponentiallyDecayingReservoir(int size, double alpha, Clock clock) {
+    this(
+        new io.dropwizard.metrics5.ExponentiallyDecayingReservoir(
+            size, alpha, clock.getDelegate()));
+  }
+
+  public ExponentiallyDecayingReservoir(
+      io.dropwizard.metrics5.ExponentiallyDecayingReservoir delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  @Override
+  public io.dropwizard.metrics5.Reservoir getDelegate() {
+    return delegate;
+  }
+
+  @Override
+  public int size() {
+    return delegate.size();
+  }
+
+  @Override
+  public void update(long value) {
+    delegate.update(value);
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    return Snapshot.of(delegate.getSnapshot());
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/FixedNameCsvFileProvider.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/FixedNameCsvFileProvider.java
@@ -5,11 +5,11 @@ import java.io.File;
 @Deprecated
 public class FixedNameCsvFileProvider implements CsvFileProvider {
 
-    private final io.dropwizard.metrics5.FixedNameCsvFileProvider delegate =
-            new io.dropwizard.metrics5.FixedNameCsvFileProvider();
+  private final io.dropwizard.metrics5.FixedNameCsvFileProvider delegate =
+      new io.dropwizard.metrics5.FixedNameCsvFileProvider();
 
-    @Override
-    public File getFile(File directory, String metricName) {
-        return delegate.getFile(directory, metricName);
-    }
+  @Override
+  public File getFile(File directory, String metricName) {
+    return delegate.getFile(directory, metricName);
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Gauge.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Gauge.java
@@ -3,36 +3,36 @@ package com.codahale.metrics;
 @Deprecated
 public interface Gauge<T> extends Metric {
 
-    T getValue();
+  T getValue();
 
-    @Override
-    default io.dropwizard.metrics5.Gauge<T> getDelegate() {
-        return new GaugeAdapter<>(this);
-    }
+  @Override
+  default io.dropwizard.metrics5.Gauge<T> getDelegate() {
+    return new GaugeAdapter<>(this);
+  }
 
-    @SuppressWarnings("unchecked")
-    static <T> Gauge<T> of(io.dropwizard.metrics5.Gauge<T> gauge) {
-        if (gauge instanceof GaugeAdapter) {
-            return ((GaugeAdapter) gauge).delegate;
-        }
-        return gauge::getValue;
+  @SuppressWarnings("unchecked")
+  static <T> Gauge<T> of(io.dropwizard.metrics5.Gauge<T> gauge) {
+    if (gauge instanceof GaugeAdapter) {
+      return ((GaugeAdapter) gauge).delegate;
     }
+    return gauge::getValue;
+  }
 
-    class GaugeAdapter<T> implements io.dropwizard.metrics5.Gauge<T> {
+  class GaugeAdapter<T> implements io.dropwizard.metrics5.Gauge<T> {
 
-        private final Gauge<T> delegate;
+    private final Gauge<T> delegate;
 
-        GaugeAdapter(Gauge<T> gauge) {
-            this.delegate = gauge;
-        }
+    GaugeAdapter(Gauge<T> gauge) {
+      this.delegate = gauge;
+    }
 
-        Gauge<T> getGauge() {
-            return delegate;
-        }
+    Gauge<T> getGauge() {
+      return delegate;
+    }
 
-        @Override
-        public T getValue() {
-            return delegate.getValue();
-        }
+    @Override
+    public T getValue() {
+      return delegate.getValue();
     }
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Histogram.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Histogram.java
@@ -5,36 +5,36 @@ import static java.util.Objects.requireNonNull;
 @Deprecated
 public class Histogram implements Metric, Sampling, Counting {
 
-    private final io.dropwizard.metrics5.Histogram delegate;
-
-    public Histogram(io.dropwizard.metrics5.Histogram delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    public Histogram(Reservoir reservoir) {
-        this.delegate = new io.dropwizard.metrics5.Histogram(reservoir.getDelegate());
-    }
-
-    public void update(int value) {
-        delegate.update(value);
-    }
-
-    public void update(long value) {
-        delegate.update(value);
-    }
-
-    @Override
-    public long getCount() {
-        return delegate.getCount();
-    }
-
-    @Override
-    public Snapshot getSnapshot() {
-        return Snapshot.of(delegate.getSnapshot());
-    }
-
-    @Override
-    public io.dropwizard.metrics5.Histogram getDelegate() {
-        return delegate;
-    }
+  private final io.dropwizard.metrics5.Histogram delegate;
+
+  public Histogram(io.dropwizard.metrics5.Histogram delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  public Histogram(Reservoir reservoir) {
+    this.delegate = new io.dropwizard.metrics5.Histogram(reservoir.getDelegate());
+  }
+
+  public void update(int value) {
+    delegate.update(value);
+  }
+
+  public void update(long value) {
+    delegate.update(value);
+  }
+
+  @Override
+  public long getCount() {
+    return delegate.getCount();
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    return Snapshot.of(delegate.getSnapshot());
+  }
+
+  @Override
+  public io.dropwizard.metrics5.Histogram getDelegate() {
+    return delegate;
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/InstrumentedExecutorService.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/InstrumentedExecutorService.java
@@ -1,5 +1,7 @@
 package com.codahale.metrics;
 
+import static java.util.Objects.requireNonNull;
+
 import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -9,87 +11,93 @@ import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static java.util.Objects.requireNonNull;
-
 @Deprecated
 public class InstrumentedExecutorService implements ExecutorService {
 
-    private final io.dropwizard.metrics5.InstrumentedExecutorService delegate;
-
-    public InstrumentedExecutorService(io.dropwizard.metrics5.InstrumentedExecutorService delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    public InstrumentedExecutorService(ExecutorService delegate, MetricRegistry registry) {
-        this(new io.dropwizard.metrics5.InstrumentedExecutorService(delegate, registry.getDelegate()));
-    }
-
-    public InstrumentedExecutorService(ExecutorService delegate, MetricRegistry registry, String name) {
-        this(new io.dropwizard.metrics5.InstrumentedExecutorService(delegate, registry.getDelegate(), name));
-    }
-
-    @Override
-    public void shutdown() {
-        delegate.shutdown();
-    }
-
-    @Override
-    public List<Runnable> shutdownNow() {
-        return delegate.shutdownNow();
-    }
-
-    @Override
-    public boolean isShutdown() {
-        return delegate.isShutdown();
-    }
-
-    @Override
-    public boolean isTerminated() {
-        return delegate.isTerminated();
-    }
-
-    @Override
-    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-        return delegate.awaitTermination(timeout, unit);
-    }
-
-    @Override
-    public <T> Future<T> submit(Callable<T> task) {
-        return delegate.submit(task);
-    }
-
-    @Override
-    public <T> Future<T> submit(Runnable task, T result) {
-        return delegate.submit(task, result);
-    }
-
-    @Override
-    public Future<?> submit(Runnable task) {
-        return delegate.submit(task);
-    }
-
-    @Override
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
-        return delegate.invokeAll(tasks);
-    }
-
-    @Override
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
-        return delegate.invokeAll(tasks, timeout, unit);
-    }
-
-    @Override
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
-        return delegate.invokeAny(tasks);
-    }
-
-    @Override
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-        return delegate.invokeAny(tasks, timeout, unit);
-    }
-
-    @Override
-    public void execute(Runnable command) {
-        delegate.execute(command);
-    }
+  private final io.dropwizard.metrics5.InstrumentedExecutorService delegate;
+
+  public InstrumentedExecutorService(io.dropwizard.metrics5.InstrumentedExecutorService delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  public InstrumentedExecutorService(ExecutorService delegate, MetricRegistry registry) {
+    this(new io.dropwizard.metrics5.InstrumentedExecutorService(delegate, registry.getDelegate()));
+  }
+
+  public InstrumentedExecutorService(
+      ExecutorService delegate, MetricRegistry registry, String name) {
+    this(
+        new io.dropwizard.metrics5.InstrumentedExecutorService(
+            delegate, registry.getDelegate(), name));
+  }
+
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
+  }
+
+  @Override
+  public List<Runnable> shutdownNow() {
+    return delegate.shutdownNow();
+  }
+
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
+
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
+  }
+
+  @Override
+  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
+    return delegate.awaitTermination(timeout, unit);
+  }
+
+  @Override
+  public <T> Future<T> submit(Callable<T> task) {
+    return delegate.submit(task);
+  }
+
+  @Override
+  public <T> Future<T> submit(Runnable task, T result) {
+    return delegate.submit(task, result);
+  }
+
+  @Override
+  public Future<?> submit(Runnable task) {
+    return delegate.submit(task);
+  }
+
+  @Override
+  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks);
+  }
+
+  @Override
+  public <T> List<Future<T>> invokeAll(
+      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks, timeout, unit);
+  }
+
+  @Override
+  public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
+      throws InterruptedException, ExecutionException {
+    return delegate.invokeAny(tasks);
+  }
+
+  @Override
+  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+      throws InterruptedException, ExecutionException, TimeoutException {
+    return delegate.invokeAny(tasks, timeout, unit);
+  }
+
+  @Override
+  public void execute(Runnable command) {
+    delegate.execute(command);
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/InstrumentedScheduledExecutorService.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/InstrumentedScheduledExecutorService.java
@@ -1,5 +1,7 @@
 package com.codahale.metrics;
 
+import static java.util.Objects.requireNonNull;
+
 import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -10,107 +12,119 @@ import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static java.util.Objects.requireNonNull;
-
 @Deprecated
 public class InstrumentedScheduledExecutorService implements ScheduledExecutorService {
 
-    private final io.dropwizard.metrics5.InstrumentedScheduledExecutorService delegate;
-
-    public InstrumentedScheduledExecutorService(io.dropwizard.metrics5.InstrumentedScheduledExecutorService delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    public InstrumentedScheduledExecutorService(ScheduledExecutorService delegate, MetricRegistry registry) {
-        this(new io.dropwizard.metrics5.InstrumentedScheduledExecutorService(delegate, registry.getDelegate()));
-    }
-
-    public InstrumentedScheduledExecutorService(ScheduledExecutorService delegate, MetricRegistry registry, String name) {
-        this(new io.dropwizard.metrics5.InstrumentedScheduledExecutorService(delegate, registry.getDelegate(), name));
-    }
-
-    @Override
-    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
-        return delegate.schedule(command, delay, unit);
-    }
-
-    @Override
-    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
-        return delegate.schedule(callable, delay, unit);
-    }
-
-    @Override
-    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
-        return delegate.scheduleAtFixedRate(command, initialDelay, period, unit);
-    }
-
-    @Override
-    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
-        return delegate.scheduleWithFixedDelay(command, initialDelay, delay, unit);
-    }
-
-    @Override
-    public void shutdown() {
-        delegate.shutdown();
-    }
-
-    @Override
-    public List<Runnable> shutdownNow() {
-        return delegate.shutdownNow();
-    }
-
-    @Override
-    public boolean isShutdown() {
-        return delegate.isShutdown();
-    }
-
-    @Override
-    public boolean isTerminated() {
-        return delegate.isTerminated();
-    }
-
-    @Override
-    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-        return delegate.awaitTermination(timeout, unit);
-    }
-
-    @Override
-    public <T> Future<T> submit(Callable<T> task) {
-        return delegate.submit(task);
-    }
-
-    @Override
-    public <T> Future<T> submit(Runnable task, T result) {
-        return delegate.submit(task, result);
-    }
-
-    @Override
-    public Future<?> submit(Runnable task) {
-        return delegate.submit(task);
-    }
-
-    @Override
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
-        return delegate.invokeAll(tasks);
-    }
-
-    @Override
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
-        return delegate.invokeAll(tasks, timeout, unit);
-    }
-
-    @Override
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
-        return delegate.invokeAny(tasks);
-    }
-
-    @Override
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-        return delegate.invokeAny(tasks, timeout, unit);
-    }
-
-    @Override
-    public void execute(Runnable command) {
-        delegate.execute(command);
-    }
+  private final io.dropwizard.metrics5.InstrumentedScheduledExecutorService delegate;
+
+  public InstrumentedScheduledExecutorService(
+      io.dropwizard.metrics5.InstrumentedScheduledExecutorService delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  public InstrumentedScheduledExecutorService(
+      ScheduledExecutorService delegate, MetricRegistry registry) {
+    this(
+        new io.dropwizard.metrics5.InstrumentedScheduledExecutorService(
+            delegate, registry.getDelegate()));
+  }
+
+  public InstrumentedScheduledExecutorService(
+      ScheduledExecutorService delegate, MetricRegistry registry, String name) {
+    this(
+        new io.dropwizard.metrics5.InstrumentedScheduledExecutorService(
+            delegate, registry.getDelegate(), name));
+  }
+
+  @Override
+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
+    return delegate.schedule(command, delay, unit);
+  }
+
+  @Override
+  public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
+    return delegate.schedule(callable, delay, unit);
+  }
+
+  @Override
+  public ScheduledFuture<?> scheduleAtFixedRate(
+      Runnable command, long initialDelay, long period, TimeUnit unit) {
+    return delegate.scheduleAtFixedRate(command, initialDelay, period, unit);
+  }
+
+  @Override
+  public ScheduledFuture<?> scheduleWithFixedDelay(
+      Runnable command, long initialDelay, long delay, TimeUnit unit) {
+    return delegate.scheduleWithFixedDelay(command, initialDelay, delay, unit);
+  }
+
+  @Override
+  public void shutdown() {
+    delegate.shutdown();
+  }
+
+  @Override
+  public List<Runnable> shutdownNow() {
+    return delegate.shutdownNow();
+  }
+
+  @Override
+  public boolean isShutdown() {
+    return delegate.isShutdown();
+  }
+
+  @Override
+  public boolean isTerminated() {
+    return delegate.isTerminated();
+  }
+
+  @Override
+  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
+    return delegate.awaitTermination(timeout, unit);
+  }
+
+  @Override
+  public <T> Future<T> submit(Callable<T> task) {
+    return delegate.submit(task);
+  }
+
+  @Override
+  public <T> Future<T> submit(Runnable task, T result) {
+    return delegate.submit(task, result);
+  }
+
+  @Override
+  public Future<?> submit(Runnable task) {
+    return delegate.submit(task);
+  }
+
+  @Override
+  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks);
+  }
+
+  @Override
+  public <T> List<Future<T>> invokeAll(
+      Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+      throws InterruptedException {
+    return delegate.invokeAll(tasks, timeout, unit);
+  }
+
+  @Override
+  public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
+      throws InterruptedException, ExecutionException {
+    return delegate.invokeAny(tasks);
+  }
+
+  @Override
+  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+      throws InterruptedException, ExecutionException, TimeoutException {
+    return delegate.invokeAny(tasks, timeout, unit);
+  }
+
+  @Override
+  public void execute(Runnable command) {
+    delegate.execute(command);
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/InstrumentedThreadFactory.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/InstrumentedThreadFactory.java
@@ -1,28 +1,30 @@
 package com.codahale.metrics;
 
-import java.util.concurrent.ThreadFactory;
-
 import static java.util.Objects.requireNonNull;
 
+import java.util.concurrent.ThreadFactory;
+
 @Deprecated
 public class InstrumentedThreadFactory implements ThreadFactory {
 
-    private final io.dropwizard.metrics5.InstrumentedThreadFactory delegate;
+  private final io.dropwizard.metrics5.InstrumentedThreadFactory delegate;
 
-    public InstrumentedThreadFactory(io.dropwizard.metrics5.InstrumentedThreadFactory delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
+  public InstrumentedThreadFactory(io.dropwizard.metrics5.InstrumentedThreadFactory delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
 
-    public InstrumentedThreadFactory(ThreadFactory delegate, MetricRegistry registry) {
-        this(new io.dropwizard.metrics5.InstrumentedThreadFactory(delegate, registry.getDelegate()));
-    }
+  public InstrumentedThreadFactory(ThreadFactory delegate, MetricRegistry registry) {
+    this(new io.dropwizard.metrics5.InstrumentedThreadFactory(delegate, registry.getDelegate()));
+  }
 
-    public InstrumentedThreadFactory(ThreadFactory delegate, MetricRegistry registry, String name) {
-        this(new io.dropwizard.metrics5.InstrumentedThreadFactory(delegate, registry.getDelegate(), name));
-    }
+  public InstrumentedThreadFactory(ThreadFactory delegate, MetricRegistry registry, String name) {
+    this(
+        new io.dropwizard.metrics5.InstrumentedThreadFactory(
+            delegate, registry.getDelegate(), name));
+  }
 
-    @Override
-    public Thread newThread(Runnable r) {
-        return delegate.newThread(r);
-    }
+  @Override
+  public Thread newThread(Runnable r) {
+    return delegate.newThread(r);
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Meter.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Meter.java
@@ -5,55 +5,55 @@ import static java.util.Objects.requireNonNull;
 @Deprecated
 public class Meter implements Metered {
 
-    private final io.dropwizard.metrics5.Meter delegate;
-
-    public Meter() {
-        this(new io.dropwizard.metrics5.Meter());
-    }
-
-    public Meter(Clock clock) {
-        this(new io.dropwizard.metrics5.Meter(clock.getDelegate()));
-    }
-
-    public Meter(io.dropwizard.metrics5.Meter delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    public void mark() {
-        delegate.mark();
-    }
-
-    public void mark(long n) {
-        delegate.mark(n);
-    }
-
-    @Override
-    public long getCount() {
-        return delegate.getCount();
-    }
-
-    @Override
-    public double getFifteenMinuteRate() {
-        return delegate.getFifteenMinuteRate();
-    }
-
-    @Override
-    public double getFiveMinuteRate() {
-        return delegate.getFiveMinuteRate();
-    }
-
-    @Override
-    public double getMeanRate() {
-        return delegate.getMeanRate();
-    }
-
-    @Override
-    public double getOneMinuteRate() {
-        return delegate.getOneMinuteRate();
-    }
-
-    @Override
-    public io.dropwizard.metrics5.Meter getDelegate() {
-        return delegate;
-    }
+  private final io.dropwizard.metrics5.Meter delegate;
+
+  public Meter() {
+    this(new io.dropwizard.metrics5.Meter());
+  }
+
+  public Meter(Clock clock) {
+    this(new io.dropwizard.metrics5.Meter(clock.getDelegate()));
+  }
+
+  public Meter(io.dropwizard.metrics5.Meter delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  public void mark() {
+    delegate.mark();
+  }
+
+  public void mark(long n) {
+    delegate.mark(n);
+  }
+
+  @Override
+  public long getCount() {
+    return delegate.getCount();
+  }
+
+  @Override
+  public double getFifteenMinuteRate() {
+    return delegate.getFifteenMinuteRate();
+  }
+
+  @Override
+  public double getFiveMinuteRate() {
+    return delegate.getFiveMinuteRate();
+  }
+
+  @Override
+  public double getMeanRate() {
+    return delegate.getMeanRate();
+  }
+
+  @Override
+  public double getOneMinuteRate() {
+    return delegate.getOneMinuteRate();
+  }
+
+  @Override
+  public io.dropwizard.metrics5.Meter getDelegate() {
+    return delegate;
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Metered.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Metered.java
@@ -3,14 +3,14 @@ package com.codahale.metrics;
 @Deprecated
 public interface Metered extends Metric, Counting {
 
-    @Override
-    long getCount();
+  @Override
+  long getCount();
 
-    double getFifteenMinuteRate();
+  double getFifteenMinuteRate();
 
-    double getFiveMinuteRate();
+  double getFiveMinuteRate();
 
-    double getMeanRate();
+  double getMeanRate();
 
-    double getOneMinuteRate();
+  double getOneMinuteRate();
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Metric.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Metric.java
@@ -3,24 +3,25 @@ package com.codahale.metrics;
 @Deprecated
 public interface Metric {
 
-    io.dropwizard.metrics5.Metric getDelegate();
+  io.dropwizard.metrics5.Metric getDelegate();
 
-    @SuppressWarnings("unchecked")
-    static Metric of(io.dropwizard.metrics5.Metric metric) {
-        if (metric instanceof io.dropwizard.metrics5.Counter) {
-            return new Counter((io.dropwizard.metrics5.Counter) metric);
-        } else if (metric instanceof io.dropwizard.metrics5.Histogram) {
-            return new Histogram((io.dropwizard.metrics5.Histogram) metric);
-        } else if (metric instanceof io.dropwizard.metrics5.Meter) {
-            return new Meter((io.dropwizard.metrics5.Meter) metric);
-        } else if (metric instanceof io.dropwizard.metrics5.Timer) {
-            return new Timer((io.dropwizard.metrics5.Timer) metric);
-        } else if (metric instanceof io.dropwizard.metrics5.Gauge) {
-            return Gauge.of((io.dropwizard.metrics5.Gauge) metric);
-        } else if (metric instanceof io.dropwizard.metrics5.MetricSet) {
-            return MetricSet.of((io.dropwizard.metrics5.MetricSet) metric);
-        } else {
-            throw new IllegalArgumentException("Can't find adaptor class for metric of type: " + metric.getClass().getName());
-        }
+  @SuppressWarnings("unchecked")
+  static Metric of(io.dropwizard.metrics5.Metric metric) {
+    if (metric instanceof io.dropwizard.metrics5.Counter) {
+      return new Counter((io.dropwizard.metrics5.Counter) metric);
+    } else if (metric instanceof io.dropwizard.metrics5.Histogram) {
+      return new Histogram((io.dropwizard.metrics5.Histogram) metric);
+    } else if (metric instanceof io.dropwizard.metrics5.Meter) {
+      return new Meter((io.dropwizard.metrics5.Meter) metric);
+    } else if (metric instanceof io.dropwizard.metrics5.Timer) {
+      return new Timer((io.dropwizard.metrics5.Timer) metric);
+    } else if (metric instanceof io.dropwizard.metrics5.Gauge) {
+      return Gauge.of((io.dropwizard.metrics5.Gauge) metric);
+    } else if (metric instanceof io.dropwizard.metrics5.MetricSet) {
+      return MetricSet.of((io.dropwizard.metrics5.MetricSet) metric);
+    } else {
+      throw new IllegalArgumentException(
+          "Can't find adaptor class for metric of type: " + metric.getClass().getName());
     }
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricAttribute.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricAttribute.java
@@ -5,40 +5,40 @@ import java.util.Set;
 
 @Deprecated
 public enum MetricAttribute {
+  MAX("max"),
+  MEAN("mean"),
+  MIN("min"),
+  STDDEV("stddev"),
+  P50("p50"),
+  P75("p75"),
+  P95("p95"),
+  P98("p98"),
+  P99("p99"),
+  P999("p999"),
+  COUNT("count"),
+  SUM("sum"),
+  M1_RATE("m1_rate"),
+  M5_RATE("m5_rate"),
+  M15_RATE("m15_rate"),
+  MEAN_RATE("mean_rate");
 
-    MAX("max"),
-    MEAN("mean"),
-    MIN("min"),
-    STDDEV("stddev"),
-    P50("p50"),
-    P75("p75"),
-    P95("p95"),
-    P98("p98"),
-    P99("p99"),
-    P999("p999"),
-    COUNT("count"),
-    SUM("sum"),
-    M1_RATE("m1_rate"),
-    M5_RATE("m5_rate"),
-    M15_RATE("m15_rate"),
-    MEAN_RATE("mean_rate");
+  private final String code;
 
-    private final String code;
+  MetricAttribute(String code) {
+    this.code = code;
+  }
 
-    MetricAttribute(String code) {
-        this.code = code;
-    }
-
-    public String getCode() {
-        return code;
-    }
+  public String getCode() {
+    return code;
+  }
 
-    public static Set<io.dropwizard.metrics5.MetricAttribute> transform(Set<MetricAttribute> metricAttributes) {
-        EnumSet<io.dropwizard.metrics5.MetricAttribute> newAttributes = EnumSet.noneOf(
-                io.dropwizard.metrics5.MetricAttribute.class);
-        for (MetricAttribute ma : metricAttributes) {
-            newAttributes.add(io.dropwizard.metrics5.MetricAttribute.valueOf(ma.name()));
-        }
-        return newAttributes;
+  public static Set<io.dropwizard.metrics5.MetricAttribute> transform(
+      Set<MetricAttribute> metricAttributes) {
+    EnumSet<io.dropwizard.metrics5.MetricAttribute> newAttributes =
+        EnumSet.noneOf(io.dropwizard.metrics5.MetricAttribute.class);
+    for (MetricAttribute ma : metricAttributes) {
+      newAttributes.add(io.dropwizard.metrics5.MetricAttribute.valueOf(ma.name()));
     }
+    return newAttributes;
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricFilter.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricFilter.java
@@ -3,24 +3,24 @@ package com.codahale.metrics;
 @Deprecated
 public interface MetricFilter {
 
-    MetricFilter ALL = (name, metric) -> true;
+  MetricFilter ALL = (name, metric) -> true;
 
-    static MetricFilter startsWith(String prefix) {
-        return (name, metric) -> name.startsWith(prefix);
-    }
+  static MetricFilter startsWith(String prefix) {
+    return (name, metric) -> name.startsWith(prefix);
+  }
 
-    static MetricFilter endsWith(String suffix) {
-        return (name, metric) -> name.endsWith(suffix);
-    }
+  static MetricFilter endsWith(String suffix) {
+    return (name, metric) -> name.endsWith(suffix);
+  }
 
-    static MetricFilter contains(String substring) {
-        return (name, metric) -> name.contains(substring);
-    }
+  static MetricFilter contains(String substring) {
+    return (name, metric) -> name.contains(substring);
+  }
 
-    boolean matches(String name, Metric metric);
+  boolean matches(String name, Metric metric);
 
-    default io.dropwizard.metrics5.MetricFilter transform() {
-        final MetricFilter origin = this;
-        return (name, metric) -> origin.matches(name.getKey(), Metric.of(metric));
-    }
+  default io.dropwizard.metrics5.MetricFilter transform() {
+    final MetricFilter origin = this;
+    return (name, metric) -> origin.matches(name.getKey(), Metric.of(metric));
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricRegistry.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricRegistry.java
@@ -1,184 +1,181 @@
 package com.codahale.metrics;
 
-import io.dropwizard.metrics5.MetricName;
+import static java.util.Collections.unmodifiableSortedMap;
+import static java.util.Collections.unmodifiableSortedSet;
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toCollection;
 
-import java.util.Collections;
+import io.dropwizard.metrics5.MetricName;
 import java.util.Map;
-import java.util.Objects;
 import java.util.SortedMap;
 import java.util.SortedSet;
 import java.util.TreeMap;
 import java.util.TreeSet;
-import java.util.stream.Collectors;
-
-import static java.util.Collections.unmodifiableSortedSet;
-import static java.util.Objects.requireNonNull;
 
 @Deprecated
 public class MetricRegistry implements MetricSet {
 
-    private final io.dropwizard.metrics5.MetricRegistry delegate;
+  private final io.dropwizard.metrics5.MetricRegistry delegate;
 
-    public static String name(Class<?> klass, String... names) {
-        return io.dropwizard.metrics5.MetricRegistry.name(klass, names).getKey();
-    }
+  public static String name(Class<?> klass, String... names) {
+    return io.dropwizard.metrics5.MetricRegistry.name(klass, names).getKey();
+  }
 
-    public static String name(String name, String... names) {
-        return io.dropwizard.metrics5.MetricRegistry.name(name, names).getKey();
-    }
+  public static String name(String name, String... names) {
+    return io.dropwizard.metrics5.MetricRegistry.name(name, names).getKey();
+  }
 
-    public MetricRegistry() {
-        this(new io.dropwizard.metrics5.MetricRegistry());
-    }
+  public MetricRegistry() {
+    this(new io.dropwizard.metrics5.MetricRegistry());
+  }
 
-    public MetricRegistry(io.dropwizard.metrics5.MetricRegistry delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
+  public MetricRegistry(io.dropwizard.metrics5.MetricRegistry delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
 
-    public <T> Gauge<T> registerGauge(String name, Gauge<T> metric) throws IllegalArgumentException {
-        delegate.registerGauge(MetricName.build(name), metric.getDelegate());
-        return metric;
-    }
+  public <T> Gauge<T> registerGauge(String name, Gauge<T> metric) throws IllegalArgumentException {
+    delegate.registerGauge(MetricName.build(name), metric.getDelegate());
+    return metric;
+  }
 
-    public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException {
-        delegate.register(MetricName.build(name), metric.getDelegate());
-        return metric;
-    }
+  public <T extends Metric> T register(String name, T metric) throws IllegalArgumentException {
+    delegate.register(MetricName.build(name), metric.getDelegate());
+    return metric;
+  }
 
-    public void registerAll(MetricSet metrics) throws IllegalArgumentException {
-        delegate.registerAll(metrics.getDelegate());
-    }
+  public void registerAll(MetricSet metrics) throws IllegalArgumentException {
+    delegate.registerAll(metrics.getDelegate());
+  }
 
-    @SuppressWarnings("unchecked")
-    public Gauge gauge(String name, MetricSupplier<Gauge> supplier) {
-        return Gauge.of(delegate.gauge(MetricName.build(name), supplier.transform()));
-    }
+  @SuppressWarnings("unchecked")
+  public Gauge gauge(String name, MetricSupplier<Gauge> supplier) {
+    return Gauge.of(delegate.gauge(MetricName.build(name), supplier.transform()));
+  }
 
-    public Counter counter(String name) {
-        return new Counter(delegate.counter(name));
-    }
+  public Counter counter(String name) {
+    return new Counter(delegate.counter(name));
+  }
+
+  public Counter counter(String name, MetricSupplier<Counter> supplier) {
+    return new Counter(delegate.counter(MetricName.build(name), supplier.transform()));
+  }
+
+  public Histogram histogram(String name) {
+    return new Histogram(delegate.histogram(MetricName.build(name)));
+  }
+
+  public Histogram histogram(String name, MetricSupplier<Histogram> supplier) {
+    return new Histogram(delegate.histogram(MetricName.build(name), supplier.transform()));
+  }
+
+  public Meter meter(String name) {
+    return new Meter(delegate.meter(MetricName.build(name)));
+  }
 
-    public Counter counter(String name, MetricSupplier<Counter> supplier) {
-        return new Counter(delegate.counter(MetricName.build(name), supplier.transform()));
-    }
+  public Meter meter(String name, MetricSupplier<Meter> supplier) {
+    return new Meter(delegate.meter(MetricName.build(name), supplier.transform()));
+  }
 
-    public Histogram histogram(String name) {
-        return new Histogram(delegate.histogram(MetricName.build(name)));
-    }
+  public Timer timer(String name) {
+    return new Timer(delegate.timer(MetricName.build(name)));
+  }
 
-    public Histogram histogram(String name, MetricSupplier<Histogram> supplier) {
-        return new Histogram(delegate.histogram(MetricName.build(name), supplier.transform()));
-    }
+  public Timer timer(String name, MetricSupplier<Timer> supplier) {
+    return new Timer(delegate.timer(MetricName.build(name), supplier.transform()));
+  }
 
-    public Meter meter(String name) {
-        return new Meter(delegate.meter(MetricName.build(name)));
-    }
+  public boolean remove(String name) {
+    return delegate.remove(MetricName.build(name));
+  }
 
-    public Meter meter(String name, MetricSupplier<Meter> supplier) {
-        return new Meter(delegate.meter(MetricName.build(name), supplier.transform()));
-    }
+  public void removeMatching(MetricFilter filter) {
+    delegate.removeMatching(filter.transform());
+  }
 
-    public Timer timer(String name) {
-        return new Timer(delegate.timer(MetricName.build(name)));
-    }
+  public void addListener(MetricRegistryListener listener) {
+    delegate.addListener(new MetricRegistryListener.Adapter(listener));
+  }
 
-    public Timer timer(String name, MetricSupplier<Timer> supplier) {
-        return new Timer(delegate.timer(MetricName.build(name), supplier.transform()));
-    }
+  public void removeListener(MetricRegistryListener listener) {
+    delegate.removeListener(new MetricRegistryListener.Adapter(listener));
+  }
 
-    public boolean remove(String name) {
-        return delegate.remove(MetricName.build(name));
-    }
+  public SortedSet<String> getNames() {
+    return unmodifiableSortedSet(
+        delegate.getNames().stream().map(MetricName::getKey).collect(toCollection(TreeSet::new)));
+  }
 
-    public void removeMatching(MetricFilter filter) {
-        delegate.removeMatching(filter.transform());
-    }
+  public SortedMap<String, Gauge> getGauges() {
+    return adaptMetrics(delegate.getGauges());
+  }
 
-    public void addListener(MetricRegistryListener listener) {
-        delegate.addListener(new MetricRegistryListener.Adapter(listener));
-    }
+  public SortedMap<String, Gauge> getGauges(MetricFilter filter) {
+    return adaptMetrics(delegate.getGauges(filter.transform()));
+  }
 
-    public void removeListener(MetricRegistryListener listener) {
-        delegate.removeListener(new MetricRegistryListener.Adapter(listener));
-    }
+  public SortedMap<String, Counter> getCounters() {
+    return adaptMetrics(delegate.getCounters());
+  }
 
-    public SortedSet<String> getNames() {
-        return unmodifiableSortedSet(delegate.getNames()
-                .stream()
-                .map(MetricName::getKey)
-                .collect(Collectors.toCollection(TreeSet::new)));
-    }
+  public SortedMap<String, Counter> getCounters(MetricFilter filter) {
+    return adaptMetrics(delegate.getCounters(filter.transform()));
+  }
 
-    public SortedMap<String, Gauge> getGauges() {
-        return adaptMetrics(delegate.getGauges());
-    }
+  public SortedMap<String, Histogram> getHistograms() {
+    return adaptMetrics(delegate.getHistograms());
+  }
 
-    public SortedMap<String, Gauge> getGauges(MetricFilter filter) {
-        return adaptMetrics(delegate.getGauges(filter.transform()));
-    }
+  public SortedMap<String, Histogram> getHistograms(MetricFilter filter) {
+    return adaptMetrics(delegate.getHistograms(filter.transform()));
+  }
 
-    public SortedMap<String, Counter> getCounters() {
-        return adaptMetrics(delegate.getCounters());
-    }
+  public SortedMap<String, Meter> getMeters() {
+    return adaptMetrics(delegate.getMeters());
+  }
 
-    public SortedMap<String, Counter> getCounters(MetricFilter filter) {
-        return adaptMetrics(delegate.getCounters(filter.transform()));
-    }
+  public SortedMap<String, Meter> getMeters(MetricFilter filter) {
+    return adaptMetrics(delegate.getMeters(filter.transform()));
+  }
 
-    public SortedMap<String, Histogram> getHistograms() {
-        return adaptMetrics(delegate.getHistograms());
-    }
+  public SortedMap<String, Timer> getTimers() {
+    return adaptMetrics(delegate.getTimers());
+  }
 
-    public SortedMap<String, Histogram> getHistograms(MetricFilter filter) {
-        return adaptMetrics(delegate.getHistograms(filter.transform()));
-    }
+  public SortedMap<String, Timer> getTimers(MetricFilter filter) {
+    return adaptMetrics(delegate.getTimers(filter.transform()));
+  }
 
-    public SortedMap<String, Meter> getMeters() {
-        return adaptMetrics(delegate.getMeters());
-    }
+  @Override
+  public Map<String, Metric> getMetrics() {
+    return adaptMetrics(delegate.getMetrics());
+  }
 
-    public SortedMap<String, Meter> getMeters(MetricFilter filter) {
-        return adaptMetrics(delegate.getMeters(filter.transform()));
+  @SuppressWarnings("unchecked")
+  static <T extends Metric> SortedMap<String, T> adaptMetrics(
+      Map<MetricName, ? extends io.dropwizard.metrics5.Metric> metrics) {
+    final SortedMap<String, T> items = new TreeMap<>();
+    for (Map.Entry<MetricName, ? extends io.dropwizard.metrics5.Metric> entry :
+        metrics.entrySet()) {
+      items.put(entry.getKey().getKey(), (T) Metric.of(entry.getValue()));
     }
+    return unmodifiableSortedMap(items);
+  }
 
-    public SortedMap<String, Timer> getTimers() {
-        return adaptMetrics(delegate.getTimers());
-    }
+  @Override
+  public io.dropwizard.metrics5.MetricRegistry getDelegate() {
+    return delegate;
+  }
 
-    public SortedMap<String, Timer> getTimers(MetricFilter filter) {
-        return adaptMetrics(delegate.getTimers(filter.transform()));
-    }
+  @FunctionalInterface
+  public interface MetricSupplier<T extends Metric> {
 
-    @Override
-    public Map<String, Metric> getMetrics() {
-        return adaptMetrics(delegate.getMetrics());
-    }
+    T newMetric();
 
     @SuppressWarnings("unchecked")
-    static <T extends Metric> SortedMap<String, T> adaptMetrics(
-            Map<MetricName, ? extends io.dropwizard.metrics5.Metric> metrics) {
-        final SortedMap<String, T> items = new TreeMap<>();
-        for (Map.Entry<MetricName, ? extends io.dropwizard.metrics5.Metric> entry : metrics.entrySet()) {
-            items.put(entry.getKey().getKey(), (T) Metric.of(entry.getValue()));
-        }
-        return Collections.unmodifiableSortedMap(items);
-    }
-
-    @Override
-    public io.dropwizard.metrics5.MetricRegistry getDelegate() {
-        return delegate;
-    }
-
-    @FunctionalInterface
-    public interface MetricSupplier<T extends Metric> {
-
-        T newMetric();
-
-        @SuppressWarnings("unchecked")
-        default <M extends io.dropwizard.metrics5.Metric>
+    default <M extends io.dropwizard.metrics5.Metric>
         io.dropwizard.metrics5.MetricRegistry.MetricSupplier<M> transform() {
-            MetricSupplier<T> original = this;
-            return () -> (M) original.newMetric().getDelegate();
-        }
+      MetricSupplier<T> original = this;
+      return () -> (M) original.newMetric().getDelegate();
     }
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricRegistryListener.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricRegistryListener.java
@@ -1,144 +1,133 @@
 package com.codahale.metrics;
 
 import io.dropwizard.metrics5.MetricName;
-
 import java.util.EventListener;
 
 @Deprecated
 public interface MetricRegistryListener extends EventListener {
 
-    abstract class Base implements MetricRegistryListener {
-        @Override
-        public void onGaugeAdded(String name, Gauge<?> gauge) {
-        }
+  abstract class Base implements MetricRegistryListener {
+    @Override
+    public void onGaugeAdded(String name, Gauge<?> gauge) {}
 
-        @Override
-        public void onGaugeRemoved(String name) {
-        }
+    @Override
+    public void onGaugeRemoved(String name) {}
 
-        @Override
-        public void onCounterAdded(String name, Counter counter) {
-        }
+    @Override
+    public void onCounterAdded(String name, Counter counter) {}
 
-        @Override
-        public void onCounterRemoved(String name) {
-        }
+    @Override
+    public void onCounterRemoved(String name) {}
 
-        @Override
-        public void onHistogramAdded(String name, Histogram histogram) {
-        }
+    @Override
+    public void onHistogramAdded(String name, Histogram histogram) {}
 
-        @Override
-        public void onHistogramRemoved(String name) {
-        }
+    @Override
+    public void onHistogramRemoved(String name) {}
 
-        @Override
-        public void onMeterAdded(String name, Meter meter) {
-        }
+    @Override
+    public void onMeterAdded(String name, Meter meter) {}
 
-        @Override
-        public void onMeterRemoved(String name) {
-        }
+    @Override
+    public void onMeterRemoved(String name) {}
 
-        @Override
-        public void onTimerAdded(String name, Timer timer) {
-        }
+    @Override
+    public void onTimerAdded(String name, Timer timer) {}
 
-        @Override
-        public void onTimerRemoved(String name) {
-        }
-    }
+    @Override
+    public void onTimerRemoved(String name) {}
+  }
 
-    void onGaugeAdded(String name, Gauge<?> gauge);
+  void onGaugeAdded(String name, Gauge<?> gauge);
 
-    void onGaugeRemoved(String name);
+  void onGaugeRemoved(String name);
 
-    void onCounterAdded(String name, Counter counter);
+  void onCounterAdded(String name, Counter counter);
 
-    void onCounterRemoved(String name);
+  void onCounterRemoved(String name);
 
-    void onHistogramAdded(String name, Histogram histogram);
+  void onHistogramAdded(String name, Histogram histogram);
 
-    void onHistogramRemoved(String name);
+  void onHistogramRemoved(String name);
 
-    void onMeterAdded(String name, Meter meter);
+  void onMeterAdded(String name, Meter meter);
 
-    void onMeterRemoved(String name);
+  void onMeterRemoved(String name);
 
-    void onTimerAdded(String name, Timer timer);
+  void onTimerAdded(String name, Timer timer);
 
-    void onTimerRemoved(String name);
+  void onTimerRemoved(String name);
 
-    class Adapter implements io.dropwizard.metrics5.MetricRegistryListener {
+  class Adapter implements io.dropwizard.metrics5.MetricRegistryListener {
 
-        private MetricRegistryListener delegate;
+    private MetricRegistryListener delegate;
 
-        public Adapter(MetricRegistryListener delegate) {
-            this.delegate = delegate;
-        }
+    public Adapter(MetricRegistryListener delegate) {
+      this.delegate = delegate;
+    }
 
-        @Override
-        public void onGaugeAdded(MetricName name, io.dropwizard.metrics5.Gauge<?> gauge) {
-            delegate.onGaugeAdded(name.getKey(), Gauge.of(gauge));
-        }
+    @Override
+    public void onGaugeAdded(MetricName name, io.dropwizard.metrics5.Gauge<?> gauge) {
+      delegate.onGaugeAdded(name.getKey(), Gauge.of(gauge));
+    }
 
-        @Override
-        public void onGaugeRemoved(MetricName name) {
-            delegate.onGaugeRemoved(name.getKey());
-        }
+    @Override
+    public void onGaugeRemoved(MetricName name) {
+      delegate.onGaugeRemoved(name.getKey());
+    }
 
-        @Override
-        public void onCounterAdded(MetricName name, io.dropwizard.metrics5.Counter counter) {
-            delegate.onCounterAdded(name.getKey(), new Counter(counter));
-        }
+    @Override
+    public void onCounterAdded(MetricName name, io.dropwizard.metrics5.Counter counter) {
+      delegate.onCounterAdded(name.getKey(), new Counter(counter));
+    }
 
-        @Override
-        public void onCounterRemoved(MetricName name) {
-            delegate.onCounterRemoved(name.getKey());
-        }
+    @Override
+    public void onCounterRemoved(MetricName name) {
+      delegate.onCounterRemoved(name.getKey());
+    }
 
-        @Override
-        public void onHistogramAdded(MetricName name, io.dropwizard.metrics5.Histogram histogram) {
-            delegate.onHistogramAdded(name.getKey(), new Histogram(histogram));
-        }
+    @Override
+    public void onHistogramAdded(MetricName name, io.dropwizard.metrics5.Histogram histogram) {
+      delegate.onHistogramAdded(name.getKey(), new Histogram(histogram));
+    }
 
-        @Override
-        public void onHistogramRemoved(MetricName name) {
-            delegate.onHistogramRemoved(name.getKey());
-        }
+    @Override
+    public void onHistogramRemoved(MetricName name) {
+      delegate.onHistogramRemoved(name.getKey());
+    }
 
-        @Override
-        public void onMeterAdded(MetricName name, io.dropwizard.metrics5.Meter meter) {
-            delegate.onMeterAdded(name.getKey(), new Meter(meter));
-        }
+    @Override
+    public void onMeterAdded(MetricName name, io.dropwizard.metrics5.Meter meter) {
+      delegate.onMeterAdded(name.getKey(), new Meter(meter));
+    }
 
-        @Override
-        public void onMeterRemoved(MetricName name) {
-            delegate.onMeterRemoved(name.getKey());
-        }
+    @Override
+    public void onMeterRemoved(MetricName name) {
+      delegate.onMeterRemoved(name.getKey());
+    }
 
-        @Override
-        public void onTimerAdded(MetricName name, io.dropwizard.metrics5.Timer timer) {
-            delegate.onTimerAdded(name.getKey(), new Timer(timer));
-        }
+    @Override
+    public void onTimerAdded(MetricName name, io.dropwizard.metrics5.Timer timer) {
+      delegate.onTimerAdded(name.getKey(), new Timer(timer));
+    }
 
-        @Override
-        public void onTimerRemoved(MetricName name) {
-            delegate.onTimerRemoved(name.getKey());
-        }
+    @Override
+    public void onTimerRemoved(MetricName name) {
+      delegate.onTimerRemoved(name.getKey());
+    }
 
-        @Override
-        public boolean equals(Object o) {
-            if (o instanceof Adapter) {
-                Adapter adapter = (Adapter) o;
-                return delegate.equals(adapter.delegate);
-            }
-            return false;
-        }
+    @Override
+    public boolean equals(Object o) {
+      if (o instanceof Adapter) {
+        Adapter adapter = (Adapter) o;
+        return delegate.equals(adapter.delegate);
+      }
+      return false;
+    }
 
-        @Override
-        public int hashCode() {
-            return delegate.hashCode();
-        }
+    @Override
+    public int hashCode() {
+      return delegate.hashCode();
     }
-}
\ No newline at end of file
+  }
+}
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricSet.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/MetricSet.java
@@ -1,55 +1,55 @@
 package com.codahale.metrics;
 
-import io.dropwizard.metrics5.MetricName;
+import static java.util.Collections.unmodifiableMap;
 
-import java.util.Collections;
+import io.dropwizard.metrics5.MetricName;
 import java.util.HashMap;
 import java.util.Map;
 
 @Deprecated
 public interface MetricSet extends Metric {
 
-    Map<String, Metric> getMetrics();
-
-    @Override
-    default io.dropwizard.metrics5.MetricSet getDelegate() {
-        return new Adapter(this);
-    }
-
-    static MetricSet of(io.dropwizard.metrics5.MetricSet original) {
-        return new MetricSet() {
-            @Override
-            public Map<String, Metric> getMetrics() {
-                final Map<String, Metric> items = new HashMap<>();
-                for (Map.Entry<MetricName, io.dropwizard.metrics5.Metric> entry : original.getMetrics().entrySet()) {
-                    items.put(entry.getKey().getKey(), Metric.of(entry.getValue()));
-                }
-                return Collections.unmodifiableMap(items);
-            }
-
-            @Override
-            public io.dropwizard.metrics5.MetricSet getDelegate() {
-                return original;
-            }
-        };
-    }
+  Map<String, Metric> getMetrics();
+
+  @Override
+  default io.dropwizard.metrics5.MetricSet getDelegate() {
+    return new Adapter(this);
+  }
+
+  static MetricSet of(io.dropwizard.metrics5.MetricSet original) {
+    return new MetricSet() {
+      @Override
+      public Map<String, Metric> getMetrics() {
+        final Map<String, Metric> items = new HashMap<>();
+        for (Map.Entry<MetricName, io.dropwizard.metrics5.Metric> entry :
+            original.getMetrics().entrySet()) {
+          items.put(entry.getKey().getKey(), Metric.of(entry.getValue()));
+        }
+        return unmodifiableMap(items);
+      }
 
-    class Adapter implements io.dropwizard.metrics5.MetricSet {
+      @Override
+      public io.dropwizard.metrics5.MetricSet getDelegate() {
+        return original;
+      }
+    };
+  }
 
-        private final MetricSet delegate;
+  class Adapter implements io.dropwizard.metrics5.MetricSet {
 
-        Adapter(MetricSet delegate) {
-            this.delegate = delegate;
-        }
+    private final MetricSet delegate;
 
-        @Override
-        public Map<MetricName, io.dropwizard.metrics5.Metric> getMetrics() {
-            final Map<MetricName, io.dropwizard.metrics5.Metric> items = new HashMap<>();
-            for (Map.Entry<String, Metric> entry : delegate.getMetrics().entrySet()) {
-                items.put(MetricName.build(entry.getKey()), entry.getValue().getDelegate());
-            }
-            return Collections.unmodifiableMap(items);
-        }
+    Adapter(MetricSet delegate) {
+      this.delegate = delegate;
     }
 
+    @Override
+    public Map<MetricName, io.dropwizard.metrics5.Metric> getMetrics() {
+      final Map<MetricName, io.dropwizard.metrics5.Metric> items = new HashMap<>();
+      for (Map.Entry<String, Metric> entry : delegate.getMetrics().entrySet()) {
+        items.put(MetricName.build(entry.getKey()), entry.getValue().getDelegate());
+      }
+      return unmodifiableMap(items);
+    }
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/RatioGauge.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/RatioGauge.java
@@ -5,32 +5,32 @@ import static java.util.Objects.requireNonNull;
 @Deprecated
 public abstract class RatioGauge implements Gauge<Double> {
 
-    public static class Ratio {
+  public static class Ratio {
 
-        private io.dropwizard.metrics5.RatioGauge.Ratio delegate;
+    private io.dropwizard.metrics5.RatioGauge.Ratio delegate;
 
-        public static Ratio of(double numerator, double denominator) {
-            return new Ratio(io.dropwizard.metrics5.RatioGauge.Ratio.of(numerator, denominator));
-        }
-
-        public Ratio(io.dropwizard.metrics5.RatioGauge.Ratio delegate) {
-            this.delegate = requireNonNull(delegate);
-        }
-
-        public double getValue() {
-            return delegate.getValue();
-        }
+    public static Ratio of(double numerator, double denominator) {
+      return new Ratio(io.dropwizard.metrics5.RatioGauge.Ratio.of(numerator, denominator));
+    }
 
-        @Override
-        public String toString() {
-            return delegate.toString();
-        }
+    public Ratio(io.dropwizard.metrics5.RatioGauge.Ratio delegate) {
+      this.delegate = requireNonNull(delegate);
     }
 
-    protected abstract Ratio getRatio();
+    public double getValue() {
+      return delegate.getValue();
+    }
 
     @Override
-    public Double getValue() {
-        return getRatio().getValue();
+    public String toString() {
+      return delegate.toString();
     }
+  }
+
+  protected abstract Ratio getRatio();
+
+  @Override
+  public Double getValue() {
+    return getRatio().getValue();
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Reporter.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Reporter.java
@@ -1,6 +1,4 @@
 package com.codahale.metrics;
 
 @Deprecated
-public interface Reporter {
-
-}
+public interface Reporter {}
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Reservoir.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Reservoir.java
@@ -3,11 +3,11 @@ package com.codahale.metrics;
 @Deprecated
 public interface Reservoir {
 
-    int size();
+  int size();
 
-    void update(long value);
+  void update(long value);
 
-    Snapshot getSnapshot();
+  Snapshot getSnapshot();
 
-    io.dropwizard.metrics5.Reservoir getDelegate();
+  io.dropwizard.metrics5.Reservoir getDelegate();
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Sampling.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Sampling.java
@@ -3,5 +3,5 @@ package com.codahale.metrics;
 @Deprecated
 public interface Sampling {
 
-    Snapshot getSnapshot();
+  Snapshot getSnapshot();
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/ScheduledReporter.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/ScheduledReporter.java
@@ -1,9 +1,10 @@
 package com.codahale.metrics;
 
-import io.dropwizard.metrics5.MetricName;
+import static java.util.Collections.unmodifiableSortedMap;
+import static java.util.Objects.requireNonNull;
 
+import io.dropwizard.metrics5.MetricName;
 import java.io.Closeable;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
@@ -11,142 +12,218 @@ import java.util.TreeMap;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
-import static java.util.Objects.requireNonNull;
-
 @Deprecated
 public abstract class ScheduledReporter implements Closeable, Reporter {
 
-    private io.dropwizard.metrics5.ScheduledReporter delegate;
-
-    protected ScheduledReporter(io.dropwizard.metrics5.ScheduledReporter delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    protected ScheduledReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit,
-                                TimeUnit durationUnit) {
-        delegate = new Adapter(registry, name, filter, rateUnit, durationUnit, this);
-    }
-
-    protected ScheduledReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit,
-                                TimeUnit durationUnit, ScheduledExecutorService executor) {
-        delegate = new Adapter(registry, name, filter, rateUnit, durationUnit, executor, this);
-    }
-
-    protected ScheduledReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit,
-                                TimeUnit durationUnit, ScheduledExecutorService executor, boolean shutdownExecutorOnStop) {
-        delegate = new Adapter(registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop, this);
-    }
-
-    protected ScheduledReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit,
-                                TimeUnit durationUnit, ScheduledExecutorService executor, boolean shutdownExecutorOnStop,
-                                Set<MetricAttribute> disabledMetricAttributes) {
-        delegate = new Adapter(registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop,
-                disabledMetricAttributes, this);
-    }
-
-    public void start(long period, TimeUnit unit) {
-        delegate.start(period, unit);
-    }
-
-    synchronized public void start(long initialDelay, long period, TimeUnit unit) {
-        delegate.start(initialDelay, period, unit);
-    }
-
-    public void stop() {
-        delegate.stop();
+  private io.dropwizard.metrics5.ScheduledReporter delegate;
+
+  protected ScheduledReporter(io.dropwizard.metrics5.ScheduledReporter delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  protected ScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit) {
+    delegate = new Adapter(registry, name, filter, rateUnit, durationUnit, this);
+  }
+
+  protected ScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      ScheduledExecutorService executor) {
+    delegate = new Adapter(registry, name, filter, rateUnit, durationUnit, executor, this);
+  }
+
+  protected ScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop) {
+    delegate =
+        new Adapter(
+            registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop, this);
+  }
+
+  protected ScheduledReporter(
+      MetricRegistry registry,
+      String name,
+      MetricFilter filter,
+      TimeUnit rateUnit,
+      TimeUnit durationUnit,
+      ScheduledExecutorService executor,
+      boolean shutdownExecutorOnStop,
+      Set<MetricAttribute> disabledMetricAttributes) {
+    delegate =
+        new Adapter(
+            registry,
+            name,
+            filter,
+            rateUnit,
+            durationUnit,
+            executor,
+            shutdownExecutorOnStop,
+            disabledMetricAttributes,
+            this);
+  }
+
+  public void start(long period, TimeUnit unit) {
+    delegate.start(period, unit);
+  }
+
+  public synchronized void start(long initialDelay, long period, TimeUnit unit) {
+    delegate.start(initialDelay, period, unit);
+  }
+
+  public void stop() {
+    delegate.stop();
+  }
+
+  @Override
+  public void close() {
+    delegate.close();
+  }
+
+  public void report() {
+    delegate.report();
+  }
+
+  public io.dropwizard.metrics5.ScheduledReporter getDelegate() {
+    return delegate;
+  }
+
+  @SuppressWarnings("rawtypes")
+  public abstract void report(
+      SortedMap<String, Gauge> gauges,
+      SortedMap<String, Counter> counters,
+      SortedMap<String, Histogram> histograms,
+      SortedMap<String, Meter> meters,
+      SortedMap<String, Timer> timers);
+
+  @SuppressWarnings("unchecked")
+  protected <T extends io.dropwizard.metrics5.Metric> SortedMap<MetricName, T> transform(
+      SortedMap<String, ? extends Metric> metrics) {
+    final SortedMap<MetricName, T> items = new TreeMap<>();
+    for (Map.Entry<String, ? extends Metric> entry : metrics.entrySet()) {
+      items.put(MetricName.build(entry.getKey()), (T) entry.getValue().getDelegate());
+    }
+    return unmodifiableSortedMap(items);
+  }
+
+  protected String getRateUnit() {
+    return delegate.getRateUnit();
+  }
+
+  protected String getDurationUnit() {
+    return delegate.getDurationUnit();
+  }
+
+  protected double convertDuration(double duration) {
+    return delegate.convertDuration(duration);
+  }
+
+  protected double convertRate(double rate) {
+    return delegate.convertRate(rate);
+  }
+
+  protected boolean isShutdownExecutorOnStop() {
+    return delegate.isShutdownExecutorOnStop();
+  }
+
+  protected Set<io.dropwizard.metrics5.MetricAttribute> getDisabledMetricAttributes() {
+    return delegate.getDisabledMetricAttributes();
+  }
+
+  public static class Adapter extends io.dropwizard.metrics5.ScheduledReporter {
+
+    private final ScheduledReporter delegate;
+
+    public Adapter(
+        MetricRegistry registry,
+        String name,
+        MetricFilter filter,
+        TimeUnit rateUnit,
+        TimeUnit durationUnit,
+        ScheduledReporter delegate) {
+      super(registry.getDelegate(), name, filter.transform(), rateUnit, durationUnit);
+      this.delegate = delegate;
+    }
+
+    public Adapter(
+        MetricRegistry registry,
+        String name,
+        MetricFilter filter,
+        TimeUnit rateUnit,
+        TimeUnit durationUnit,
+        ScheduledExecutorService executor,
+        ScheduledReporter delegate) {
+      super(registry.getDelegate(), name, filter.transform(), rateUnit, durationUnit, executor);
+      this.delegate = delegate;
+    }
+
+    public Adapter(
+        MetricRegistry registry,
+        String name,
+        MetricFilter filter,
+        TimeUnit rateUnit,
+        TimeUnit durationUnit,
+        ScheduledExecutorService executor,
+        boolean shutdownExecutorOnStop,
+        ScheduledReporter delegate) {
+      super(
+          registry.getDelegate(),
+          name,
+          filter.transform(),
+          rateUnit,
+          durationUnit,
+          executor,
+          shutdownExecutorOnStop);
+      this.delegate = delegate;
+    }
+
+    public Adapter(
+        MetricRegistry registry,
+        String name,
+        MetricFilter filter,
+        TimeUnit rateUnit,
+        TimeUnit durationUnit,
+        ScheduledExecutorService executor,
+        boolean shutdownExecutorOnStop,
+        Set<MetricAttribute> disabledMetricAttributes,
+        ScheduledReporter delegate) {
+      super(
+          registry.getDelegate(),
+          name,
+          filter.transform(),
+          rateUnit,
+          durationUnit,
+          executor,
+          shutdownExecutorOnStop,
+          MetricAttribute.transform(disabledMetricAttributes));
+      this.delegate = delegate;
     }
 
     @Override
-    public void close() {
-        delegate.close();
-    }
-
-    public void report() {
-        delegate.report();
-    }
-
-    public io.dropwizard.metrics5.ScheduledReporter getDelegate() {
-        return delegate;
-    }
-
-    @SuppressWarnings("rawtypes")
-    public abstract void report(SortedMap<String, Gauge> gauges,
-                                SortedMap<String, Counter> counters,
-                                SortedMap<String, Histogram> histograms,
-                                SortedMap<String, Meter> meters,
-                                SortedMap<String, Timer> timers);
-
-    @SuppressWarnings("unchecked")
-    protected <T extends io.dropwizard.metrics5.Metric> SortedMap<MetricName, T> transform(
-            SortedMap<String, ? extends Metric> metrics) {
-        final SortedMap<MetricName, T> items = new TreeMap<>();
-        for (Map.Entry<String, ? extends Metric> entry : metrics.entrySet()) {
-            items.put(MetricName.build(entry.getKey()), (T) entry.getValue().getDelegate());
-        }
-        return Collections.unmodifiableSortedMap(items);
-    }
-
-    protected String getRateUnit() {
-        return delegate.getRateUnit();
-    }
-
-    protected String getDurationUnit() {
-        return delegate.getDurationUnit();
-    }
-
-    protected double convertDuration(double duration) {
-        return delegate.convertDuration(duration);
-    }
-
-    protected double convertRate(double rate) {
-        return delegate.convertRate(rate);
-    }
-
-    protected boolean isShutdownExecutorOnStop() {
-        return delegate.isShutdownExecutorOnStop();
-    }
-
-    protected Set<io.dropwizard.metrics5.MetricAttribute> getDisabledMetricAttributes() {
-        return delegate.getDisabledMetricAttributes();
-    }
-
-    public static class Adapter extends io.dropwizard.metrics5.ScheduledReporter {
-
-        private final ScheduledReporter delegate;
-
-        public Adapter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit,
-                       ScheduledReporter delegate) {
-            super(registry.getDelegate(), name, filter.transform(), rateUnit, durationUnit);
-            this.delegate = delegate;
-        }
-
-        public Adapter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit,
-                       ScheduledExecutorService executor, ScheduledReporter delegate) {
-            super(registry.getDelegate(), name, filter.transform(), rateUnit, durationUnit, executor);
-            this.delegate = delegate;
-        }
-
-        public Adapter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit,
-                       ScheduledExecutorService executor, boolean shutdownExecutorOnStop, ScheduledReporter delegate) {
-            super(registry.getDelegate(), name, filter.transform(), rateUnit, durationUnit, executor, shutdownExecutorOnStop);
-            this.delegate = delegate;
-        }
-
-        public Adapter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit,
-                       ScheduledExecutorService executor, boolean shutdownExecutorOnStop, Set<MetricAttribute> disabledMetricAttributes,
-                       ScheduledReporter delegate) {
-            super(registry.getDelegate(), name, filter.transform(), rateUnit, durationUnit, executor, shutdownExecutorOnStop,
-                    MetricAttribute.transform(disabledMetricAttributes));
-            this.delegate = delegate;
-        }
-
-        @Override
-        public void report(SortedMap<MetricName, io.dropwizard.metrics5.Gauge<?>> gauges, SortedMap<MetricName, io.dropwizard.metrics5.Counter> counters,
-                           SortedMap<MetricName, io.dropwizard.metrics5.Histogram> histograms, SortedMap<MetricName, io.dropwizard.metrics5.Meter> meters,
-                           SortedMap<MetricName, io.dropwizard.metrics5.Timer> timers) {
-            delegate.report(MetricRegistry.adaptMetrics(gauges), MetricRegistry.adaptMetrics(counters),
-                    MetricRegistry.adaptMetrics(histograms), MetricRegistry.adaptMetrics(meters),
-                    MetricRegistry.adaptMetrics(timers));
-        }
-    }
+    public void report(
+        SortedMap<MetricName, io.dropwizard.metrics5.Gauge<?>> gauges,
+        SortedMap<MetricName, io.dropwizard.metrics5.Counter> counters,
+        SortedMap<MetricName, io.dropwizard.metrics5.Histogram> histograms,
+        SortedMap<MetricName, io.dropwizard.metrics5.Meter> meters,
+        SortedMap<MetricName, io.dropwizard.metrics5.Timer> timers) {
+      delegate.report(
+          MetricRegistry.adaptMetrics(gauges),
+          MetricRegistry.adaptMetrics(counters),
+          MetricRegistry.adaptMetrics(histograms),
+          MetricRegistry.adaptMetrics(meters),
+          MetricRegistry.adaptMetrics(timers));
+    }
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/SharedMetricRegistries.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/SharedMetricRegistries.java
@@ -2,48 +2,47 @@ package com.codahale.metrics;
 
 import java.util.Optional;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicReference;
 
 @Deprecated
 public class SharedMetricRegistries {
 
-    public static void clear() {
-        io.dropwizard.metrics5.SharedMetricRegistries.clear();
-    }
-
-    public static Set<String> names() {
-        return io.dropwizard.metrics5.SharedMetricRegistries.names();
-    }
-
-    public static void remove(String key) {
-        io.dropwizard.metrics5.SharedMetricRegistries.remove(key);
-    }
-
-    public static MetricRegistry add(String name, MetricRegistry registry) {
-        io.dropwizard.metrics5.SharedMetricRegistries.add(name, registry.getDelegate());
-        return registry;
-    }
-
-    public static MetricRegistry getOrCreate(String name) {
-        return new MetricRegistry(io.dropwizard.metrics5.SharedMetricRegistries.getOrCreate(name));
-    }
-
-    public synchronized static MetricRegistry setDefault(String name) {
-        return new MetricRegistry(io.dropwizard.metrics5.SharedMetricRegistries.setDefault(name));
-    }
-
-    public static MetricRegistry setDefault(String name, MetricRegistry metricRegistry) {
-        io.dropwizard.metrics5.SharedMetricRegistries.setDefault(name, metricRegistry.getDelegate());
-        return metricRegistry;
-    }
-
-    public static MetricRegistry getDefault() {
-        return new MetricRegistry(io.dropwizard.metrics5.SharedMetricRegistries.getDefault());
-    }
-
-    public static MetricRegistry tryGetDefault() {
-        return Optional.ofNullable(io.dropwizard.metrics5.SharedMetricRegistries.tryGetDefault())
-                .map(MetricRegistry::new)
-                .orElse(null);
-    }
+  public static void clear() {
+    io.dropwizard.metrics5.SharedMetricRegistries.clear();
+  }
+
+  public static Set<String> names() {
+    return io.dropwizard.metrics5.SharedMetricRegistries.names();
+  }
+
+  public static void remove(String key) {
+    io.dropwizard.metrics5.SharedMetricRegistries.remove(key);
+  }
+
+  public static MetricRegistry add(String name, MetricRegistry registry) {
+    io.dropwizard.metrics5.SharedMetricRegistries.add(name, registry.getDelegate());
+    return registry;
+  }
+
+  public static MetricRegistry getOrCreate(String name) {
+    return new MetricRegistry(io.dropwizard.metrics5.SharedMetricRegistries.getOrCreate(name));
+  }
+
+  public static synchronized MetricRegistry setDefault(String name) {
+    return new MetricRegistry(io.dropwizard.metrics5.SharedMetricRegistries.setDefault(name));
+  }
+
+  public static MetricRegistry setDefault(String name, MetricRegistry metricRegistry) {
+    io.dropwizard.metrics5.SharedMetricRegistries.setDefault(name, metricRegistry.getDelegate());
+    return metricRegistry;
+  }
+
+  public static MetricRegistry getDefault() {
+    return new MetricRegistry(io.dropwizard.metrics5.SharedMetricRegistries.getDefault());
+  }
+
+  public static MetricRegistry tryGetDefault() {
+    return Optional.ofNullable(io.dropwizard.metrics5.SharedMetricRegistries.tryGetDefault())
+        .map(MetricRegistry::new)
+        .orElse(null);
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Slf4jReporter.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Slf4jReporter.java
@@ -1,91 +1,106 @@
 package com.codahale.metrics;
 
-import org.slf4j.Logger;
-import org.slf4j.Marker;
+import static java.util.Objects.requireNonNull;
 
 import java.util.SortedMap;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
-
-import static java.util.Objects.requireNonNull;
+import org.slf4j.Logger;
+import org.slf4j.Marker;
 
 @Deprecated
 public class Slf4jReporter extends ScheduledReporter {
 
-    public static Slf4jReporter.Builder forRegistry(MetricRegistry registry) {
-        return new Slf4jReporter.Builder(io.dropwizard.metrics5.Slf4jReporter.forRegistry(registry.getDelegate()));
-    }
-
-    public enum LoggingLevel {TRACE, DEBUG, INFO, WARN, ERROR}
+  public static Slf4jReporter.Builder forRegistry(MetricRegistry registry) {
+    return new Slf4jReporter.Builder(
+        io.dropwizard.metrics5.Slf4jReporter.forRegistry(registry.getDelegate()));
+  }
 
-    public static class Builder {
+  public enum LoggingLevel {
+    TRACE,
+    DEBUG,
+    INFO,
+    WARN,
+    ERROR
+  }
 
-        private io.dropwizard.metrics5.Slf4jReporter.Builder delegate;
+  public static class Builder {
 
-        private Builder(io.dropwizard.metrics5.Slf4jReporter.Builder delegate) {
-            this.delegate = requireNonNull(delegate);
-        }
+    private io.dropwizard.metrics5.Slf4jReporter.Builder delegate;
 
-        public Slf4jReporter.Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
-            delegate.shutdownExecutorOnStop(shutdownExecutorOnStop);
-            return this;
-        }
-
-        public Slf4jReporter.Builder scheduleOn(ScheduledExecutorService executor) {
-            delegate.scheduleOn(executor);
-            return this;
-        }
+    private Builder(io.dropwizard.metrics5.Slf4jReporter.Builder delegate) {
+      this.delegate = requireNonNull(delegate);
+    }
 
-        public Slf4jReporter.Builder outputTo(Logger logger) {
-            delegate.outputTo(logger);
-            return this;
-        }
+    public Slf4jReporter.Builder shutdownExecutorOnStop(boolean shutdownExecutorOnStop) {
+      delegate.shutdownExecutorOnStop(shutdownExecutorOnStop);
+      return this;
+    }
 
-        public Slf4jReporter.Builder markWith(Marker marker) {
-            delegate.markWith(marker);
-            return this;
-        }
+    public Slf4jReporter.Builder scheduleOn(ScheduledExecutorService executor) {
+      delegate.scheduleOn(executor);
+      return this;
+    }
 
-        public Slf4jReporter.Builder prefixedWith(String prefix) {
-            delegate.prefixedWith(prefix);
-            return this;
-        }
+    public Slf4jReporter.Builder outputTo(Logger logger) {
+      delegate.outputTo(logger);
+      return this;
+    }
 
-        public Slf4jReporter.Builder convertRatesTo(TimeUnit rateUnit) {
-            delegate.convertRatesTo(rateUnit);
-            return this;
-        }
+    public Slf4jReporter.Builder markWith(Marker marker) {
+      delegate.markWith(marker);
+      return this;
+    }
 
-        public Slf4jReporter.Builder convertDurationsTo(TimeUnit durationUnit) {
-            delegate.convertDurationsTo(durationUnit);
-            return this;
-        }
+    public Slf4jReporter.Builder prefixedWith(String prefix) {
+      delegate.prefixedWith(prefix);
+      return this;
+    }
 
-        public Slf4jReporter.Builder filter(MetricFilter filter) {
-            delegate.filter(filter.transform());
-            return this;
-        }
+    public Slf4jReporter.Builder convertRatesTo(TimeUnit rateUnit) {
+      delegate.convertRatesTo(rateUnit);
+      return this;
+    }
 
-        public Slf4jReporter.Builder withLoggingLevel(LoggingLevel loggingLevel) {
-            delegate.withLoggingLevel(io.dropwizard.metrics5.Slf4jReporter.LoggingLevel.valueOf(loggingLevel.name()));
-            return this;
-        }
+    public Slf4jReporter.Builder convertDurationsTo(TimeUnit durationUnit) {
+      delegate.convertDurationsTo(durationUnit);
+      return this;
+    }
 
-        public Slf4jReporter build() {
-            return new Slf4jReporter(delegate.build());
-        }
+    public Slf4jReporter.Builder filter(MetricFilter filter) {
+      delegate.filter(filter.transform());
+      return this;
     }
 
-    private Slf4jReporter(io.dropwizard.metrics5.ScheduledReporter delegate) {
-        super(delegate);
+    public Slf4jReporter.Builder withLoggingLevel(LoggingLevel loggingLevel) {
+      delegate.withLoggingLevel(
+          io.dropwizard.metrics5.Slf4jReporter.LoggingLevel.valueOf(loggingLevel.name()));
+      return this;
     }
 
-    @Override
-    @SuppressWarnings("rawtypes")
-    public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters,
-                       SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters,
-                       SortedMap<String, Timer> timers) {
-        getDelegate().report(transform(gauges), transform(counters), transform(histograms), transform(meters),
-                transform(timers));
+    public Slf4jReporter build() {
+      return new Slf4jReporter(delegate.build());
     }
+  }
+
+  private Slf4jReporter(io.dropwizard.metrics5.ScheduledReporter delegate) {
+    super(delegate);
+  }
+
+  @Override
+  @SuppressWarnings("rawtypes")
+  public void report(
+      SortedMap<String, Gauge> gauges,
+      SortedMap<String, Counter> counters,
+      SortedMap<String, Histogram> histograms,
+      SortedMap<String, Meter> meters,
+      SortedMap<String, Timer> timers) {
+    getDelegate()
+        .report(
+            transform(gauges),
+            transform(counters),
+            transform(histograms),
+            transform(meters),
+            transform(timers));
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/SlidingTimeWindowArrayReservoir.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/SlidingTimeWindowArrayReservoir.java
@@ -1,43 +1,46 @@
 package com.codahale.metrics;
 
-import java.util.concurrent.TimeUnit;
-
 import static java.util.Objects.requireNonNull;
 
+import java.util.concurrent.TimeUnit;
+
 @Deprecated
 public class SlidingTimeWindowArrayReservoir implements Reservoir {
 
-    private io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir delegate;
-
-    public SlidingTimeWindowArrayReservoir(long window, TimeUnit windowUnit) {
-        this(new io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir(window, windowUnit));
-    }
-
-    public SlidingTimeWindowArrayReservoir(long window, TimeUnit windowUnit, Clock clock) {
-        this(new io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir(window, windowUnit, clock.getDelegate()));
-    }
-
-    public SlidingTimeWindowArrayReservoir(io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    @Override
-    public io.dropwizard.metrics5.Reservoir getDelegate() {
-        return delegate;
-    }
-
-    @Override
-    public int size() {
-        return delegate.size();
-    }
-
-    @Override
-    public void update(long value) {
-        delegate.update(value);
-    }
-
-    @Override
-    public Snapshot getSnapshot() {
-        return Snapshot.of(delegate.getSnapshot());
-    }
+  private io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir delegate;
+
+  public SlidingTimeWindowArrayReservoir(long window, TimeUnit windowUnit) {
+    this(new io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir(window, windowUnit));
+  }
+
+  public SlidingTimeWindowArrayReservoir(long window, TimeUnit windowUnit, Clock clock) {
+    this(
+        new io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir(
+            window, windowUnit, clock.getDelegate()));
+  }
+
+  public SlidingTimeWindowArrayReservoir(
+      io.dropwizard.metrics5.SlidingTimeWindowArrayReservoir delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  @Override
+  public io.dropwizard.metrics5.Reservoir getDelegate() {
+    return delegate;
+  }
+
+  @Override
+  public int size() {
+    return delegate.size();
+  }
+
+  @Override
+  public void update(long value) {
+    delegate.update(value);
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    return Snapshot.of(delegate.getSnapshot());
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/SlidingTimeWindowReservoir.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/SlidingTimeWindowReservoir.java
@@ -1,43 +1,45 @@
 package com.codahale.metrics;
 
-import java.util.concurrent.TimeUnit;
-
 import static java.util.Objects.requireNonNull;
 
+import java.util.concurrent.TimeUnit;
+
 @Deprecated
 public class SlidingTimeWindowReservoir implements Reservoir {
 
-    private io.dropwizard.metrics5.SlidingTimeWindowReservoir delegate;
-
-    public SlidingTimeWindowReservoir(long window, TimeUnit windowUnit) {
-        this(new io.dropwizard.metrics5.SlidingTimeWindowReservoir(window, windowUnit));
-    }
-
-    public SlidingTimeWindowReservoir(long window, TimeUnit windowUnit, Clock clock) {
-        this(new io.dropwizard.metrics5.SlidingTimeWindowReservoir(window, windowUnit, clock.getDelegate()));
-    }
-
-    public SlidingTimeWindowReservoir(io.dropwizard.metrics5.SlidingTimeWindowReservoir delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    @Override
-    public io.dropwizard.metrics5.Reservoir getDelegate() {
-        return delegate;
-    }
-
-    @Override
-    public int size() {
-        return delegate.size();
-    }
-
-    @Override
-    public void update(long value) {
-        delegate.update(value);
-    }
-
-    @Override
-    public Snapshot getSnapshot() {
-        return Snapshot.of(delegate.getSnapshot());
-    }
+  private io.dropwizard.metrics5.SlidingTimeWindowReservoir delegate;
+
+  public SlidingTimeWindowReservoir(long window, TimeUnit windowUnit) {
+    this(new io.dropwizard.metrics5.SlidingTimeWindowReservoir(window, windowUnit));
+  }
+
+  public SlidingTimeWindowReservoir(long window, TimeUnit windowUnit, Clock clock) {
+    this(
+        new io.dropwizard.metrics5.SlidingTimeWindowReservoir(
+            window, windowUnit, clock.getDelegate()));
+  }
+
+  public SlidingTimeWindowReservoir(io.dropwizard.metrics5.SlidingTimeWindowReservoir delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  @Override
+  public io.dropwizard.metrics5.Reservoir getDelegate() {
+    return delegate;
+  }
+
+  @Override
+  public int size() {
+    return delegate.size();
+  }
+
+  @Override
+  public void update(long value) {
+    delegate.update(value);
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    return Snapshot.of(delegate.getSnapshot());
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/SlidingWindowReservoir.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/SlidingWindowReservoir.java
@@ -5,33 +5,33 @@ import static java.util.Objects.requireNonNull;
 @Deprecated
 public class SlidingWindowReservoir implements Reservoir {
 
-    private io.dropwizard.metrics5.SlidingWindowReservoir delegate;
-
-    public SlidingWindowReservoir(int size) {
-        this(new io.dropwizard.metrics5.SlidingWindowReservoir(size));
-    }
-
-    public SlidingWindowReservoir(io.dropwizard.metrics5.SlidingWindowReservoir delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    @Override
-    public io.dropwizard.metrics5.Reservoir getDelegate() {
-        return delegate;
-    }
-
-    @Override
-    public int size() {
-        return delegate.size();
-    }
-
-    @Override
-    public void update(long value) {
-        delegate.update(value);
-    }
-
-    @Override
-    public Snapshot getSnapshot() {
-        return Snapshot.of(delegate.getSnapshot());
-    }
+  private io.dropwizard.metrics5.SlidingWindowReservoir delegate;
+
+  public SlidingWindowReservoir(int size) {
+    this(new io.dropwizard.metrics5.SlidingWindowReservoir(size));
+  }
+
+  public SlidingWindowReservoir(io.dropwizard.metrics5.SlidingWindowReservoir delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  @Override
+  public io.dropwizard.metrics5.Reservoir getDelegate() {
+    return delegate;
+  }
+
+  @Override
+  public int size() {
+    return delegate.size();
+  }
+
+  @Override
+  public void update(long value) {
+    delegate.update(value);
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    return Snapshot.of(delegate.getSnapshot());
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Snapshot.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Snapshot.java
@@ -5,88 +5,88 @@ import java.io.OutputStream;
 @Deprecated
 public abstract class Snapshot {
 
-    public abstract double getValue(double quantile);
+  public abstract double getValue(double quantile);
 
-    public abstract long[] getValues();
+  public abstract long[] getValues();
 
-    public abstract int size();
+  public abstract int size();
 
-    public double getMedian() {
-        return getValue(0.5);
-    }
+  public double getMedian() {
+    return getValue(0.5);
+  }
 
-    public double get75thPercentile() {
-        return getValue(0.75);
-    }
+  public double get75thPercentile() {
+    return getValue(0.75);
+  }
 
-    public double get95thPercentile() {
-        return getValue(0.95);
-    }
+  public double get95thPercentile() {
+    return getValue(0.95);
+  }
 
-    public double get98thPercentile() {
-        return getValue(0.98);
-    }
+  public double get98thPercentile() {
+    return getValue(0.98);
+  }
 
-    public double get99thPercentile() {
-        return getValue(0.99);
-    }
+  public double get99thPercentile() {
+    return getValue(0.99);
+  }
 
-    public double get999thPercentile() {
-        return getValue(0.999);
-    }
+  public double get999thPercentile() {
+    return getValue(0.999);
+  }
 
-    public abstract long getMax();
+  public abstract long getMax();
 
-    public abstract double getMean();
+  public abstract double getMean();
 
-    public abstract long getMin();
+  public abstract long getMin();
 
-    public abstract double getStdDev();
+  public abstract double getStdDev();
 
-    public abstract void dump(OutputStream output);
+  public abstract void dump(OutputStream output);
 
-    public static Snapshot of(io.dropwizard.metrics5.Snapshot delegate) {
-        return new Snapshot() {
+  public static Snapshot of(io.dropwizard.metrics5.Snapshot delegate) {
+    return new Snapshot() {
 
-            @Override
-            public double getValue(double quantile) {
-                return delegate.getValue(quantile);
-            }
+      @Override
+      public double getValue(double quantile) {
+        return delegate.getValue(quantile);
+      }
 
-            @Override
-            public long[] getValues() {
-                return delegate.getValues();
-            }
+      @Override
+      public long[] getValues() {
+        return delegate.getValues();
+      }
 
-            @Override
-            public int size() {
-                return delegate.size();
-            }
+      @Override
+      public int size() {
+        return delegate.size();
+      }
 
-            @Override
-            public long getMax() {
-                return delegate.getMax();
-            }
+      @Override
+      public long getMax() {
+        return delegate.getMax();
+      }
 
-            @Override
-            public double getMean() {
-                return delegate.getMean();
-            }
+      @Override
+      public double getMean() {
+        return delegate.getMean();
+      }
 
-            @Override
-            public long getMin() {
-                return delegate.getMin();
-            }
+      @Override
+      public long getMin() {
+        return delegate.getMin();
+      }
 
-            @Override
-            public double getStdDev() {
-                return delegate.getStdDev();
-            }
+      @Override
+      public double getStdDev() {
+        return delegate.getStdDev();
+      }
 
-            @Override
-            public void dump(OutputStream output) {
-                delegate.dump(output);
-            }
-        };
-    }
+      @Override
+      public void dump(OutputStream output) {
+        delegate.dump(output);
+      }
+    };
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Timer.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/Timer.java
@@ -1,109 +1,107 @@
 package com.codahale.metrics;
 
+import static java.util.Objects.requireNonNull;
+
 import java.io.Closeable;
 import java.time.Duration;
 import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
-import static java.util.Objects.requireNonNull;
-
 @Deprecated
 public class Timer implements Metered, Sampling {
 
-    private final io.dropwizard.metrics5.Timer delegate;
-
-    public static class Context implements Closeable {
-
-        private final io.dropwizard.metrics5.Timer.Context context;
-
-        private Context(io.dropwizard.metrics5.Timer.Context context) {
-            this.context = context;
-        }
-
-        public long stop() {
-            return context.stop();
-        }
-
-        @Override
-        public void close() {
-            context.close();
-        }
-    }
-
-    public Timer() {
-        this(new io.dropwizard.metrics5.Timer());
-    }
-
-    public Timer(Reservoir reservoir) {
-        this(reservoir, Clock.defaultClock());
-    }
+  private final io.dropwizard.metrics5.Timer delegate;
 
-    public Timer(Reservoir reservoir, Clock clock) {
-        this(new io.dropwizard.metrics5.Timer(reservoir.getDelegate(), clock.getDelegate()));
-    }
-
-    public Timer(io.dropwizard.metrics5.Timer delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    @Override
-    public Snapshot getSnapshot() {
-        return Snapshot.of(delegate.getSnapshot());
-    }
-
-    @Override
-    public long getCount() {
-        return delegate.getCount();
-    }
+  public static class Context implements Closeable {
 
-    @Override
-    public double getFifteenMinuteRate() {
-        return delegate.getFifteenMinuteRate();
-    }
+    private final io.dropwizard.metrics5.Timer.Context context;
 
-    @Override
-    public double getFiveMinuteRate() {
-        return delegate.getFiveMinuteRate();
+    private Context(io.dropwizard.metrics5.Timer.Context context) {
+      this.context = context;
     }
 
-    @Override
-    public double getMeanRate() {
-        return delegate.getMeanRate();
+    public long stop() {
+      return context.stop();
     }
 
     @Override
-    public double getOneMinuteRate() {
-        return delegate.getOneMinuteRate();
-    }
-
-    public void update(long duration, TimeUnit unit) {
-        delegate.update(duration, unit);
-    }
-
-    public void update(Duration duration) {
-        delegate.update(duration);
-    }
-
-    public <T> T time(Callable<T> event) throws Exception {
-        return delegate.time(event);
-    }
-
-    public void time(Runnable event) {
-        delegate.time(event);
-    }
-
-    public <T> T timeSupplier(Supplier<T> event) {
-        return delegate.timeSupplier(event);
-    }
-
-    public Context time() {
-        return new Context(delegate.time());
-    }
-
-    public io.dropwizard.metrics5.Timer getDelegate() {
-        return delegate;
-    }
-
-
+    public void close() {
+      context.close();
+    }
+  }
+
+  public Timer() {
+    this(new io.dropwizard.metrics5.Timer());
+  }
+
+  public Timer(Reservoir reservoir) {
+    this(reservoir, Clock.defaultClock());
+  }
+
+  public Timer(Reservoir reservoir, Clock clock) {
+    this(new io.dropwizard.metrics5.Timer(reservoir.getDelegate(), clock.getDelegate()));
+  }
+
+  public Timer(io.dropwizard.metrics5.Timer delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    return Snapshot.of(delegate.getSnapshot());
+  }
+
+  @Override
+  public long getCount() {
+    return delegate.getCount();
+  }
+
+  @Override
+  public double getFifteenMinuteRate() {
+    return delegate.getFifteenMinuteRate();
+  }
+
+  @Override
+  public double getFiveMinuteRate() {
+    return delegate.getFiveMinuteRate();
+  }
+
+  @Override
+  public double getMeanRate() {
+    return delegate.getMeanRate();
+  }
+
+  @Override
+  public double getOneMinuteRate() {
+    return delegate.getOneMinuteRate();
+  }
+
+  public void update(long duration, TimeUnit unit) {
+    delegate.update(duration, unit);
+  }
+
+  public void update(Duration duration) {
+    delegate.update(duration);
+  }
+
+  public <T> T time(Callable<T> event) throws Exception {
+    return delegate.time(event);
+  }
+
+  public void time(Runnable event) {
+    delegate.time(event);
+  }
+
+  public <T> T timeSupplier(Supplier<T> event) {
+    return delegate.timeSupplier(event);
+  }
+
+  public Context time() {
+    return new Context(delegate.time());
+  }
+
+  public io.dropwizard.metrics5.Timer getDelegate() {
+    return delegate;
+  }
 }
--- a/metrics-legacy-adapter/src/main/java/com/codahale/metrics/UniformReservoir.java
+++ b/metrics-legacy-adapter/src/main/java/com/codahale/metrics/UniformReservoir.java
@@ -5,37 +5,37 @@ import static java.util.Objects.requireNonNull;
 @Deprecated
 public class UniformReservoir implements Reservoir {
 
-    private io.dropwizard.metrics5.UniformReservoir delegate;
-
-    public UniformReservoir() {
-        this(new io.dropwizard.metrics5.UniformReservoir());
-    }
-
-    public UniformReservoir(int size) {
-        this(new io.dropwizard.metrics5.UniformReservoir(size));
-    }
-
-    public UniformReservoir(io.dropwizard.metrics5.UniformReservoir delegate) {
-        this.delegate = requireNonNull(delegate);
-    }
-
-    @Override
-    public io.dropwizard.metrics5.Reservoir getDelegate() {
-        return delegate;
-    }
-
-    @Override
-    public int size() {
-        return delegate.size();
-    }
-
-    @Override
-    public void update(long value) {
-        delegate.update(value);
-    }
-
-    @Override
-    public Snapshot getSnapshot() {
-        return Snapshot.of(delegate.getSnapshot());
-    }
+  private io.dropwizard.metrics5.UniformReservoir delegate;
+
+  public UniformReservoir() {
+    this(new io.dropwizard.metrics5.UniformReservoir());
+  }
+
+  public UniformReservoir(int size) {
+    this(new io.dropwizard.metrics5.UniformReservoir(size));
+  }
+
+  public UniformReservoir(io.dropwizard.metrics5.UniformReservoir delegate) {
+    this.delegate = requireNonNull(delegate);
+  }
+
+  @Override
+  public io.dropwizard.metrics5.Reservoir getDelegate() {
+    return delegate;
+  }
+
+  @Override
+  public int size() {
+    return delegate.size();
+  }
+
+  @Override
+  public void update(long value) {
+    delegate.update(value);
+  }
+
+  @Override
+  public Snapshot getSnapshot() {
+    return Snapshot.of(delegate.getSnapshot());
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/CachedGaugeTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/CachedGaugeTest.java
@@ -1,34 +1,34 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class CachedGaugeTest {
+final class CachedGaugeTest {
 
-    @Test
-    void testCreate() {
-        CachedGauge<String> cachedGauge = new CachedGauge<String>(100, TimeUnit.MILLISECONDS) {
-            @Override
-            protected String loadValue() {
-                return "heavyValue";
-            }
+  @Test
+  void create() {
+    CachedGauge<String> cachedGauge =
+        new CachedGauge<String>(100, TimeUnit.MILLISECONDS) {
+          @Override
+          protected String loadValue() {
+            return "heavyValue";
+          }
         };
-        assertThat(cachedGauge.getValue()).isEqualTo("heavyValue");
-    }
+    assertThat(cachedGauge.getValue()).isEqualTo("heavyValue");
+  }
 
-    @Test
-    void testCreateWothClock() {
-        CachedGauge<String> cachedGauge = new CachedGauge<String>(new Clock.UserTimeClock(), 100,
-                TimeUnit.MILLISECONDS) {
-            @Override
-            protected String loadValue() {
-                return "heavyValue";
-            }
+  @Test
+  void createWothClock() {
+    CachedGauge<String> cachedGauge =
+        new CachedGauge<String>(new Clock.UserTimeClock(), 100, TimeUnit.MILLISECONDS) {
+          @Override
+          protected String loadValue() {
+            return "heavyValue";
+          }
         };
-        assertThat(cachedGauge.getValue()).isEqualTo("heavyValue");
-    }
+    assertThat(cachedGauge.getValue()).isEqualTo("heavyValue");
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/ClockTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/ClockTest.java
@@ -1,32 +1,33 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
+import org.junit.jupiter.api.Test;
+
 @SuppressWarnings("deprecation")
-class ClockTest {
+final class ClockTest {
 
-    @Test
-    void testDefaultClockCanBeUsed() {
-        Clock clock = Clock.defaultClock();
-        assertThat(clock.getTick()).isGreaterThan(0);
-    }
+  @Test
+  void defaultClockCanBeUsed() {
+    Clock clock = Clock.defaultClock();
+    assertThat(clock.getTick()).isPositive();
+  }
 
-    @Test
-    void testUserTimeClockCanBeUsed() {
-        Clock clock = new Clock.UserTimeClock();
-        assertThat(clock.getTick()).isGreaterThan(0);
-    }
+  @Test
+  void userTimeClockCanBeUsed() {
+    Clock clock = new Clock.UserTimeClock();
+    assertThat(clock.getTick()).isPositive();
+  }
 
-    @Test
-    void testCustomTimeClockCanBeUsed() {
-        Clock clock = new Clock() {
-            @Override
-            public long getTick() {
-                return 24;
-            }
+  @Test
+  void customTimeClockCanBeUsed() {
+    Clock clock =
+        new Clock() {
+          @Override
+          public long getTick() {
+            return 24;
+          }
         };
-        assertThat(clock.getTick()).isEqualTo(24);
-    }
+    assertThat(clock.getTick()).isEqualTo(24);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/ConsoleReporterTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/ConsoleReporterTest.java
@@ -1,124 +1,129 @@
 package com.codahale.metrics;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
-import java.nio.charset.StandardCharsets;
 import java.util.EnumSet;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
-
 import org.apache.commons.lang3.JavaVersion;
 import org.apache.commons.lang3.SystemUtils;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class ConsoleReporterTest {
+final class ConsoleReporterTest {
 
-    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
-    private final String dateHeader = SystemUtils.isJavaVersionAtMost(JavaVersion.JAVA_1_8) ?
-            "3/17/13 6:04:36 PM =============================================================" :
-            // https://bugs.openjdk.org/browse/JDK-8304925
-            SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_20) ?
-            "3/17/13, 6:04:36\u202FPM ============================================================" :
-            "3/17/13, 6:04:36 PM ============================================================";
+  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
+  private final String dateHeader =
+      SystemUtils.isJavaVersionAtMost(JavaVersion.JAVA_1_8)
+          ? "3/17/13 6:04:36 PM ============================================================="
+          :
+          // https://bugs.openjdk.org/browse/JDK-8304925
+          SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_20)
+              ? "3/17/13, 6:04:36\u202FPM ============================================================"
+              : "3/17/13, 6:04:36 PM ============================================================";
 
-    @AfterEach
-    void tearDown() throws Exception {
-        executor.shutdownNow();
-    }
+  @AfterEach
+  void tearDown() throws Exception {
+    executor.shutdownNow();
+  }
 
-    @Test
-    void testCreateConsoleReporter() throws Exception {
-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+  @Test
+  void createConsoleReporter() throws Exception {
+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
 
-        MetricRegistry metricRegistry = new MetricRegistry();
-        metricRegistry.timer("test-timer");
-        metricRegistry.meter("test-meter");
-        metricRegistry.histogram("test-histogram");
-        metricRegistry.counter("test-counter");
-        metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 20);
+    MetricRegistry metricRegistry = new MetricRegistry();
+    metricRegistry.timer("test-timer");
+    metricRegistry.meter("test-meter");
+    metricRegistry.histogram("test-histogram");
+    metricRegistry.counter("test-counter");
+    metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 20);
 
-        ConsoleReporter consoleReporter = ConsoleReporter.forRegistry(metricRegistry)
-                .shutdownExecutorOnStop(false)
-                .scheduleOn(executor)
-                .outputTo(new PrintStream(byteArrayOutputStream))
-                .formattedFor(Locale.ENGLISH)
-                .withClock(new Clock() {
+    ConsoleReporter consoleReporter =
+        ConsoleReporter.forRegistry(metricRegistry)
+            .shutdownExecutorOnStop(false)
+            .scheduleOn(executor)
+            .outputTo(new PrintStream(byteArrayOutputStream))
+            .formattedFor(Locale.ENGLISH)
+            .withClock(
+                new Clock() {
 
-                    @Override
-                    public long getTime() {
-                        return 1363568676000L;
-                    }
+                  @Override
+                  public long getTime() {
+                    return 1363568676000L;
+                  }
 
-                    @Override
-                    public long getTick() {
-                        return 0;
-                    }
-                }).formattedFor(TimeZone.getTimeZone("America/Los_Angeles"))
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .filter(MetricFilter.ALL)
-                .disabledMetricAttributes(EnumSet.of(MetricAttribute.P98, MetricAttribute.P99))
-                .build();
-        consoleReporter.report();
+                  @Override
+                  public long getTick() {
+                    return 0;
+                  }
+                })
+            .formattedFor(TimeZone.getTimeZone("America/Los_Angeles"))
+            .convertRatesTo(TimeUnit.SECONDS)
+            .convertDurationsTo(TimeUnit.MILLISECONDS)
+            .filter(MetricFilter.ALL)
+            .disabledMetricAttributes(EnumSet.of(MetricAttribute.P98, MetricAttribute.P99))
+            .build();
+    consoleReporter.report();
 
-        assertThat(new String(byteArrayOutputStream.toByteArray(), StandardCharsets.UTF_8))
-                .isEqualToNormalizingNewlines(dateHeader + "\n" +
-                        "\n" +
-                        "-- Gauges ----------------------------------------------------------------------\n" +
-                        "test-gauge\n" +
-                        "             value = 20\n" +
-                        "\n" +
-                        "-- Counters --------------------------------------------------------------------\n" +
-                        "test-counter\n" +
-                        "             count = 0\n" +
-                        "\n" +
-                        "-- Histograms ------------------------------------------------------------------\n" +
-                        "test-histogram\n" +
-                        "             count = 0\n" +
-                        "               sum = 0\n" +
-                        "               min = 0\n" +
-                        "               max = 0\n" +
-                        "              mean = 0.00\n" +
-                        "            stddev = 0.00\n" +
-                        "            median = 0.00\n" +
-                        "              75% <= 0.00\n" +
-                        "              95% <= 0.00\n" +
-                        "            99.9% <= 0.00\n" +
-                        "\n" +
-                        "-- Meters ----------------------------------------------------------------------\n" +
-                        "test-meter\n" +
-                        "             count = 0\n" +
-                        "               sum = 0\n" +
-                        "         mean rate = 0.00 events/second\n" +
-                        "     1-minute rate = 0.00 events/second\n" +
-                        "     5-minute rate = 0.00 events/second\n" +
-                        "    15-minute rate = 0.00 events/second\n" +
-                        "\n" +
-                        "-- Timers ----------------------------------------------------------------------\n" +
-                        "test-timer\n" +
-                        "             count = 0\n" +
-                        "               sum = 0.00\n" +
-                        "         mean rate = 0.00 calls/second\n" +
-                        "     1-minute rate = 0.00 calls/second\n" +
-                        "     5-minute rate = 0.00 calls/second\n" +
-                        "    15-minute rate = 0.00 calls/second\n" +
-                        "               min = 0.00 milliseconds\n" +
-                        "               max = 0.00 milliseconds\n" +
-                        "              mean = 0.00 milliseconds\n" +
-                        "            stddev = 0.00 milliseconds\n" +
-                        "            median = 0.00 milliseconds\n" +
-                        "              75% <= 0.00 milliseconds\n" +
-                        "              95% <= 0.00 milliseconds\n" +
-                        "            99.9% <= 0.00 milliseconds\n" +
-                        "\n" +
-                        "\n"
-                );
-    }
+    assertThat(new String(byteArrayOutputStream.toByteArray(), UTF_8))
+        .isEqualToNormalizingNewlines(
+            dateHeader
+                + "\n"
+                + "\n"
+                + "-- Gauges ----------------------------------------------------------------------\n"
+                + "test-gauge\n"
+                + "             value = 20\n"
+                + "\n"
+                + "-- Counters --------------------------------------------------------------------\n"
+                + "test-counter\n"
+                + "             count = 0\n"
+                + "\n"
+                + "-- Histograms ------------------------------------------------------------------\n"
+                + "test-histogram\n"
+                + "             count = 0\n"
+                + "               sum = 0\n"
+                + "               min = 0\n"
+                + "               max = 0\n"
+                + "              mean = 0.00\n"
+                + "            stddev = 0.00\n"
+                + "            median = 0.00\n"
+                + "              75% <= 0.00\n"
+                + "              95% <= 0.00\n"
+                + "            99.9% <= 0.00\n"
+                + "\n"
+                + "-- Meters ----------------------------------------------------------------------\n"
+                + "test-meter\n"
+                + "             count = 0\n"
+                + "               sum = 0\n"
+                + "         mean rate = 0.00 events/second\n"
+                + "     1-minute rate = 0.00 events/second\n"
+                + "     5-minute rate = 0.00 events/second\n"
+                + "    15-minute rate = 0.00 events/second\n"
+                + "\n"
+                + "-- Timers ----------------------------------------------------------------------\n"
+                + "test-timer\n"
+                + "             count = 0\n"
+                + "               sum = 0.00\n"
+                + "         mean rate = 0.00 calls/second\n"
+                + "     1-minute rate = 0.00 calls/second\n"
+                + "     5-minute rate = 0.00 calls/second\n"
+                + "    15-minute rate = 0.00 calls/second\n"
+                + "               min = 0.00 milliseconds\n"
+                + "               max = 0.00 milliseconds\n"
+                + "              mean = 0.00 milliseconds\n"
+                + "            stddev = 0.00 milliseconds\n"
+                + "            median = 0.00 milliseconds\n"
+                + "              75% <= 0.00 milliseconds\n"
+                + "              95% <= 0.00 milliseconds\n"
+                + "            99.9% <= 0.00 milliseconds\n"
+                + "\n"
+                + "\n");
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/CounterTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/CounterTest.java
@@ -1,40 +1,40 @@
 package com.codahale.metrics;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.Counter;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 @SuppressWarnings("deprecation")
-class CounterTest {
+final class CounterTest {
 
-    private Counter counter = new Counter();
+  private Counter counter = new Counter();
 
-    @Test
-    void testIncrementCounter() {
-        counter.inc();
+  @Test
+  void incrementCounter() {
+    counter.inc();
 
-        assertThat(counter.getCount()).isEqualTo(1);
-    }
+    assertThat(counter.getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void testIncrementCounterOnManyPoints() {
-        counter.inc(5);
+  @Test
+  void incrementCounterOnManyPoints() {
+    counter.inc(5);
 
-        assertThat(counter.getCount()).isEqualTo(5);
-    }
+    assertThat(counter.getCount()).isEqualTo(5);
+  }
 
-    @Test
-    void testDecrementCounter() {
-        counter.dec();
+  @Test
+  void decrementCounter() {
+    counter.dec();
 
-        assertThat(counter.getCount()).isEqualTo(-1);
-    }
+    assertThat(counter.getCount()).isEqualTo(-1);
+  }
 
-    @Test
-    void testDecrementCounterOnManyPoints() {
-        counter.dec(5);
+  @Test
+  void decrementCounterOnManyPoints() {
+    counter.dec(5);
 
-        assertThat(counter.getCount()).isEqualTo(-5);
-    }
+    assertThat(counter.getCount()).isEqualTo(-5);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/DerivativeGaugeTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/DerivativeGaugeTest.java
@@ -1,20 +1,21 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
+import org.junit.jupiter.api.Test;
+
 @SuppressWarnings("deprecation")
-class DerivativeGaugeTest {
+final class DerivativeGaugeTest {
 
-    @Test
-    void testCalculate() {
-        DerivativeGauge<String, Integer> derivativeGauge = new DerivativeGauge<String, Integer>(() -> "23") {
-            @Override
-            protected Integer transform(String value) {
-                return Integer.parseInt(value);
-            }
+  @Test
+  void calculate() {
+    DerivativeGauge<String, Integer> derivativeGauge =
+        new DerivativeGauge<String, Integer>(() -> "23") {
+          @Override
+          protected Integer transform(String value) {
+            return Integer.parseInt(value);
+          }
         };
-        assertThat(derivativeGauge.getValue()).isEqualTo(23);
-    }
+    assertThat(derivativeGauge.getValue()).isEqualTo(23);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/ExponentiallyDecayingReservoirTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/ExponentiallyDecayingReservoirTest.java
@@ -1,53 +1,55 @@
 package com.codahale.metrics;
 
-import org.assertj.core.data.Offset;
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 
-@SuppressWarnings("deprecation")
-class ExponentiallyDecayingReservoirTest {
-
-    @Test
-    void testCreateReservoir() {
-        ExponentiallyDecayingReservoir reservoir = new ExponentiallyDecayingReservoir();
-        reservoir.update(120);
-        reservoir.update(190);
-        reservoir.update(200);
-        reservoir.update(130);
-        reservoir.update(140);
-
-        Snapshot snapshot = reservoir.getSnapshot();
-        assertThat(snapshot.size()).isEqualTo(5);
-        assertThat(snapshot.getValues()).contains(120, 130, 140, 190, 200);
-        assertThat(snapshot.getMin()).isEqualTo(120);
-        assertThat(snapshot.getMax()).isEqualTo(200);
-        assertThat(snapshot.getStdDev()).isEqualTo(32.62, Offset.offset(0.1));
-        assertThat(snapshot.get75thPercentile()).isEqualTo(190);
-        assertThat(snapshot.get95thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get98thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get99thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get999thPercentile()).isEqualTo(200);
-    }
-
-    @Test
-    void testCreateReservoirWithCustomSizeAndAlpha() {
-        ExponentiallyDecayingReservoir reservoir = new ExponentiallyDecayingReservoir(512, 0.01);
-        reservoir.update(100);
-        assertThat(reservoir.size()).isEqualTo(1);
-    }
-
+import org.junit.jupiter.api.Test;
 
-    @Test
-    void testCreateReservoirWithCustomSizeAlphaAndClock() {
-        ExponentiallyDecayingReservoir reservoir = new ExponentiallyDecayingReservoir(512, 0.01,
-                new Clock() {
-                    @Override
-                    public long getTick() {
-                        return 24;
-                    }
-                });
-        reservoir.update(100);
-        assertThat(reservoir.size()).isEqualTo(1);
-    }
+@SuppressWarnings("deprecation")
+final class ExponentiallyDecayingReservoirTest {
+
+  @Test
+  void createReservoir() {
+    ExponentiallyDecayingReservoir reservoir = new ExponentiallyDecayingReservoir();
+    reservoir.update(120);
+    reservoir.update(190);
+    reservoir.update(200);
+    reservoir.update(130);
+    reservoir.update(140);
+
+    Snapshot snapshot = reservoir.getSnapshot();
+    assertThat(snapshot.size()).isEqualTo(5);
+    assertThat(snapshot.getValues()).contains(120, 130, 140, 190, 200);
+    assertThat(snapshot.getMin()).isEqualTo(120);
+    assertThat(snapshot.getMax()).isEqualTo(200);
+    assertThat(snapshot.getStdDev()).isCloseTo(32.62, offset(0.1));
+    assertThat(snapshot.get75thPercentile()).isEqualTo(190);
+    assertThat(snapshot.get95thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get98thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get99thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get999thPercentile()).isEqualTo(200);
+  }
+
+  @Test
+  void createReservoirWithCustomSizeAndAlpha() {
+    ExponentiallyDecayingReservoir reservoir = new ExponentiallyDecayingReservoir(512, 0.01);
+    reservoir.update(100);
+    assertThat(reservoir.size()).isEqualTo(1);
+  }
+
+  @Test
+  void createReservoirWithCustomSizeAlphaAndClock() {
+    ExponentiallyDecayingReservoir reservoir =
+        new ExponentiallyDecayingReservoir(
+            512,
+            0.01,
+            new Clock() {
+              @Override
+              public long getTick() {
+                return 24;
+              }
+            });
+    reservoir.update(100);
+    assertThat(reservoir.size()).isEqualTo(1);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/FixedNameCsvFileProviderTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/FixedNameCsvFileProviderTest.java
@@ -1,35 +1,34 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.File;
 import java.nio.file.Files;
 import java.nio.file.Path;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class FixedNameCsvFileProviderTest {
-
-    private Path tempDirectory;
-    private FixedNameCsvFileProvider fixedNameCsvFileProvider = new FixedNameCsvFileProvider();
-
-    @BeforeEach
-    void setUp() throws Exception {
-        tempDirectory = Files.createTempDirectory("csv-test");
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        Files.delete(tempDirectory);
-    }
-
-    @Test
-    void getFile() throws Exception {
-        File file = fixedNameCsvFileProvider.getFile(tempDirectory.toFile(), "timer-test");
-        assertThat(file.toString()).startsWith(tempDirectory.toString());
-        assertThat(file.toString()).endsWith("timer-test.csv");
-    }
+final class FixedNameCsvFileProviderTest {
+
+  private Path tempDirectory;
+  private FixedNameCsvFileProvider fixedNameCsvFileProvider = new FixedNameCsvFileProvider();
+
+  @BeforeEach
+  void setUp() throws Exception {
+    tempDirectory = Files.createTempDirectory("csv-test");
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    Files.delete(tempDirectory);
+  }
+
+  @Test
+  void getFile() throws Exception {
+    File file = fixedNameCsvFileProvider.getFile(tempDirectory.toFile(), "timer-test");
+    assertThat(file.toString()).startsWith(tempDirectory.toString());
+    assertThat(file.toString()).endsWith("timer-test.csv");
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/GaugeTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/GaugeTest.java
@@ -1,16 +1,16 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
+import org.junit.jupiter.api.Test;
+
 @SuppressWarnings("deprecation")
-class GaugeTest {
+final class GaugeTest {
 
-    private Gauge<Integer> gauge = () -> 83;
+  private Gauge<Integer> gauge = () -> 83;
 
-    @Test
-    void testGetValue() {
-        assertThat(gauge.getValue()).isEqualTo(83);
-    }
+  @Test
+  void getValue() {
+    assertThat(gauge.getValue()).isEqualTo(83);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/HistogramTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/HistogramTest.java
@@ -1,33 +1,33 @@
 package com.codahale.metrics;
 
-import org.assertj.core.data.Offset;
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
+
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class HistogramTest {
+final class HistogramTest {
 
-    @Test
-    void testCreate() {
-        Histogram histogram = new Histogram(new ExponentiallyDecayingReservoir());
-        histogram.update(120);
-        histogram.update(190);
-        histogram.update(200L);
-        histogram.update(130);
-        histogram.update(140);
+  @Test
+  void create() {
+    Histogram histogram = new Histogram(new ExponentiallyDecayingReservoir());
+    histogram.update(120);
+    histogram.update(190);
+    histogram.update(200L);
+    histogram.update(130);
+    histogram.update(140);
 
-        assertThat(histogram.getCount()).isEqualTo(5);
-        Snapshot snapshot = histogram.getSnapshot();
-        assertThat(snapshot.size()).isEqualTo(5);
-        assertThat(snapshot.getValues()).contains(120, 130, 140, 190, 200);
-        assertThat(snapshot.getMin()).isEqualTo(120);
-        assertThat(snapshot.getMax()).isEqualTo(200);
-        assertThat(snapshot.getStdDev()).isEqualTo(32.62, Offset.offset(0.1));
-        assertThat(snapshot.get75thPercentile()).isEqualTo(190);
-        assertThat(snapshot.get95thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get98thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get99thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get999thPercentile()).isEqualTo(200);
-    }
+    assertThat(histogram.getCount()).isEqualTo(5);
+    Snapshot snapshot = histogram.getSnapshot();
+    assertThat(snapshot.size()).isEqualTo(5);
+    assertThat(snapshot.getValues()).contains(120, 130, 140, 190, 200);
+    assertThat(snapshot.getMin()).isEqualTo(120);
+    assertThat(snapshot.getMax()).isEqualTo(200);
+    assertThat(snapshot.getStdDev()).isCloseTo(32.62, offset(0.1));
+    assertThat(snapshot.get75thPercentile()).isEqualTo(190);
+    assertThat(snapshot.get95thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get98thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get99thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get999thPercentile()).isEqualTo(200);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/InstrumentedExecutorServiceTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/InstrumentedExecutorServiceTest.java
@@ -1,34 +1,37 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class InstrumentedExecutorServiceTest {
-
+final class InstrumentedExecutorServiceTest {
 
-    @Test
-    void testCreate() throws Exception {
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        MetricRegistry registry = new MetricRegistry();
-        InstrumentedExecutorService instrumentedExecutorService = new InstrumentedExecutorService(executorService,
-                registry, "test-instrumented");
-        CountDownLatch countDownLatch = new CountDownLatch(10);
-        for (int i = 0; i < 10; i++) {
-            instrumentedExecutorService.submit(countDownLatch::countDown);
-        }
-        countDownLatch.await(5, TimeUnit.SECONDS);
-        executorService.shutdown();
-        executorService.awaitTermination(5, TimeUnit.SECONDS);
-
-        assertThat(registry.getMetrics()).containsOnlyKeys("test-instrumented.completed",
-                "test-instrumented.submitted", "test-instrumented.duration", "test-instrumented.idle",
-                "test-instrumented.running", "test-instrumented.rejected");
+  @Test
+  void create() throws Exception {
+    ExecutorService executorService = Executors.newSingleThreadExecutor();
+    MetricRegistry registry = new MetricRegistry();
+    InstrumentedExecutorService instrumentedExecutorService =
+        new InstrumentedExecutorService(executorService, registry, "test-instrumented");
+    CountDownLatch countDownLatch = new CountDownLatch(10);
+    for (int i = 0; i < 10; i++) {
+      instrumentedExecutorService.submit(countDownLatch::countDown);
     }
+    countDownLatch.await(5, TimeUnit.SECONDS);
+    executorService.shutdown();
+    executorService.awaitTermination(5, TimeUnit.SECONDS);
+
+    assertThat(registry.getMetrics())
+        .containsOnlyKeys(
+            "test-instrumented.completed",
+            "test-instrumented.submitted",
+            "test-instrumented.duration",
+            "test-instrumented.idle",
+            "test-instrumented.running",
+            "test-instrumented.rejected");
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/InstrumentedScheduledExecutorServiceTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/InstrumentedScheduledExecutorServiceTest.java
@@ -1,37 +1,44 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class InstrumentedScheduledExecutorServiceTest {
-    private ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
+final class InstrumentedScheduledExecutorServiceTest {
+  private ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
 
-    @AfterEach
-    void tearDown() {
-        executorService.shutdown();
-    }
+  @AfterEach
+  void tearDown() {
+    executorService.shutdown();
+  }
 
-    @Test
-    void testCreate() throws Exception {
-        MetricRegistry registry = new MetricRegistry();
-        InstrumentedScheduledExecutorService instrumentedExecutorService = new InstrumentedScheduledExecutorService(
-                executorService, registry, "test-scheduled-instrumented");
-        CountDownLatch countDownLatch = new CountDownLatch(10);
-        instrumentedExecutorService.scheduleAtFixedRate(countDownLatch::countDown, 0, 10, TimeUnit.MILLISECONDS);
-        countDownLatch.await(5, TimeUnit.SECONDS);
-        instrumentedExecutorService.shutdown();
+  @Test
+  void create() throws Exception {
+    MetricRegistry registry = new MetricRegistry();
+    InstrumentedScheduledExecutorService instrumentedExecutorService =
+        new InstrumentedScheduledExecutorService(
+            executorService, registry, "test-scheduled-instrumented");
+    CountDownLatch countDownLatch = new CountDownLatch(10);
+    instrumentedExecutorService.scheduleAtFixedRate(
+        countDownLatch::countDown, 0, 10, TimeUnit.MILLISECONDS);
+    countDownLatch.await(5, TimeUnit.SECONDS);
+    instrumentedExecutorService.shutdown();
 
-        assertThat(registry.getMetrics()).containsOnlyKeys("test-scheduled-instrumented.completed",
-                "test-scheduled-instrumented.submitted", "test-scheduled-instrumented.duration", "test-scheduled-instrumented.running",
-                "test-scheduled-instrumented.scheduled.once", "test-scheduled-instrumented.scheduled.overrun",
-                "test-scheduled-instrumented.scheduled.percent-of-period", "test-scheduled-instrumented.scheduled.repetitively");
-    }
+    assertThat(registry.getMetrics())
+        .containsOnlyKeys(
+            "test-scheduled-instrumented.completed",
+            "test-scheduled-instrumented.submitted",
+            "test-scheduled-instrumented.duration",
+            "test-scheduled-instrumented.running",
+            "test-scheduled-instrumented.scheduled.once",
+            "test-scheduled-instrumented.scheduled.overrun",
+            "test-scheduled-instrumented.scheduled.percent-of-period",
+            "test-scheduled-instrumented.scheduled.repetitively");
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/InstrumentedThreadFactoryTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/InstrumentedThreadFactoryTest.java
@@ -1,28 +1,29 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class InstrumentedThreadFactoryTest {
+final class InstrumentedThreadFactoryTest {
 
-    @Test
-    @SuppressWarnings("DoNotCall")
-    void testFactory() throws Exception {
-        MetricRegistry registry = new MetricRegistry();
-        InstrumentedThreadFactory threadFactory = new InstrumentedThreadFactory(Thread::new, registry,
-                "test-instrumented-thread-factory");
-        CountDownLatch latch = new CountDownLatch(4);
-        for (int i = 0; i < 4; i++) {
-            threadFactory.newThread(latch::countDown).run();
-        }
-        latch.await(5, TimeUnit.SECONDS);
-        assertThat(registry.meter("test-instrumented-thread-factory.created").getCount()).isEqualTo(4);
-        assertThat(registry.counter("test-instrumented-thread-factory.running").getCount()).isEqualTo(0);
-        assertThat(registry.meter("test-instrumented-thread-factory.terminated").getCount()).isEqualTo(4);
+  @SuppressWarnings("DoNotCall")
+  @Test
+  void factory() throws Exception {
+    MetricRegistry registry = new MetricRegistry();
+    InstrumentedThreadFactory threadFactory =
+        new InstrumentedThreadFactory(Thread::new, registry, "test-instrumented-thread-factory");
+    CountDownLatch latch = new CountDownLatch(4);
+    for (int i = 0; i < 4; i++) {
+      threadFactory.newThread(latch::countDown).run();
     }
+    latch.await(5, TimeUnit.SECONDS);
+    assertThat(registry.meter("test-instrumented-thread-factory.created").getCount()).isEqualTo(4);
+    assertThat(registry.counter("test-instrumented-thread-factory.running").getCount())
+        .isEqualTo(0);
+    assertThat(registry.meter("test-instrumented-thread-factory.terminated").getCount())
+        .isEqualTo(4);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/MeterTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/MeterTest.java
@@ -1,50 +1,53 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class MeterTest {
-
-    @Test
-    void testCreateMeteer() {
-        Meter meter = new Meter();
-        assertThat(meter.getCount()).isEqualTo(0);
-    }
-
-    @Test
-    void testCreateMeterWithCustomClock() {
-        Meter meter = new Meter(new Clock() {
-            @Override
-            public long getTick() {
+final class MeterTest {
+
+  @Test
+  void createMeteer() {
+    Meter meter = new Meter();
+    assertThat(meter.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void createMeterWithCustomClock() {
+    Meter meter =
+        new Meter(
+            new Clock() {
+              @Override
+              public long getTick() {
                 return 0;
-            }
-        });
-        assertThat(meter.getCount()).isEqualTo(0);
-    }
+              }
+            });
+    assertThat(meter.getCount()).isEqualTo(0);
+  }
 
-    @Test
-    void testMark() {
-        Meter meter = new Meter(new Clock() {
+  @Test
+  void mark() {
+    Meter meter =
+        new Meter(
+            new Clock() {
 
-            private long start = System.nanoTime();
+              private long start = System.nanoTime();
 
-            @Override
-            public long getTick() {
+              @Override
+              public long getTick() {
                 return start += TimeUnit.SECONDS.toNanos(1);
-            }
-        });
-        for (int i = 0; i < 60; i++) {
-            meter.mark();
-        }
-        for (int i = 0; i < 60; i++) {
-            meter.mark(2);
-        }
-
-        assertThat(meter.getCount()).isEqualTo(180);
-        assertThat(meter.getMeanRate()).isBetween(1.0, 2.0);
+              }
+            });
+    for (int i = 0; i < 60; i++) {
+      meter.mark();
     }
+    for (int i = 0; i < 60; i++) {
+      meter.mark(2);
+    }
+
+    assertThat(meter.getCount()).isEqualTo(180);
+    assertThat(meter.getMeanRate()).isBetween(1.0, 2.0);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/MetricRegistryTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/MetricRegistryTest.java
@@ -1,509 +1,554 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 
 import java.util.HashMap;
 import java.util.Map;
 import java.util.SortedMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class MetricRegistryTest {
-
-    private MetricRegistry metricRegistry = new MetricRegistry();
-
-    @Test
-    void testRegisterMetric() {
-        Counter counter = metricRegistry.register("test-counter", new Counter());
-        counter.inc(42);
-        assertThat(metricRegistry.counter("test-counter").getCount()).isEqualTo(42);
-    }
-
-    @Test
-    void testRegisterAll() {
-        metricRegistry.registerAll(() -> {
-            Map<String, Metric> map = new HashMap<>();
-            map.put("test-counter", new Counter());
-            map.put("test-gauge", (Gauge<Integer>) () -> 28);
-            map.put("test-histogram", new Histogram(new ExponentiallyDecayingReservoir()));
-            return map;
-        });
-        Map<String, Metric> metrics = metricRegistry.getMetrics();
-        assertThat(metrics).containsOnlyKeys("test-counter", "test-histogram", "test-gauge");
-        assertThat(metrics.get("test-counter")).isInstanceOf(Counter.class);
-        assertThat(metrics.get("test-histogram")).isInstanceOf(Histogram.class);
-        assertThat(metrics.get("test-gauge")).isInstanceOf(Gauge.class);
-    }
-
-    @Test
-    void testRegisterGauge() {
-        metricRegistry.registerGauge("test-gauge", () -> 42);
-        assertThat(metricRegistry.getGauges().get("test-gauge").getValue()).isEqualTo(42);
-    }
-
-    @Test
-    void testCreateCustomGauge() {
-        Gauge gauge = metricRegistry.gauge("test-gauge-supplier", () -> () -> 42);
-        assertThat(gauge.getValue()).isEqualTo(42);
-    }
-
-    @Test
-    void testCreateCounter() {
-        Counter counter = metricRegistry.counter("test-counter");
-        counter.inc(42);
-        assertThat(metricRegistry.counter("test-counter").getCount()).isEqualTo(42);
-    }
-
-    @Test
-    void testCreateCustomCounter() {
-        Counter counter = metricRegistry.counter("test-custom-counter", () -> {
-            Counter c = new Counter();
-            c.inc(8);
-            return c;
-        });
-        counter.inc(16);
-        assertThat(metricRegistry.counter("test-custom-counter").getCount()).isEqualTo(24);
-    }
-
-    @Test
-    void testCreateHistogram() {
-        Histogram histogram = metricRegistry.histogram("test-histogram");
-        histogram.update(100);
-        histogram.update(200);
-        histogram.update(180);
-        assertThat(metricRegistry.histogram("test-histogram").getSnapshot().getMean())
-                .isCloseTo(160.0, offset(0.1));
-    }
-
-    @Test
-    void testCreateCustomHistogram() {
-        Histogram histogram = metricRegistry.histogram("test-custom-histogram",
-                () -> new Histogram(new SlidingWindowReservoir(2)));
-        histogram.update(100);
-        histogram.update(200);
-        histogram.update(180);
-        assertThat(metricRegistry.histogram("test-custom-histogram").getSnapshot().getMean())
-                .isCloseTo(190.0, offset(0.1));
-    }
-
-    @Test
-    void testCreateMeter() {
-        Meter meter = metricRegistry.meter("test-meter");
-        meter.mark();
-        meter.mark(2);
-
-        assertThat(metricRegistry.meter("test-meter").getCount()).isEqualTo(3);
-    }
-
-    @Test
-    void testCreateCustomMeter() {
-        Meter meter = metricRegistry.meter("test-custom-meter", () -> {
-            Meter m = new Meter();
-            m.mark(16);
-            return m;
-        });
-        meter.mark();
-
-        assertThat(metricRegistry.meter("test-custom-meter").getCount()).isEqualTo(17);
-    }
-
-    @Test
-    void testCreateTimer() {
-        Timer timer = metricRegistry.timer("test-timer");
-        timer.update(100, TimeUnit.MILLISECONDS);
-        timer.update(200, TimeUnit.MILLISECONDS);
-        timer.update(180, TimeUnit.MILLISECONDS);
-
-        assertThat(metricRegistry.timer("test-timer").getCount()).isEqualTo(3);
-    }
-
-    @Test
-    void testCreateCustomTimer() {
-        Timer timer = metricRegistry.timer("custom-test-timer", () -> {
-            Timer t = new Timer(new UniformReservoir());
-            t.update(300, TimeUnit.MILLISECONDS);
-            t.update(200, TimeUnit.MILLISECONDS);
-            return t;
+final class MetricRegistryTest {
+
+  private MetricRegistry metricRegistry = new MetricRegistry();
+
+  @Test
+  void registerMetric() {
+    Counter counter = metricRegistry.register("test-counter", new Counter());
+    counter.inc(42);
+    assertThat(metricRegistry.counter("test-counter").getCount()).isEqualTo(42);
+  }
+
+  @Test
+  void registerAll() {
+    metricRegistry.registerAll(
+        () -> {
+          Map<String, Metric> map = new HashMap<>();
+          map.put("test-counter", new Counter());
+          map.put("test-gauge", (Gauge<Integer>) () -> 28);
+          map.put("test-histogram", new Histogram(new ExponentiallyDecayingReservoir()));
+          return map;
         });
-        timer.update(180, TimeUnit.MILLISECONDS);
-
-        assertThat(metricRegistry.timer("custom-test-timer").getCount()).isEqualTo(3);
-    }
-
-    @Test
-    void testRemoveMetric() {
-        metricRegistry.timer("test-timer");
-        metricRegistry.counter("test-counter");
-        metricRegistry.meter("test-meter");
-
-        assertThat(metricRegistry.remove("test-counter")).isTrue();
-
-        assertThat(metricRegistry.getMetrics()).containsOnlyKeys("test-timer", "test-meter");
-    }
-
-    @Test
-    void testRemoveMatching() {
-        metricRegistry.counter("test-counter");
-        metricRegistry.timer("test-timer");
-        metricRegistry.timer("test-custom-timer");
-        metricRegistry.meter("test-meter");
-
-        metricRegistry.removeMatching((name, metric) -> metric instanceof Timer && name.startsWith("test"));
-        assertThat(metricRegistry.getMetrics()).containsOnlyKeys("test-counter", "test-meter");
-    }
-
-    @Test
-    void testAddListenerForGauge() throws Exception {
-        CountDownLatch gaugeAddedLatch = new CountDownLatch(1);
-        CountDownLatch gaugeRemovedLatch = new CountDownLatch(1);
-        metricRegistry.addListener(new MetricRegistryListener.Base() {
-            @Override
-            public void onGaugeAdded(String name, Gauge<?> gauge) {
-                assertThat(name).isEqualTo("test-gauge");
-                assertThat(gauge.getValue()).isEqualTo(42);
-                gaugeAddedLatch.countDown();
-            }
-
-            @Override
-            public void onGaugeRemoved(String name) {
-                assertThat(name).isEqualTo("test-gauge");
-                gaugeRemovedLatch.countDown();
-            }
+    Map<String, Metric> metrics = metricRegistry.getMetrics();
+    assertThat(metrics).containsOnlyKeys("test-counter", "test-histogram", "test-gauge");
+    assertThat(metrics.get("test-counter")).isInstanceOf(Counter.class);
+    assertThat(metrics.get("test-histogram")).isInstanceOf(Histogram.class);
+    assertThat(metrics.get("test-gauge")).isInstanceOf(Gauge.class);
+  }
+
+  @Test
+  void registerGauge() {
+    metricRegistry.registerGauge("test-gauge", () -> 42);
+    assertThat(metricRegistry.getGauges().get("test-gauge").getValue()).isEqualTo(42);
+  }
+
+  @Test
+  void createCustomGauge() {
+    Gauge gauge = metricRegistry.gauge("test-gauge-supplier", () -> () -> 42);
+    assertThat(gauge.getValue()).isEqualTo(42);
+  }
+
+  @Test
+  void createCounter() {
+    Counter counter = metricRegistry.counter("test-counter");
+    counter.inc(42);
+    assertThat(metricRegistry.counter("test-counter").getCount()).isEqualTo(42);
+  }
+
+  @Test
+  void createCustomCounter() {
+    Counter counter =
+        metricRegistry.counter(
+            "test-custom-counter",
+            () -> {
+              Counter c = new Counter();
+              c.inc(8);
+              return c;
+            });
+    counter.inc(16);
+    assertThat(metricRegistry.counter("test-custom-counter").getCount()).isEqualTo(24);
+  }
+
+  @Test
+  void createHistogram() {
+    Histogram histogram = metricRegistry.histogram("test-histogram");
+    histogram.update(100);
+    histogram.update(200);
+    histogram.update(180);
+    assertThat(metricRegistry.histogram("test-histogram").getSnapshot().getMean())
+        .isCloseTo(160.0, offset(0.1));
+  }
+
+  @Test
+  void createCustomHistogram() {
+    Histogram histogram =
+        metricRegistry.histogram(
+            "test-custom-histogram", () -> new Histogram(new SlidingWindowReservoir(2)));
+    histogram.update(100);
+    histogram.update(200);
+    histogram.update(180);
+    assertThat(metricRegistry.histogram("test-custom-histogram").getSnapshot().getMean())
+        .isCloseTo(190.0, offset(0.1));
+  }
+
+  @Test
+  void createMeter() {
+    Meter meter = metricRegistry.meter("test-meter");
+    meter.mark();
+    meter.mark(2);
+
+    assertThat(metricRegistry.meter("test-meter").getCount()).isEqualTo(3);
+  }
+
+  @Test
+  void createCustomMeter() {
+    Meter meter =
+        metricRegistry.meter(
+            "test-custom-meter",
+            () -> {
+              Meter m = new Meter();
+              m.mark(16);
+              return m;
+            });
+    meter.mark();
+
+    assertThat(metricRegistry.meter("test-custom-meter").getCount()).isEqualTo(17);
+  }
+
+  @Test
+  void createTimer() {
+    Timer timer = metricRegistry.timer("test-timer");
+    timer.update(100, TimeUnit.MILLISECONDS);
+    timer.update(200, TimeUnit.MILLISECONDS);
+    timer.update(180, TimeUnit.MILLISECONDS);
+
+    assertThat(metricRegistry.timer("test-timer").getCount()).isEqualTo(3);
+  }
+
+  @Test
+  void createCustomTimer() {
+    Timer timer =
+        metricRegistry.timer(
+            "custom-test-timer",
+            () -> {
+              Timer t = new Timer(new UniformReservoir());
+              t.update(300, TimeUnit.MILLISECONDS);
+              t.update(200, TimeUnit.MILLISECONDS);
+              return t;
+            });
+    timer.update(180, TimeUnit.MILLISECONDS);
+
+    assertThat(metricRegistry.timer("custom-test-timer").getCount()).isEqualTo(3);
+  }
+
+  @Test
+  void removeMetric() {
+    metricRegistry.timer("test-timer");
+    metricRegistry.counter("test-counter");
+    metricRegistry.meter("test-meter");
+
+    assertThat(metricRegistry.remove("test-counter")).isTrue();
+
+    assertThat(metricRegistry.getMetrics()).containsOnlyKeys("test-timer", "test-meter");
+  }
+
+  @Test
+  void removeMatching() {
+    metricRegistry.counter("test-counter");
+    metricRegistry.timer("test-timer");
+    metricRegistry.timer("test-custom-timer");
+    metricRegistry.meter("test-meter");
+
+    metricRegistry.removeMatching(
+        (name, metric) -> metric instanceof Timer && name.startsWith("test"));
+    assertThat(metricRegistry.getMetrics()).containsOnlyKeys("test-counter", "test-meter");
+  }
+
+  @Test
+  void addListenerForGauge() throws Exception {
+    CountDownLatch gaugeAddedLatch = new CountDownLatch(1);
+    CountDownLatch gaugeRemovedLatch = new CountDownLatch(1);
+    metricRegistry.addListener(
+        new MetricRegistryListener.Base() {
+          @Override
+          public void onGaugeAdded(String name, Gauge<?> gauge) {
+            assertThat(name).isEqualTo("test-gauge");
+            assertThat(gauge.getValue()).isEqualTo(42);
+            gaugeAddedLatch.countDown();
+          }
+
+          @Override
+          public void onGaugeRemoved(String name) {
+            assertThat(name).isEqualTo("test-gauge");
+            gaugeRemovedLatch.countDown();
+          }
         });
 
-        metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
-        gaugeAddedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(gaugeAddedLatch.getCount()).isEqualTo(0);
-
-        metricRegistry.remove("test-gauge");
-        gaugeRemovedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(gaugeRemovedLatch.getCount()).isEqualTo(0);
-    }
-
-    @Test
-    void testAddListenerForCounter() throws Exception {
-        CountDownLatch counterAddedLatch = new CountDownLatch(1);
-        CountDownLatch counterRemovedLatch = new CountDownLatch(1);
-        metricRegistry.addListener(new MetricRegistryListener.Base() {
-            @Override
-            public void onCounterAdded(String name, Counter counter) {
-                assertThat(name).isEqualTo("test-counter");
-                counterAddedLatch.countDown();
-            }
-
-            @Override
-            public void onCounterRemoved(String name) {
-                assertThat(name).isEqualTo("test-counter");
-                counterRemovedLatch.countDown();
-            }
+    metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
+    gaugeAddedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(gaugeAddedLatch.getCount()).isEqualTo(0);
+
+    metricRegistry.remove("test-gauge");
+    gaugeRemovedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(gaugeRemovedLatch.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void addListenerForCounter() throws Exception {
+    CountDownLatch counterAddedLatch = new CountDownLatch(1);
+    CountDownLatch counterRemovedLatch = new CountDownLatch(1);
+    metricRegistry.addListener(
+        new MetricRegistryListener.Base() {
+          @Override
+          public void onCounterAdded(String name, Counter counter) {
+            assertThat(name).isEqualTo("test-counter");
+            counterAddedLatch.countDown();
+          }
+
+          @Override
+          public void onCounterRemoved(String name) {
+            assertThat(name).isEqualTo("test-counter");
+            counterRemovedLatch.countDown();
+          }
         });
 
-        metricRegistry.counter("test-counter");
-        counterAddedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(counterAddedLatch.getCount()).isEqualTo(0);
-
-        metricRegistry.remove("test-counter");
-        counterRemovedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(counterRemovedLatch.getCount()).isEqualTo(0);
-    }
-
-    @Test
-    void testAddListenerForHistogram() throws Exception {
-        CountDownLatch histogramAddedLatch = new CountDownLatch(1);
-        CountDownLatch histogramRemovedLatch = new CountDownLatch(1);
-        metricRegistry.addListener(new MetricRegistryListener.Base() {
-
-
-            @Override
-            public void onHistogramAdded(String name, Histogram histogram) {
-                assertThat(name).isEqualTo("test-histogram");
-                histogramAddedLatch.countDown();
-            }
-
-            @Override
-            public void onHistogramRemoved(String name) {
-                assertThat(name).isEqualTo("test-histogram");
-                histogramRemovedLatch.countDown();
-            }
+    metricRegistry.counter("test-counter");
+    counterAddedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(counterAddedLatch.getCount()).isEqualTo(0);
+
+    metricRegistry.remove("test-counter");
+    counterRemovedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(counterRemovedLatch.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void addListenerForHistogram() throws Exception {
+    CountDownLatch histogramAddedLatch = new CountDownLatch(1);
+    CountDownLatch histogramRemovedLatch = new CountDownLatch(1);
+    metricRegistry.addListener(
+        new MetricRegistryListener.Base() {
+
+          @Override
+          public void onHistogramAdded(String name, Histogram histogram) {
+            assertThat(name).isEqualTo("test-histogram");
+            histogramAddedLatch.countDown();
+          }
+
+          @Override
+          public void onHistogramRemoved(String name) {
+            assertThat(name).isEqualTo("test-histogram");
+            histogramRemovedLatch.countDown();
+          }
         });
 
-        metricRegistry.histogram("test-histogram");
-        histogramAddedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(histogramAddedLatch.getCount()).isEqualTo(0);
-
-        metricRegistry.remove("test-histogram");
-        histogramRemovedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(histogramRemovedLatch.getCount()).isEqualTo(0);
-    }
-
-    @Test
-    void testAddListenerForMeter() throws Exception {
-        CountDownLatch meterAddedLatch = new CountDownLatch(1);
-        CountDownLatch meterRemovedLatch = new CountDownLatch(1);
-        metricRegistry.addListener(new MetricRegistryListener.Base() {
-
-            @Override
-            public void onMeterAdded(String name, Meter meter) {
-                assertThat(name).isEqualTo("test-meter");
-                meterAddedLatch.countDown();
-            }
-
-            @Override
-            public void onMeterRemoved(String name) {
-                assertThat(name).isEqualTo("test-meter");
-                meterRemovedLatch.countDown();
-            }
+    metricRegistry.histogram("test-histogram");
+    histogramAddedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(histogramAddedLatch.getCount()).isEqualTo(0);
+
+    metricRegistry.remove("test-histogram");
+    histogramRemovedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(histogramRemovedLatch.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void addListenerForMeter() throws Exception {
+    CountDownLatch meterAddedLatch = new CountDownLatch(1);
+    CountDownLatch meterRemovedLatch = new CountDownLatch(1);
+    metricRegistry.addListener(
+        new MetricRegistryListener.Base() {
+
+          @Override
+          public void onMeterAdded(String name, Meter meter) {
+            assertThat(name).isEqualTo("test-meter");
+            meterAddedLatch.countDown();
+          }
+
+          @Override
+          public void onMeterRemoved(String name) {
+            assertThat(name).isEqualTo("test-meter");
+            meterRemovedLatch.countDown();
+          }
         });
 
-        metricRegistry.meter("test-meter");
-        meterAddedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(meterAddedLatch.getCount()).isEqualTo(0);
-
-        metricRegistry.remove("test-meter");
-        meterRemovedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(meterRemovedLatch.getCount()).isEqualTo(0);
-    }
-
-    @Test
-    void testAddListenerForTimer() throws Exception {
-        CountDownLatch timerAddedLatch = new CountDownLatch(1);
-        CountDownLatch timerRemovedLatch = new CountDownLatch(1);
-        metricRegistry.addListener(new MetricRegistryListener.Base() {
-
-            @Override
-            public void onTimerAdded(String name, Timer timer) {
-                assertThat(name).isEqualTo("test-timer");
-                timerAddedLatch.countDown();
-            }
-
-            @Override
-            public void onTimerRemoved(String name) {
-                assertThat(name).isEqualTo("test-timer");
-                timerRemovedLatch.countDown();
-            }
+    metricRegistry.meter("test-meter");
+    meterAddedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(meterAddedLatch.getCount()).isEqualTo(0);
+
+    metricRegistry.remove("test-meter");
+    meterRemovedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(meterRemovedLatch.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void addListenerForTimer() throws Exception {
+    CountDownLatch timerAddedLatch = new CountDownLatch(1);
+    CountDownLatch timerRemovedLatch = new CountDownLatch(1);
+    metricRegistry.addListener(
+        new MetricRegistryListener.Base() {
+
+          @Override
+          public void onTimerAdded(String name, Timer timer) {
+            assertThat(name).isEqualTo("test-timer");
+            timerAddedLatch.countDown();
+          }
+
+          @Override
+          public void onTimerRemoved(String name) {
+            assertThat(name).isEqualTo("test-timer");
+            timerRemovedLatch.countDown();
+          }
         });
 
-        metricRegistry.timer("test-timer");
-        timerAddedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(timerAddedLatch.getCount()).isEqualTo(0);
-
-        metricRegistry.remove("test-timer");
-        timerRemovedLatch.await(5, TimeUnit.SECONDS);
-        assertThat(timerRemovedLatch.getCount()).isEqualTo(0);
-    }
-
-    @Test
-    void testRemoveListener() throws Exception {
-        CountDownLatch gaugeAddedLatch = new CountDownLatch(1);
-        MetricRegistryListener listener = new MetricRegistryListener.Base() {
-            @Override
-            public void onGaugeAdded(String name, Gauge<?> gauge) {
-                gaugeAddedLatch.countDown();
-            }
+    metricRegistry.timer("test-timer");
+    timerAddedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(timerAddedLatch.getCount()).isEqualTo(0);
+
+    metricRegistry.remove("test-timer");
+    timerRemovedLatch.await(5, TimeUnit.SECONDS);
+    assertThat(timerRemovedLatch.getCount()).isEqualTo(0);
+  }
+
+  @Test
+  void removeListener() throws Exception {
+    CountDownLatch gaugeAddedLatch = new CountDownLatch(1);
+    MetricRegistryListener listener =
+        new MetricRegistryListener.Base() {
+          @Override
+          public void onGaugeAdded(String name, Gauge<?> gauge) {
+            gaugeAddedLatch.countDown();
+          }
         };
-        metricRegistry.addListener(listener);
-        metricRegistry.removeListener(listener);
-
-        metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 39);
-
-        gaugeAddedLatch.await(100, TimeUnit.MILLISECONDS);
-        assertThat(gaugeAddedLatch.getCount()).isEqualTo(1);
-    }
-
-    @Test
-    void testGetNames() {
-        metricRegistry.counter("test-counter");
-        metricRegistry.timer("test-timer");
-        metricRegistry.timer("test-custom-timer");
-        metricRegistry.meter("test-meter");
-
-        assertThat(metricRegistry.getNames()).containsExactly("test-counter", "test-custom-timer",
-                "test-meter", "test-timer");
-    }
-
-    @Test
-    void testGetGauges() {
-        metricRegistry.counter("test-counter");
-        metricRegistry.timer("test-timer");
-        metricRegistry.meter("test-meter");
-        metricRegistry.register("test-text-gauge-2", new CachedGauge<String>(1, TimeUnit.MINUTES) {
-            @Override
-            protected String loadValue() {
-                return "eu2";
-            }
+    metricRegistry.addListener(listener);
+    metricRegistry.removeListener(listener);
+
+    metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 39);
+
+    gaugeAddedLatch.await(100, TimeUnit.MILLISECONDS);
+    assertThat(gaugeAddedLatch.getCount()).isEqualTo(1);
+  }
+
+  @Test
+  void getNames() {
+    metricRegistry.counter("test-counter");
+    metricRegistry.timer("test-timer");
+    metricRegistry.timer("test-custom-timer");
+    metricRegistry.meter("test-meter");
+
+    assertThat(metricRegistry.getNames())
+        .containsExactly("test-counter", "test-custom-timer", "test-meter", "test-timer");
+  }
+
+  @Test
+  void getGauges() {
+    metricRegistry.counter("test-counter");
+    metricRegistry.timer("test-timer");
+    metricRegistry.meter("test-meter");
+    metricRegistry.register(
+        "test-text-gauge-2",
+        new CachedGauge<String>(1, TimeUnit.MINUTES) {
+          @Override
+          protected String loadValue() {
+            return "eu2";
+          }
         });
-        metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
-        metricRegistry.register("test-text-gauge-1", new DerivativeGauge<Integer, String>(() -> 1) {
-            @Override
-            protected String transform(Integer value) {
-                return "eu" + value;
-            }
+    metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
+    metricRegistry.register(
+        "test-text-gauge-1",
+        new DerivativeGauge<Integer, String>(() -> 1) {
+          @Override
+          protected String transform(Integer value) {
+            return "eu" + value;
+          }
         });
 
-        SortedMap<String, Gauge> gauges = metricRegistry.getGauges();
-        assertThat(gauges).containsOnlyKeys("test-gauge", "test-text-gauge-1", "test-text-gauge-2");
-    }
-
-    @Test
-    void testGetGaugesWithFilter() {
-        metricRegistry.counter("test-counter");
-        metricRegistry.timer("test-timer");
-        metricRegistry.meter("test-meter");
-        metricRegistry.register("test-text-gauge-2", new CachedGauge<String>(1, TimeUnit.MINUTES) {
-            @Override
-            protected String loadValue() {
-                return "eu2";
-            }
+    SortedMap<String, Gauge> gauges = metricRegistry.getGauges();
+    assertThat(gauges).containsOnlyKeys("test-gauge", "test-text-gauge-1", "test-text-gauge-2");
+  }
+
+  @Test
+  void getGaugesWithFilter() {
+    metricRegistry.counter("test-counter");
+    metricRegistry.timer("test-timer");
+    metricRegistry.meter("test-meter");
+    metricRegistry.register(
+        "test-text-gauge-2",
+        new CachedGauge<String>(1, TimeUnit.MINUTES) {
+          @Override
+          protected String loadValue() {
+            return "eu2";
+          }
         });
-        metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
-        metricRegistry.register("test-text-gauge-1", new DerivativeGauge<Integer, String>(() -> 1) {
-            @Override
-            protected String transform(Integer value) {
-                return "eu" + value;
-            }
+    metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
+    metricRegistry.register(
+        "test-text-gauge-1",
+        new DerivativeGauge<Integer, String>(() -> 1) {
+          @Override
+          protected String transform(Integer value) {
+            return "eu" + value;
+          }
         });
 
-        assertThat(metricRegistry.getGauges((name, metric) -> name.contains("gauge") && metric instanceof CachedGauge))
-                .containsOnlyKeys("test-text-gauge-2");
-    }
-
-    @Test
-    void testGetHistograms() {
-        metricRegistry.counter("test-counter");
-        metricRegistry.timer("test-timer");
-        metricRegistry.meter("test-meter");
-        metricRegistry.histogram("test-histogram-1");
-        metricRegistry.histogram("test-histogram-3");
-        metricRegistry.histogram("test-histogram-2");
-
-        assertThat(metricRegistry.getHistograms())
-                .containsOnlyKeys("test-histogram-1", "test-histogram-2", "test-histogram-3");
-    }
-
-    @Test
-    void testGetHistogramsWithFilter() {
-        metricRegistry.counter("sw-counter");
-        metricRegistry.timer("sw-timer");
-        metricRegistry.meter("sw-meter");
-        metricRegistry.histogram("sw-histogram-1");
-        metricRegistry.histogram("se-histogram-3");
-        metricRegistry.histogram("sw-histogram-2");
-
-        assertThat(metricRegistry.getHistograms(MetricFilter.startsWith("sw")))
-                .containsOnlyKeys("sw-histogram-1", "sw-histogram-2");
-    }
-
-    @Test
-    void testGetCounters() {
-        metricRegistry.histogram("test-histogram");
-        metricRegistry.timer("test-timer");
-        metricRegistry.meter("test-meter");
-        metricRegistry.counter("test-counter-1");
-        metricRegistry.counter("test-counter-3");
-        metricRegistry.counter("test-counter-2");
-
-        assertThat(metricRegistry.getCounters())
-                .containsOnlyKeys("test-counter-1", "test-counter-2", "test-counter-3");
-    }
-
-    @Test
-    void testGetCountersWithFilter() {
-        metricRegistry.histogram("test-histogram");
-        metricRegistry.timer("test-timer");
-        metricRegistry.meter("test-meter");
-        metricRegistry.counter("test-counter-1");
-        metricRegistry.counter("test-counter-3");
-        metricRegistry.counter("test-cnt-2");
-
-        assertThat(metricRegistry.getCounters(MetricFilter.contains("counter")))
-                .containsOnlyKeys("test-counter-1", "test-counter-3");
-    }
-
-    @Test
-    void testGetMeters() {
-        metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
-        metricRegistry.histogram("test-histogram");
-        metricRegistry.timer("test-timer");
-        metricRegistry.counter("test-counter");
-        metricRegistry.meter("test-meter-1");
-        metricRegistry.meter("test-meter-3");
-        metricRegistry.meter("test-meter-2");
-
-        assertThat(metricRegistry.getMeters()).containsOnlyKeys("test-meter-1", "test-meter-2", "test-meter-3");
-    }
-
-    @Test
-    void testGetMetersWithFilter() {
-        metricRegistry.register("sw-gauge", (Gauge<Integer>) () -> 42);
-        metricRegistry.histogram("sw-histogram");
-        metricRegistry.timer("sw-timer");
-        metricRegistry.counter("sw-counter");
-        metricRegistry.meter("nw-meter-1");
-        metricRegistry.meter("sw-meter-3");
-        metricRegistry.meter("nw-meter-2");
-
-        assertThat(metricRegistry.getMeters(MetricFilter.startsWith("sw"))).containsOnlyKeys("sw-meter-3");
-    }
-
-    @Test
-    void testGetTimers() {
-        metricRegistry.histogram("test-histogram");
-        metricRegistry.meter("test-meter");
-        metricRegistry.counter("test-counter");
-        metricRegistry.timer("test-timer-1");
-        metricRegistry.timer("test-timer-3");
-        metricRegistry.timer("test-timer-2");
-
-        assertThat(metricRegistry.getTimers()).containsOnlyKeys("test-timer-1", "test-timer-2", "test-timer-3");
-    }
-
-    @Test
-    void testGetTimersWithFilter() {
-        metricRegistry.histogram("test-histogram-2");
-        metricRegistry.meter("test-meter-2");
-        metricRegistry.counter("test-counter-2");
-        metricRegistry.timer("test-timer-1");
-        metricRegistry.timer("test-timer-3");
-        metricRegistry.timer("test-timer-2");
-
-        assertThat(metricRegistry.getTimers(MetricFilter.endsWith("2"))).containsOnlyKeys("test-timer-2");
-    }
-
-    @Test
-    void testGetMetrics() {
-        metricRegistry.register("test-text-gauge-2", new CachedGauge<String>(1, TimeUnit.MINUTES) {
-            @Override
-            protected String loadValue() {
-                return "eu2";
-            }
+    assertThat(
+            metricRegistry.getGauges(
+                (name, metric) -> name.contains("gauge") && metric instanceof CachedGauge))
+        .containsOnlyKeys("test-text-gauge-2");
+  }
+
+  @Test
+  void getHistograms() {
+    metricRegistry.counter("test-counter");
+    metricRegistry.timer("test-timer");
+    metricRegistry.meter("test-meter");
+    metricRegistry.histogram("test-histogram-1");
+    metricRegistry.histogram("test-histogram-3");
+    metricRegistry.histogram("test-histogram-2");
+
+    assertThat(metricRegistry.getHistograms())
+        .containsOnlyKeys("test-histogram-1", "test-histogram-2", "test-histogram-3");
+  }
+
+  @Test
+  void getHistogramsWithFilter() {
+    metricRegistry.counter("sw-counter");
+    metricRegistry.timer("sw-timer");
+    metricRegistry.meter("sw-meter");
+    metricRegistry.histogram("sw-histogram-1");
+    metricRegistry.histogram("se-histogram-3");
+    metricRegistry.histogram("sw-histogram-2");
+
+    assertThat(metricRegistry.getHistograms(MetricFilter.startsWith("sw")))
+        .containsOnlyKeys("sw-histogram-1", "sw-histogram-2");
+  }
+
+  @Test
+  void getCounters() {
+    metricRegistry.histogram("test-histogram");
+    metricRegistry.timer("test-timer");
+    metricRegistry.meter("test-meter");
+    metricRegistry.counter("test-counter-1");
+    metricRegistry.counter("test-counter-3");
+    metricRegistry.counter("test-counter-2");
+
+    assertThat(metricRegistry.getCounters())
+        .containsOnlyKeys("test-counter-1", "test-counter-2", "test-counter-3");
+  }
+
+  @Test
+  void getCountersWithFilter() {
+    metricRegistry.histogram("test-histogram");
+    metricRegistry.timer("test-timer");
+    metricRegistry.meter("test-meter");
+    metricRegistry.counter("test-counter-1");
+    metricRegistry.counter("test-counter-3");
+    metricRegistry.counter("test-cnt-2");
+
+    assertThat(metricRegistry.getCounters(MetricFilter.contains("counter")))
+        .containsOnlyKeys("test-counter-1", "test-counter-3");
+  }
+
+  @Test
+  void getMeters() {
+    metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
+    metricRegistry.histogram("test-histogram");
+    metricRegistry.timer("test-timer");
+    metricRegistry.counter("test-counter");
+    metricRegistry.meter("test-meter-1");
+    metricRegistry.meter("test-meter-3");
+    metricRegistry.meter("test-meter-2");
+
+    assertThat(metricRegistry.getMeters())
+        .containsOnlyKeys("test-meter-1", "test-meter-2", "test-meter-3");
+  }
+
+  @Test
+  void getMetersWithFilter() {
+    metricRegistry.register("sw-gauge", (Gauge<Integer>) () -> 42);
+    metricRegistry.histogram("sw-histogram");
+    metricRegistry.timer("sw-timer");
+    metricRegistry.counter("sw-counter");
+    metricRegistry.meter("nw-meter-1");
+    metricRegistry.meter("sw-meter-3");
+    metricRegistry.meter("nw-meter-2");
+
+    assertThat(metricRegistry.getMeters(MetricFilter.startsWith("sw")))
+        .containsOnlyKeys("sw-meter-3");
+  }
+
+  @Test
+  void getTimers() {
+    metricRegistry.histogram("test-histogram");
+    metricRegistry.meter("test-meter");
+    metricRegistry.counter("test-counter");
+    metricRegistry.timer("test-timer-1");
+    metricRegistry.timer("test-timer-3");
+    metricRegistry.timer("test-timer-2");
+
+    assertThat(metricRegistry.getTimers())
+        .containsOnlyKeys("test-timer-1", "test-timer-2", "test-timer-3");
+  }
+
+  @Test
+  void getTimersWithFilter() {
+    metricRegistry.histogram("test-histogram-2");
+    metricRegistry.meter("test-meter-2");
+    metricRegistry.counter("test-counter-2");
+    metricRegistry.timer("test-timer-1");
+    metricRegistry.timer("test-timer-3");
+    metricRegistry.timer("test-timer-2");
+
+    assertThat(metricRegistry.getTimers(MetricFilter.endsWith("2")))
+        .containsOnlyKeys("test-timer-2");
+  }
+
+  @Test
+  void getMetrics() {
+    metricRegistry.register(
+        "test-text-gauge-2",
+        new CachedGauge<String>(1, TimeUnit.MINUTES) {
+          @Override
+          protected String loadValue() {
+            return "eu2";
+          }
         });
-        metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
-        metricRegistry.register("test-text-gauge-1", new RatioGauge() {
-            @Override
-            protected Ratio getRatio() {
-                return Ratio.of(1, 2);
-            }
+    metricRegistry.register("test-gauge", (Gauge<Integer>) () -> 42);
+    metricRegistry.register(
+        "test-text-gauge-1",
+        new RatioGauge() {
+          @Override
+          protected Ratio getRatio() {
+            return Ratio.of(1, 2);
+          }
         });
-        metricRegistry.histogram("test-histogram-1");
-        metricRegistry.histogram("test-histogram-2");
-        metricRegistry.meter("test-meter-1");
-        metricRegistry.meter("test-meter-2");
-        metricRegistry.counter("test-counter");
-        metricRegistry.timer("test-timer-1");
-        metricRegistry.timer("test-timer-2");
-        MetricRegistry subMetrics = new MetricRegistry();
-        subMetrics.counter("sb-counter-1");
-        subMetrics.counter("sb-counter-2");
-        subMetrics.histogram("sb-histogram-1");
-        metricRegistry.register("test-ms", subMetrics);
-
-        assertThat(metricRegistry.getMetrics()).containsOnlyKeys("test-text-gauge-2", "test-gauge", "test-text-gauge-1",
-                "test-histogram-1", "test-histogram-2", "test-meter-1", "test-meter-2", "test-counter",
-                "test-timer-1", "test-timer-2",
-                "test-ms.sb-counter-1", "test-ms.sb-counter-2", "test-ms.sb-histogram-1");
-    }
+    metricRegistry.histogram("test-histogram-1");
+    metricRegistry.histogram("test-histogram-2");
+    metricRegistry.meter("test-meter-1");
+    metricRegistry.meter("test-meter-2");
+    metricRegistry.counter("test-counter");
+    metricRegistry.timer("test-timer-1");
+    metricRegistry.timer("test-timer-2");
+    MetricRegistry subMetrics = new MetricRegistry();
+    subMetrics.counter("sb-counter-1");
+    subMetrics.counter("sb-counter-2");
+    subMetrics.histogram("sb-histogram-1");
+    metricRegistry.register("test-ms", subMetrics);
+
+    assertThat(metricRegistry.getMetrics())
+        .containsOnlyKeys(
+            "test-text-gauge-2",
+            "test-gauge",
+            "test-text-gauge-1",
+            "test-histogram-1",
+            "test-histogram-2",
+            "test-meter-1",
+            "test-meter-2",
+            "test-counter",
+            "test-timer-1",
+            "test-timer-2",
+            "test-ms.sb-counter-1",
+            "test-ms.sb-counter-2",
+            "test-ms.sb-histogram-1");
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/RatioGaugeTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/RatioGaugeTest.java
@@ -1,28 +1,28 @@
 package com.codahale.metrics;
 
-import org.assertj.core.data.Offset;
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
+
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class RatioGaugeTest {
+final class RatioGaugeTest {
 
-    private RatioGauge ratioGauge = new RatioGauge() {
+  private RatioGauge ratioGauge =
+      new RatioGauge() {
         @Override
         protected Ratio getRatio() {
-            return Ratio.of(1, 3);
+          return Ratio.of(1, 3);
         }
-    };
-
-    @Test
-    void testViewRatin() {
-        assertThat(ratioGauge.getRatio().toString()).isEqualTo("1.0:3.0");
-    }
+      };
 
+  @Test
+  void viewRatin() {
+    assertThat(ratioGauge.getRatio()).hasToString("1.0:3.0");
+  }
 
-    @Test
-    void testCalculateRatio() {
-        assertThat(ratioGauge.getValue()).isCloseTo(0.33, Offset.offset(0.01));
-    }
+  @Test
+  void calculateRatio() {
+    assertThat(ratioGauge.getValue()).isCloseTo(0.33, offset(0.01));
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/ScheduledReporterTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/ScheduledReporterTest.java
@@ -1,80 +1,82 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.SortedMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class ScheduledReporterTest {
+final class ScheduledReporterTest {
 
-    private MetricRegistry metricRegistry = new MetricRegistry();
-    private ScheduledReporter scheduledReporter;
+  private MetricRegistry metricRegistry = new MetricRegistry();
+  private ScheduledReporter scheduledReporter;
 
-    @BeforeEach
-    void setUp() throws Exception {
-        metricRegistry.register("sw-gauge", (Gauge<Integer>) () -> 28);
-        metricRegistry.counter("sw-counter");
-        metricRegistry.timer("sw-timer");
-        metricRegistry.meter("sw-meter");
-        metricRegistry.histogram("sw-histogram");
-    }
+  @BeforeEach
+  void setUp() throws Exception {
+    metricRegistry.register("sw-gauge", (Gauge<Integer>) () -> 28);
+    metricRegistry.counter("sw-counter");
+    metricRegistry.timer("sw-timer");
+    metricRegistry.meter("sw-meter");
+    metricRegistry.histogram("sw-histogram");
+  }
 
-    @AfterEach
-    void tearDown() throws Exception {
-        scheduledReporter.stop();
-    }
+  @AfterEach
+  void tearDown() throws Exception {
+    scheduledReporter.stop();
+  }
 
-    private ScheduledReporter createScheduledReporter(CountDownLatch latch) {
-        return new ScheduledReporter(metricRegistry, "test", MetricFilter.ALL, TimeUnit.MILLISECONDS,
-                TimeUnit.MINUTES) {
-            @Override
-            @SuppressWarnings("rawtypes")
-            public void report(SortedMap<String, Gauge> gauges, SortedMap<String, Counter> counters,
-                    SortedMap<String, Histogram> histograms, SortedMap<String, Meter> meters,
-                    SortedMap<String, Timer> timers) {
-                assertThat(gauges).containsOnlyKeys("sw-gauge");
-                assertThat(counters).containsOnlyKeys("sw-counter");
-                assertThat(histograms).containsOnlyKeys("sw-histogram");
-                assertThat(meters).containsOnlyKeys("sw-meter");
-                assertThat(timers).containsOnlyKeys("sw-timer");
-                latch.countDown();
-            }
-        };
-    }
+  private ScheduledReporter createScheduledReporter(CountDownLatch latch) {
+    return new ScheduledReporter(
+        metricRegistry, "test", MetricFilter.ALL, TimeUnit.MILLISECONDS, TimeUnit.MINUTES) {
+      @Override
+      @SuppressWarnings("rawtypes")
+      public void report(
+          SortedMap<String, Gauge> gauges,
+          SortedMap<String, Counter> counters,
+          SortedMap<String, Histogram> histograms,
+          SortedMap<String, Meter> meters,
+          SortedMap<String, Timer> timers) {
+        assertThat(gauges).containsOnlyKeys("sw-gauge");
+        assertThat(counters).containsOnlyKeys("sw-counter");
+        assertThat(histograms).containsOnlyKeys("sw-histogram");
+        assertThat(meters).containsOnlyKeys("sw-meter");
+        assertThat(timers).containsOnlyKeys("sw-timer");
+        latch.countDown();
+      }
+    };
+  }
 
-    @Test
-    void testReport() throws Exception {
-        CountDownLatch latch = new CountDownLatch(1);
-        scheduledReporter = createScheduledReporter(latch);
-        scheduledReporter.report();
+  @Test
+  void report() throws Exception {
+    CountDownLatch latch = new CountDownLatch(1);
+    scheduledReporter = createScheduledReporter(latch);
+    scheduledReporter.report();
 
-        latch.await(5, TimeUnit.SECONDS);
-        assertThat(latch.getCount()).isEqualTo(0);
-    }
+    latch.await(5, TimeUnit.SECONDS);
+    assertThat(latch.getCount()).isEqualTo(0);
+  }
 
-    @Test
-    void testStart() throws Exception {
-        CountDownLatch latch = new CountDownLatch(2);
-        scheduledReporter = createScheduledReporter(latch);
-        scheduledReporter.start(10, TimeUnit.MILLISECONDS);
+  @Test
+  void start() throws Exception {
+    CountDownLatch latch = new CountDownLatch(2);
+    scheduledReporter = createScheduledReporter(latch);
+    scheduledReporter.start(10, TimeUnit.MILLISECONDS);
 
-        latch.await(5, TimeUnit.SECONDS);
-        assertThat(latch.getCount()).isEqualTo(0);
-    }
+    latch.await(5, TimeUnit.SECONDS);
+    assertThat(latch.getCount()).isEqualTo(0);
+  }
 
-    @Test
-    void testStartWithoutDelay() throws Exception {
-        CountDownLatch latch = new CountDownLatch(2);
-        scheduledReporter = createScheduledReporter(latch);
-        scheduledReporter.start(0, 10, TimeUnit.MILLISECONDS);
+  @Test
+  void startWithoutDelay() throws Exception {
+    CountDownLatch latch = new CountDownLatch(2);
+    scheduledReporter = createScheduledReporter(latch);
+    scheduledReporter.start(0, 10, TimeUnit.MILLISECONDS);
 
-        latch.await(5, TimeUnit.SECONDS);
-        assertThat(latch.getCount()).isEqualTo(0);
-    }
+    latch.await(5, TimeUnit.SECONDS);
+    assertThat(latch.getCount()).isEqualTo(0);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SharedMetricRegistriesTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SharedMetricRegistriesTest.java
@@ -1,53 +1,55 @@
 package com.codahale.metrics;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatIllegalStateException;
-
 @SuppressWarnings("deprecation")
-class SharedMetricRegistriesTest {
-
-    @AfterEach
-    void tearDown() throws Exception {
-        SharedMetricRegistries.clear();
-    }
-
-    @Test
-    void testGetOrCreateMetricRegistry() {
-        SharedMetricRegistries.getOrCreate("get-or-create").counter("test-counter");
-
-        assertThat(SharedMetricRegistries.getOrCreate("get-or-create").getCounters())
-                .containsOnlyKeys("test-counter");
-    }
-
-    @Test
-    void testAddMetricRegistry() {
-        MetricRegistry metricRegistry = new MetricRegistry();
-        metricRegistry.histogram("test-histogram");
-        SharedMetricRegistries.add("add", metricRegistry);
-
-        assertThat(SharedMetricRegistries.getOrCreate("add").getHistograms())
-                .containsOnlyKeys("test-histogram");
-    }
-
-    @Test
-    void testNames() {
-        SharedMetricRegistries.add("registry-1", new MetricRegistry());
-        SharedMetricRegistries.add("registry-2", new MetricRegistry());
-        SharedMetricRegistries.add("registry-3", new MetricRegistry());
-
-        assertThat(SharedMetricRegistries.names()).containsOnly("registry-1", "registry-2", "registry-3");
-    }
-
-    @Test
-    void testTryGetDefaultRegistry() {
-        assertThat(SharedMetricRegistries.tryGetDefault()).isNull();
-    }
-
-    @Test
-    void testGetDefaultRegistry() {
-        assertThatIllegalStateException().isThrownBy(SharedMetricRegistries::getDefault);
-    }
+final class SharedMetricRegistriesTest {
+
+  @AfterEach
+  void tearDown() throws Exception {
+    SharedMetricRegistries.clear();
+  }
+
+  @Test
+  void getOrCreateMetricRegistry() {
+    SharedMetricRegistries.getOrCreate("get-or-create").counter("test-counter");
+
+    assertThat(SharedMetricRegistries.getOrCreate("get-or-create").getCounters())
+        .containsOnlyKeys("test-counter");
+  }
+
+  @Test
+  void addMetricRegistry() {
+    MetricRegistry metricRegistry = new MetricRegistry();
+    metricRegistry.histogram("test-histogram");
+    SharedMetricRegistries.add("add", metricRegistry);
+
+    assertThat(SharedMetricRegistries.getOrCreate("add").getHistograms())
+        .containsOnlyKeys("test-histogram");
+  }
+
+  @Test
+  void names() {
+    SharedMetricRegistries.add("registry-1", new MetricRegistry());
+    SharedMetricRegistries.add("registry-2", new MetricRegistry());
+    SharedMetricRegistries.add("registry-3", new MetricRegistry());
+
+    assertThat(SharedMetricRegistries.names())
+        .containsOnly("registry-1", "registry-2", "registry-3");
+  }
+
+  @Test
+  void tryGetDefaultRegistry() {
+    assertThat(SharedMetricRegistries.tryGetDefault()).isNull();
+  }
+
+  @Test
+  void getDefaultRegistry() {
+    assertThatThrownBy(SharedMetricRegistries::getDefault)
+        .isInstanceOf(IllegalStateException.class);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/Slf4jReporterTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/Slf4jReporterTest.java
@@ -1,55 +1,55 @@
 package com.codahale.metrics;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 @SuppressWarnings("deprecation")
-class Slf4jReporterTest {
-
-    private ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
-    private Logger logger = mock(Logger.class);
-    private Marker marker = mock(Marker.class);
-
-    @BeforeEach
-    void setUp() throws Exception {
-        when(logger.isInfoEnabled(marker)).thenReturn(true);
-    }
-
-    @AfterEach
-    void tearDown() throws Exception {
-        executor.shutdownNow();
-    }
-
-    @Test
-    void testReport() throws Exception {
-        MetricRegistry metricRegistry = new MetricRegistry();
-        metricRegistry.counter("test-counter").inc(100);
-
-        Slf4jReporter slf4jReporter = Slf4jReporter.forRegistry(metricRegistry)
-                .shutdownExecutorOnStop(false)
-                .scheduleOn(executor)
-                .outputTo(logger)
-                .markWith(marker)
-                .prefixedWith("us-nw")
-                .convertRatesTo(TimeUnit.SECONDS)
-                .convertDurationsTo(TimeUnit.MILLISECONDS)
-                .filter(MetricFilter.ALL)
-                .withLoggingLevel(Slf4jReporter.LoggingLevel.INFO)
-                .build();
-
-        slf4jReporter.report();
-
-        verify(logger).info(marker, "type=COUNTER, name=us-nw.test-counter, count=100");
-    }
+final class Slf4jReporterTest {
+
+  private ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
+  private Logger logger = mock();
+  private Marker marker = mock();
+
+  @BeforeEach
+  void setUp() throws Exception {
+    when(logger.isInfoEnabled(marker)).thenReturn(true);
+  }
+
+  @AfterEach
+  void tearDown() throws Exception {
+    executor.shutdownNow();
+  }
+
+  @Test
+  void report() throws Exception {
+    MetricRegistry metricRegistry = new MetricRegistry();
+    metricRegistry.counter("test-counter").inc(100);
+
+    Slf4jReporter slf4jReporter =
+        Slf4jReporter.forRegistry(metricRegistry)
+            .shutdownExecutorOnStop(false)
+            .scheduleOn(executor)
+            .outputTo(logger)
+            .markWith(marker)
+            .prefixedWith("us-nw")
+            .convertRatesTo(TimeUnit.SECONDS)
+            .convertDurationsTo(TimeUnit.MILLISECONDS)
+            .filter(MetricFilter.ALL)
+            .withLoggingLevel(Slf4jReporter.LoggingLevel.INFO)
+            .build();
+
+    slf4jReporter.report();
+
+    verify(logger).info(marker, "type=COUNTER, name=us-nw.test-counter, count=100");
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SlidingTimeWindowArrayReservoirTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SlidingTimeWindowArrayReservoirTest.java
@@ -1,34 +1,34 @@
 package com.codahale.metrics;
 
-import org.assertj.core.data.Offset;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class SlidingTimeWindowArrayReservoirTest {
-
-    @Test
-    void testCreateWithWindow() {
-        SlidingTimeWindowArrayReservoir reservoir = new SlidingTimeWindowArrayReservoir(1, TimeUnit.HOURS);
-        reservoir.update(100);
-        reservoir.update(200);
-        reservoir.update(30);
-
-        assertThat(reservoir.size()).isEqualTo(3);
-        assertThat(reservoir.getSnapshot().getMean()).isCloseTo(110, Offset.offset(0.1));
-    }
-
-    @Test
-    void testCreateWithWindowAndClock() {
-        SlidingTimeWindowArrayReservoir reservoir = new SlidingTimeWindowArrayReservoir(1, TimeUnit.HOURS,
-                new Clock.UserTimeClock());
-        reservoir.update(400);
-        reservoir.update(300);
-
-        assertThat(reservoir.size()).isEqualTo(2);
-        assertThat(reservoir.getSnapshot().getMean()).isCloseTo(350, Offset.offset(0.1));
-    }
+final class SlidingTimeWindowArrayReservoirTest {
+
+  @Test
+  void createWithWindow() {
+    SlidingTimeWindowArrayReservoir reservoir =
+        new SlidingTimeWindowArrayReservoir(1, TimeUnit.HOURS);
+    reservoir.update(100);
+    reservoir.update(200);
+    reservoir.update(30);
+
+    assertThat(reservoir.size()).isEqualTo(3);
+    assertThat(reservoir.getSnapshot().getMean()).isCloseTo(110, offset(0.1));
+  }
+
+  @Test
+  void createWithWindowAndClock() {
+    SlidingTimeWindowArrayReservoir reservoir =
+        new SlidingTimeWindowArrayReservoir(1, TimeUnit.HOURS, new Clock.UserTimeClock());
+    reservoir.update(400);
+    reservoir.update(300);
+
+    assertThat(reservoir.size()).isEqualTo(2);
+    assertThat(reservoir.getSnapshot().getMean()).isCloseTo(350, offset(0.1));
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SlidingTimeWindowReservoirTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SlidingTimeWindowReservoirTest.java
@@ -1,34 +1,33 @@
 package com.codahale.metrics;
 
-import org.assertj.core.data.Offset;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 
 import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class SlidingTimeWindowReservoirTest {
-
-    @Test
-    void testCreateWithWindow() {
-        SlidingTimeWindowReservoir reservoir = new SlidingTimeWindowReservoir(1, TimeUnit.HOURS);
-        reservoir.update(100);
-        reservoir.update(200);
-        reservoir.update(30);
-
-        assertThat(reservoir.size()).isEqualTo(3);
-        assertThat(reservoir.getSnapshot().getMean()).isCloseTo(110, Offset.offset(0.1));
-    }
-
-    @Test
-    void testCreateWithWindowAndClock() {
-        SlidingTimeWindowReservoir reservoir = new SlidingTimeWindowReservoir(1, TimeUnit.HOURS,
-                new Clock.UserTimeClock());
-        reservoir.update(400);
-        reservoir.update(300);
-
-        assertThat(reservoir.size()).isEqualTo(2);
-        assertThat(reservoir.getSnapshot().getMean()).isCloseTo(350, Offset.offset(0.1));
-    }
+final class SlidingTimeWindowReservoirTest {
+
+  @Test
+  void createWithWindow() {
+    SlidingTimeWindowReservoir reservoir = new SlidingTimeWindowReservoir(1, TimeUnit.HOURS);
+    reservoir.update(100);
+    reservoir.update(200);
+    reservoir.update(30);
+
+    assertThat(reservoir.size()).isEqualTo(3);
+    assertThat(reservoir.getSnapshot().getMean()).isCloseTo(110, offset(0.1));
+  }
+
+  @Test
+  void createWithWindowAndClock() {
+    SlidingTimeWindowReservoir reservoir =
+        new SlidingTimeWindowReservoir(1, TimeUnit.HOURS, new Clock.UserTimeClock());
+    reservoir.update(400);
+    reservoir.update(300);
+
+    assertThat(reservoir.size()).isEqualTo(2);
+    assertThat(reservoir.getSnapshot().getMean()).isCloseTo(350, offset(0.1));
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SlidingWindowReservoirTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SlidingWindowReservoirTest.java
@@ -1,33 +1,33 @@
 package com.codahale.metrics;
 
-import org.assertj.core.data.Offset;
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
+
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class SlidingWindowReservoirTest {
+final class SlidingWindowReservoirTest {
 
-    @Test
-    void testCreateWithBigWindow() {
-        SlidingWindowReservoir reservoir = new SlidingWindowReservoir(100);
-        reservoir.update(100);
-        reservoir.update(220);
-        reservoir.update(130);
+  @Test
+  void createWithBigWindow() {
+    SlidingWindowReservoir reservoir = new SlidingWindowReservoir(100);
+    reservoir.update(100);
+    reservoir.update(220);
+    reservoir.update(130);
 
-        assertThat(reservoir.size()).isEqualTo(3);
-        assertThat(reservoir.getSnapshot().getMean()).isCloseTo(150, Offset.offset(0.1));
-    }
+    assertThat(reservoir.size()).isEqualTo(3);
+    assertThat(reservoir.getSnapshot().getMean()).isCloseTo(150, offset(0.1));
+  }
 
-    @Test
-    void testCreateWithLowWindow() {
-        SlidingWindowReservoir reservoir = new SlidingWindowReservoir(3);
-        reservoir.update(500);
-        reservoir.update(220);
-        reservoir.update(100);
-        reservoir.update(40);
+  @Test
+  void createWithLowWindow() {
+    SlidingWindowReservoir reservoir = new SlidingWindowReservoir(3);
+    reservoir.update(500);
+    reservoir.update(220);
+    reservoir.update(100);
+    reservoir.update(40);
 
-        assertThat(reservoir.size()).isEqualTo(3);
-        assertThat(reservoir.getSnapshot().getMean()).isCloseTo(120, Offset.offset(0.1));
-    }
+    assertThat(reservoir.size()).isEqualTo(3);
+    assertThat(reservoir.getSnapshot().getMean()).isCloseTo(120, offset(0.1));
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SnapshotTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/SnapshotTest.java
@@ -1,38 +1,34 @@
 package com.codahale.metrics;
 
-import io.dropwizard.metrics5.UniformSnapshot;
-import org.assertj.core.data.Offset;
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 
+import io.dropwizard.metrics5.UniformSnapshot;
 import java.io.ByteArrayOutputStream;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class SnapshotTest {
+final class SnapshotTest {
 
-    @Test
-    void testCreateSnapshot() throws Exception {
-        Snapshot snapshot = Snapshot.of(new UniformSnapshot(new long[]{5, 1, 2, 3, 4}));
+  @Test
+  void createSnapshot() throws Exception {
+    Snapshot snapshot = Snapshot.of(new UniformSnapshot(new long[] {5, 1, 2, 3, 4}));
 
-        assertThat(snapshot.getValues()).isEqualTo(new long[]{1, 2, 3, 4, 5});
-        assertThat(snapshot.size()).isEqualTo(5);
-        assertThat(snapshot.getMin()).isEqualTo(1);
-        assertThat(snapshot.getMax()).isEqualTo(5);
-        assertThat(snapshot.getStdDev()).isEqualTo(1.58, Offset.offset(0.01));
-        assertThat(snapshot.getMedian()).isEqualTo(3, Offset.offset(0.01));
-        assertThat(snapshot.get75thPercentile()).isEqualTo(4.5, Offset.offset(0.01));
-        assertThat(snapshot.get95thPercentile()).isEqualTo(5, Offset.offset(0.01));
-        assertThat(snapshot.get98thPercentile()).isEqualTo(5, Offset.offset(0.01));
-        assertThat(snapshot.get99thPercentile()).isEqualTo(5, Offset.offset(0.01));
-        assertThat(snapshot.get999thPercentile()).isEqualTo(5, Offset.offset(0.01));
+    assertThat(snapshot.getValues()).isEqualTo(new long[] {1, 2, 3, 4, 5});
+    assertThat(snapshot.size()).isEqualTo(5);
+    assertThat(snapshot.getMin()).isEqualTo(1);
+    assertThat(snapshot.getMax()).isEqualTo(5);
+    assertThat(snapshot.getStdDev()).isCloseTo(1.58, offset(0.01));
+    assertThat(snapshot.getMedian()).isCloseTo(3, offset(0.01));
+    assertThat(snapshot.get75thPercentile()).isCloseTo(4.5, offset(0.01));
+    assertThat(snapshot.get95thPercentile()).isCloseTo(5, offset(0.01));
+    assertThat(snapshot.get98thPercentile()).isCloseTo(5, offset(0.01));
+    assertThat(snapshot.get99thPercentile()).isCloseTo(5, offset(0.01));
+    assertThat(snapshot.get999thPercentile()).isCloseTo(5, offset(0.01));
 
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        snapshot.dump(baos);
-        assertThat(baos.toString("UTF-8")).isEqualToNormalizingNewlines("1\n" +
-                "2\n" +
-                "3\n" +
-                "4\n" +
-                "5\n");
-    }
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    snapshot.dump(baos);
+    assertThat(baos.toString("UTF-8"))
+        .isEqualToNormalizingNewlines("1\n" + "2\n" + "3\n" + "4\n" + "5\n");
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/TimerTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/TimerTest.java
@@ -1,103 +1,102 @@
 package com.codahale.metrics;
 
-import org.junit.jupiter.api.Test;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.time.Duration;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
-
-import static org.assertj.core.api.Assertions.assertThat;
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class TimerTest {
+final class TimerTest {
 
-    private static class ManualClock extends Clock {
+  private static class ManualClock extends Clock {
 
-        long startTime = System.nanoTime();
+    long startTime = System.nanoTime();
 
-        @Override
-        public long getTick() {
-            return startTime += 100_000_000;
-        }
+    @Override
+    public long getTick() {
+      return startTime += 100_000_000;
     }
+  }
 
-    private static void verifyOneEvent(Timer timer) {
-        assertThat(timer.getCount()).isEqualTo(1);
-        assertThat(timer.getSnapshot().getValues()).containsExactly(100_000_000L);
-    }
+  private static void verifyOneEvent(Timer timer) {
+    assertThat(timer.getCount()).isEqualTo(1);
+    assertThat(timer.getSnapshot().getValues()).containsExactly(100_000_000L);
+  }
 
-    @Test
-    void testCreate() {
-        Timer timer = new Timer();
-        timer.update(100, TimeUnit.MILLISECONDS);
-        timer.update(200, TimeUnit.MILLISECONDS);
+  @Test
+  void create() {
+    Timer timer = new Timer();
+    timer.update(100, TimeUnit.MILLISECONDS);
+    timer.update(200, TimeUnit.MILLISECONDS);
 
-        assertThat(timer.getCount()).isEqualTo(2);
-    }
+    assertThat(timer.getCount()).isEqualTo(2);
+  }
 
-    @Test
-    void testCreateWithCustomReservoir() {
-        Timer timer = new Timer(new SlidingWindowReservoir(100));
-        timer.update(100, TimeUnit.MILLISECONDS);
-        timer.update(200, TimeUnit.MILLISECONDS);
+  @Test
+  void createWithCustomReservoir() {
+    Timer timer = new Timer(new SlidingWindowReservoir(100));
+    timer.update(100, TimeUnit.MILLISECONDS);
+    timer.update(200, TimeUnit.MILLISECONDS);
 
-        assertThat(timer.getCount()).isEqualTo(2);
-    }
+    assertThat(timer.getCount()).isEqualTo(2);
+  }
 
-    @Test
-    void testCreateWithCustomReservoirAndClock() {
-        Timer timer = new Timer(new SlidingWindowReservoir(100), new Clock.UserTimeClock());
-        timer.update(100, TimeUnit.MILLISECONDS);
-        timer.update(200, TimeUnit.MILLISECONDS);
+  @Test
+  void createWithCustomReservoirAndClock() {
+    Timer timer = new Timer(new SlidingWindowReservoir(100), new Clock.UserTimeClock());
+    timer.update(100, TimeUnit.MILLISECONDS);
+    timer.update(200, TimeUnit.MILLISECONDS);
 
-        assertThat(timer.getCount()).isEqualTo(2);
-    }
+    assertThat(timer.getCount()).isEqualTo(2);
+  }
 
-    @Test
-    void testTimerContext() {
-        Timer timer = new Timer(new SlidingWindowReservoir(100), new ManualClock());
-        timer.time().stop();
+  @Test
+  void timerContext() {
+    Timer timer = new Timer(new SlidingWindowReservoir(100), new ManualClock());
+    timer.time().stop();
 
-        verifyOneEvent(timer);
-    }
+    verifyOneEvent(timer);
+  }
 
-    @Test
-    void testTimerRunnable() {
-        Timer timer = new Timer(new SlidingWindowReservoir(100), new ManualClock());
+  @Test
+  void timerRunnable() {
+    Timer timer = new Timer(new SlidingWindowReservoir(100), new ManualClock());
 
-        AtomicInteger counter = new AtomicInteger();
-        timer.time((Runnable) counter::incrementAndGet);
+    AtomicInteger counter = new AtomicInteger();
+    timer.time((Runnable) counter::incrementAndGet);
 
-        assertThat(counter.get()).isEqualTo(1);
-        verifyOneEvent(timer);
-    }
+    assertThat(counter.get()).isEqualTo(1);
+    verifyOneEvent(timer);
+  }
 
-    @Test
-    void testTimerCallable() throws Exception {
-        Timer timer = new Timer(new SlidingWindowReservoir(100), new ManualClock());
+  @Test
+  void timerCallable() throws Exception {
+    Timer timer = new Timer(new SlidingWindowReservoir(100), new ManualClock());
 
-        String message = timer.time(() -> "SUCCESS");
+    String message = timer.time(() -> "SUCCESS");
 
-        assertThat(message).isEqualTo("SUCCESS");
-        verifyOneEvent(timer);
-    }
+    assertThat(message).isEqualTo("SUCCESS");
+    verifyOneEvent(timer);
+  }
 
-    @Test
-    void testTimerSupplier() throws Exception {
-        Timer timer = new Timer(new SlidingWindowReservoir(100), new ManualClock());
+  @Test
+  void timerSupplier() throws Exception {
+    Timer timer = new Timer(new SlidingWindowReservoir(100), new ManualClock());
 
-        Integer result = timer.timeSupplier(() -> 42);
+    Integer result = timer.timeSupplier(() -> 42);
 
-        assertThat(result).isEqualTo(42);
-        verifyOneEvent(timer);
-    }
+    assertThat(result).isEqualTo(42);
+    verifyOneEvent(timer);
+  }
 
-    @Test
-    void testUpdateDuration() {
-        Timer timer = new Timer();
-        timer.update(Duration.ofMillis(100));
-        timer.update(Duration.ofMillis(200));
+  @Test
+  void updateDuration() {
+    Timer timer = new Timer();
+    timer.update(Duration.ofMillis(100));
+    timer.update(Duration.ofMillis(200));
 
-        assertThat(timer.getCount()).isEqualTo(2);
-    }
+    assertThat(timer.getCount()).isEqualTo(2);
+  }
 }
--- a/metrics-legacy-adapter/src/test/java/com/codahale/metrics/UniformReservoirTest.java
+++ b/metrics-legacy-adapter/src/test/java/com/codahale/metrics/UniformReservoirTest.java
@@ -1,42 +1,42 @@
 package com.codahale.metrics;
 
-import org.assertj.core.data.Offset;
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
+
+import org.junit.jupiter.api.Test;
 
 @SuppressWarnings("deprecation")
-class UniformReservoirTest {
+final class UniformReservoirTest {
 
-    @Test
-    void testCreateReservoir() {
-        UniformReservoir reservoir = new UniformReservoir();
-        reservoir.update(120);
-        reservoir.update(190);
-        reservoir.update(200);
-        reservoir.update(130);
-        reservoir.update(140);
+  @Test
+  void createReservoir() {
+    UniformReservoir reservoir = new UniformReservoir();
+    reservoir.update(120);
+    reservoir.update(190);
+    reservoir.update(200);
+    reservoir.update(130);
+    reservoir.update(140);
 
-        Snapshot snapshot = reservoir.getSnapshot();
-        assertThat(snapshot.size()).isEqualTo(5);
-        assertThat(snapshot.getValues()).contains(120, 130, 140, 190, 200);
-        assertThat(snapshot.getMin()).isEqualTo(120);
-        assertThat(snapshot.getMax()).isEqualTo(200);
-        assertThat(snapshot.getStdDev()).isEqualTo(36.47, Offset.offset(0.1));
-        assertThat(snapshot.get75thPercentile()).isEqualTo(195);
-        assertThat(snapshot.get95thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get98thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get99thPercentile()).isEqualTo(200);
-        assertThat(snapshot.get999thPercentile()).isEqualTo(200);
-    }
+    Snapshot snapshot = reservoir.getSnapshot();
+    assertThat(snapshot.size()).isEqualTo(5);
+    assertThat(snapshot.getValues()).contains(120, 130, 140, 190, 200);
+    assertThat(snapshot.getMin()).isEqualTo(120);
+    assertThat(snapshot.getMax()).isEqualTo(200);
+    assertThat(snapshot.getStdDev()).isCloseTo(36.47, offset(0.1));
+    assertThat(snapshot.get75thPercentile()).isEqualTo(195);
+    assertThat(snapshot.get95thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get98thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get99thPercentile()).isEqualTo(200);
+    assertThat(snapshot.get999thPercentile()).isEqualTo(200);
+  }
 
-    @Test
-    void testCreateReservoirWithCustomSize() {
-        UniformReservoir reservoir = new UniformReservoir(128);
-        reservoir.update(440);
-        reservoir.update(250);
-        reservoir.update(380);
+  @Test
+  void createReservoirWithCustomSize() {
+    UniformReservoir reservoir = new UniformReservoir(128);
+    reservoir.update(440);
+    reservoir.update(250);
+    reservoir.update(380);
 
-        assertThat(reservoir.size()).isEqualTo(3);
-    }
+    assertThat(reservoir.size()).isEqualTo(3);
+  }
 }
--- a/metrics-log4j2/src/main/java/io/dropwizard/metrics5/log4j2/InstrumentedAppender.java
+++ b/metrics-log4j2/src/main/java/io/dropwizard/metrics5/log4j2/InstrumentedAppender.java
@@ -1,8 +1,11 @@
 package io.dropwizard.metrics5.log4j2;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.SharedMetricRegistries;
+import java.io.Serializable;
 import org.apache.logging.log4j.core.Appender;
 import org.apache.logging.log4j.core.Filter;
 import org.apache.logging.log4j.core.Layout;
@@ -12,127 +15,131 @@ import org.apache.logging.log4j.core.config.plugins.Plugin;
 import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
 import org.apache.logging.log4j.core.config.plugins.PluginFactory;
 
-import java.io.Serializable;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 /**
- * A Log4J 2.x {@link Appender} which has seven meters, one for each logging level and one for the total
- * number of statements being logged. The meter names are the logging level names appended to the
- * name of the appender.
+ * A Log4J 2.x {@link Appender} which has seven meters, one for each logging level and one for the
+ * total number of statements being logged. The meter names are the logging level names appended to
+ * the name of the appender.
  */
 @Plugin(name = "MetricsAppender", category = "Core", elementType = "appender")
 public class InstrumentedAppender extends AbstractAppender {
 
-    private transient final MetricRegistry registry;
+  private final transient MetricRegistry registry;
 
-    private transient Meter all;
-    private transient Meter trace;
-    private transient Meter debug;
-    private transient Meter info;
-    private transient Meter warn;
-    private transient Meter error;
-    private transient Meter fatal;
+  private transient Meter all;
+  private transient Meter trace;
+  private transient Meter debug;
+  private transient Meter info;
+  private transient Meter warn;
+  private transient Meter error;
+  private transient Meter fatal;
 
-    /**
-     * Create a new instrumented appender using the given registry name.
-     *
-     * @param registryName     the name of the registry in {@link SharedMetricRegistries}
-     * @param filter           The Filter to associate with the Appender.
-     * @param layout           The layout to use to format the event.
-     * @param ignoreExceptions If true, exceptions will be logged and suppressed. If false errors will be
-     *                         logged and then passed to the application.
-     */
-    public InstrumentedAppender(String registryName, Filter filter, Layout<? extends Serializable> layout, boolean ignoreExceptions) {
-        this(SharedMetricRegistries.getOrCreate(registryName), filter, layout, ignoreExceptions);
-    }
+  /**
+   * Create a new instrumented appender using the given registry name.
+   *
+   * @param registryName the name of the registry in {@link SharedMetricRegistries}
+   * @param filter The Filter to associate with the Appender.
+   * @param layout The layout to use to format the event.
+   * @param ignoreExceptions If true, exceptions will be logged and suppressed. If false errors will
+   *     be logged and then passed to the application.
+   */
+  public InstrumentedAppender(
+      String registryName,
+      Filter filter,
+      Layout<? extends Serializable> layout,
+      boolean ignoreExceptions) {
+    this(SharedMetricRegistries.getOrCreate(registryName), filter, layout, ignoreExceptions);
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry name.
-     *
-     * @param registryName the name of the registry in {@link SharedMetricRegistries}
-     */
-    public InstrumentedAppender(String registryName) {
-        this(SharedMetricRegistries.getOrCreate(registryName));
-    }
+  /**
+   * Create a new instrumented appender using the given registry name.
+   *
+   * @param registryName the name of the registry in {@link SharedMetricRegistries}
+   */
+  public InstrumentedAppender(String registryName) {
+    this(SharedMetricRegistries.getOrCreate(registryName));
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry.
-     *
-     * @param registry the metric registry
-     */
-    public InstrumentedAppender(MetricRegistry registry) {
-        this(registry, null, null, true);
-    }
+  /**
+   * Create a new instrumented appender using the given registry.
+   *
+   * @param registry the metric registry
+   */
+  public InstrumentedAppender(MetricRegistry registry) {
+    this(registry, null, null, true);
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry.
-     *
-     * @param registry         the metric registry
-     * @param filter           The Filter to associate with the Appender.
-     * @param layout           The layout to use to format the event.
-     * @param ignoreExceptions If true, exceptions will be logged and suppressed. If false errors will be
-     *                         logged and then passed to the application.
-     */
-    public InstrumentedAppender(MetricRegistry registry, Filter filter, Layout<? extends Serializable> layout, boolean ignoreExceptions) {
-        super(name(Appender.class).getKey(), filter, layout, ignoreExceptions);
-        this.registry = registry;
-    }
+  /**
+   * Create a new instrumented appender using the given registry.
+   *
+   * @param registry the metric registry
+   * @param filter The Filter to associate with the Appender.
+   * @param layout The layout to use to format the event.
+   * @param ignoreExceptions If true, exceptions will be logged and suppressed. If false errors will
+   *     be logged and then passed to the application.
+   */
+  public InstrumentedAppender(
+      MetricRegistry registry,
+      Filter filter,
+      Layout<? extends Serializable> layout,
+      boolean ignoreExceptions) {
+    super(name(Appender.class).getKey(), filter, layout, ignoreExceptions);
+    this.registry = registry;
+  }
 
-    /**
-     * Create a new instrumented appender using the given appender name and registry.
-     *
-     * @param appenderName The name of the appender.
-     * @param registry     the metric registry
-     */
-    public InstrumentedAppender(String appenderName, MetricRegistry registry) {
-        super(appenderName, null, null, true);
-        this.registry = registry;
-    }
+  /**
+   * Create a new instrumented appender using the given appender name and registry.
+   *
+   * @param appenderName The name of the appender.
+   * @param registry the metric registry
+   */
+  public InstrumentedAppender(String appenderName, MetricRegistry registry) {
+    super(appenderName, null, null, true);
+    this.registry = registry;
+  }
 
-    @PluginFactory
-    public static InstrumentedAppender createAppender(
-            @PluginAttribute("name") String name,
-            @PluginAttribute(value = "registryName", defaultString = "log4j2Metrics") String registry) {
-        return new InstrumentedAppender(name, SharedMetricRegistries.getOrCreate(registry));
-    }
+  @PluginFactory
+  public static InstrumentedAppender createAppender(
+      @PluginAttribute("name") String name,
+      @PluginAttribute(value = "registryName", defaultString = "log4j2Metrics") String registry) {
+    return new InstrumentedAppender(name, SharedMetricRegistries.getOrCreate(registry));
+  }
 
-    @Override
-    public void start() {
-        this.all = registry.meter(name(getName(), "all"));
-        this.trace = registry.meter(name(getName(), "trace"));
-        this.debug = registry.meter(name(getName(), "debug"));
-        this.info = registry.meter(name(getName(), "info"));
-        this.warn = registry.meter(name(getName(), "warn"));
-        this.error = registry.meter(name(getName(), "error"));
-        this.fatal = registry.meter(name(getName(), "fatal"));
-        super.start();
-    }
+  @Override
+  public void start() {
+    this.all = registry.meter(name(getName(), "all"));
+    this.trace = registry.meter(name(getName(), "trace"));
+    this.debug = registry.meter(name(getName(), "debug"));
+    this.info = registry.meter(name(getName(), "info"));
+    this.warn = registry.meter(name(getName(), "warn"));
+    this.error = registry.meter(name(getName(), "error"));
+    this.fatal = registry.meter(name(getName(), "fatal"));
+    super.start();
+  }
 
-    @Override
-    public void append(LogEvent event) {
-        all.mark();
-        switch (event.getLevel().getStandardLevel()) {
-            case TRACE:
-                trace.mark();
-                break;
-            case DEBUG:
-                debug.mark();
-                break;
-            case INFO:
-                info.mark();
-                break;
-            case WARN:
-                warn.mark();
-                break;
-            case ERROR:
-                error.mark();
-                break;
-            case FATAL:
-                fatal.mark();
-                break;
-            default:
-                break;
-        }
+  @Override
+  public void append(LogEvent event) {
+    all.mark();
+    switch (event.getLevel().getStandardLevel()) {
+      case TRACE:
+        trace.mark();
+        break;
+      case DEBUG:
+        debug.mark();
+        break;
+      case INFO:
+        info.mark();
+        break;
+      case WARN:
+        warn.mark();
+        break;
+      case ERROR:
+        error.mark();
+        break;
+      case FATAL:
+        fatal.mark();
+        break;
+      default:
+        break;
     }
+  }
 }
--- a/metrics-log4j2/src/test/java/io/dropwizard/metrics5/log4j2/InstrumentedAppenderConfigTest.java
+++ b/metrics-log4j2/src/test/java/io/dropwizard/metrics5/log4j2/InstrumentedAppenderConfigTest.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.log4j2;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.SharedMetricRegistries;
 import org.apache.logging.log4j.core.Logger;
@@ -10,57 +12,55 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class InstrumentedAppenderConfigTest {
-    public static final String METRIC_NAME_PREFIX = "metrics";
-    public static final String REGISTRY_NAME = "shared-metrics-registry";
-
-    private final MetricRegistry registry = SharedMetricRegistries.getOrCreate(REGISTRY_NAME);
-    private ConfigurationSource source;
-    private LoggerContext context;
+final class InstrumentedAppenderConfigTest {
+  public static final String METRIC_NAME_PREFIX = "metrics";
+  public static final String REGISTRY_NAME = "shared-metrics-registry";
 
-    @BeforeEach
-    void setUp() throws Exception {
-        source = new ConfigurationSource(this.getClass().getClassLoader().getResourceAsStream("log4j2-testconfig.xml"));
-        context = Configurator.initialize(null, source);
-    }
+  private final MetricRegistry registry = SharedMetricRegistries.getOrCreate(REGISTRY_NAME);
+  private ConfigurationSource source;
+  private LoggerContext context;
 
-    @AfterEach
-    void tearDown() {
-        context.stop();
-    }
+  @BeforeEach
+  void setUp() throws Exception {
+    source =
+        new ConfigurationSource(
+            this.getClass().getClassLoader().getResourceAsStream("log4j2-testconfig.xml"));
+    context = Configurator.initialize(null, source);
+  }
 
-    // The biggest test is that we can initialize the log4j2 config at all.
+  @AfterEach
+  void tearDown() {
+    context.stop();
+  }
 
-    @Test
-    void canRecordAll() {
-        Logger logger = context.getLogger(this.getClass().getName());
+  // The biggest test is that we can initialize the log4j2 config at all.
 
-        long initialAllCount = registry.meter(METRIC_NAME_PREFIX + ".all").getCount();
-        logger.error("an error message");
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(initialAllCount + 1);
-    }
+  @Test
+  void canRecordAll() {
+    Logger logger = context.getLogger(this.getClass().getName());
 
-    @Test
-    void canRecordError() {
-        Logger logger = context.getLogger(this.getClass().getName());
+    long initialAllCount = registry.meter(METRIC_NAME_PREFIX + ".all").getCount();
+    logger.error("an error message");
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
+        .isEqualTo(initialAllCount + 1);
+  }
 
-        long initialErrorCount = registry.meter(METRIC_NAME_PREFIX + ".error").getCount();
-        logger.error("an error message");
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(initialErrorCount + 1);
-    }
+  @Test
+  void canRecordError() {
+    Logger logger = context.getLogger(this.getClass().getName());
 
-    @Test
-    void noInvalidRecording() {
-        Logger logger = context.getLogger(this.getClass().getName());
+    long initialErrorCount = registry.meter(METRIC_NAME_PREFIX + ".error").getCount();
+    logger.error("an error message");
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
+        .isEqualTo(initialErrorCount + 1);
+  }
 
-        long initialInfoCount = registry.meter(METRIC_NAME_PREFIX + ".info").getCount();
-        logger.error("an error message");
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(initialInfoCount);
-    }
+  @Test
+  void noInvalidRecording() {
+    Logger logger = context.getLogger(this.getClass().getName());
 
+    long initialInfoCount = registry.meter(METRIC_NAME_PREFIX + ".info").getCount();
+    logger.error("an error message");
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(initialInfoCount);
+  }
 }
--- a/metrics-log4j2/src/test/java/io/dropwizard/metrics5/log4j2/InstrumentedAppenderTest.java
+++ b/metrics-log4j2/src/test/java/io/dropwizard/metrics5/log4j2/InstrumentedAppenderTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.log4j2;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.SharedMetricRegistries;
 import org.apache.logging.log4j.Level;
@@ -8,121 +12,104 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-public class InstrumentedAppenderTest {
+final class InstrumentedAppenderTest {
 
-    public static final String METRIC_NAME_PREFIX = "org.apache.logging.log4j.core.Appender";
+  public static final String METRIC_NAME_PREFIX = "org.apache.logging.log4j.core.Appender";
 
-    private final MetricRegistry registry = new MetricRegistry();
-    private final InstrumentedAppender appender = new InstrumentedAppender(registry);
-    private final LogEvent event = mock(LogEvent.class);
+  private final MetricRegistry registry = new MetricRegistry();
+  private final InstrumentedAppender appender = new InstrumentedAppender(registry);
+  private final LogEvent event = mock();
 
-    @BeforeEach
-    void setUp() {
-        appender.start();
-    }
+  @BeforeEach
+  void setUp() {
+    appender.start();
+  }
 
-    @AfterEach
-    void tearDown() {
-        SharedMetricRegistries.clear();
-    }
+  @AfterEach
+  void tearDown() {
+    SharedMetricRegistries.clear();
+  }
 
-    @Test
-    void metersTraceEvents() {
-        when(event.getLevel()).thenReturn(Level.TRACE);
+  @Test
+  void metersTraceEvents() {
+    when(event.getLevel()).thenReturn(Level.TRACE);
 
-        appender.append(event);
+    appender.append(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void metersDebugEvents() {
-        when(event.getLevel()).thenReturn(Level.DEBUG);
+  @Test
+  void metersDebugEvents() {
+    when(event.getLevel()).thenReturn(Level.DEBUG);
 
-        appender.append(event);
+    appender.append(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".debug").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".debug").getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void metersInfoEvents() {
-        when(event.getLevel()).thenReturn(Level.INFO);
+  @Test
+  void metersInfoEvents() {
+    when(event.getLevel()).thenReturn(Level.INFO);
 
-        appender.append(event);
+    appender.append(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void metersWarnEvents() {
-        when(event.getLevel()).thenReturn(Level.WARN);
+  @Test
+  void metersWarnEvents() {
+    when(event.getLevel()).thenReturn(Level.WARN);
 
-        appender.append(event);
+    appender.append(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".warn").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".warn").getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void metersErrorEvents() {
-        when(event.getLevel()).thenReturn(Level.ERROR);
+  @Test
+  void metersErrorEvents() {
+    when(event.getLevel()).thenReturn(Level.ERROR);
 
-        appender.append(event);
+    appender.append(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".error").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".error").getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void metersFatalEvents() {
-        when(event.getLevel()).thenReturn(Level.FATAL);
+  @Test
+  void metersFatalEvents() {
+    when(event.getLevel()).thenReturn(Level.FATAL);
 
-        appender.append(event);
+    appender.append(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".fatal").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".fatal").getCount()).isEqualTo(1);
+  }
 
-    @Test
-    void usesSharedRegistries() {
+  @Test
+  void usesSharedRegistries() {
 
-        String registryName = "registry";
+    String registryName = "registry";
 
-        SharedMetricRegistries.add(registryName, registry);
+    SharedMetricRegistries.add(registryName, registry);
 
-        final InstrumentedAppender shared = new InstrumentedAppender(registryName);
-        shared.start();
+    final InstrumentedAppender shared = new InstrumentedAppender(registryName);
+    shared.start();
 
-        when(event.getLevel()).thenReturn(Level.INFO);
+    when(event.getLevel()).thenReturn(Level.INFO);
 
-        shared.append(event);
+    shared.append(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-logback13/src/main/java/io/dropwizard/metrics/logback13/InstrumentedAppender.java
+++ b/metrics-logback13/src/main/java/io/dropwizard/metrics/logback13/InstrumentedAppender.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics.logback13;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import ch.qos.logback.classic.Level;
 import ch.qos.logback.classic.spi.ILoggingEvent;
 import ch.qos.logback.core.Appender;
@@ -8,84 +10,79 @@ import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.SharedMetricRegistries;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 /**
  * A Logback {@link Appender} which has six meters, one for each logging level and one for the total
  * number of statements being logged. The meter names are the logging level names appended to the
  * name of the appender.
  */
 public class InstrumentedAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {
-    private final MetricRegistry registry;
-    public static final String DEFAULT_REGISTRY = "logback-metrics";
-    public static final String REGISTRY_PROPERTY_NAME = "metrics.logback.registry";
+  private final MetricRegistry registry;
+  public static final String DEFAULT_REGISTRY = "logback-metrics";
+  public static final String REGISTRY_PROPERTY_NAME = "metrics.logback.registry";
 
-    private Meter all;
-    private Meter trace;
-    private Meter debug;
-    private Meter info;
-    private Meter warn;
-    private Meter error;
+  private Meter all;
+  private Meter trace;
+  private Meter debug;
+  private Meter info;
+  private Meter warn;
+  private Meter error;
 
+  /** Create a new instrumented appender using the given registry name. */
+  public InstrumentedAppender() {
+    this(System.getProperty(REGISTRY_PROPERTY_NAME, DEFAULT_REGISTRY));
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry name.
-     */
-    public InstrumentedAppender() {
-        this(System.getProperty(REGISTRY_PROPERTY_NAME, DEFAULT_REGISTRY));
-    }
+  /**
+   * Create a new instrumented appender using the given registry name.
+   *
+   * @param registryName the name of the registry in {@link SharedMetricRegistries}
+   */
+  public InstrumentedAppender(String registryName) {
+    this(SharedMetricRegistries.getOrCreate(registryName));
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry name.
-     *
-     * @param registryName the name of the registry in {@link SharedMetricRegistries}
-     */
-    public InstrumentedAppender(String registryName) {
-        this(SharedMetricRegistries.getOrCreate(registryName));
-    }
-
-    /**
-     * Create a new instrumented appender using the given registry.
-     *
-     * @param registry the metric registry
-     */
-    public InstrumentedAppender(MetricRegistry registry) {
-        this.registry = registry;
-        setName(Appender.class.getName());
-    }
+  /**
+   * Create a new instrumented appender using the given registry.
+   *
+   * @param registry the metric registry
+   */
+  public InstrumentedAppender(MetricRegistry registry) {
+    this.registry = registry;
+    setName(Appender.class.getName());
+  }
 
-    @Override
-    public void start() {
-        this.all = registry.meter(name(getName(), "all"));
-        this.trace = registry.meter(name(getName(), "trace"));
-        this.debug = registry.meter(name(getName(), "debug"));
-        this.info = registry.meter(name(getName(), "info"));
-        this.warn = registry.meter(name(getName(), "warn"));
-        this.error = registry.meter(name(getName(), "error"));
-        super.start();
-    }
+  @Override
+  public void start() {
+    this.all = registry.meter(name(getName(), "all"));
+    this.trace = registry.meter(name(getName(), "trace"));
+    this.debug = registry.meter(name(getName(), "debug"));
+    this.info = registry.meter(name(getName(), "info"));
+    this.warn = registry.meter(name(getName(), "warn"));
+    this.error = registry.meter(name(getName(), "error"));
+    super.start();
+  }
 
-    @Override
-    protected void append(ILoggingEvent event) {
-        all.mark();
-        switch (event.getLevel().toInt()) {
-            case Level.TRACE_INT:
-                trace.mark();
-                break;
-            case Level.DEBUG_INT:
-                debug.mark();
-                break;
-            case Level.INFO_INT:
-                info.mark();
-                break;
-            case Level.WARN_INT:
-                warn.mark();
-                break;
-            case Level.ERROR_INT:
-                error.mark();
-                break;
-            default:
-                break;
-        }
+  @Override
+  protected void append(ILoggingEvent event) {
+    all.mark();
+    switch (event.getLevel().toInt()) {
+      case Level.TRACE_INT:
+        trace.mark();
+        break;
+      case Level.DEBUG_INT:
+        debug.mark();
+        break;
+      case Level.INFO_INT:
+        info.mark();
+        break;
+      case Level.WARN_INT:
+        warn.mark();
+        break;
+      case Level.ERROR_INT:
+        error.mark();
+        break;
+      default:
+        break;
     }
+  }
 }
--- a/metrics-logback13/src/test/java/io/dropwizard/metrics/logback13/InstrumentedAppenderTest.java
+++ b/metrics-logback13/src/test/java/io/dropwizard/metrics/logback13/InstrumentedAppenderTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics.logback13;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import ch.qos.logback.classic.Level;
 import ch.qos.logback.classic.spi.ILoggingEvent;
 import io.dropwizard.metrics5.MetricRegistry;
@@ -8,135 +12,117 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-public class InstrumentedAppenderTest {
-
-    public static final String METRIC_NAME_PREFIX = "ch.qos.logback.core.Appender";
+final class InstrumentedAppenderTest {
 
-    private final MetricRegistry registry = new MetricRegistry();
-    private final InstrumentedAppender appender = new InstrumentedAppender(registry);
-    private final ILoggingEvent event = mock(ILoggingEvent.class);
+  public static final String METRIC_NAME_PREFIX = "ch.qos.logback.core.Appender";
 
-    @BeforeEach
-    void setUp() {
-        appender.start();
-    }
+  private final MetricRegistry registry = new MetricRegistry();
+  private final InstrumentedAppender appender = new InstrumentedAppender(registry);
+  private final ILoggingEvent event = mock();
 
-    @AfterEach
-    void tearDown() {
-        SharedMetricRegistries.clear();
-    }
+  @BeforeEach
+  void setUp() {
+    appender.start();
+  }
 
-    @Test
-    void metersTraceEvents() {
-        when(event.getLevel()).thenReturn(Level.TRACE);
+  @AfterEach
+  void tearDown() {
+    SharedMetricRegistries.clear();
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersTraceEvents() {
+    when(event.getLevel()).thenReturn(Level.TRACE);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersDebugEvents() {
-        when(event.getLevel()).thenReturn(Level.DEBUG);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersDebugEvents() {
+    when(event.getLevel()).thenReturn(Level.DEBUG);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".debug").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersInfoEvents() {
-        when(event.getLevel()).thenReturn(Level.INFO);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".debug").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersInfoEvents() {
+    when(event.getLevel()).thenReturn(Level.INFO);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersWarnEvents() {
-        when(event.getLevel()).thenReturn(Level.WARN);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersWarnEvents() {
+    when(event.getLevel()).thenReturn(Level.WARN);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".warn").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersErrorEvents() {
-        when(event.getLevel()).thenReturn(Level.ERROR);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".warn").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersErrorEvents() {
+    when(event.getLevel()).thenReturn(Level.ERROR);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".error").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void usesSharedRegistries() {
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".error").getCount()).isEqualTo(1);
+  }
 
-        String registryName = "registry";
+  @Test
+  void usesSharedRegistries() {
 
-        SharedMetricRegistries.add(registryName, registry);
-        final InstrumentedAppender shared = new InstrumentedAppender(registryName);
-        shared.start();
+    String registryName = "registry";
 
-        when(event.getLevel()).thenReturn(Level.INFO);
+    SharedMetricRegistries.add(registryName, registry);
+    final InstrumentedAppender shared = new InstrumentedAppender(registryName);
+    shared.start();
 
-        shared.doAppend(event);
+    when(event.getLevel()).thenReturn(Level.INFO);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+    shared.doAppend(event);
 
-    @Test
-    void usesDefaultRegistry() {
-        SharedMetricRegistries.add(InstrumentedAppender.DEFAULT_REGISTRY, registry);
-        final InstrumentedAppender shared = new InstrumentedAppender();
-        shared.start();
-        when(event.getLevel()).thenReturn(Level.INFO);
-        shared.doAppend(event);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        assertThat(SharedMetricRegistries.names()).contains(InstrumentedAppender.DEFAULT_REGISTRY);
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+  @Test
+  void usesDefaultRegistry() {
+    SharedMetricRegistries.add(InstrumentedAppender.DEFAULT_REGISTRY, registry);
+    final InstrumentedAppender shared = new InstrumentedAppender();
+    shared.start();
+    when(event.getLevel()).thenReturn(Level.INFO);
+    shared.doAppend(event);
 
-    @Test
-    void usesRegistryFromProperty() {
-        SharedMetricRegistries.add("something_else", registry);
-        System.setProperty(InstrumentedAppender.REGISTRY_PROPERTY_NAME, "something_else");
-        final InstrumentedAppender shared = new InstrumentedAppender();
-        shared.start();
-        when(event.getLevel()).thenReturn(Level.INFO);
-        shared.doAppend(event);
+    assertThat(SharedMetricRegistries.names()).contains(InstrumentedAppender.DEFAULT_REGISTRY);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        assertThat(SharedMetricRegistries.names()).contains("something_else");
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+  @Test
+  void usesRegistryFromProperty() {
+    SharedMetricRegistries.add("something_else", registry);
+    System.setProperty(InstrumentedAppender.REGISTRY_PROPERTY_NAME, "something_else");
+    final InstrumentedAppender shared = new InstrumentedAppender();
+    shared.start();
+    when(event.getLevel()).thenReturn(Level.INFO);
+    shared.doAppend(event);
 
+    assertThat(SharedMetricRegistries.names()).contains("something_else");
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-logback14/src/main/java/io/dropwizard/metrics/logback14/InstrumentedAppender.java
+++ b/metrics-logback14/src/main/java/io/dropwizard/metrics/logback14/InstrumentedAppender.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics.logback14;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import ch.qos.logback.classic.Level;
 import ch.qos.logback.classic.spi.ILoggingEvent;
 import ch.qos.logback.core.Appender;
@@ -8,84 +10,79 @@ import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.SharedMetricRegistries;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 /**
  * A Logback {@link Appender} which has six meters, one for each logging level and one for the total
  * number of statements being logged. The meter names are the logging level names appended to the
  * name of the appender.
  */
 public class InstrumentedAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {
-    private final MetricRegistry registry;
-    public static final String DEFAULT_REGISTRY = "logback-metrics";
-    public static final String REGISTRY_PROPERTY_NAME = "metrics.logback.registry";
+  private final MetricRegistry registry;
+  public static final String DEFAULT_REGISTRY = "logback-metrics";
+  public static final String REGISTRY_PROPERTY_NAME = "metrics.logback.registry";
 
-    private Meter all;
-    private Meter trace;
-    private Meter debug;
-    private Meter info;
-    private Meter warn;
-    private Meter error;
+  private Meter all;
+  private Meter trace;
+  private Meter debug;
+  private Meter info;
+  private Meter warn;
+  private Meter error;
 
+  /** Create a new instrumented appender using the given registry name. */
+  public InstrumentedAppender() {
+    this(System.getProperty(REGISTRY_PROPERTY_NAME, DEFAULT_REGISTRY));
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry name.
-     */
-    public InstrumentedAppender() {
-        this(System.getProperty(REGISTRY_PROPERTY_NAME, DEFAULT_REGISTRY));
-    }
+  /**
+   * Create a new instrumented appender using the given registry name.
+   *
+   * @param registryName the name of the registry in {@link SharedMetricRegistries}
+   */
+  public InstrumentedAppender(String registryName) {
+    this(SharedMetricRegistries.getOrCreate(registryName));
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry name.
-     *
-     * @param registryName the name of the registry in {@link SharedMetricRegistries}
-     */
-    public InstrumentedAppender(String registryName) {
-        this(SharedMetricRegistries.getOrCreate(registryName));
-    }
-
-    /**
-     * Create a new instrumented appender using the given registry.
-     *
-     * @param registry the metric registry
-     */
-    public InstrumentedAppender(MetricRegistry registry) {
-        this.registry = registry;
-        setName(Appender.class.getName());
-    }
+  /**
+   * Create a new instrumented appender using the given registry.
+   *
+   * @param registry the metric registry
+   */
+  public InstrumentedAppender(MetricRegistry registry) {
+    this.registry = registry;
+    setName(Appender.class.getName());
+  }
 
-    @Override
-    public void start() {
-        this.all = registry.meter(name(getName(), "all"));
-        this.trace = registry.meter(name(getName(), "trace"));
-        this.debug = registry.meter(name(getName(), "debug"));
-        this.info = registry.meter(name(getName(), "info"));
-        this.warn = registry.meter(name(getName(), "warn"));
-        this.error = registry.meter(name(getName(), "error"));
-        super.start();
-    }
+  @Override
+  public void start() {
+    this.all = registry.meter(name(getName(), "all"));
+    this.trace = registry.meter(name(getName(), "trace"));
+    this.debug = registry.meter(name(getName(), "debug"));
+    this.info = registry.meter(name(getName(), "info"));
+    this.warn = registry.meter(name(getName(), "warn"));
+    this.error = registry.meter(name(getName(), "error"));
+    super.start();
+  }
 
-    @Override
-    protected void append(ILoggingEvent event) {
-        all.mark();
-        switch (event.getLevel().toInt()) {
-            case Level.TRACE_INT:
-                trace.mark();
-                break;
-            case Level.DEBUG_INT:
-                debug.mark();
-                break;
-            case Level.INFO_INT:
-                info.mark();
-                break;
-            case Level.WARN_INT:
-                warn.mark();
-                break;
-            case Level.ERROR_INT:
-                error.mark();
-                break;
-            default:
-                break;
-        }
+  @Override
+  protected void append(ILoggingEvent event) {
+    all.mark();
+    switch (event.getLevel().toInt()) {
+      case Level.TRACE_INT:
+        trace.mark();
+        break;
+      case Level.DEBUG_INT:
+        debug.mark();
+        break;
+      case Level.INFO_INT:
+        info.mark();
+        break;
+      case Level.WARN_INT:
+        warn.mark();
+        break;
+      case Level.ERROR_INT:
+        error.mark();
+        break;
+      default:
+        break;
     }
+  }
 }
--- a/metrics-logback14/src/test/java/io/dropwizard/metrics/logback14/InstrumentedAppenderTest.java
+++ b/metrics-logback14/src/test/java/io/dropwizard/metrics/logback14/InstrumentedAppenderTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics.logback14;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import ch.qos.logback.classic.Level;
 import ch.qos.logback.classic.spi.ILoggingEvent;
 import io.dropwizard.metrics5.MetricRegistry;
@@ -8,135 +12,117 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-public class InstrumentedAppenderTest {
-
-    public static final String METRIC_NAME_PREFIX = "ch.qos.logback.core.Appender";
+final class InstrumentedAppenderTest {
 
-    private final MetricRegistry registry = new MetricRegistry();
-    private final InstrumentedAppender appender = new InstrumentedAppender(registry);
-    private final ILoggingEvent event = mock(ILoggingEvent.class);
+  public static final String METRIC_NAME_PREFIX = "ch.qos.logback.core.Appender";
 
-    @BeforeEach
-    void setUp() {
-        appender.start();
-    }
+  private final MetricRegistry registry = new MetricRegistry();
+  private final InstrumentedAppender appender = new InstrumentedAppender(registry);
+  private final ILoggingEvent event = mock();
 
-    @AfterEach
-    void tearDown() {
-        SharedMetricRegistries.clear();
-    }
+  @BeforeEach
+  void setUp() {
+    appender.start();
+  }
 
-    @Test
-    void metersTraceEvents() {
-        when(event.getLevel()).thenReturn(Level.TRACE);
+  @AfterEach
+  void tearDown() {
+    SharedMetricRegistries.clear();
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersTraceEvents() {
+    when(event.getLevel()).thenReturn(Level.TRACE);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersDebugEvents() {
-        when(event.getLevel()).thenReturn(Level.DEBUG);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersDebugEvents() {
+    when(event.getLevel()).thenReturn(Level.DEBUG);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".debug").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersInfoEvents() {
-        when(event.getLevel()).thenReturn(Level.INFO);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".debug").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersInfoEvents() {
+    when(event.getLevel()).thenReturn(Level.INFO);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersWarnEvents() {
-        when(event.getLevel()).thenReturn(Level.WARN);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersWarnEvents() {
+    when(event.getLevel()).thenReturn(Level.WARN);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".warn").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersErrorEvents() {
-        when(event.getLevel()).thenReturn(Level.ERROR);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".warn").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersErrorEvents() {
+    when(event.getLevel()).thenReturn(Level.ERROR);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".error").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void usesSharedRegistries() {
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".error").getCount()).isEqualTo(1);
+  }
 
-        String registryName = "registry";
+  @Test
+  void usesSharedRegistries() {
 
-        SharedMetricRegistries.add(registryName, registry);
-        final InstrumentedAppender shared = new InstrumentedAppender(registryName);
-        shared.start();
+    String registryName = "registry";
 
-        when(event.getLevel()).thenReturn(Level.INFO);
+    SharedMetricRegistries.add(registryName, registry);
+    final InstrumentedAppender shared = new InstrumentedAppender(registryName);
+    shared.start();
 
-        shared.doAppend(event);
+    when(event.getLevel()).thenReturn(Level.INFO);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+    shared.doAppend(event);
 
-    @Test
-    void usesDefaultRegistry() {
-        SharedMetricRegistries.add(InstrumentedAppender.DEFAULT_REGISTRY, registry);
-        final InstrumentedAppender shared = new InstrumentedAppender();
-        shared.start();
-        when(event.getLevel()).thenReturn(Level.INFO);
-        shared.doAppend(event);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        assertThat(SharedMetricRegistries.names()).contains(InstrumentedAppender.DEFAULT_REGISTRY);
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+  @Test
+  void usesDefaultRegistry() {
+    SharedMetricRegistries.add(InstrumentedAppender.DEFAULT_REGISTRY, registry);
+    final InstrumentedAppender shared = new InstrumentedAppender();
+    shared.start();
+    when(event.getLevel()).thenReturn(Level.INFO);
+    shared.doAppend(event);
 
-    @Test
-    void usesRegistryFromProperty() {
-        SharedMetricRegistries.add("something_else", registry);
-        System.setProperty(InstrumentedAppender.REGISTRY_PROPERTY_NAME, "something_else");
-        final InstrumentedAppender shared = new InstrumentedAppender();
-        shared.start();
-        when(event.getLevel()).thenReturn(Level.INFO);
-        shared.doAppend(event);
+    assertThat(SharedMetricRegistries.names()).contains(InstrumentedAppender.DEFAULT_REGISTRY);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        assertThat(SharedMetricRegistries.names()).contains("something_else");
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+  @Test
+  void usesRegistryFromProperty() {
+    SharedMetricRegistries.add("something_else", registry);
+    System.setProperty(InstrumentedAppender.REGISTRY_PROPERTY_NAME, "something_else");
+    final InstrumentedAppender shared = new InstrumentedAppender();
+    shared.start();
+    when(event.getLevel()).thenReturn(Level.INFO);
+    shared.doAppend(event);
 
+    assertThat(SharedMetricRegistries.names()).contains("something_else");
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-logback15/src/main/java/io/dropwizard/metrics5/logback15/InstrumentedAppender.java
+++ b/metrics-logback15/src/main/java/io/dropwizard/metrics5/logback15/InstrumentedAppender.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.logback15;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import ch.qos.logback.classic.Level;
 import ch.qos.logback.classic.spi.ILoggingEvent;
 import ch.qos.logback.core.Appender;
@@ -8,84 +10,79 @@ import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.SharedMetricRegistries;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 /**
  * A Logback {@link Appender} which has six meters, one for each logging level and one for the total
  * number of statements being logged. The meter names are the logging level names appended to the
  * name of the appender.
  */
 public class InstrumentedAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {
-    private final MetricRegistry registry;
-    public static final String DEFAULT_REGISTRY = "logback-metrics";
-    public static final String REGISTRY_PROPERTY_NAME = "metrics.logback.registry";
+  private final MetricRegistry registry;
+  public static final String DEFAULT_REGISTRY = "logback-metrics";
+  public static final String REGISTRY_PROPERTY_NAME = "metrics.logback.registry";
 
-    private Meter all;
-    private Meter trace;
-    private Meter debug;
-    private Meter info;
-    private Meter warn;
-    private Meter error;
+  private Meter all;
+  private Meter trace;
+  private Meter debug;
+  private Meter info;
+  private Meter warn;
+  private Meter error;
 
+  /** Create a new instrumented appender using the given registry name. */
+  public InstrumentedAppender() {
+    this(System.getProperty(REGISTRY_PROPERTY_NAME, DEFAULT_REGISTRY));
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry name.
-     */
-    public InstrumentedAppender() {
-        this(System.getProperty(REGISTRY_PROPERTY_NAME, DEFAULT_REGISTRY));
-    }
+  /**
+   * Create a new instrumented appender using the given registry name.
+   *
+   * @param registryName the name of the registry in {@link SharedMetricRegistries}
+   */
+  public InstrumentedAppender(String registryName) {
+    this(SharedMetricRegistries.getOrCreate(registryName));
+  }
 
-    /**
-     * Create a new instrumented appender using the given registry name.
-     *
-     * @param registryName the name of the registry in {@link SharedMetricRegistries}
-     */
-    public InstrumentedAppender(String registryName) {
-        this(SharedMetricRegistries.getOrCreate(registryName));
-    }
-
-    /**
-     * Create a new instrumented appender using the given registry.
-     *
-     * @param registry the metric registry
-     */
-    public InstrumentedAppender(MetricRegistry registry) {
-        this.registry = registry;
-        setName(Appender.class.getName());
-    }
+  /**
+   * Create a new instrumented appender using the given registry.
+   *
+   * @param registry the metric registry
+   */
+  public InstrumentedAppender(MetricRegistry registry) {
+    this.registry = registry;
+    setName(Appender.class.getName());
+  }
 
-    @Override
-    public void start() {
-        this.all = registry.meter(name(getName(), "all"));
-        this.trace = registry.meter(name(getName(), "trace"));
-        this.debug = registry.meter(name(getName(), "debug"));
-        this.info = registry.meter(name(getName(), "info"));
-        this.warn = registry.meter(name(getName(), "warn"));
-        this.error = registry.meter(name(getName(), "error"));
-        super.start();
-    }
+  @Override
+  public void start() {
+    this.all = registry.meter(name(getName(), "all"));
+    this.trace = registry.meter(name(getName(), "trace"));
+    this.debug = registry.meter(name(getName(), "debug"));
+    this.info = registry.meter(name(getName(), "info"));
+    this.warn = registry.meter(name(getName(), "warn"));
+    this.error = registry.meter(name(getName(), "error"));
+    super.start();
+  }
 
-    @Override
-    protected void append(ILoggingEvent event) {
-        all.mark();
-        switch (event.getLevel().toInt()) {
-            case Level.TRACE_INT:
-                trace.mark();
-                break;
-            case Level.DEBUG_INT:
-                debug.mark();
-                break;
-            case Level.INFO_INT:
-                info.mark();
-                break;
-            case Level.WARN_INT:
-                warn.mark();
-                break;
-            case Level.ERROR_INT:
-                error.mark();
-                break;
-            default:
-                break;
-        }
+  @Override
+  protected void append(ILoggingEvent event) {
+    all.mark();
+    switch (event.getLevel().toInt()) {
+      case Level.TRACE_INT:
+        trace.mark();
+        break;
+      case Level.DEBUG_INT:
+        debug.mark();
+        break;
+      case Level.INFO_INT:
+        info.mark();
+        break;
+      case Level.WARN_INT:
+        warn.mark();
+        break;
+      case Level.ERROR_INT:
+        error.mark();
+        break;
+      default:
+        break;
     }
+  }
 }
--- a/metrics-logback15/src/test/java/io/dropwizard/metrics5/logback15/InstrumentedAppenderTest.java
+++ b/metrics-logback15/src/test/java/io/dropwizard/metrics5/logback15/InstrumentedAppenderTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.logback15;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import ch.qos.logback.classic.Level;
 import ch.qos.logback.classic.spi.ILoggingEvent;
 import io.dropwizard.metrics5.MetricRegistry;
@@ -8,135 +12,117 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-public class InstrumentedAppenderTest {
-
-    public static final String METRIC_NAME_PREFIX = "ch.qos.logback.core.Appender";
+final class InstrumentedAppenderTest {
 
-    private final MetricRegistry registry = new MetricRegistry();
-    private final InstrumentedAppender appender = new InstrumentedAppender(registry);
-    private final ILoggingEvent event = mock(ILoggingEvent.class);
+  public static final String METRIC_NAME_PREFIX = "ch.qos.logback.core.Appender";
 
-    @BeforeEach
-    void setUp() {
-        appender.start();
-    }
+  private final MetricRegistry registry = new MetricRegistry();
+  private final InstrumentedAppender appender = new InstrumentedAppender(registry);
+  private final ILoggingEvent event = mock();
 
-    @AfterEach
-    void tearDown() {
-        SharedMetricRegistries.clear();
-    }
+  @BeforeEach
+  void setUp() {
+    appender.start();
+  }
 
-    @Test
-    void metersTraceEvents() {
-        when(event.getLevel()).thenReturn(Level.TRACE);
+  @AfterEach
+  void tearDown() {
+    SharedMetricRegistries.clear();
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersTraceEvents() {
+    when(event.getLevel()).thenReturn(Level.TRACE);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersDebugEvents() {
-        when(event.getLevel()).thenReturn(Level.DEBUG);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".trace").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersDebugEvents() {
+    when(event.getLevel()).thenReturn(Level.DEBUG);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".debug").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersInfoEvents() {
-        when(event.getLevel()).thenReturn(Level.INFO);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".debug").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersInfoEvents() {
+    when(event.getLevel()).thenReturn(Level.INFO);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersWarnEvents() {
-        when(event.getLevel()).thenReturn(Level.WARN);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersWarnEvents() {
+    when(event.getLevel()).thenReturn(Level.WARN);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".warn").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void metersErrorEvents() {
-        when(event.getLevel()).thenReturn(Level.ERROR);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".warn").getCount()).isEqualTo(1);
+  }
 
-        appender.doAppend(event);
+  @Test
+  void metersErrorEvents() {
+    when(event.getLevel()).thenReturn(Level.ERROR);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount())
-                .isEqualTo(1);
+    appender.doAppend(event);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".error").getCount())
-                .isEqualTo(1);
-    }
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".all").getCount()).isEqualTo(1);
 
-    @Test
-    void usesSharedRegistries() {
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".error").getCount()).isEqualTo(1);
+  }
 
-        String registryName = "registry";
+  @Test
+  void usesSharedRegistries() {
 
-        SharedMetricRegistries.add(registryName, registry);
-        final InstrumentedAppender shared = new InstrumentedAppender(registryName);
-        shared.start();
+    String registryName = "registry";
 
-        when(event.getLevel()).thenReturn(Level.INFO);
+    SharedMetricRegistries.add(registryName, registry);
+    final InstrumentedAppender shared = new InstrumentedAppender(registryName);
+    shared.start();
 
-        shared.doAppend(event);
+    when(event.getLevel()).thenReturn(Level.INFO);
 
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+    shared.doAppend(event);
 
-    @Test
-    void usesDefaultRegistry() {
-        SharedMetricRegistries.add(InstrumentedAppender.DEFAULT_REGISTRY, registry);
-        final InstrumentedAppender shared = new InstrumentedAppender();
-        shared.start();
-        when(event.getLevel()).thenReturn(Level.INFO);
-        shared.doAppend(event);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        assertThat(SharedMetricRegistries.names()).contains(InstrumentedAppender.DEFAULT_REGISTRY);
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+  @Test
+  void usesDefaultRegistry() {
+    SharedMetricRegistries.add(InstrumentedAppender.DEFAULT_REGISTRY, registry);
+    final InstrumentedAppender shared = new InstrumentedAppender();
+    shared.start();
+    when(event.getLevel()).thenReturn(Level.INFO);
+    shared.doAppend(event);
 
-    @Test
-    void usesRegistryFromProperty() {
-        SharedMetricRegistries.add("something_else", registry);
-        System.setProperty(InstrumentedAppender.REGISTRY_PROPERTY_NAME, "something_else");
-        final InstrumentedAppender shared = new InstrumentedAppender();
-        shared.start();
-        when(event.getLevel()).thenReturn(Level.INFO);
-        shared.doAppend(event);
+    assertThat(SharedMetricRegistries.names()).contains(InstrumentedAppender.DEFAULT_REGISTRY);
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 
-        assertThat(SharedMetricRegistries.names()).contains("something_else");
-        assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount())
-                .isEqualTo(1);
-    }
+  @Test
+  void usesRegistryFromProperty() {
+    SharedMetricRegistries.add("something_else", registry);
+    System.setProperty(InstrumentedAppender.REGISTRY_PROPERTY_NAME, "something_else");
+    final InstrumentedAppender shared = new InstrumentedAppender();
+    shared.start();
+    when(event.getLevel()).thenReturn(Level.INFO);
+    shared.doAppend(event);
 
+    assertThat(SharedMetricRegistries.names()).contains("something_else");
+    assertThat(registry.meter(METRIC_NAME_PREFIX + ".info").getCount()).isEqualTo(1);
+  }
 }
--- a/metrics-servlet/src/main/java/io/dropwizard/metrics5/servlet/AbstractInstrumentedFilter.java
+++ b/metrics-servlet/src/main/java/io/dropwizard/metrics5/servlet/AbstractInstrumentedFilter.java
@@ -1,10 +1,17 @@
 package io.dropwizard.metrics5.servlet;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
+import com.google.common.base.Strings;
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
-
+import java.io.IOException;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import javax.servlet.AsyncEvent;
 import javax.servlet.AsyncListener;
 import javax.servlet.Filter;
@@ -15,204 +22,192 @@ import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.HttpServletResponseWrapper;
-import java.io.IOException;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-
-import static io.dropwizard.metrics5.MetricRegistry.name;
 
 /**
  * {@link Filter} implementation which captures request information and a breakdown of the response
  * codes being returned.
  */
 public abstract class AbstractInstrumentedFilter implements Filter {
-    static final String METRIC_PREFIX = "name-prefix";
-
-    private final String otherMetricName;
-    private final Map<Integer, String> meterNamesByStatusCode;
-    private final String registryAttribute;
-
-    // initialized after call of init method
-    private ConcurrentMap<Integer, Meter> metersByStatusCode;
-    private Meter otherMeter;
-    private Meter timeoutsMeter;
-    private Meter errorsMeter;
-    private Counter activeRequests;
-    private Timer requestTimer;
-
-
-    /**
-     * Creates a new instance of the filter.
-     *
-     * @param registryAttribute      the attribute used to look up the metrics registry in the
-     *                               servlet context
-     * @param meterNamesByStatusCode A map, keyed by status code, of meter names that we are
-     *                               interested in.
-     * @param otherMetricName        The name used for the catch-all meter.
-     */
-    protected AbstractInstrumentedFilter(String registryAttribute,
-                                         Map<Integer, String> meterNamesByStatusCode,
-                                         String otherMetricName) {
-        this.registryAttribute = registryAttribute;
-        this.otherMetricName = otherMetricName;
-        this.meterNamesByStatusCode = meterNamesByStatusCode;
+  static final String METRIC_PREFIX = "name-prefix";
+
+  private final String otherMetricName;
+  private final Map<Integer, String> meterNamesByStatusCode;
+  private final String registryAttribute;
+
+  // initialized after call of init method
+  private ConcurrentMap<Integer, Meter> metersByStatusCode;
+  private Meter otherMeter;
+  private Meter timeoutsMeter;
+  private Meter errorsMeter;
+  private Counter activeRequests;
+  private Timer requestTimer;
+
+  /**
+   * Creates a new instance of the filter.
+   *
+   * @param registryAttribute the attribute used to look up the metrics registry in the servlet
+   *     context
+   * @param meterNamesByStatusCode A map, keyed by status code, of meter names that we are
+   *     interested in.
+   * @param otherMetricName The name used for the catch-all meter.
+   */
+  protected AbstractInstrumentedFilter(
+      String registryAttribute,
+      Map<Integer, String> meterNamesByStatusCode,
+      String otherMetricName) {
+    this.registryAttribute = registryAttribute;
+    this.otherMetricName = otherMetricName;
+    this.meterNamesByStatusCode = meterNamesByStatusCode;
+  }
+
+  @Override
+  public void init(FilterConfig filterConfig) throws ServletException {
+    final MetricRegistry metricsRegistry = getMetricsFactory(filterConfig);
+
+    String metricName = filterConfig.getInitParameter(METRIC_PREFIX);
+    if (Strings.isNullOrEmpty(metricName)) {
+      metricName = getClass().getName();
     }
 
-    @Override
-    public void init(FilterConfig filterConfig) throws ServletException {
-        final MetricRegistry metricsRegistry = getMetricsFactory(filterConfig);
-
-        String metricName = filterConfig.getInitParameter(METRIC_PREFIX);
-        if (metricName == null || metricName.isEmpty()) {
-            metricName = getClass().getName();
-        }
-
-        this.metersByStatusCode = new ConcurrentHashMap<>(meterNamesByStatusCode.size());
-        for (Entry<Integer, String> entry : meterNamesByStatusCode.entrySet()) {
-            metersByStatusCode.put(entry.getKey(),
-                    metricsRegistry.meter(name(metricName, entry.getValue())));
-        }
-        this.otherMeter = metricsRegistry.meter(name(metricName, otherMetricName));
-        this.timeoutsMeter = metricsRegistry.meter(name(metricName, "timeouts"));
-        this.errorsMeter = metricsRegistry.meter(name(metricName, "errors"));
-        this.activeRequests = metricsRegistry.counter(name(metricName, "activeRequests"));
-        this.requestTimer = metricsRegistry.timer(name(metricName, "requests"));
-
+    this.metersByStatusCode = new ConcurrentHashMap<>(meterNamesByStatusCode.size());
+    for (Entry<Integer, String> entry : meterNamesByStatusCode.entrySet()) {
+      metersByStatusCode.put(
+          entry.getKey(), metricsRegistry.meter(name(metricName, entry.getValue())));
     }
-
-    private MetricRegistry getMetricsFactory(FilterConfig filterConfig) {
-        final MetricRegistry metricsRegistry;
-
-        final Object o = filterConfig.getServletContext().getAttribute(this.registryAttribute);
-        if (o instanceof MetricRegistry) {
-            metricsRegistry = (MetricRegistry) o;
+    this.otherMeter = metricsRegistry.meter(name(metricName, otherMetricName));
+    this.timeoutsMeter = metricsRegistry.meter(name(metricName, "timeouts"));
+    this.errorsMeter = metricsRegistry.meter(name(metricName, "errors"));
+    this.activeRequests = metricsRegistry.counter(name(metricName, "activeRequests"));
+    this.requestTimer = metricsRegistry.timer(name(metricName, "requests"));
+  }
+
+  private MetricRegistry getMetricsFactory(FilterConfig filterConfig) {
+    final MetricRegistry metricsRegistry;
+
+    final Object o = filterConfig.getServletContext().getAttribute(this.registryAttribute);
+    if (o instanceof MetricRegistry) {
+      metricsRegistry = (MetricRegistry) o;
+    } else {
+      metricsRegistry = new MetricRegistry();
+    }
+    return metricsRegistry;
+  }
+
+  @Override
+  public void destroy() {}
+
+  @Override
+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
+      throws IOException, ServletException {
+    final StatusExposingServletResponse wrappedResponse =
+        new StatusExposingServletResponse((HttpServletResponse) response);
+    activeRequests.inc();
+    final Timer.Context context = requestTimer.time();
+    boolean error = false;
+    try {
+      chain.doFilter(request, wrappedResponse);
+    } catch (IOException | RuntimeException | ServletException e) {
+      error = true;
+      throw e;
+    } finally {
+      if (!error && request.isAsyncStarted()) {
+        request.getAsyncContext().addListener(new AsyncResultListener(context));
+      } else {
+        context.stop();
+        activeRequests.dec();
+        if (error) {
+          errorsMeter.mark();
         } else {
-            metricsRegistry = new MetricRegistry();
+          markMeterForStatusCode(wrappedResponse.getStatus());
         }
-        return metricsRegistry;
+      }
+    }
+  }
+
+  private void markMeterForStatusCode(int status) {
+    final Meter metric = metersByStatusCode.get(status);
+    if (metric != null) {
+      metric.mark();
+    } else {
+      otherMeter.mark();
     }
+  }
 
-    @Override
-    public void destroy() {
+  private static class StatusExposingServletResponse extends HttpServletResponseWrapper {
+    // The Servlet spec says: calling setStatus is optional, if no status is set, the default is
+    // 200.
+    private int httpStatus = 200;
 
+    public StatusExposingServletResponse(HttpServletResponse response) {
+      super(response);
     }
 
     @Override
-    public void doFilter(ServletRequest request,
-                         ServletResponse response,
-                         FilterChain chain) throws IOException, ServletException {
-        final StatusExposingServletResponse wrappedResponse =
-                new StatusExposingServletResponse((HttpServletResponse) response);
-        activeRequests.inc();
-        final Timer.Context context = requestTimer.time();
-        boolean error = false;
-        try {
-            chain.doFilter(request, wrappedResponse);
-        } catch (IOException | RuntimeException | ServletException e) {
-            error = true;
-            throw e;
-        } finally {
-            if (!error && request.isAsyncStarted()) {
-                request.getAsyncContext().addListener(new AsyncResultListener(context));
-            } else {
-                context.stop();
-                activeRequests.dec();
-                if (error) {
-                    errorsMeter.mark();
-                } else {
-                    markMeterForStatusCode(wrappedResponse.getStatus());
-                }
-            }
-        }
+    public void sendError(int sc) throws IOException {
+      httpStatus = sc;
+      super.sendError(sc);
     }
 
-    private void markMeterForStatusCode(int status) {
-        final Meter metric = metersByStatusCode.get(status);
-        if (metric != null) {
-            metric.mark();
-        } else {
-            otherMeter.mark();
-        }
+    @Override
+    public void sendError(int sc, String msg) throws IOException {
+      httpStatus = sc;
+      super.sendError(sc, msg);
     }
 
-    private static class StatusExposingServletResponse extends HttpServletResponseWrapper {
-        // The Servlet spec says: calling setStatus is optional, if no status is set, the default is 200.
-        private int httpStatus = 200;
-
-        public StatusExposingServletResponse(HttpServletResponse response) {
-            super(response);
-        }
-
-        @Override
-        public void sendError(int sc) throws IOException {
-            httpStatus = sc;
-            super.sendError(sc);
-        }
-
-        @Override
-        public void sendError(int sc, String msg) throws IOException {
-            httpStatus = sc;
-            super.sendError(sc, msg);
-        }
-
-        @Override
-        public void setStatus(int sc) {
-            httpStatus = sc;
-            super.setStatus(sc);
-        }
-
-        @Override
-        @SuppressWarnings("deprecation")
-        public void setStatus(int sc, String sm) {
-            httpStatus = sc;
-            super.setStatus(sc, sm);
-        }
-
-        @Override
-        public int getStatus() {
-            return httpStatus;
-        }
+    @Override
+    public void setStatus(int sc) {
+      httpStatus = sc;
+      super.setStatus(sc);
     }
 
-    private class AsyncResultListener implements AsyncListener {
-        private Timer.Context context;
-        private boolean done = false;
+    @Override
+    @SuppressWarnings("deprecation")
+    public void setStatus(int sc, String sm) {
+      httpStatus = sc;
+      super.setStatus(sc, sm);
+    }
 
-        public AsyncResultListener(Timer.Context context) {
-            this.context = context;
-        }
+    @Override
+    public int getStatus() {
+      return httpStatus;
+    }
+  }
 
-        @Override
-        public void onComplete(AsyncEvent event) throws IOException {
-            if (!done) {
-                HttpServletResponse suppliedResponse = (HttpServletResponse) event.getSuppliedResponse();
-                context.stop();
-                activeRequests.dec();
-                markMeterForStatusCode(suppliedResponse.getStatus());
-            }
-        }
+  private class AsyncResultListener implements AsyncListener {
+    private Timer.Context context;
+    private boolean done = false;
 
-        @Override
-        public void onTimeout(AsyncEvent event) throws IOException {
-            context.stop();
-            activeRequests.dec();
-            timeoutsMeter.mark();
-            done = true;
-        }
+    public AsyncResultListener(Timer.Context context) {
+      this.context = context;
+    }
 
-        @Override
-        public void onError(AsyncEvent event) throws IOException {
-            context.stop();
-            activeRequests.dec();
-            errorsMeter.mark();
-            done = true;
-        }
+    @Override
+    public void onComplete(AsyncEvent event) throws IOException {
+      if (!done) {
+        HttpServletResponse suppliedResponse = (HttpServletResponse) event.getSuppliedResponse();
+        context.stop();
+        activeRequests.dec();
+        markMeterForStatusCode(suppliedResponse.getStatus());
+      }
+    }
 
-        @Override
-        public void onStartAsync(AsyncEvent event) throws IOException {
+    @Override
+    public void onTimeout(AsyncEvent event) throws IOException {
+      context.stop();
+      activeRequests.dec();
+      timeoutsMeter.mark();
+      done = true;
+    }
 
-        }
+    @Override
+    public void onError(AsyncEvent event) throws IOException {
+      context.stop();
+      activeRequests.dec();
+      errorsMeter.mark();
+      done = true;
     }
+
+    @Override
+    public void onStartAsync(AsyncEvent event) throws IOException {}
+  }
 }
--- a/metrics-servlet/src/main/java/io/dropwizard/metrics5/servlet/InstrumentedFilter.java
+++ b/metrics-servlet/src/main/java/io/dropwizard/metrics5/servlet/InstrumentedFilter.java
@@ -4,8 +4,13 @@ import java.util.HashMap;
 import java.util.Map;
 
 /**
- * Implementation of the {@link AbstractInstrumentedFilter} which provides a default set of response codes
- * to capture information about. <p>Use it in your servlet.xml like this:<p>
+ * Implementation of the {@link AbstractInstrumentedFilter} which provides a default set of response
+ * codes to capture information about.
+ *
+ * <p>Use it in your servlet.xml like this:
+ *
+ * <p>
+ *
  * <pre>{@code
  * <filter>
  *     <filter-name>instrumentedFilter</filter-name>
@@ -18,31 +23,29 @@ import java.util.Map;
  * }</pre>
  */
 public class InstrumentedFilter extends AbstractInstrumentedFilter {
-    public static final String REGISTRY_ATTRIBUTE = InstrumentedFilter.class.getName() + ".registry";
+  public static final String REGISTRY_ATTRIBUTE = InstrumentedFilter.class.getName() + ".registry";
 
-    private static final String NAME_PREFIX = "responseCodes.";
-    private static final int OK = 200;
-    private static final int CREATED = 201;
-    private static final int NO_CONTENT = 204;
-    private static final int BAD_REQUEST = 400;
-    private static final int NOT_FOUND = 404;
-    private static final int SERVER_ERROR = 500;
+  private static final String NAME_PREFIX = "responseCodes.";
+  private static final int OK = 200;
+  private static final int CREATED = 201;
+  private static final int NO_CONTENT = 204;
+  private static final int BAD_REQUEST = 400;
+  private static final int NOT_FOUND = 404;
+  private static final int SERVER_ERROR = 500;
 
-    /**
-     * Creates a new instance of the filter.
-     */
-    public InstrumentedFilter() {
-        super(REGISTRY_ATTRIBUTE, createMeterNamesByStatusCode(), NAME_PREFIX + "other");
-    }
+  /** Creates a new instance of the filter. */
+  public InstrumentedFilter() {
+    super(REGISTRY_ATTRIBUTE, createMeterNamesByStatusCode(), NAME_PREFIX + "other");
+  }
 
-    private static Map<Integer, String> createMeterNamesByStatusCode() {
-        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);
-        meterNamesByStatusCode.put(OK, NAME_PREFIX + "ok");
-        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + "created");
-        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + "noContent");
-        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + "badRequest");
-        meterNamesByStatusCode.put(NOT_FOUND, NAME_PREFIX + "notFound");
-        meterNamesByStatusCode.put(SERVER_ERROR, NAME_PREFIX + "serverError");
-        return meterNamesByStatusCode;
-    }
+  private static Map<Integer, String> createMeterNamesByStatusCode() {
+    final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);
+    meterNamesByStatusCode.put(OK, NAME_PREFIX + "ok");
+    meterNamesByStatusCode.put(CREATED, NAME_PREFIX + "created");
+    meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + "noContent");
+    meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + "badRequest");
+    meterNamesByStatusCode.put(NOT_FOUND, NAME_PREFIX + "notFound");
+    meterNamesByStatusCode.put(SERVER_ERROR, NAME_PREFIX + "serverError");
+    return meterNamesByStatusCode;
+  }
 }
--- a/metrics-servlet/src/main/java/io/dropwizard/metrics5/servlet/InstrumentedFilterContextListener.java
+++ b/metrics-servlet/src/main/java/io/dropwizard/metrics5/servlet/InstrumentedFilterContextListener.java
@@ -1,7 +1,6 @@
 package io.dropwizard.metrics5.servlet;
 
 import io.dropwizard.metrics5.MetricRegistry;
-
 import javax.servlet.ServletContextEvent;
 import javax.servlet.ServletContextListener;
 
@@ -11,17 +10,17 @@ import javax.servlet.ServletContextListener;
  * application.
  */
 public abstract class InstrumentedFilterContextListener implements ServletContextListener {
-    /**
-     * @return the {@link MetricRegistry} to inject into the servlet context.
-     */
-    protected abstract MetricRegistry getMetricRegistry();
+  /**
+   * @return the {@link MetricRegistry} to inject into the servlet context.
+   */
+  protected abstract MetricRegistry getMetricRegistry();
 
-    @Override
-    public void contextInitialized(ServletContextEvent sce) {
-        sce.getServletContext().setAttribute(InstrumentedFilter.REGISTRY_ATTRIBUTE, getMetricRegistry());
-    }
+  @Override
+  public void contextInitialized(ServletContextEvent sce) {
+    sce.getServletContext()
+        .setAttribute(InstrumentedFilter.REGISTRY_ATTRIBUTE, getMetricRegistry());
+  }
 
-    @Override
-    public void contextDestroyed(ServletContextEvent sce) {
-    }
+  @Override
+  public void contextDestroyed(ServletContextEvent sce) {}
 }
--- a/metrics-servlet/src/test/java/io/dropwizard/metrics5/servlet/InstrumentedFilterContextListenerTest.java
+++ b/metrics-servlet/src/test/java/io/dropwizard/metrics5/servlet/InstrumentedFilterContextListenerTest.java
@@ -1,33 +1,34 @@
 package io.dropwizard.metrics5.servlet;
 
-import io.dropwizard.metrics5.MetricRegistry;
-import org.junit.jupiter.api.Test;
-
-import javax.servlet.ServletContext;
-import javax.servlet.ServletContextEvent;
-
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-class InstrumentedFilterContextListenerTest {
-    private final MetricRegistry registry = mock(MetricRegistry.class);
-    private final InstrumentedFilterContextListener listener = new InstrumentedFilterContextListener() {
+import io.dropwizard.metrics5.MetricRegistry;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletContextEvent;
+import org.junit.jupiter.api.Test;
+
+final class InstrumentedFilterContextListenerTest {
+  private final MetricRegistry registry = mock();
+  private final InstrumentedFilterContextListener listener =
+      new InstrumentedFilterContextListener() {
         @Override
         protected MetricRegistry getMetricRegistry() {
-            return registry;
+          return registry;
         }
-    };
+      };
 
-    @Test
-    void injectsTheMetricRegistryIntoTheServletContext() {
-        final ServletContext context = mock(ServletContext.class);
+  @Test
+  void injectsTheMetricRegistryIntoTheServletContext() {
+    final ServletContext context = mock();
 
-        final ServletContextEvent event = mock(ServletContextEvent.class);
-        when(event.getServletContext()).thenReturn(context);
+    final ServletContextEvent event = mock();
+    when(event.getServletContext()).thenReturn(context);
 
-        listener.contextInitialized(event);
+    listener.contextInitialized(event);
 
-        verify(context).setAttribute("io.dropwizard.metrics5.servlet.InstrumentedFilter.registry", registry);
-    }
+    verify(context)
+        .setAttribute("io.dropwizard.metrics5.servlet.InstrumentedFilter.registry", registry);
+  }
 }
--- a/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/AdminServlet.java
+++ b/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/AdminServlet.java
@@ -1,189 +1,210 @@
 package io.dropwizard.metrics5.servlets;
 
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.text.MessageFormat;
 import javax.servlet.ServletConfig;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.text.MessageFormat;
 
 public class AdminServlet extends HttpServlet {
-    public static final String DEFAULT_HEALTHCHECK_URI = "/healthcheck";
-    public static final String DEFAULT_METRICS_URI = "/metrics";
-    public static final String DEFAULT_PING_URI = "/ping";
-    public static final String DEFAULT_THREADS_URI = "/threads";
-    public static final String DEFAULT_CPU_PROFILE_URI = "/pprof";
-
-    public static final String METRICS_ENABLED_PARAM_KEY = "metrics-enabled";
-    public static final String METRICS_URI_PARAM_KEY = "metrics-uri";
-    public static final String PING_ENABLED_PARAM_KEY = "ping-enabled";
-    public static final String PING_URI_PARAM_KEY = "ping-uri";
-    public static final String THREADS_ENABLED_PARAM_KEY = "threads-enabled";
-    public static final String THREADS_URI_PARAM_KEY = "threads-uri";
-    public static final String HEALTHCHECK_ENABLED_PARAM_KEY = "healthcheck-enabled";
-    public static final String HEALTHCHECK_URI_PARAM_KEY = "healthcheck-uri";
-    public static final String SERVICE_NAME_PARAM_KEY = "service-name";
-    public static final String CPU_PROFILE_ENABLED_PARAM_KEY = "cpu-profile-enabled";
-    public static final String CPU_PROFILE_URI_PARAM_KEY = "cpu-profile-uri";
-
-    private static final String BASE_TEMPLATE =
-            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n" +
-                    "        \"http://www.w3.org/TR/html4/loose.dtd\">%n" +
-                    "<html>%n" +
-                    "<head>%n" +
-                    "  <title>Metrics{10}</title>%n" +
-                    "</head>%n" +
-                    "<body>%n" +
-                    "  <h1>Operational Menu{10}</h1>%n" +
-                    "  <ul>%n" +
-                    "%s" +
-                    "  </ul>%n" +
-                    "</body>%n" +
-                    "</html>";
-    private static final String METRICS_LINK = "    <li><a href=\"{0}{1}?pretty=true\">Metrics</a></li>%n";
-    private static final String PING_LINK = "    <li><a href=\"{2}{3}\">Ping</a></li>%n" ;
-    private static final String THREADS_LINK = "    <li><a href=\"{4}{5}\">Threads</a></li>%n" ;
-    private static final String HEALTHCHECK_LINK = "    <li><a href=\"{6}{7}?pretty=true\">Healthcheck</a></li>%n" ;
-    private static final String CPU_PROFILE_LINK = "    <li><a href=\"{8}{9}\">CPU Profile</a></li>%n" +
-            "    <li><a href=\"{8}{9}?state=blocked\">CPU Contention</a></li>%n";
-
-
-    private static final String CONTENT_TYPE = "text/html";
-    private static final long serialVersionUID = -2850794040708785318L;
-
-    private transient HealthCheckServlet healthCheckServlet;
-    private transient MetricsServlet metricsServlet;
-    private transient PingServlet pingServlet;
-    private transient ThreadDumpServlet threadDumpServlet;
-    private transient CpuProfileServlet cpuProfileServlet;
-    private transient boolean metricsEnabled;
-    private transient String metricsUri;
-    private transient boolean pingEnabled;
-    private transient String pingUri;
-    private transient boolean threadsEnabled;
-    private transient String threadsUri;
-    private transient boolean healthcheckEnabled;
-    private transient String healthcheckUri;
-    private transient boolean cpuProfileEnabled;
-    private transient String cpuProfileUri;
-    private transient String serviceName;
-    private transient String pageContentTemplate;
-
-    @Override
-    public void init(ServletConfig config) throws ServletException {
-        super.init(config);
-
-        final ServletContext context = config.getServletContext();
-        final StringBuilder servletLinks = new StringBuilder();
-
-        this.metricsEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(METRICS_ENABLED_PARAM_KEY), "true"));
-        if (this.metricsEnabled) {
-            servletLinks.append(METRICS_LINK);
-        }
-        this.metricsServlet = new MetricsServlet();
-        metricsServlet.init(config);
-
-        this.pingEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(PING_ENABLED_PARAM_KEY), "true"));
-        if (this.pingEnabled) {
-            servletLinks.append(PING_LINK);
-        }
-        this.pingServlet = new PingServlet();
-        pingServlet.init(config);
-
-        this.threadsEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(THREADS_ENABLED_PARAM_KEY), "true"));
-        if (this.threadsEnabled) {
-            servletLinks.append(THREADS_LINK);
-        }
-        this.threadDumpServlet = new ThreadDumpServlet();
-        threadDumpServlet.init(config);
-
-        this.healthcheckEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(HEALTHCHECK_ENABLED_PARAM_KEY), "true"));
-        if (this.healthcheckEnabled) {
-            servletLinks.append(HEALTHCHECK_LINK);
-        }
-        this.healthCheckServlet = new HealthCheckServlet();
-        healthCheckServlet.init(config);
-
-        this.cpuProfileEnabled =
-                Boolean.parseBoolean(getParam(context.getInitParameter(CPU_PROFILE_ENABLED_PARAM_KEY), "true"));
-        if (this.cpuProfileEnabled) {
-            servletLinks.append(CPU_PROFILE_LINK);
-        }
-        this.cpuProfileServlet = new CpuProfileServlet();
-        cpuProfileServlet.init(config);
-
-        pageContentTemplate = String.format(BASE_TEMPLATE, String.format(servletLinks.toString()));
-
-        this.metricsUri = getParam(context.getInitParameter(METRICS_URI_PARAM_KEY), DEFAULT_METRICS_URI);
-        this.pingUri = getParam(context.getInitParameter(PING_URI_PARAM_KEY), DEFAULT_PING_URI);
-        this.threadsUri = getParam(context.getInitParameter(THREADS_URI_PARAM_KEY), DEFAULT_THREADS_URI);
-        this.healthcheckUri = getParam(context.getInitParameter(HEALTHCHECK_URI_PARAM_KEY), DEFAULT_HEALTHCHECK_URI);
-        this.cpuProfileUri = getParam(context.getInitParameter(CPU_PROFILE_URI_PARAM_KEY), DEFAULT_CPU_PROFILE_URI);
-        this.serviceName = getParam(context.getInitParameter(SERVICE_NAME_PARAM_KEY), null);
+  public static final String DEFAULT_HEALTHCHECK_URI = "/healthcheck";
+  public static final String DEFAULT_METRICS_URI = "/metrics";
+  public static final String DEFAULT_PING_URI = "/ping";
+  public static final String DEFAULT_THREADS_URI = "/threads";
+  public static final String DEFAULT_CPU_PROFILE_URI = "/pprof";
+
+  public static final String METRICS_ENABLED_PARAM_KEY = "metrics-enabled";
+  public static final String METRICS_URI_PARAM_KEY = "metrics-uri";
+  public static final String PING_ENABLED_PARAM_KEY = "ping-enabled";
+  public static final String PING_URI_PARAM_KEY = "ping-uri";
+  public static final String THREADS_ENABLED_PARAM_KEY = "threads-enabled";
+  public static final String THREADS_URI_PARAM_KEY = "threads-uri";
+  public static final String HEALTHCHECK_ENABLED_PARAM_KEY = "healthcheck-enabled";
+  public static final String HEALTHCHECK_URI_PARAM_KEY = "healthcheck-uri";
+  public static final String SERVICE_NAME_PARAM_KEY = "service-name";
+  public static final String CPU_PROFILE_ENABLED_PARAM_KEY = "cpu-profile-enabled";
+  public static final String CPU_PROFILE_URI_PARAM_KEY = "cpu-profile-uri";
+
+  private static final String BASE_TEMPLATE =
+      "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n"
+          + "        \"http://www.w3.org/TR/html4/loose.dtd\">%n"
+          + "<html>%n"
+          + "<head>%n"
+          + "  <title>Metrics{10}</title>%n"
+          + "</head>%n"
+          + "<body>%n"
+          + "  <h1>Operational Menu{10}</h1>%n"
+          + "  <ul>%n"
+          + "%s"
+          + "  </ul>%n"
+          + "</body>%n"
+          + "</html>";
+  private static final String METRICS_LINK =
+      "    <li><a href=\"{0}{1}?pretty=true\">Metrics</a></li>%n";
+  private static final String PING_LINK = "    <li><a href=\"{2}{3}\">Ping</a></li>%n";
+  private static final String THREADS_LINK = "    <li><a href=\"{4}{5}\">Threads</a></li>%n";
+  private static final String HEALTHCHECK_LINK =
+      "    <li><a href=\"{6}{7}?pretty=true\">Healthcheck</a></li>%n";
+  private static final String CPU_PROFILE_LINK =
+      "    <li><a href=\"{8}{9}\">CPU Profile</a></li>%n"
+          + "    <li><a href=\"{8}{9}?state=blocked\">CPU Contention</a></li>%n";
+
+  private static final String CONTENT_TYPE = "text/html";
+  private static final long serialVersionUID = -2850794040708785318L;
+
+  private transient HealthCheckServlet healthCheckServlet;
+  private transient MetricsServlet metricsServlet;
+  private transient PingServlet pingServlet;
+  private transient ThreadDumpServlet threadDumpServlet;
+  private transient CpuProfileServlet cpuProfileServlet;
+  private transient boolean metricsEnabled;
+  private transient String metricsUri;
+  private transient boolean pingEnabled;
+  private transient String pingUri;
+  private transient boolean threadsEnabled;
+  private transient String threadsUri;
+  private transient boolean healthcheckEnabled;
+  private transient String healthcheckUri;
+  private transient boolean cpuProfileEnabled;
+  private transient String cpuProfileUri;
+  private transient String serviceName;
+  private transient String pageContentTemplate;
+
+  @Override
+  public void init(ServletConfig config) throws ServletException {
+    super.init(config);
+
+    final ServletContext context = config.getServletContext();
+    final StringBuilder servletLinks = new StringBuilder();
+
+    this.metricsEnabled =
+        Boolean.parseBoolean(getParam(context.getInitParameter(METRICS_ENABLED_PARAM_KEY), "true"));
+    if (this.metricsEnabled) {
+      servletLinks.append(METRICS_LINK);
     }
+    this.metricsServlet = new MetricsServlet();
+    metricsServlet.init(config);
 
-    @Override
-    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
-        final String path = req.getContextPath() + req.getServletPath();
-
-        resp.setStatus(HttpServletResponse.SC_OK);
-        resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
-        resp.setContentType(CONTENT_TYPE);
-        try (PrintWriter writer = resp.getWriter()) {
-            writer.println(MessageFormat.format(pageContentTemplate, path, metricsUri, path, pingUri, path,
-                    threadsUri, path, healthcheckUri, path, cpuProfileUri,
-                    serviceName == null ? "" : " (" + serviceName + ")"));
-        }
+    this.pingEnabled =
+        Boolean.parseBoolean(getParam(context.getInitParameter(PING_ENABLED_PARAM_KEY), "true"));
+    if (this.pingEnabled) {
+      servletLinks.append(PING_LINK);
     }
+    this.pingServlet = new PingServlet();
+    pingServlet.init(config);
 
-    @Override
-    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
-        final String uri = req.getPathInfo();
-        if (uri == null || uri.equals("/")) {
-            super.service(req, resp);
-        } else if (uri.equals(healthcheckUri)) {
-            if (healthcheckEnabled) {
-                healthCheckServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else if (uri.startsWith(metricsUri)) {
-            if (metricsEnabled) {
-                metricsServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else if (uri.equals(pingUri)) {
-            if (pingEnabled) {
-                pingServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else if (uri.equals(threadsUri)) {
-            if (threadsEnabled) {
-                threadDumpServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else if (uri.equals(cpuProfileUri)) {
-            if (cpuProfileEnabled) {
-                cpuProfileServlet.service(req, resp);
-            } else {
-                resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-            }
-        } else {
-            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
-        }
+    this.threadsEnabled =
+        Boolean.parseBoolean(getParam(context.getInitParameter(THREADS_ENABLED_PARAM_KEY), "true"));
+    if (this.threadsEnabled) {
+      servletLinks.append(THREADS_LINK);
     }
-
-    private static String getParam(String initParam, String defaultValue) {
-        return initParam == null ? defaultValue : initParam;
+    this.threadDumpServlet = new ThreadDumpServlet();
+    threadDumpServlet.init(config);
+
+    this.healthcheckEnabled =
+        Boolean.parseBoolean(
+            getParam(context.getInitParameter(HEALTHCHECK_ENABLED_PARAM_KEY), "true"));
+    if (this.healthcheckEnabled) {
+      servletLinks.append(HEALTHCHECK_LINK);
+    }
+    this.healthCheckServlet = new HealthCheckServlet();
+    healthCheckServlet.init(config);
+
+    this.cpuProfileEnabled =
+        Boolean.parseBoolean(
+            getParam(context.getInitParameter(CPU_PROFILE_ENABLED_PARAM_KEY), "true"));
+    if (this.cpuProfileEnabled) {
+      servletLinks.append(CPU_PROFILE_LINK);
+    }
+    this.cpuProfileServlet = new CpuProfileServlet();
+    cpuProfileServlet.init(config);
+
+    pageContentTemplate = String.format(BASE_TEMPLATE, String.format(servletLinks.toString()));
+
+    this.metricsUri =
+        getParam(context.getInitParameter(METRICS_URI_PARAM_KEY), DEFAULT_METRICS_URI);
+    this.pingUri = getParam(context.getInitParameter(PING_URI_PARAM_KEY), DEFAULT_PING_URI);
+    this.threadsUri =
+        getParam(context.getInitParameter(THREADS_URI_PARAM_KEY), DEFAULT_THREADS_URI);
+    this.healthcheckUri =
+        getParam(context.getInitParameter(HEALTHCHECK_URI_PARAM_KEY), DEFAULT_HEALTHCHECK_URI);
+    this.cpuProfileUri =
+        getParam(context.getInitParameter(CPU_PROFILE_URI_PARAM_KEY), DEFAULT_CPU_PROFILE_URI);
+    this.serviceName = getParam(context.getInitParameter(SERVICE_NAME_PARAM_KEY), null);
+  }
+
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    final String path = req.getContextPath() + req.getServletPath();
+
+    resp.setStatus(HttpServletResponse.SC_OK);
+    resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
+    resp.setContentType(CONTENT_TYPE);
+    try (PrintWriter writer = resp.getWriter()) {
+      writer.println(
+          MessageFormat.format(
+              pageContentTemplate,
+              path,
+              metricsUri,
+              path,
+              pingUri,
+              path,
+              threadsUri,
+              path,
+              healthcheckUri,
+              path,
+              cpuProfileUri,
+              serviceName == null ? "" : " (" + serviceName + ")"));
     }
+  }
+
+  @Override
+  protected void service(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    final String uri = req.getPathInfo();
+    if (uri == null || uri.equals("/")) {
+      super.service(req, resp);
+    } else if (uri.equals(healthcheckUri)) {
+      if (healthcheckEnabled) {
+        healthCheckServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else if (uri.startsWith(metricsUri)) {
+      if (metricsEnabled) {
+        metricsServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else if (uri.equals(pingUri)) {
+      if (pingEnabled) {
+        pingServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else if (uri.equals(threadsUri)) {
+      if (threadsEnabled) {
+        threadDumpServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else if (uri.equals(cpuProfileUri)) {
+      if (cpuProfileEnabled) {
+        cpuProfileServlet.service(req, resp);
+      } else {
+        resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+      }
+    } else {
+      resp.sendError(HttpServletResponse.SC_NOT_FOUND);
+    }
+  }
+
+  private static String getParam(String initParam, String defaultValue) {
+    return initParam == null ? defaultValue : initParam;
+  }
 }
--- a/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/CpuProfileServlet.java
+++ b/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/CpuProfileServlet.java
@@ -1,5 +1,6 @@
 package io.dropwizard.metrics5.servlets;
 
+import com.papertrail.profiler.CpuProfile;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.time.Duration;
@@ -10,70 +11,69 @@ import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import com.papertrail.profiler.CpuProfile;
-
 /**
- * An HTTP servlets which outputs a <a href="https://github.com/gperftools/gperftools">pprof</a> parseable response.
+ * An HTTP servlets which outputs a <a href="https://github.com/gperftools/gperftools">pprof</a>
+ * parseable response.
  */
 public class CpuProfileServlet extends HttpServlet {
-    private static final long serialVersionUID = -668666696530287501L;
-    private static final String CONTENT_TYPE = "pprof/raw";
-    private static final String CACHE_CONTROL = "Cache-Control";
-    private static final String NO_CACHE = "must-revalidate,no-cache,no-store";
-    private final Lock lock = new ReentrantLock();
+  private static final long serialVersionUID = -668666696530287501L;
+  private static final String CONTENT_TYPE = "pprof/raw";
+  private static final String CACHE_CONTROL = "Cache-Control";
+  private static final String NO_CACHE = "must-revalidate,no-cache,no-store";
+  private final Lock lock = new ReentrantLock();
 
-    @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
 
-        int duration = 10;
-        if (req.getParameter("duration") != null) {
-            try {
-                duration = Integer.parseInt(req.getParameter("duration"));
-            } catch (NumberFormatException e) {
-                duration = 10;
-            }
-        }
+    int duration = 10;
+    if (req.getParameter("duration") != null) {
+      try {
+        duration = Integer.parseInt(req.getParameter("duration"));
+      } catch (NumberFormatException e) {
+        duration = 10;
+      }
+    }
 
-        int frequency = 100;
-        if (req.getParameter("frequency") != null) {
-            try {
-                frequency = Integer.parseInt(req.getParameter("frequency"));
-                frequency = Math.min(Math.max(frequency, 1), 1000);
-            } catch (NumberFormatException e) {
-                frequency = 100;
-            }
-        }
+    int frequency = 100;
+    if (req.getParameter("frequency") != null) {
+      try {
+        frequency = Integer.parseInt(req.getParameter("frequency"));
+        frequency = Math.min(Math.max(frequency, 1), 1000);
+      } catch (NumberFormatException e) {
+        frequency = 100;
+      }
+    }
 
-        final Thread.State state;
-        if ("blocked".equalsIgnoreCase(req.getParameter("state"))) {
-            state = Thread.State.BLOCKED;
-        } else {
-            state = Thread.State.RUNNABLE;
-        }
+    final Thread.State state;
+    if ("blocked".equalsIgnoreCase(req.getParameter("state"))) {
+      state = Thread.State.BLOCKED;
+    } else {
+      state = Thread.State.RUNNABLE;
+    }
 
-        resp.setStatus(HttpServletResponse.SC_OK);
-        resp.setHeader(CACHE_CONTROL, NO_CACHE);
-        resp.setContentType(CONTENT_TYPE);
-        try (OutputStream output = resp.getOutputStream()) {
-            doProfile(output, duration, frequency, state);
-        }
+    resp.setStatus(HttpServletResponse.SC_OK);
+    resp.setHeader(CACHE_CONTROL, NO_CACHE);
+    resp.setContentType(CONTENT_TYPE);
+    try (OutputStream output = resp.getOutputStream()) {
+      doProfile(output, duration, frequency, state);
     }
+  }
 
-    protected void doProfile(OutputStream out, int duration, int frequency, Thread.State state) throws IOException {
-        if (lock.tryLock()) {
-            try {
-                CpuProfile profile = CpuProfile.record(Duration.ofSeconds(duration),
-                        frequency, state);
-                if (profile == null) {
-                    throw new RuntimeException("could not create CpuProfile");
-                }
-                profile.writeGoogleProfile(out);
-                return;
-            } finally {
-                lock.unlock();
-            }
+  protected void doProfile(OutputStream out, int duration, int frequency, Thread.State state)
+      throws IOException {
+    if (lock.tryLock()) {
+      try {
+        CpuProfile profile = CpuProfile.record(Duration.ofSeconds(duration), frequency, state);
+        if (profile == null) {
+          throw new RuntimeException("could not create CpuProfile");
         }
-        throw new RuntimeException("Only one profile request may be active at a time");
+        profile.writeGoogleProfile(out);
+        return;
+      } finally {
+        lock.unlock();
+      }
     }
+    throw new RuntimeException("Only one profile request may be active at a time");
+  }
 }
--- a/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/HealthCheckServlet.java
+++ b/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/HealthCheckServlet.java
@@ -6,7 +6,11 @@ import io.dropwizard.metrics5.health.HealthCheck;
 import io.dropwizard.metrics5.health.HealthCheckFilter;
 import io.dropwizard.metrics5.health.HealthCheckRegistry;
 import io.dropwizard.metrics5.json.HealthCheckModule;
-
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Map;
+import java.util.SortedMap;
+import java.util.concurrent.ExecutorService;
 import javax.servlet.ServletConfig;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletContextEvent;
@@ -15,181 +19,181 @@ import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.concurrent.ExecutorService;
 
 public class HealthCheckServlet extends HttpServlet {
-    public static abstract class ContextListener implements ServletContextListener {
-        /**
-         * @return the {@link HealthCheckRegistry} to inject into the servlet context.
-         */
-        protected abstract HealthCheckRegistry getHealthCheckRegistry();
-
-        /**
-         * @return the {@link ExecutorService} to inject into the servlet context, or {@code null}
-         * if the health checks should be run in the servlet worker thread.
-         */
-        protected ExecutorService getExecutorService() {
-            // don't use a thread pool by default
-            return null;
-        }
-
-        /**
-         * @return the {@link HealthCheckFilter} that shall be used to filter health checks,
-         * or {@link HealthCheckFilter#ALL} if the default should be used.
-         */
-        protected HealthCheckFilter getHealthCheckFilter() {
-            return HealthCheckFilter.ALL;
-        }
-
-        /**
-         * @return the {@link ObjectMapper} that shall be used to render health checks,
-         * or {@code null} if the default object mapper should be used.
-         */
-        protected ObjectMapper getObjectMapper() {
-            // don't use an object mapper by default
-            return null;
-        }
-
-        @Override
-        public void contextInitialized(ServletContextEvent event) {
-            final ServletContext context = event.getServletContext();
-            context.setAttribute(HEALTH_CHECK_REGISTRY, getHealthCheckRegistry());
-            context.setAttribute(HEALTH_CHECK_EXECUTOR, getExecutorService());
-            context.setAttribute(HEALTH_CHECK_MAPPER, getObjectMapper());
-        }
-
-        @Override
-        public void contextDestroyed(ServletContextEvent event) {
-            // no-op
-        }
-    }
-
-    public static final String HEALTH_CHECK_REGISTRY = HealthCheckServlet.class.getCanonicalName() + ".registry";
-    public static final String HEALTH_CHECK_EXECUTOR = HealthCheckServlet.class.getCanonicalName() + ".executor";
-    public static final String HEALTH_CHECK_FILTER = HealthCheckServlet.class.getCanonicalName() + ".healthCheckFilter";
-    public static final String HEALTH_CHECK_MAPPER = HealthCheckServlet.class.getCanonicalName() + ".mapper";
-    public static final String HEALTH_CHECK_HTTP_STATUS_INDICATOR = HealthCheckServlet.class.getCanonicalName() + ".httpStatusIndicator";
-
-    private static final long serialVersionUID = -8432996484889177321L;
-    private static final String CONTENT_TYPE = "application/json";
-    private static final String HTTP_STATUS_INDICATOR_PARAM = "httpStatusIndicator";
-
-    private transient HealthCheckRegistry registry;
-    private transient ExecutorService executorService;
-    private transient HealthCheckFilter filter;
-    private transient ObjectMapper mapper;
-    private transient boolean httpStatusIndicator;
-
-    public HealthCheckServlet() {
-    }
-
-    public HealthCheckServlet(HealthCheckRegistry registry) {
-        this.registry = registry;
+  public abstract static class ContextListener implements ServletContextListener {
+    /**
+     * @return the {@link HealthCheckRegistry} to inject into the servlet context.
+     */
+    protected abstract HealthCheckRegistry getHealthCheckRegistry();
+
+    /**
+     * @return the {@link ExecutorService} to inject into the servlet context, or {@code null} if
+     *     the health checks should be run in the servlet worker thread.
+     */
+    protected ExecutorService getExecutorService() {
+      // don't use a thread pool by default
+      return null;
     }
 
-    @Override
-    public void init(ServletConfig config) throws ServletException {
-        super.init(config);
-
-        final ServletContext context = config.getServletContext();
-        if (null == registry) {
-            final Object registryAttr = context.getAttribute(HEALTH_CHECK_REGISTRY);
-            if (registryAttr instanceof HealthCheckRegistry) {
-                this.registry = (HealthCheckRegistry) registryAttr;
-            } else {
-                throw new ServletException("Couldn't find a HealthCheckRegistry instance.");
-            }
-        }
-
-        final Object executorAttr = context.getAttribute(HEALTH_CHECK_EXECUTOR);
-        if (executorAttr instanceof ExecutorService) {
-            this.executorService = (ExecutorService) executorAttr;
-        }
-
-        final Object filterAttr = context.getAttribute(HEALTH_CHECK_FILTER);
-        if (filterAttr instanceof HealthCheckFilter) {
-            filter = (HealthCheckFilter) filterAttr;
-        }
-        if (filter == null) {
-            filter = HealthCheckFilter.ALL;
-        }
-
-        final Object mapperAttr = context.getAttribute(HEALTH_CHECK_MAPPER);
-        if (mapperAttr instanceof ObjectMapper) {
-            this.mapper = (ObjectMapper) mapperAttr;
-        } else {
-            this.mapper = new ObjectMapper();
-        }
-        this.mapper.registerModule(new HealthCheckModule());
-
-        final Object httpStatusIndicatorAttr = context.getAttribute(HEALTH_CHECK_HTTP_STATUS_INDICATOR);
-        if (httpStatusIndicatorAttr instanceof Boolean) {
-            this.httpStatusIndicator = (Boolean) httpStatusIndicatorAttr;
-        } else {
-            this.httpStatusIndicator = true;
-        }
+    /**
+     * @return the {@link HealthCheckFilter} that shall be used to filter health checks, or {@link
+     *     HealthCheckFilter#ALL} if the default should be used.
+     */
+    protected HealthCheckFilter getHealthCheckFilter() {
+      return HealthCheckFilter.ALL;
+    }
+
+    /**
+     * @return the {@link ObjectMapper} that shall be used to render health checks, or {@code null}
+     *     if the default object mapper should be used.
+     */
+    protected ObjectMapper getObjectMapper() {
+      // don't use an object mapper by default
+      return null;
     }
 
     @Override
-    public void destroy() {
-        super.destroy();
-        registry.shutdown();
+    public void contextInitialized(ServletContextEvent event) {
+      final ServletContext context = event.getServletContext();
+      context.setAttribute(HEALTH_CHECK_REGISTRY, getHealthCheckRegistry());
+      context.setAttribute(HEALTH_CHECK_EXECUTOR, getExecutorService());
+      context.setAttribute(HEALTH_CHECK_MAPPER, getObjectMapper());
     }
 
     @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
-        final SortedMap<String, HealthCheck.Result> results = runHealthChecks();
-        resp.setContentType(CONTENT_TYPE);
-        resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
-        if (results.isEmpty()) {
-            resp.setStatus(HttpServletResponse.SC_NOT_IMPLEMENTED);
-        } else {
-            final String reqParameter = req.getParameter(HTTP_STATUS_INDICATOR_PARAM);
-            final boolean httpStatusIndicatorParam = Boolean.parseBoolean(reqParameter);
-            final boolean useHttpStatusForHealthCheck = reqParameter == null ? httpStatusIndicator : httpStatusIndicatorParam;
-            if (!useHttpStatusForHealthCheck || isAllHealthy(results)) {
-                resp.setStatus(HttpServletResponse.SC_OK);
-            } else {
-                resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
-            }
-        }
-
-        try (OutputStream output = resp.getOutputStream()) {
-            getWriter(req).writeValue(output, results);
-        }
-    }
-
-    private ObjectWriter getWriter(HttpServletRequest request) {
-        final boolean prettyPrint = Boolean.parseBoolean(request.getParameter("pretty"));
-        if (prettyPrint) {
-            return mapper.writerWithDefaultPrettyPrinter();
-        }
-        return mapper.writer();
-    }
-
-    private SortedMap<String, HealthCheck.Result> runHealthChecks() {
-        if (executorService == null) {
-            return registry.runHealthChecks(filter);
-        }
-        return registry.runHealthChecks(executorService, filter);
-    }
-
-    private static boolean isAllHealthy(Map<String, HealthCheck.Result> results) {
-        for (HealthCheck.Result result : results.values()) {
-            if (!result.isHealthy()) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // visible for testing
-    ObjectMapper getMapper() {
-        return mapper;
+    public void contextDestroyed(ServletContextEvent event) {
+      // no-op
+    }
+  }
+
+  public static final String HEALTH_CHECK_REGISTRY =
+      HealthCheckServlet.class.getCanonicalName() + ".registry";
+  public static final String HEALTH_CHECK_EXECUTOR =
+      HealthCheckServlet.class.getCanonicalName() + ".executor";
+  public static final String HEALTH_CHECK_FILTER =
+      HealthCheckServlet.class.getCanonicalName() + ".healthCheckFilter";
+  public static final String HEALTH_CHECK_MAPPER =
+      HealthCheckServlet.class.getCanonicalName() + ".mapper";
+  public static final String HEALTH_CHECK_HTTP_STATUS_INDICATOR =
+      HealthCheckServlet.class.getCanonicalName() + ".httpStatusIndicator";
+
+  private static final long serialVersionUID = -8432996484889177321L;
+  private static final String CONTENT_TYPE = "application/json";
+  private static final String HTTP_STATUS_INDICATOR_PARAM = "httpStatusIndicator";
+
+  private transient HealthCheckRegistry registry;
+  private transient ExecutorService executorService;
+  private transient HealthCheckFilter filter;
+  private transient ObjectMapper mapper;
+  private transient boolean httpStatusIndicator;
+
+  public HealthCheckServlet() {}
+
+  public HealthCheckServlet(HealthCheckRegistry registry) {
+    this.registry = registry;
+  }
+
+  @Override
+  public void init(ServletConfig config) throws ServletException {
+    super.init(config);
+
+    final ServletContext context = config.getServletContext();
+    if (registry == null) {
+      final Object registryAttr = context.getAttribute(HEALTH_CHECK_REGISTRY);
+      if (registryAttr instanceof HealthCheckRegistry) {
+        this.registry = (HealthCheckRegistry) registryAttr;
+      } else {
+        throw new ServletException("Couldn't find a HealthCheckRegistry instance.");
+      }
+    }
+
+    final Object executorAttr = context.getAttribute(HEALTH_CHECK_EXECUTOR);
+    if (executorAttr instanceof ExecutorService) {
+      this.executorService = (ExecutorService) executorAttr;
     }
+
+    final Object filterAttr = context.getAttribute(HEALTH_CHECK_FILTER);
+    if (filterAttr instanceof HealthCheckFilter) {
+      filter = (HealthCheckFilter) filterAttr;
+    }
+    if (filter == null) {
+      filter = HealthCheckFilter.ALL;
+    }
+
+    final Object mapperAttr = context.getAttribute(HEALTH_CHECK_MAPPER);
+    if (mapperAttr instanceof ObjectMapper) {
+      this.mapper = (ObjectMapper) mapperAttr;
+    } else {
+      this.mapper = new ObjectMapper();
+    }
+    this.mapper.registerModule(new HealthCheckModule());
+
+    final Object httpStatusIndicatorAttr = context.getAttribute(HEALTH_CHECK_HTTP_STATUS_INDICATOR);
+    if (httpStatusIndicatorAttr instanceof Boolean) {
+      this.httpStatusIndicator = (Boolean) httpStatusIndicatorAttr;
+    } else {
+      this.httpStatusIndicator = true;
+    }
+  }
+
+  @Override
+  public void destroy() {
+    super.destroy();
+    registry.shutdown();
+  }
+
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    final SortedMap<String, HealthCheck.Result> results = runHealthChecks();
+    resp.setContentType(CONTENT_TYPE);
+    resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
+    if (results.isEmpty()) {
+      resp.setStatus(HttpServletResponse.SC_NOT_IMPLEMENTED);
+    } else {
+      final String reqParameter = req.getParameter(HTTP_STATUS_INDICATOR_PARAM);
+      final boolean httpStatusIndicatorParam = Boolean.parseBoolean(reqParameter);
+      final boolean useHttpStatusForHealthCheck =
+          reqParameter == null ? httpStatusIndicator : httpStatusIndicatorParam;
+      if (!useHttpStatusForHealthCheck || isAllHealthy(results)) {
+        resp.setStatus(HttpServletResponse.SC_OK);
+      } else {
+        resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
+      }
+    }
+
+    try (OutputStream output = resp.getOutputStream()) {
+      getWriter(req).writeValue(output, results);
+    }
+  }
+
+  private ObjectWriter getWriter(HttpServletRequest request) {
+    final boolean prettyPrint = Boolean.parseBoolean(request.getParameter("pretty"));
+    if (prettyPrint) {
+      return mapper.writerWithDefaultPrettyPrinter();
+    }
+    return mapper.writer();
+  }
+
+  private SortedMap<String, HealthCheck.Result> runHealthChecks() {
+    if (executorService == null) {
+      return registry.runHealthChecks(filter);
+    }
+    return registry.runHealthChecks(executorService, filter);
+  }
+
+  private static boolean isAllHealthy(Map<String, HealthCheck.Result> results) {
+    for (HealthCheck.Result result : results.values()) {
+      if (!result.isHealthy()) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  // visible for testing
+  ObjectMapper getMapper() {
+    return mapper;
+  }
 }
--- a/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/MetricsServlet.java
+++ b/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/MetricsServlet.java
@@ -6,7 +6,10 @@ import com.fasterxml.jackson.databind.util.JSONPObject;
 import io.dropwizard.metrics5.MetricFilter;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.json.MetricsModule;
-
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Locale;
+import java.util.concurrent.TimeUnit;
 import javax.servlet.ServletConfig;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletContextEvent;
@@ -15,185 +18,182 @@ import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Locale;
-import java.util.concurrent.TimeUnit;
 
 /**
  * A servlet which returns the metrics in a given registry as an {@code application/json} response.
  */
 public class MetricsServlet extends HttpServlet {
+  /**
+   * An abstract {@link ServletContextListener} which allows you to programmatically inject the
+   * {@link MetricRegistry}, rate and duration units, and allowed origin for {@link MetricsServlet}.
+   */
+  public abstract static class ContextListener implements ServletContextListener {
     /**
-     * An abstract {@link ServletContextListener} which allows you to programmatically inject the
-     * {@link MetricRegistry}, rate and duration units, and allowed origin for
-     * {@link MetricsServlet}.
+     * @return the {@link MetricRegistry} to inject into the servlet context.
      */
-    public static abstract class ContextListener implements ServletContextListener {
-        /**
-         * @return the {@link MetricRegistry} to inject into the servlet context.
-         */
-        protected abstract MetricRegistry getMetricRegistry();
-
-        /**
-         * @return the {@link TimeUnit} to which rates should be converted, or {@code null} if the
-         * default should be used.
-         */
-        protected TimeUnit getRateUnit() {
-            // use the default
-            return null;
-        }
-
-        /**
-         * @return the {@link TimeUnit} to which durations should be converted, or {@code null} if
-         * the default should be used.
-         */
-        protected TimeUnit getDurationUnit() {
-            // use the default
-            return null;
-        }
-
-        /**
-         * @return the {@code Access-Control-Allow-Origin} header value, if any.
-         */
-        protected String getAllowedOrigin() {
-            // use the default
-            return null;
-        }
-
-        /**
-         * Returns the name of the parameter used to specify the jsonp callback, if any.
-         */
-        protected String getJsonpCallbackParameter() {
-            return null;
-        }
-
-        /**
-         * Returns the {@link MetricFilter} that shall be used to filter metrics, or {@link MetricFilter#ALL} if
-         * the default should be used.
-         */
-        protected MetricFilter getMetricFilter() {
-            // use the default
-            return MetricFilter.ALL;
-        }
-
-        @Override
-        public void contextInitialized(ServletContextEvent event) {
-            final ServletContext context = event.getServletContext();
-            context.setAttribute(METRICS_REGISTRY, getMetricRegistry());
-            context.setAttribute(METRIC_FILTER, getMetricFilter());
-            if (getDurationUnit() != null) {
-                context.setInitParameter(MetricsServlet.DURATION_UNIT, getDurationUnit().toString());
-            }
-            if (getRateUnit() != null) {
-                context.setInitParameter(MetricsServlet.RATE_UNIT, getRateUnit().toString());
-            }
-            if (getAllowedOrigin() != null) {
-                context.setInitParameter(MetricsServlet.ALLOWED_ORIGIN, getAllowedOrigin());
-            }
-            if (getJsonpCallbackParameter() != null) {
-                context.setAttribute(CALLBACK_PARAM, getJsonpCallbackParameter());
-            }
-        }
-
-        @Override
-        public void contextDestroyed(ServletContextEvent event) {
-            // no-op
-        }
-    }
-
-    public static final String RATE_UNIT = MetricsServlet.class.getCanonicalName() + ".rateUnit";
-    public static final String DURATION_UNIT = MetricsServlet.class.getCanonicalName() + ".durationUnit";
-    public static final String SHOW_SAMPLES = MetricsServlet.class.getCanonicalName() + ".showSamples";
-    public static final String METRICS_REGISTRY = MetricsServlet.class.getCanonicalName() + ".registry";
-    public static final String ALLOWED_ORIGIN = MetricsServlet.class.getCanonicalName() + ".allowedOrigin";
-    public static final String METRIC_FILTER = MetricsServlet.class.getCanonicalName() + ".metricFilter";
-    public static final String CALLBACK_PARAM = MetricsServlet.class.getCanonicalName() + ".jsonpCallback";
+    protected abstract MetricRegistry getMetricRegistry();
 
-    private static final long serialVersionUID = 1049773947734939602L;
-    private static final String CONTENT_TYPE = "application/json";
+    /**
+     * @return the {@link TimeUnit} to which rates should be converted, or {@code null} if the
+     *     default should be used.
+     */
+    protected TimeUnit getRateUnit() {
+      // use the default
+      return null;
+    }
 
-    protected String allowedOrigin;
-    protected String jsonpParamName;
-    protected transient MetricRegistry registry;
-    protected transient ObjectMapper mapper;
+    /**
+     * @return the {@link TimeUnit} to which durations should be converted, or {@code null} if the
+     *     default should be used.
+     */
+    protected TimeUnit getDurationUnit() {
+      // use the default
+      return null;
+    }
 
-    public MetricsServlet() {
+    /**
+     * @return the {@code Access-Control-Allow-Origin} header value, if any.
+     */
+    protected String getAllowedOrigin() {
+      // use the default
+      return null;
     }
 
-    public MetricsServlet(MetricRegistry registry) {
-        this.registry = registry;
+    /** Returns the name of the parameter used to specify the jsonp callback, if any. */
+    protected String getJsonpCallbackParameter() {
+      return null;
     }
 
-    @Override
-    public void init(ServletConfig config) throws ServletException {
-        super.init(config);
-
-        final ServletContext context = config.getServletContext();
-        if (null == registry) {
-            final Object registryAttr = context.getAttribute(METRICS_REGISTRY);
-            if (registryAttr instanceof MetricRegistry) {
-                this.registry = (MetricRegistry) registryAttr;
-            } else {
-                throw new ServletException("Couldn't find a MetricRegistry instance.");
-            }
-        }
-        this.allowedOrigin = context.getInitParameter(ALLOWED_ORIGIN);
-        this.jsonpParamName = context.getInitParameter(CALLBACK_PARAM);
-
-        setupMetricsModule(context);
+    /**
+     * Returns the {@link MetricFilter} that shall be used to filter metrics, or {@link
+     * MetricFilter#ALL} if the default should be used.
+     */
+    protected MetricFilter getMetricFilter() {
+      // use the default
+      return MetricFilter.ALL;
     }
 
-    protected void setupMetricsModule(ServletContext context) {
-        final TimeUnit rateUnit = parseTimeUnit(context.getInitParameter(RATE_UNIT),
-                TimeUnit.SECONDS);
-        final TimeUnit durationUnit = parseTimeUnit(context.getInitParameter(DURATION_UNIT),
-                TimeUnit.SECONDS);
-        final boolean showSamples = Boolean.parseBoolean(context.getInitParameter(SHOW_SAMPLES));
-        MetricFilter filter = (MetricFilter) context.getAttribute(METRIC_FILTER);
-        if (filter == null) {
-            filter = MetricFilter.ALL;
-        }
-
-        this.mapper = new ObjectMapper().registerModule(new MetricsModule(rateUnit,
-                durationUnit,
-                showSamples,
-                filter));
+    @Override
+    public void contextInitialized(ServletContextEvent event) {
+      final ServletContext context = event.getServletContext();
+      context.setAttribute(METRICS_REGISTRY, getMetricRegistry());
+      context.setAttribute(METRIC_FILTER, getMetricFilter());
+      if (getDurationUnit() != null) {
+        context.setInitParameter(MetricsServlet.DURATION_UNIT, getDurationUnit().toString());
+      }
+      if (getRateUnit() != null) {
+        context.setInitParameter(MetricsServlet.RATE_UNIT, getRateUnit().toString());
+      }
+      if (getAllowedOrigin() != null) {
+        context.setInitParameter(MetricsServlet.ALLOWED_ORIGIN, getAllowedOrigin());
+      }
+      if (getJsonpCallbackParameter() != null) {
+        context.setAttribute(CALLBACK_PARAM, getJsonpCallbackParameter());
+      }
     }
 
     @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
-        resp.setContentType(CONTENT_TYPE);
-        if (allowedOrigin != null) {
-            resp.setHeader("Access-Control-Allow-Origin", allowedOrigin);
-        }
-        resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
-        resp.setStatus(HttpServletResponse.SC_OK);
-
-        try (OutputStream output = resp.getOutputStream()) {
-            if (jsonpParamName != null && req.getParameter(jsonpParamName) != null) {
-                getWriter(req).writeValue(output, new JSONPObject(req.getParameter(jsonpParamName), registry));
-            } else {
-                getWriter(req).writeValue(output, registry);
-            }
-        }
+    public void contextDestroyed(ServletContextEvent event) {
+      // no-op
+    }
+  }
+
+  public static final String RATE_UNIT = MetricsServlet.class.getCanonicalName() + ".rateUnit";
+  public static final String DURATION_UNIT =
+      MetricsServlet.class.getCanonicalName() + ".durationUnit";
+  public static final String SHOW_SAMPLES =
+      MetricsServlet.class.getCanonicalName() + ".showSamples";
+  public static final String METRICS_REGISTRY =
+      MetricsServlet.class.getCanonicalName() + ".registry";
+  public static final String ALLOWED_ORIGIN =
+      MetricsServlet.class.getCanonicalName() + ".allowedOrigin";
+  public static final String METRIC_FILTER =
+      MetricsServlet.class.getCanonicalName() + ".metricFilter";
+  public static final String CALLBACK_PARAM =
+      MetricsServlet.class.getCanonicalName() + ".jsonpCallback";
+
+  private static final long serialVersionUID = 1049773947734939602L;
+  private static final String CONTENT_TYPE = "application/json";
+
+  protected String allowedOrigin;
+  protected String jsonpParamName;
+  protected transient MetricRegistry registry;
+  protected transient ObjectMapper mapper;
+
+  public MetricsServlet() {}
+
+  public MetricsServlet(MetricRegistry registry) {
+    this.registry = registry;
+  }
+
+  @Override
+  public void init(ServletConfig config) throws ServletException {
+    super.init(config);
+
+    final ServletContext context = config.getServletContext();
+    if (registry == null) {
+      final Object registryAttr = context.getAttribute(METRICS_REGISTRY);
+      if (registryAttr instanceof MetricRegistry) {
+        this.registry = (MetricRegistry) registryAttr;
+      } else {
+        throw new ServletException("Couldn't find a MetricRegistry instance.");
+      }
+    }
+    this.allowedOrigin = context.getInitParameter(ALLOWED_ORIGIN);
+    this.jsonpParamName = context.getInitParameter(CALLBACK_PARAM);
+
+    setupMetricsModule(context);
+  }
+
+  protected void setupMetricsModule(ServletContext context) {
+    final TimeUnit rateUnit = parseTimeUnit(context.getInitParameter(RATE_UNIT), TimeUnit.SECONDS);
+    final TimeUnit durationUnit =
+        parseTimeUnit(context.getInitParameter(DURATION_UNIT), TimeUnit.SECONDS);
+    final boolean showSamples = Boolean.parseBoolean(context.getInitParameter(SHOW_SAMPLES));
+    MetricFilter filter = (MetricFilter) context.getAttribute(METRIC_FILTER);
+    if (filter == null) {
+      filter = MetricFilter.ALL;
     }
 
-    protected ObjectWriter getWriter(HttpServletRequest request) {
-        final boolean prettyPrint = Boolean.parseBoolean(request.getParameter("pretty"));
-        if (prettyPrint) {
-            return mapper.writerWithDefaultPrettyPrinter();
-        }
-        return mapper.writer();
+    this.mapper =
+        new ObjectMapper()
+            .registerModule(new MetricsModule(rateUnit, durationUnit, showSamples, filter));
+  }
+
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    resp.setContentType(CONTENT_TYPE);
+    if (allowedOrigin != null) {
+      resp.setHeader("Access-Control-Allow-Origin", allowedOrigin);
+    }
+    resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
+    resp.setStatus(HttpServletResponse.SC_OK);
+
+    try (OutputStream output = resp.getOutputStream()) {
+      if (jsonpParamName != null && req.getParameter(jsonpParamName) != null) {
+        getWriter(req)
+            .writeValue(output, new JSONPObject(req.getParameter(jsonpParamName), registry));
+      } else {
+        getWriter(req).writeValue(output, registry);
+      }
     }
+  }
 
-    @SuppressWarnings("IdentityConversion")
-    protected TimeUnit parseTimeUnit(String value, TimeUnit defaultValue) {
-        try {
-            return TimeUnit.valueOf(String.valueOf(value).toUpperCase(Locale.US));
-        } catch (IllegalArgumentException e) {
-            return defaultValue;
-        }
+  protected ObjectWriter getWriter(HttpServletRequest request) {
+    final boolean prettyPrint = Boolean.parseBoolean(request.getParameter("pretty"));
+    if (prettyPrint) {
+      return mapper.writerWithDefaultPrettyPrinter();
+    }
+    return mapper.writer();
+  }
+
+  @SuppressWarnings("IdentityConversion")
+  protected TimeUnit parseTimeUnit(String value, TimeUnit defaultValue) {
+    try {
+      return TimeUnit.valueOf(String.valueOf(value).toUpperCase(Locale.US));
+    } catch (IllegalArgumentException e) {
+      return defaultValue;
     }
+  }
 }
--- a/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/PingServlet.java
+++ b/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/PingServlet.java
@@ -1,30 +1,28 @@
 package io.dropwizard.metrics5.servlets;
 
+import java.io.IOException;
+import java.io.PrintWriter;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.PrintWriter;
 
-/**
- * An HTTP servlets which outputs a {@code text/plain} {@code "pong"} response.
- */
+/** An HTTP servlets which outputs a {@code text/plain} {@code "pong"} response. */
 public class PingServlet extends HttpServlet {
-    private static final long serialVersionUID = 3772654177231086757L;
-    private static final String CONTENT_TYPE = "text/plain";
-    private static final String CONTENT = "pong";
-    private static final String CACHE_CONTROL = "Cache-Control";
-    private static final String NO_CACHE = "must-revalidate,no-cache,no-store";
+  private static final long serialVersionUID = 3772654177231086757L;
+  private static final String CONTENT_TYPE = "text/plain";
+  private static final String CONTENT = "pong";
+  private static final String CACHE_CONTROL = "Cache-Control";
+  private static final String NO_CACHE = "must-revalidate,no-cache,no-store";
 
-    @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
-        resp.setStatus(HttpServletResponse.SC_OK);
-        resp.setHeader(CACHE_CONTROL, NO_CACHE);
-        resp.setContentType(CONTENT_TYPE);
-        try (PrintWriter writer = resp.getWriter()) {
-            writer.println(CONTENT);
-        }
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    resp.setStatus(HttpServletResponse.SC_OK);
+    resp.setHeader(CACHE_CONTROL, NO_CACHE);
+    resp.setContentType(CONTENT_TYPE);
+    try (PrintWriter writer = resp.getWriter()) {
+      writer.println(CONTENT);
     }
+  }
 }
--- a/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/ThreadDumpServlet.java
+++ b/metrics-servlets/src/main/java/io/dropwizard/metrics5/servlets/ThreadDumpServlet.java
@@ -1,55 +1,54 @@
 package io.dropwizard.metrics5.servlets;
 
 import io.dropwizard.metrics5.jvm.ThreadDump;
-
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.management.ManagementFactory;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.lang.management.ManagementFactory;
 
 /**
- * An HTTP servlets which outputs a {@code text/plain} dump of all threads in
- * the VM. Only responds to {@code GET} requests.
+ * An HTTP servlets which outputs a {@code text/plain} dump of all threads in the VM. Only responds
+ * to {@code GET} requests.
  */
 public class ThreadDumpServlet extends HttpServlet {
 
-    private static final long serialVersionUID = -2690343532336103046L;
-    private static final String CONTENT_TYPE = "text/plain";
+  private static final long serialVersionUID = -2690343532336103046L;
+  private static final String CONTENT_TYPE = "text/plain";
 
-    private transient ThreadDump threadDump;
+  private transient ThreadDump threadDump;
 
-    @Override
-    public void init() throws ServletException {
-        try {
-            // Some PaaS like Google App Engine blacklist java.lang.managament
-            this.threadDump = new ThreadDump(ManagementFactory.getThreadMXBean());
-        } catch (NoClassDefFoundError ncdfe) {
-            this.threadDump = null; // we won't be able to provide thread dump
-        }
+  @Override
+  public void init() throws ServletException {
+    try {
+      // Some PaaS like Google App Engine blacklist java.lang.managament
+      this.threadDump = new ThreadDump(ManagementFactory.getThreadMXBean());
+    } catch (NoClassDefFoundError ncdfe) {
+      this.threadDump = null; // we won't be able to provide thread dump
     }
-
-    @Override
-    protected void doGet(HttpServletRequest req,
-                         HttpServletResponse resp) throws ServletException, IOException {
-        final boolean includeMonitors = getParam(req.getParameter("monitors"), true);
-        final boolean includeSynchronizers = getParam(req.getParameter("synchronizers"), true);
-
-        resp.setStatus(HttpServletResponse.SC_OK);
-        resp.setContentType(CONTENT_TYPE);
-        resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
-        if (threadDump == null) {
-            resp.getWriter().println("Sorry your runtime environment does not allow to dump threads.");
-            return;
-        }
-        try (OutputStream output = resp.getOutputStream()) {
-            threadDump.dump(includeMonitors, includeSynchronizers, output);
-        }
+  }
+
+  @Override
+  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+      throws ServletException, IOException {
+    final boolean includeMonitors = getParam(req.getParameter("monitors"), true);
+    final boolean includeSynchronizers = getParam(req.getParameter("synchronizers"), true);
+
+    resp.setStatus(HttpServletResponse.SC_OK);
+    resp.setContentType(CONTENT_TYPE);
+    resp.setHeader("Cache-Control", "must-revalidate,no-cache,no-store");
+    if (threadDump == null) {
+      resp.getWriter().println("Sorry your runtime environment does not allow to dump threads.");
+      return;
     }
-
-    private static Boolean getParam(String initParam, boolean defaultValue) {
-        return initParam == null ? defaultValue : Boolean.parseBoolean(initParam);
+    try (OutputStream output = resp.getOutputStream()) {
+      threadDump.dump(includeMonitors, includeSynchronizers, output);
     }
+  }
+
+  private static Boolean getParam(String initParam, boolean defaultValue) {
+    return initParam == null ? defaultValue : Boolean.parseBoolean(initParam);
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/AbstractServletTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/AbstractServletTest.java
@@ -6,24 +6,24 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 
 public abstract class AbstractServletTest {
-    private final ServletTester tester = new ServletTester();
-    protected final HttpTester.Request request = HttpTester.newRequest();
-    protected HttpTester.Response response;
+  private final ServletTester tester = new ServletTester();
+  protected final HttpTester.Request request = HttpTester.newRequest();
+  protected HttpTester.Response response;
 
-    @BeforeEach
-    public void setUpTester() throws Exception {
-        setUp(tester);
-        tester.start();
-    }
+  @BeforeEach
+  public void setUpTester() throws Exception {
+    setUp(tester);
+    tester.start();
+  }
 
-    protected abstract void setUp(ServletTester tester);
+  protected abstract void setUp(ServletTester tester);
 
-    @AfterEach
-    public void tearDownTester() throws Exception {
-        tester.stop();
-    }
+  @AfterEach
+  public void tearDownTester() throws Exception {
+    tester.stop();
+  }
 
-    protected void processRequest() throws Exception {
-        this.response = HttpTester.parseResponse(tester.getResponses(request.generate()));
-    }
+  protected void processRequest() throws Exception {
+    this.response = HttpTester.parseResponse(tester.getResponses(request.generate()));
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletTest.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.health.HealthCheckRegistry;
 import org.eclipse.jetty.http.HttpHeader;
@@ -7,56 +9,53 @@ import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class AdminServletTest extends AbstractServletTest {
-    private final MetricRegistry registry = new MetricRegistry();
-    private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.setContextPath("/context");
-
-        tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
-        tester.setAttribute("io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
-        tester.addServlet(AdminServlet.class, "/admin");
-    }
-
-    @BeforeEach
-    void setUp() {
-        request.setMethod("GET");
-        request.setURI("/context/admin");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.getContent())
-                .isEqualTo(String.format(
-                        "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n" +
-                                "        \"http://www.w3.org/TR/html4/loose.dtd\">%n" +
-                                "<html>%n" +
-                                "<head>%n" +
-                                "  <title>Metrics</title>%n" +
-                                "</head>%n" +
-                                "<body>%n" +
-                                "  <h1>Operational Menu</h1>%n" +
-                                "  <ul>%n" +
-                                "    <li><a href=\"/context/admin/metrics?pretty=true\">Metrics</a></li>%n" +
-                                "    <li><a href=\"/context/admin/ping\">Ping</a></li>%n" +
-                                "    <li><a href=\"/context/admin/threads\">Threads</a></li>%n" +
-                                "    <li><a href=\"/context/admin/healthcheck?pretty=true\">Healthcheck</a></li>%n" +
-                                "    <li><a href=\"/context/admin/pprof\">CPU Profile</a></li>%n" +
-                                "    <li><a href=\"/context/admin/pprof?state=blocked\">CPU Contention</a></li>%n" +
-                                "  </ul>%n" +
-                                "</body>%n" +
-                                "</html>%n"
-                ));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/html;charset=UTF-8");
-    }
+final class AdminServletTest extends AbstractServletTest {
+  private final MetricRegistry registry = new MetricRegistry();
+  private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.setContextPath("/context");
+
+    tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
+    tester.setAttribute(
+        "io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
+    tester.addServlet(AdminServlet.class, "/admin");
+  }
+
+  @BeforeEach
+  void setUp() {
+    request.setMethod("GET");
+    request.setURI("/context/admin");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n"
+                    + "        \"http://www.w3.org/TR/html4/loose.dtd\">%n"
+                    + "<html>%n"
+                    + "<head>%n"
+                    + "  <title>Metrics</title>%n"
+                    + "</head>%n"
+                    + "<body>%n"
+                    + "  <h1>Operational Menu</h1>%n"
+                    + "  <ul>%n"
+                    + "    <li><a href=\"/context/admin/metrics?pretty=true\">Metrics</a></li>%n"
+                    + "    <li><a href=\"/context/admin/ping\">Ping</a></li>%n"
+                    + "    <li><a href=\"/context/admin/threads\">Threads</a></li>%n"
+                    + "    <li><a href=\"/context/admin/healthcheck?pretty=true\">Healthcheck</a></li>%n"
+                    + "    <li><a href=\"/context/admin/pprof\">CPU Profile</a></li>%n"
+                    + "    <li><a href=\"/context/admin/pprof?state=blocked\">CPU Contention</a></li>%n"
+                    + "  </ul>%n"
+                    + "</body>%n"
+                    + "</html>%n"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/html;charset=UTF-8");
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletUriTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/AdminServletUriTest.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.health.HealthCheckRegistry;
 import org.eclipse.jetty.http.HttpHeader;
@@ -7,61 +9,58 @@ import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class AdminServletUriTest extends AbstractServletTest {
-    private final MetricRegistry registry = new MetricRegistry();
-    private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
+final class AdminServletUriTest extends AbstractServletTest {
+  private final MetricRegistry registry = new MetricRegistry();
+  private final HealthCheckRegistry healthCheckRegistry = new HealthCheckRegistry();
 
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.setContextPath("/context");
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.setContextPath("/context");
 
-        tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
-        tester.setAttribute("io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
-        tester.setInitParameter("metrics-uri", "/metrics-test");
-        tester.setInitParameter("ping-uri", "/ping-test");
-        tester.setInitParameter("threads-uri", "/threads-test");
-        tester.setInitParameter("healthcheck-uri", "/healthcheck-test");
-        tester.setInitParameter("cpu-profile-uri", "/pprof-test");
-        tester.addServlet(AdminServlet.class, "/admin");
-    }
+    tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
+    tester.setAttribute(
+        "io.dropwizard.metrics5.servlets.HealthCheckServlet.registry", healthCheckRegistry);
+    tester.setInitParameter("metrics-uri", "/metrics-test");
+    tester.setInitParameter("ping-uri", "/ping-test");
+    tester.setInitParameter("threads-uri", "/threads-test");
+    tester.setInitParameter("healthcheck-uri", "/healthcheck-test");
+    tester.setInitParameter("cpu-profile-uri", "/pprof-test");
+    tester.addServlet(AdminServlet.class, "/admin");
+  }
 
-    @BeforeEach
-    void setUp() {
-        request.setMethod("GET");
-        request.setURI("/context/admin");
-        request.setVersion("HTTP/1.0");
-    }
+  @BeforeEach
+  void setUp() {
+    request.setMethod("GET");
+    request.setURI("/context/admin");
+    request.setVersion("HTTP/1.0");
+  }
 
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
 
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.getContent())
-                .isEqualTo(String.format(
-                        "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n" +
-                                "        \"http://www.w3.org/TR/html4/loose.dtd\">%n" +
-                                "<html>%n" +
-                                "<head>%n" +
-                                "  <title>Metrics</title>%n" +
-                                "</head>%n" +
-                                "<body>%n" +
-                                "  <h1>Operational Menu</h1>%n" +
-                                "  <ul>%n" +
-                                "    <li><a href=\"/context/admin/metrics-test?pretty=true\">Metrics</a></li>%n" +
-                                "    <li><a href=\"/context/admin/ping-test\">Ping</a></li>%n" +
-                                "    <li><a href=\"/context/admin/threads-test\">Threads</a></li>%n" +
-                                "    <li><a href=\"/context/admin/healthcheck-test?pretty=true\">Healthcheck</a></li>%n" +
-                                "    <li><a href=\"/context/admin/pprof-test\">CPU Profile</a></li>%n" +
-                                "    <li><a href=\"/context/admin/pprof-test?state=blocked\">CPU Contention</a></li>%n" +
-                                "  </ul>%n" +
-                                "</body>%n" +
-                                "</html>%n"
-                ));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/html;charset=UTF-8");
-    }
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"%n"
+                    + "        \"http://www.w3.org/TR/html4/loose.dtd\">%n"
+                    + "<html>%n"
+                    + "<head>%n"
+                    + "  <title>Metrics</title>%n"
+                    + "</head>%n"
+                    + "<body>%n"
+                    + "  <h1>Operational Menu</h1>%n"
+                    + "  <ul>%n"
+                    + "    <li><a href=\"/context/admin/metrics-test?pretty=true\">Metrics</a></li>%n"
+                    + "    <li><a href=\"/context/admin/ping-test\">Ping</a></li>%n"
+                    + "    <li><a href=\"/context/admin/threads-test\">Threads</a></li>%n"
+                    + "    <li><a href=\"/context/admin/healthcheck-test?pretty=true\">Healthcheck</a></li>%n"
+                    + "    <li><a href=\"/context/admin/pprof-test\">CPU Profile</a></li>%n"
+                    + "    <li><a href=\"/context/admin/pprof-test?state=blocked\">CPU Contention</a></li>%n"
+                    + "  </ul>%n"
+                    + "</body>%n"
+                    + "</html>%n"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/html;charset=UTF-8");
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/CpuProfileServletTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/CpuProfileServletTest.java
@@ -7,38 +7,35 @@ import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-class CpuProfileServletTest extends AbstractServletTest {
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.addServlet(CpuProfileServlet.class, "/pprof");
-    }
-
-    @BeforeEach
-    void setUp() throws Exception {
-        request.setMethod("GET");
-        request.setURI("/pprof?duration=1");
-        request.setVersion("HTTP/1.0");
-
-        processRequest();
-    }
-
-    @Test
-    void returns200OK() {
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-    }
-
-    @Test
-    void returnsPprofRaw() {
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("pprof/raw");
-    }
-
-    @Test
-    void returnsUncacheable() {
-        assertThat(response.get(HttpHeader.CACHE_CONTROL))
-                .isEqualTo("must-revalidate,no-cache,no-store");
-
-    }
+final class CpuProfileServletTest extends AbstractServletTest {
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.addServlet(CpuProfileServlet.class, "/pprof");
+  }
+
+  @BeforeEach
+  void setUp() throws Exception {
+    request.setMethod("GET");
+    request.setURI("/pprof?duration=1");
+    request.setVersion("HTTP/1.0");
+
+    processRequest();
+  }
+
+  @Test
+  void returns200OK() {
+    assertThat(response.getStatus()).isEqualTo(200);
+  }
+
+  @Test
+  void returnsPprofRaw() {
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("pprof/raw");
+  }
+
+  @Test
+  void returnsUncacheable() {
+    assertThat(response.get(HttpHeader.CACHE_CONTROL))
+        .isEqualTo("must-revalidate,no-cache,no-store");
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/HealthCheckServletTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/HealthCheckServletTest.java
@@ -1,258 +1,269 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import com.fasterxml.jackson.databind.ObjectMapper;
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.health.HealthCheck;
 import io.dropwizard.metrics5.health.HealthCheckFilter;
 import io.dropwizard.metrics5.health.HealthCheckRegistry;
-import org.eclipse.jetty.http.HttpHeader;
-import org.eclipse.jetty.servlet.ServletTester;
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
+import org.eclipse.jetty.http.HttpHeader;
+import org.eclipse.jetty.servlet.ServletTester;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-class HealthCheckServletTest extends AbstractServletTest {
+final class HealthCheckServletTest extends AbstractServletTest {
 
-    private static final ZonedDateTime FIXED_TIME = ZonedDateTime.now();
+  private static final ZonedDateTime FIXED_TIME = ZonedDateTime.now();
 
-    private static final DateTimeFormatter DATE_TIME_FORMATTER =
-            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
+  private static final DateTimeFormatter DATE_TIME_FORMATTER =
+      DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
 
-    private static final String EXPECTED_TIMESTAMP = DATE_TIME_FORMATTER.format(FIXED_TIME);
+  private static final String EXPECTED_TIMESTAMP = DATE_TIME_FORMATTER.format(FIXED_TIME);
 
-    private static final Clock FIXED_CLOCK = new Clock() {
+  private static final Clock FIXED_CLOCK =
+      new Clock() {
         @Override
         public long getTick() {
-            return 0L;
+          return 0L;
         }
 
         @Override
         public long getTime() {
-            return FIXED_TIME.toInstant().toEpochMilli();
+          return FIXED_TIME.toInstant().toEpochMilli();
         }
-    };
-
-    private final HealthCheckRegistry registry = new HealthCheckRegistry();
-    private final ExecutorService threadPool = Executors.newCachedThreadPool();
-    private final ObjectMapper mapper = new ObjectMapper();
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.addServlet(HealthCheckServlet.class, "/healthchecks");
-        tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".registry", registry);
-        tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".executor", threadPool);
-        tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".mapper", mapper);
-        tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".healthCheckFilter",
-                (HealthCheckFilter) (name, healthCheck) -> !"filtered".equals(name));
-    }
-
-    @BeforeEach
-    void setUp() {
-        request.setMethod("GET");
-        request.setURI("/healthchecks");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @AfterEach
-    void tearDown() {
-        threadPool.shutdown();
-    }
-
-    @Test
-    void returns501IfNoHealthChecksAreRegistered() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(501);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent()).isEqualTo("{}");
-    }
-
-    @Test
-    void returnsA200IfAllHealthChecksAreHealthy() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent())
-                .isEqualTo("{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" +
-                        EXPECTED_TIMESTAMP +
-                        "\"}}");
+      };
+
+  private final HealthCheckRegistry registry = new HealthCheckRegistry();
+  private final ExecutorService threadPool = Executors.newCachedThreadPool();
+  private final ObjectMapper mapper = new ObjectMapper();
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.addServlet(HealthCheckServlet.class, "/healthchecks");
+    tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".registry", registry);
+    tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".executor", threadPool);
+    tester.setAttribute(HealthCheckServlet.class.getCanonicalName() + ".mapper", mapper);
+    tester.setAttribute(
+        HealthCheckServlet.class.getCanonicalName() + ".healthCheckFilter",
+        (HealthCheckFilter) (name, healthCheck) -> !"filtered".equals(name));
+  }
+
+  @BeforeEach
+  void setUp() {
+    request.setMethod("GET");
+    request.setURI("/healthchecks");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @AfterEach
+  void tearDown() {
+    threadPool.shutdown();
+  }
+
+  @Test
+  void returns501IfNoHealthChecksAreRegistered() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(501);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent()).isEqualTo("{}");
+  }
+
+  @Test
+  void returnsA200IfAllHealthChecksAreHealthy() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"%s\"}}",
+            EXPECTED_TIMESTAMP);
+  }
+
+  @Test
+  void returnsASubsetOfHealthChecksIfFiltered() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
+    registry.register("filtered", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"%s\"}}",
+            EXPECTED_TIMESTAMP);
+  }
+
+  @Test
+  void returnsA500IfAnyHealthChecksAreUnhealthy() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
+    registry.register("notFun", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(500);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .contains(
+            "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\""
+                + EXPECTED_TIMESTAMP
+                + "\"}",
+            ",\"notFun\":{\"healthy\":false,\"message\":\"whee\",\"duration\":0,\"timestamp\":\""
+                + EXPECTED_TIMESTAMP
+                + "\"}}");
+  }
+
+  @Test
+  void returnsA200IfAnyHealthChecksAreUnhealthyAndHttpStatusIndicatorIsDisabled() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
+    registry.register("notFun", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
+    request.setURI("/healthchecks?httpStatusIndicator=false");
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .contains(
+            "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\""
+                + EXPECTED_TIMESTAMP
+                + "\"}",
+            ",\"notFun\":{\"healthy\":false,\"message\":\"whee\",\"duration\":0,\"timestamp\":\""
+                + EXPECTED_TIMESTAMP
+                + "\"}}");
+  }
+
+  @Test
+  void optionallyPrettyPrintsTheJson() throws Exception {
+    registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("foo bar 123")));
+
+    request.setURI("/healthchecks?pretty=true");
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "{%n  \"fun\" : {%n    \"healthy\" : true,%n    \"message\" : \"foo bar 123\",%n    \"duration\" : 0,%n    \"timestamp\" : \"%s\"%n  }%n}",
+                EXPECTED_TIMESTAMP));
+  }
+
+  private static HealthCheck.Result healthyResultWithMessage(String message) {
+    return HealthCheck.Result.builder()
+        .healthy()
+        .withMessage(message)
+        .usingClock(FIXED_CLOCK)
+        .build();
+  }
+
+  private static HealthCheck.Result unhealthyResultWithMessage(String message) {
+    return HealthCheck.Result.builder()
+        .unhealthy()
+        .withMessage(message)
+        .usingClock(FIXED_CLOCK)
+        .build();
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentIsUsedInPreferenceOverServletConfig() throws Exception {
+    final HealthCheckRegistry healthCheckRegistry = mock();
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+
+    final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(healthCheckRegistry);
+    healthCheckServlet.init(servletConfig);
+
+    verify(servletConfig).getServletContext();
+    verify(servletContext, never()).getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY);
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentUsesServletConfigWhenNull() throws Exception {
+    final HealthCheckRegistry healthCheckRegistry = mock();
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+    when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
+        .thenReturn(healthCheckRegistry);
+
+    final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
+    healthCheckServlet.init(servletConfig);
+
+    verify(servletConfig).getServletContext();
+    verify(servletContext).getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY);
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentUsesServletConfigWhenNullButWrongTypeInContext()
+      throws Exception {
+    assertThatThrownBy(
+            () -> {
+              final ServletContext servletContext = mock();
+              final ServletConfig servletConfig = mock();
+              when(servletConfig.getServletContext()).thenReturn(servletContext);
+              when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
+                  .thenReturn("IRELLEVANT_STRING");
+
+              final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
+              healthCheckServlet.init(servletConfig);
+            })
+        .isInstanceOf(ServletException.class);
+  }
+
+  @Test
+  void constructorWithObjectMapperAsArgumentUsesServletConfigWhenNullButWrongTypeInContext()
+      throws Exception {
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+    when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
+        .thenReturn(registry);
+    when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_MAPPER))
+        .thenReturn("IRELLEVANT_STRING");
+
+    final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
+    healthCheckServlet.init(servletConfig);
+
+    assertThat(healthCheckServlet.getMapper()).isNotNull().isInstanceOf(ObjectMapper.class);
+  }
+
+  static class TestHealthCheck implements HealthCheck {
+    private final Callable<Result> check;
+
+    public TestHealthCheck(Callable<Result> check) {
+      this.check = check;
     }
 
-    @Test
-    void returnsASubsetOfHealthChecksIfFiltered() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
-        registry.register("filtered", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent())
-                .isEqualTo("{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" +
-                        EXPECTED_TIMESTAMP +
-                        "\"}}");
-    }
-
-    @Test
-    void returnsA500IfAnyHealthChecksAreUnhealthy() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
-        registry.register("notFun", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(500);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent()).contains(
-                "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" + EXPECTED_TIMESTAMP + "\"}",
-                ",\"notFun\":{\"healthy\":false,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" + EXPECTED_TIMESTAMP + "\"}}");
-    }
-
-    @Test
-    void returnsA200IfAnyHealthChecksAreUnhealthyAndHttpStatusIndicatorIsDisabled() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("whee")));
-        registry.register("notFun", new TestHealthCheck(() -> unhealthyResultWithMessage("whee")));
-        request.setURI("/healthchecks?httpStatusIndicator=false");
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent()).contains(
-                "{\"fun\":{\"healthy\":true,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" + EXPECTED_TIMESTAMP + "\"}",
-                ",\"notFun\":{\"healthy\":false,\"message\":\"whee\",\"duration\":0,\"timestamp\":\"" + EXPECTED_TIMESTAMP + "\"}}");
-    }
-
-    @Test
-    void optionallyPrettyPrintsTheJson() throws Exception {
-        registry.register("fun", new TestHealthCheck(() -> healthyResultWithMessage("foo bar 123")));
-
-        request.setURI("/healthchecks?pretty=true");
-
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
-        assertThat(response.getContent())
-                .isEqualTo(String.format("{%n" +
-                        "  \"fun\" : {%n" +
-                        "    \"healthy\" : true,%n" +
-                        "    \"message\" : \"foo bar 123\",%n" +
-                        "    \"duration\" : 0,%n" +
-                        "    \"timestamp\" : \"" + EXPECTED_TIMESTAMP + "\"" +
-                        "%n  }%n}"));
-    }
-
-    private static HealthCheck.Result healthyResultWithMessage(String message) {
-        return HealthCheck.Result.builder()
-                .healthy()
-                .withMessage(message)
-                .usingClock(FIXED_CLOCK)
-                .build();
-    }
-
-    private static HealthCheck.Result unhealthyResultWithMessage(String message) {
-        return HealthCheck.Result.builder()
-                .unhealthy()
-                .withMessage(message)
-                .usingClock(FIXED_CLOCK)
-                .build();
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentIsUsedInPreferenceOverServletConfig() throws Exception {
-        final HealthCheckRegistry healthCheckRegistry = mock(HealthCheckRegistry.class);
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-
-        final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(healthCheckRegistry);
-        healthCheckServlet.init(servletConfig);
-
-        verify(servletConfig, times(1)).getServletContext();
-        verify(servletContext, never()).getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY);
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentUsesServletConfigWhenNull() throws Exception {
-        final HealthCheckRegistry healthCheckRegistry = mock(HealthCheckRegistry.class);
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-        when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
-                .thenReturn(healthCheckRegistry);
-
-        final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
-        healthCheckServlet.init(servletConfig);
-
-        verify(servletConfig, times(1)).getServletContext();
-        verify(servletContext, times(1)).getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY);
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentUsesServletConfigWhenNullButWrongTypeInContext() throws Exception {
-        assertThrows(ServletException.class, () -> {
-            final ServletContext servletContext = mock(ServletContext.class);
-            final ServletConfig servletConfig = mock(ServletConfig.class);
-            when(servletConfig.getServletContext()).thenReturn(servletContext);
-            when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY))
-                    .thenReturn("IRELLEVANT_STRING");
-
-            final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
-            healthCheckServlet.init(servletConfig);
-        });
-    }
-
-    @Test
-    void constructorWithObjectMapperAsArgumentUsesServletConfigWhenNullButWrongTypeInContext() throws Exception {
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-        when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY)).thenReturn(registry);
-        when(servletContext.getAttribute(HealthCheckServlet.HEALTH_CHECK_MAPPER)).thenReturn("IRELLEVANT_STRING");
-
-        final HealthCheckServlet healthCheckServlet = new HealthCheckServlet(null);
-        healthCheckServlet.init(servletConfig);
-
-        assertThat(healthCheckServlet.getMapper())
-                .isNotNull()
-                .isInstanceOf(ObjectMapper.class);
+    @Override
+    public Result check() throws Exception {
+      return check.call();
     }
 
-    static class TestHealthCheck implements HealthCheck {
-        private final Callable<Result> check;
-
-        public TestHealthCheck(Callable<Result> check) {
-            this.check = check;
-        }
-
-        @Override
-        public Result check() throws Exception {
-            return check.call();
-        }
-
-        @Override
-        public Clock clock() {
-            return FIXED_CLOCK;
-        }
+    @Override
+    public Clock clock() {
+      return FIXED_CLOCK;
     }
-}
\ No newline at end of file
+  }
+}
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/MetricsServletContextListenerTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/MetricsServletContextListenerTest.java
@@ -1,5 +1,9 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.ExponentiallyDecayingReservoir;
 import io.dropwizard.metrics5.Gauge;
@@ -7,166 +11,163 @@ import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.util.concurrent.TimeUnit;
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-class MetricsServletContextListenerTest extends AbstractServletTest {
-    private final Clock clock = mock(Clock.class);
-    private final MetricRegistry registry = new MetricRegistry();
-    private final String allowedOrigin = "some.other.origin";
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
-        tester.addServlet(MetricsServlet.class, "/metrics");
-        tester.getContext().addEventListener(new MetricsServlet.ContextListener() {
-            @Override
-            protected MetricRegistry getMetricRegistry() {
+final class MetricsServletContextListenerTest extends AbstractServletTest {
+  private final Clock clock = mock();
+  private final MetricRegistry registry = new MetricRegistry();
+  private final String allowedOrigin = "some.other.origin";
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
+    tester.addServlet(MetricsServlet.class, "/metrics");
+    tester
+        .getContext()
+        .addEventListener(
+            new MetricsServlet.ContextListener() {
+              @Override
+              protected MetricRegistry getMetricRegistry() {
                 return registry;
-            }
+              }
 
-            @Override
-            protected TimeUnit getDurationUnit() {
+              @Override
+              protected TimeUnit getDurationUnit() {
                 return TimeUnit.MILLISECONDS;
-            }
+              }
 
-            @Override
-            protected TimeUnit getRateUnit() {
+              @Override
+              protected TimeUnit getRateUnit() {
                 return TimeUnit.MINUTES;
-            }
+              }
 
-            @Override
-            protected String getAllowedOrigin() {
+              @Override
+              protected String getAllowedOrigin() {
                 return allowedOrigin;
-            }
-        });
-    }
-
-    @BeforeEach
-    void setUp() {
-        // provide ticks for the setup (calls getTick 6 times). The serialization in the tests themselves
-        // will call getTick again several times and always get the same value (the last specified here)
-        when(clock.getTick()).thenReturn(100L, 100L, 200L, 300L, 300L, 400L);
-
-        registry.register(MetricName.build("g1"), (Gauge<Long>) () -> 100L);
-        registry.counter("c").inc();
-        registry.histogram("h").update(1);
-        registry.register(MetricName.build("m"), new Meter(clock)).mark();
-        registry.register(MetricName.build("t"), new Timer(new ExponentiallyDecayingReservoir(), clock))
-                .update(1, TimeUnit.SECONDS);
-
-        request.setMethod("GET");
-        request.setURI("/metrics");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo(allowedOrigin);
-        assertThat(response.getContent())
-                .isEqualTo("{" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{" +
-                        "\"g1\":{\"value\":100}" +
-                        "}," +
-                        "\"counters\":{" +
-                        "\"c\":{\"count\":1}" +
-                        "}," +
-                        "\"histograms\":{" +
-                        "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}" +
-                        "}," +
-                        "\"meters\":{" +
-                        "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":2.0E8,\"units\":\"events/minute\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1000.0,\"mean\":1000.0,\"min\":1000.0,\"p50\":1000.0,\"p75\":1000.0,\"p95\":1000.0,\"p98\":1000.0,\"p99\":1000.0,\"p999\":1000.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":6.0E8,\"duration_units\":\"milliseconds\",\"rate_units\":\"calls/minute\"}" +
-                        "}" +
-                        "}");
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void optionallyPrettyPrintsTheJson() throws Exception {
-        request.setURI("/metrics?pretty=true");
-
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo(allowedOrigin);
-        assertThat(response.getContent())
-                .isEqualTo(String.format("{%n" +
-                        "  \"version\" : \"5.0.0\",%n" +
-                        "  \"gauges\" : {%n" +
-                        "    \"g1\" : {%n" +
-                        "      \"value\" : 100%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"counters\" : {%n" +
-                        "    \"c\" : {%n" +
-                        "      \"count\" : 1%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"histograms\" : {%n" +
-                        "    \"h\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"max\" : 1,%n" +
-                        "      \"mean\" : 1.0,%n" +
-                        "      \"min\" : 1,%n" +
-                        "      \"p50\" : 1.0,%n" +
-                        "      \"p75\" : 1.0,%n" +
-                        "      \"p95\" : 1.0,%n" +
-                        "      \"p98\" : 1.0,%n" +
-                        "      \"p99\" : 1.0,%n" +
-                        "      \"p999\" : 1.0,%n" +
-                        "      \"stddev\" : 0.0%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"meters\" : {%n" +
-                        "    \"m\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"m15_rate\" : 0.0,%n" +
-                        "      \"m1_rate\" : 0.0,%n" +
-                        "      \"m5_rate\" : 0.0,%n" +
-                        "      \"mean_rate\" : 2.0E8,%n" +
-                        "      \"units\" : \"events/minute\"%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"timers\" : {%n" +
-                        "    \"t\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"max\" : 1000.0,%n" +
-                        "      \"mean\" : 1000.0,%n" +
-                        "      \"min\" : 1000.0,%n" +
-                        "      \"p50\" : 1000.0,%n" +
-                        "      \"p75\" : 1000.0,%n" +
-                        "      \"p95\" : 1000.0,%n" +
-                        "      \"p98\" : 1000.0,%n" +
-                        "      \"p99\" : 1000.0,%n" +
-                        "      \"p999\" : 1000.0,%n" +
-                        "      \"stddev\" : 0.0,%n" +
-                        "      \"m15_rate\" : 0.0,%n" +
-                        "      \"m1_rate\" : 0.0,%n" +
-                        "      \"m5_rate\" : 0.0,%n" +
-                        "      \"mean_rate\" : 6.0E8,%n" +
-                        "      \"duration_units\" : \"milliseconds\",%n" +
-                        "      \"rate_units\" : \"calls/minute\"%n" +
-                        "    }%n" +
-                        "  }%n" +
-                        "}"));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
+              }
+            });
+  }
+
+  @BeforeEach
+  void setUp() {
+    // provide ticks for the setup (calls getTick 6 times). The serialization in the tests
+    // themselves
+    // will call getTick again several times and always get the same value (the last specified here)
+    when(clock.getTick()).thenReturn(100L, 100L, 200L, 300L, 300L, 400L);
+
+    registry.register(MetricName.build("g1"), (Gauge<Long>) () -> 100L);
+    registry.counter("c").inc();
+    registry.histogram("h").update(1);
+    registry.register(MetricName.build("m"), new Meter(clock)).mark();
+    registry
+        .register(MetricName.build("t"), new Timer(new ExponentiallyDecayingReservoir(), clock))
+        .update(1, TimeUnit.SECONDS);
+
+    request.setMethod("GET");
+    request.setURI("/metrics");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo(allowedOrigin);
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{"
+                + "\"version\":\"5.0.0\","
+                + "\"gauges\":{"
+                + "\"g1\":{\"value\":100}"
+                + "},"
+                + "\"counters\":{"
+                + "\"c\":{\"count\":1}"
+                + "},"
+                + "\"histograms\":{"
+                + "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}"
+                + "},"
+                + "\"meters\":{"
+                + "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":2.0E8,\"units\":\"events/minute\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1000.0,\"mean\":1000.0,\"min\":1000.0,\"p50\":1000.0,\"p75\":1000.0,\"p95\":1000.0,\"p98\":1000.0,\"p99\":1000.0,\"p999\":1000.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":6.0E8,\"duration_units\":\"milliseconds\",\"rate_units\":\"calls/minute\"}"
+                + "}"
+                + "}");
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void optionallyPrettyPrintsTheJson() throws Exception {
+    request.setURI("/metrics?pretty=true");
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo(allowedOrigin);
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "{%n"
+                    + "  \"version\" : \"5.0.0\",%n"
+                    + "  \"gauges\" : {%n"
+                    + "    \"g1\" : {%n"
+                    + "      \"value\" : 100%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"counters\" : {%n"
+                    + "    \"c\" : {%n"
+                    + "      \"count\" : 1%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"histograms\" : {%n"
+                    + "    \"h\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"max\" : 1,%n"
+                    + "      \"mean\" : 1.0,%n"
+                    + "      \"min\" : 1,%n"
+                    + "      \"p50\" : 1.0,%n"
+                    + "      \"p75\" : 1.0,%n"
+                    + "      \"p95\" : 1.0,%n"
+                    + "      \"p98\" : 1.0,%n"
+                    + "      \"p99\" : 1.0,%n"
+                    + "      \"p999\" : 1.0,%n"
+                    + "      \"stddev\" : 0.0%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"meters\" : {%n"
+                    + "    \"m\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"m15_rate\" : 0.0,%n"
+                    + "      \"m1_rate\" : 0.0,%n"
+                    + "      \"m5_rate\" : 0.0,%n"
+                    + "      \"mean_rate\" : 2.0E8,%n"
+                    + "      \"units\" : \"events/minute\"%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"timers\" : {%n"
+                    + "    \"t\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"max\" : 1000.0,%n"
+                    + "      \"mean\" : 1000.0,%n"
+                    + "      \"min\" : 1000.0,%n"
+                    + "      \"p50\" : 1000.0,%n"
+                    + "      \"p75\" : 1000.0,%n"
+                    + "      \"p95\" : 1000.0,%n"
+                    + "      \"p98\" : 1000.0,%n"
+                    + "      \"p99\" : 1000.0,%n"
+                    + "      \"p999\" : 1000.0,%n"
+                    + "      \"stddev\" : 0.0,%n"
+                    + "      \"m15_rate\" : 0.0,%n"
+                    + "      \"m1_rate\" : 0.0,%n"
+                    + "      \"m5_rate\" : 0.0,%n"
+                    + "      \"mean_rate\" : 6.0E8,%n"
+                    + "      \"duration_units\" : \"milliseconds\",%n"
+                    + "      \"rate_units\" : \"calls/minute\"%n"
+                    + "    }%n"
+                    + "  }%n"
+                    + "}"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/MetricsServletTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/MetricsServletTest.java
@@ -1,5 +1,12 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 import io.dropwizard.metrics5.Clock;
 import io.dropwizard.metrics5.ExponentiallyDecayingReservoir;
 import io.dropwizard.metrics5.Gauge;
@@ -7,261 +14,241 @@ import io.dropwizard.metrics5.Meter;
 import io.dropwizard.metrics5.MetricName;
 import io.dropwizard.metrics5.MetricRegistry;
 import io.dropwizard.metrics5.Timer;
+import java.util.concurrent.TimeUnit;
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletException;
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
-import java.util.concurrent.TimeUnit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-class MetricsServletTest extends AbstractServletTest {
-    private final Clock clock = mock(Clock.class);
-    private final MetricRegistry registry = new MetricRegistry();
-    private ServletTester tester;
-
-    @Override
-    protected void setUp(ServletTester tester) {
-        this.tester = tester;
-        tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
-        tester.addServlet(MetricsServlet.class, "/metrics");
-        tester.getContext().setInitParameter("io.dropwizard.metrics5.servlets.MetricsServlet.allowedOrigin", "*");
-    }
-
-    @BeforeEach
-    void setUp() {
-        // provide ticks for the setup (calls getTick 6 times). The serialization in the tests themselves
-        // will call getTick again several times and always get the same value (the last specified here)
-        when(clock.getTick()).thenReturn(100L, 100L, 200L, 300L, 300L, 400L);
-
-        registry.register(MetricName.build("g1"), (Gauge<Long>) () -> 100L);
-        registry.counter("c").inc();
-        registry.histogram("h").update(1);
-        registry.register(MetricName.build("m"), new Meter(clock)).mark();
-        registry.register(MetricName.build("t"), new Timer(new ExponentiallyDecayingReservoir(), clock))
-                .update(1, TimeUnit.SECONDS);
-
-        request.setMethod("GET");
-        request.setURI("/metrics");
-        request.setVersion("HTTP/1.0");
-    }
-
-    @Test
-    void returnsA200() throws Exception {
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo("*");
-        assertThat(response.getContent())
-                .isEqualTo("{" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{" +
-                        "\"g1\":{\"value\":100}" +
-                        "}," +
-                        "\"counters\":{" +
-                        "\"c\":{\"count\":1}" +
-                        "}," +
-                        "\"histograms\":{" +
-                        "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}" +
-                        "}," +
-                        "\"meters\":{" +
-                        "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}" +
-                        "}" +
-                        "}");
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void returnsJsonWhenJsonpInitParamNotSet() throws Exception {
-        String callbackParamName = "callbackParam";
-        String callbackParamVal = "callbackParamVal";
-        request.setURI("/metrics?" + callbackParamName + "=" + callbackParamVal);
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo("*");
-        assertThat(response.getContent())
-                .isEqualTo("{" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{" +
-                        "\"g1\":{\"value\":100}" +
-                        "}," +
-                        "\"counters\":{" +
-                        "\"c\":{\"count\":1}" +
-                        "}," +
-                        "\"histograms\":{" +
-                        "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}" +
-                        "}," +
-                        "\"meters\":{" +
-                        "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}" +
-                        "}" +
-                        "}");
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void returnsJsonpWhenInitParamSet() throws Exception {
-        String callbackParamName = "callbackParam";
-        String callbackParamVal = "callbackParamVal";
-        request.setURI("/metrics?" + callbackParamName + "=" + callbackParamVal);
-        tester.getContext().setInitParameter("io.dropwizard.metrics5.servlets.MetricsServlet.jsonpCallback", callbackParamName);
-        processRequest();
-
-        assertThat(response.getStatus()).isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo("*");
-        assertThat(response.getContent())
-                .isEqualTo(callbackParamVal + "({" +
-                        "\"version\":\"5.0.0\"," +
-                        "\"gauges\":{" +
-                        "\"g1\":{\"value\":100}" +
-                        "}," +
-                        "\"counters\":{" +
-                        "\"c\":{\"count\":1}" +
-                        "}," +
-                        "\"histograms\":{" +
-                        "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}" +
-                        "}," +
-                        "\"meters\":{" +
-                        "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}" +
-                        "}" +
-                        "})");
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void optionallyPrettyPrintsTheJson() throws Exception {
-        request.setURI("/metrics?pretty=true");
-
-        processRequest();
-
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-        assertThat(response.get("Access-Control-Allow-Origin"))
-                .isEqualTo("*");
-        assertThat(response.getContent())
-                .isEqualTo(String.format("{%n" +
-                        "  \"version\" : \"5.0.0\",%n" +
-                        "  \"gauges\" : {%n" +
-                        "    \"g1\" : {%n" +
-                        "      \"value\" : 100%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"counters\" : {%n" +
-                        "    \"c\" : {%n" +
-                        "      \"count\" : 1%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"histograms\" : {%n" +
-                        "    \"h\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"max\" : 1,%n" +
-                        "      \"mean\" : 1.0,%n" +
-                        "      \"min\" : 1,%n" +
-                        "      \"p50\" : 1.0,%n" +
-                        "      \"p75\" : 1.0,%n" +
-                        "      \"p95\" : 1.0,%n" +
-                        "      \"p98\" : 1.0,%n" +
-                        "      \"p99\" : 1.0,%n" +
-                        "      \"p999\" : 1.0,%n" +
-                        "      \"stddev\" : 0.0%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"meters\" : {%n" +
-                        "    \"m\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"m15_rate\" : 0.0,%n" +
-                        "      \"m1_rate\" : 0.0,%n" +
-                        "      \"m5_rate\" : 0.0,%n" +
-                        "      \"mean_rate\" : 3333333.3333333335,%n" +
-                        "      \"units\" : \"events/second\"%n" +
-                        "    }%n" +
-                        "  },%n" +
-                        "  \"timers\" : {%n" +
-                        "    \"t\" : {%n" +
-                        "      \"count\" : 1,%n" +
-                        "      \"max\" : 1.0,%n" +
-                        "      \"mean\" : 1.0,%n" +
-                        "      \"min\" : 1.0,%n" +
-                        "      \"p50\" : 1.0,%n" +
-                        "      \"p75\" : 1.0,%n" +
-                        "      \"p95\" : 1.0,%n" +
-                        "      \"p98\" : 1.0,%n" +
-                        "      \"p99\" : 1.0,%n" +
-                        "      \"p999\" : 1.0,%n" +
-                        "      \"stddev\" : 0.0,%n" +
-                        "      \"m15_rate\" : 0.0,%n" +
-                        "      \"m1_rate\" : 0.0,%n" +
-                        "      \"m5_rate\" : 0.0,%n" +
-                        "      \"mean_rate\" : 1.0E7,%n" +
-                        "      \"duration_units\" : \"seconds\",%n" +
-                        "      \"rate_units\" : \"calls/second\"%n" +
-                        "    }%n" +
-                        "  }%n" +
-                        "}"));
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("application/json");
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentIsUsedInPreferenceOverServletConfig() throws Exception {
-        final MetricRegistry metricRegistry = mock(MetricRegistry.class);
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-
-        final MetricsServlet metricsServlet = new MetricsServlet(metricRegistry);
-        metricsServlet.init(servletConfig);
-
-        verify(servletConfig, times(1)).getServletContext();
-        verify(servletContext, never()).getAttribute(eq(MetricsServlet.METRICS_REGISTRY));
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentUsesServletConfigWhenNull() throws Exception {
-        final MetricRegistry metricRegistry = mock(MetricRegistry.class);
-        final ServletContext servletContext = mock(ServletContext.class);
-        final ServletConfig servletConfig = mock(ServletConfig.class);
-        when(servletConfig.getServletContext()).thenReturn(servletContext);
-        when(servletContext.getAttribute(eq(MetricsServlet.METRICS_REGISTRY)))
-                .thenReturn(metricRegistry);
-
-        final MetricsServlet metricsServlet = new MetricsServlet(null);
-        metricsServlet.init(servletConfig);
-
-        verify(servletConfig, times(1)).getServletContext();
-        verify(servletContext, times(1)).getAttribute(eq(MetricsServlet.METRICS_REGISTRY));
-    }
-
-    @Test
-    void constructorWithRegistryAsArgumentUsesServletConfigWhenNullButWrongTypeInContext() throws Exception {
-        assertThrows(ServletException.class, () -> {
-            final ServletContext servletContext = mock(ServletContext.class);
-            final ServletConfig servletConfig = mock(ServletConfig.class);
-            when(servletConfig.getServletContext()).thenReturn(servletContext);
-            when(servletContext.getAttribute(eq(MetricsServlet.METRICS_REGISTRY)))
-                    .thenReturn("IRELLEVANT_STRING");
-
-            final MetricsServlet metricsServlet = new MetricsServlet(null);
-            metricsServlet.init(servletConfig);
-        });
-    }
+final class MetricsServletTest extends AbstractServletTest {
+  private final Clock clock = mock();
+  private final MetricRegistry registry = new MetricRegistry();
+  private ServletTester tester;
+
+  @Override
+  protected void setUp(ServletTester tester) {
+    this.tester = tester;
+    tester.setAttribute("io.dropwizard.metrics5.servlets.MetricsServlet.registry", registry);
+    tester.addServlet(MetricsServlet.class, "/metrics");
+    tester
+        .getContext()
+        .setInitParameter("io.dropwizard.metrics5.servlets.MetricsServlet.allowedOrigin", "*");
+  }
+
+  @BeforeEach
+  void setUp() {
+    // provide ticks for the setup (calls getTick 6 times). The serialization in the tests
+    // themselves
+    // will call getTick again several times and always get the same value (the last specified here)
+    when(clock.getTick()).thenReturn(100L, 100L, 200L, 300L, 300L, 400L);
+
+    registry.register(MetricName.build("g1"), (Gauge<Long>) () -> 100L);
+    registry.counter("c").inc();
+    registry.histogram("h").update(1);
+    registry.register(MetricName.build("m"), new Meter(clock)).mark();
+    registry
+        .register(MetricName.build("t"), new Timer(new ExponentiallyDecayingReservoir(), clock))
+        .update(1, TimeUnit.SECONDS);
+
+    request.setMethod("GET");
+    request.setURI("/metrics");
+    request.setVersion("HTTP/1.0");
+  }
+
+  @Test
+  void returnsA200() throws Exception {
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo("*");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{"
+                + "\"version\":\"5.0.0\","
+                + "\"gauges\":{"
+                + "\"g1\":{\"value\":100}"
+                + "},"
+                + "\"counters\":{"
+                + "\"c\":{\"count\":1}"
+                + "},"
+                + "\"histograms\":{"
+                + "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}"
+                + "},"
+                + "\"meters\":{"
+                + "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}"
+                + "}"
+                + "}");
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void returnsJsonWhenJsonpInitParamNotSet() throws Exception {
+    String callbackParamName = "callbackParam";
+    String callbackParamVal = "callbackParamVal";
+    request.setURI("/metrics?" + callbackParamName + "=" + callbackParamVal);
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo("*");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "{"
+                + "\"version\":\"5.0.0\","
+                + "\"gauges\":{"
+                + "\"g1\":{\"value\":100}"
+                + "},"
+                + "\"counters\":{"
+                + "\"c\":{\"count\":1}"
+                + "},"
+                + "\"histograms\":{"
+                + "\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}"
+                + "},"
+                + "\"meters\":{"
+                + "\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}"
+                + "}"
+                + "}");
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void returnsJsonpWhenInitParamSet() throws Exception {
+    String callbackParamName = "callbackParam";
+    String callbackParamVal = "callbackParamVal";
+    request.setURI("/metrics?" + callbackParamName + "=" + callbackParamVal);
+    tester
+        .getContext()
+        .setInitParameter(
+            "io.dropwizard.metrics5.servlets.MetricsServlet.jsonpCallback", callbackParamName);
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo("*");
+    assertThat(response.getContent())
+        .isEqualTo(
+            "%s({\"version\":\"5.0.0\",\"gauges\":{\"g1\":{\"value\":100}},\"counters\":{\"c\":{\"count\":1}},\"histograms\":{\"h\":{\"count\":1,\"max\":1,\"mean\":1.0,\"min\":1,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0}},\"meters\":{\"m\":{\"count\":1,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":3333333.3333333335,\"units\":\"events/second\"}},\"timers\":{\"t\":{\"count\":1,\"max\":1.0,\"mean\":1.0,\"min\":1.0,\"p50\":1.0,\"p75\":1.0,\"p95\":1.0,\"p98\":1.0,\"p99\":1.0,\"p999\":1.0,\"stddev\":0.0,\"m15_rate\":0.0,\"m1_rate\":0.0,\"m5_rate\":0.0,\"mean_rate\":1.0E7,\"duration_units\":\"seconds\",\"rate_units\":\"calls/second\"}}})",
+            callbackParamVal);
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void optionallyPrettyPrintsTheJson() throws Exception {
+    request.setURI("/metrics?pretty=true");
+
+    processRequest();
+
+    assertThat(response.getStatus()).isEqualTo(200);
+    assertThat(response.get("Access-Control-Allow-Origin")).isEqualTo("*");
+    assertThat(response.getContent())
+        .isEqualTo(
+            String.format(
+                "{%n"
+                    + "  \"version\" : \"5.0.0\",%n"
+                    + "  \"gauges\" : {%n"
+                    + "    \"g1\" : {%n"
+                    + "      \"value\" : 100%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"counters\" : {%n"
+                    + "    \"c\" : {%n"
+                    + "      \"count\" : 1%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"histograms\" : {%n"
+                    + "    \"h\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"max\" : 1,%n"
+                    + "      \"mean\" : 1.0,%n"
+                    + "      \"min\" : 1,%n"
+                    + "      \"p50\" : 1.0,%n"
+                    + "      \"p75\" : 1.0,%n"
+                    + "      \"p95\" : 1.0,%n"
+                    + "      \"p98\" : 1.0,%n"
+                    + "      \"p99\" : 1.0,%n"
+                    + "      \"p999\" : 1.0,%n"
+                    + "      \"stddev\" : 0.0%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"meters\" : {%n"
+                    + "    \"m\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"m15_rate\" : 0.0,%n"
+                    + "      \"m1_rate\" : 0.0,%n"
+                    + "      \"m5_rate\" : 0.0,%n"
+                    + "      \"mean_rate\" : 3333333.3333333335,%n"
+                    + "      \"units\" : \"events/second\"%n"
+                    + "    }%n"
+                    + "  },%n"
+                    + "  \"timers\" : {%n"
+                    + "    \"t\" : {%n"
+                    + "      \"count\" : 1,%n"
+                    + "      \"max\" : 1.0,%n"
+                    + "      \"mean\" : 1.0,%n"
+                    + "      \"min\" : 1.0,%n"
+                    + "      \"p50\" : 1.0,%n"
+                    + "      \"p75\" : 1.0,%n"
+                    + "      \"p95\" : 1.0,%n"
+                    + "      \"p98\" : 1.0,%n"
+                    + "      \"p99\" : 1.0,%n"
+                    + "      \"p999\" : 1.0,%n"
+                    + "      \"stddev\" : 0.0,%n"
+                    + "      \"m15_rate\" : 0.0,%n"
+                    + "      \"m1_rate\" : 0.0,%n"
+                    + "      \"m5_rate\" : 0.0,%n"
+                    + "      \"mean_rate\" : 1.0E7,%n"
+                    + "      \"duration_units\" : \"seconds\",%n"
+                    + "      \"rate_units\" : \"calls/second\"%n"
+                    + "    }%n"
+                    + "  }%n"
+                    + "}"));
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("application/json");
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentIsUsedInPreferenceOverServletConfig() throws Exception {
+    final MetricRegistry metricRegistry = mock();
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+
+    final MetricsServlet metricsServlet = new MetricsServlet(metricRegistry);
+    metricsServlet.init(servletConfig);
+
+    verify(servletConfig).getServletContext();
+    verify(servletContext, never()).getAttribute(MetricsServlet.METRICS_REGISTRY);
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentUsesServletConfigWhenNull() throws Exception {
+    final MetricRegistry metricRegistry = mock();
+    final ServletContext servletContext = mock();
+    final ServletConfig servletConfig = mock();
+    when(servletConfig.getServletContext()).thenReturn(servletContext);
+    when(servletContext.getAttribute(MetricsServlet.METRICS_REGISTRY)).thenReturn(metricRegistry);
+
+    final MetricsServlet metricsServlet = new MetricsServlet(null);
+    metricsServlet.init(servletConfig);
+
+    verify(servletConfig).getServletContext();
+    verify(servletContext).getAttribute(MetricsServlet.METRICS_REGISTRY);
+  }
+
+  @Test
+  void constructorWithRegistryAsArgumentUsesServletConfigWhenNullButWrongTypeInContext()
+      throws Exception {
+    assertThatThrownBy(
+            () -> {
+              final ServletContext servletContext = mock();
+              final ServletConfig servletConfig = mock();
+              when(servletConfig.getServletContext()).thenReturn(servletContext);
+              when(servletContext.getAttribute(MetricsServlet.METRICS_REGISTRY))
+                  .thenReturn("IRELLEVANT_STRING");
+
+              final MetricsServlet metricsServlet = new MetricsServlet(null);
+              metricsServlet.init(servletConfig);
+            })
+        .isInstanceOf(ServletException.class);
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/PingServletTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/PingServletTest.java
@@ -1,49 +1,45 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class PingServletTest extends AbstractServletTest {
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.addServlet(PingServlet.class, "/ping");
-    }
-
-    @BeforeEach
-    void setUp() throws Exception  {
-        request.setMethod("GET");
-        request.setURI("/ping");
-        request.setVersion("HTTP/1.0");
-
-        processRequest();
-    }
-
-    @Test
-    void returns200OK()  {
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-    }
-
-    @Test
-    void returnsPong()  {
-        assertThat(response.getContent())
-                .isEqualTo(String.format("pong%n"));
-    }
-
-    @Test
-    void returnsTextPlain()  {
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/plain;charset=ISO-8859-1");
-    }
-
-    @Test
-    void returnsUncacheable()  {
-        assertThat(response.get(HttpHeader.CACHE_CONTROL))
-                .isEqualTo("must-revalidate,no-cache,no-store");
-
-    }
+final class PingServletTest extends AbstractServletTest {
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.addServlet(PingServlet.class, "/ping");
+  }
+
+  @BeforeEach
+  void setUp() throws Exception {
+    request.setMethod("GET");
+    request.setURI("/ping");
+    request.setVersion("HTTP/1.0");
+
+    processRequest();
+  }
+
+  @Test
+  void returns200OK() {
+    assertThat(response.getStatus()).isEqualTo(200);
+  }
+
+  @Test
+  void returnsPong() {
+    assertThat(response.getContent()).isEqualTo(String.format("pong%n"));
+  }
+
+  @Test
+  void returnsTextPlain() {
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/plain;charset=ISO-8859-1");
+  }
+
+  @Test
+  void returnsUncacheable() {
+    assertThat(response.get(HttpHeader.CACHE_CONTROL))
+        .isEqualTo("must-revalidate,no-cache,no-store");
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/ThreadDumpServletTest.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/ThreadDumpServletTest.java
@@ -1,49 +1,45 @@
 package io.dropwizard.metrics5.servlets;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.servlet.ServletTester;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
-class ThreadDumpServletTest extends AbstractServletTest {
-    @Override
-    protected void setUp(ServletTester tester) {
-        tester.addServlet(ThreadDumpServlet.class, "/threads");
-    }
-
-    @BeforeEach
-    void setUp() throws Exception {
-        request.setMethod("GET");
-        request.setURI("/threads");
-        request.setVersion("HTTP/1.0");
-
-        processRequest();
-    }
-
-    @Test
-    void returns200OK() {
-        assertThat(response.getStatus())
-                .isEqualTo(200);
-    }
-
-    @Test
-    void returnsAThreadDump() {
-        assertThat(response.getContent())
-                .contains("Finalizer");
-    }
-
-    @Test
-    void returnsTextPlain() {
-        assertThat(response.get(HttpHeader.CONTENT_TYPE))
-                .isEqualTo("text/plain");
-    }
-
-    @Test
-    void returnsUncacheable() {
-        assertThat(response.get(HttpHeader.CACHE_CONTROL))
-                .isEqualTo("must-revalidate,no-cache,no-store");
-
-    }
+final class ThreadDumpServletTest extends AbstractServletTest {
+  @Override
+  protected void setUp(ServletTester tester) {
+    tester.addServlet(ThreadDumpServlet.class, "/threads");
+  }
+
+  @BeforeEach
+  void setUp() throws Exception {
+    request.setMethod("GET");
+    request.setURI("/threads");
+    request.setVersion("HTTP/1.0");
+
+    processRequest();
+  }
+
+  @Test
+  void returns200OK() {
+    assertThat(response.getStatus()).isEqualTo(200);
+  }
+
+  @Test
+  void returnsAThreadDump() {
+    assertThat(response.getContent()).contains("Finalizer");
+  }
+
+  @Test
+  void returnsTextPlain() {
+    assertThat(response.get(HttpHeader.CONTENT_TYPE)).isEqualTo("text/plain");
+  }
+
+  @Test
+  void returnsUncacheable() {
+    assertThat(response.get(HttpHeader.CACHE_CONTROL))
+        .isEqualTo("must-revalidate,no-cache,no-store");
+  }
 }
--- a/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/experiments/ExampleServer.java
+++ b/metrics-servlets/src/test/java/io/dropwizard/metrics5/servlets/experiments/ExampleServer.java
@@ -1,5 +1,7 @@
 package io.dropwizard.metrics5.servlets.experiments;
 
+import static io.dropwizard.metrics5.MetricRegistry.name;
+
 import io.dropwizard.metrics5.Counter;
 import io.dropwizard.metrics5.Gauge;
 import io.dropwizard.metrics5.MetricRegistry;
@@ -18,43 +20,48 @@ import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
 import org.eclipse.jetty.util.thread.ThreadPool;
 
-import static io.dropwizard.metrics5.MetricRegistry.name;
-
 public class ExampleServer {
-    private static final MetricRegistry REGISTRY = new MetricRegistry();
-    private static final Counter COUNTER_1 = REGISTRY.counter(name(ExampleServer.class, "wah", "doody"));
-    private static final Counter COUNTER_2 = REGISTRY.counter(name(ExampleServer.class, "woo"));
+  private static final MetricRegistry REGISTRY = new MetricRegistry();
+  private static final Counter COUNTER_1 =
+      REGISTRY.counter(name(ExampleServer.class, "wah", "doody"));
+  private static final Counter COUNTER_2 = REGISTRY.counter(name(ExampleServer.class, "woo"));
 
-    static {
-        REGISTRY.register(name(ExampleServer.class, "boo"), (Gauge<Integer>) () -> {
-            throw new RuntimeException("asplode!");
-        });
-    }
+  static {
+    REGISTRY.register(
+        name(ExampleServer.class, "boo"),
+        (Gauge<Integer>)
+            () -> {
+              throw new RuntimeException("asplode!");
+            });
+  }
 
-    public static void main(String[] args) throws Exception {
-        COUNTER_1.inc();
-        COUNTER_2.inc();
+  public static void main(String[] args) throws Exception {
+    COUNTER_1.inc();
+    COUNTER_2.inc();
 
-        final ThreadPool threadPool = new InstrumentedQueuedThreadPool(REGISTRY);
-        final Server server = new Server(threadPool);
+    final ThreadPool threadPool = new InstrumentedQueuedThreadPool(REGISTRY);
+    final Server server = new Server(threadPool);
 
-        final Connector connector = new ServerConnector(server, new InstrumentedConnectionFactory(
+    final Connector connector =
+        new ServerConnector(
+            server,
+            new InstrumentedConnectionFactory(
                 new HttpConnectionFactory(), REGISTRY.timer("http.connection")));
-        server.addConnector(connector);
+    server.addConnector(connector);
 
-        final ServletContextHandler context = new ServletContextHandler();
-        context.setContextPath("/initial");
-        context.setAttribute(MetricsServlet.METRICS_REGISTRY, REGISTRY);
-        context.setAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY, new HealthCheckRegistry());
+    final ServletContextHandler context = new ServletContextHandler();
+    context.setContextPath("/initial");
+    context.setAttribute(MetricsServlet.METRICS_REGISTRY, REGISTRY);
+    context.setAttribute(HealthCheckServlet.HEALTH_CHECK_REGISTRY, new HealthCheckRegistry());
 
-        final ServletHolder holder = new ServletHolder(new AdminServlet());
-        context.addServlet(holder, "/dingo/*");
+    final ServletHolder holder = new ServletHolder(new AdminServlet());
+    context.addServlet(holder, "/dingo/*");
 
-        final InstrumentedHandler handler = new InstrumentedHandler(REGISTRY);
-        handler.setHandler(context);
-        server.setHandler(handler);
+    final InstrumentedHandler handler = new InstrumentedHandler(REGISTRY);
+    handler.setHandler(context);
+    server.setHandler(handler);
 
-        server.start();
-        server.join();
-    }
+    server.start();
+    server.join();
+  }
 }
