diff --git a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java
index b16828f8e..f9f24a5ea 100644
--- a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java
+++ b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java
@@ -38,19 +38,21 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 
 import static org.apache.calcite.util.DateTimeStringUtils.ISO_DATETIME_FRACTIONAL_SECOND_FORMAT;
 import static org.apache.calcite.util.DateTimeStringUtils.getDateFormatter;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Implementation of a {@link org.apache.calcite.rel.core.Filter} relational expression in
  * Cassandra.
@@ -105,7 +107,7 @@ public CassandraFilter(
 
   @Override public void implement(Implementor implementor) {
     implementor.visitChild(0, getInput());
-    implementor.add(null, Collections.singletonList(match));
+    implementor.add(null, ImmutableList.of(match));
   }
 
   /**
@@ -304,7 +306,7 @@ private String translateOp2(String op, String name, RexLiteral right) {
       Object value = literalValue(right);
       String valueString = value.toString();
       if (value instanceof String) {
-        RelDataTypeField field = Objects.requireNonNull(rowType.getField(name, true, false));
+        RelDataTypeField field = requireNonNull(rowType.getField(name, true, false));
         SqlTypeName typeName = field.getType().getSqlTypeName();
         if (typeName != SqlTypeName.CHAR) {
           valueString = "'" + valueString + "'";
diff --git a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java
index 838b5d3d9..71c3ce946 100644
--- a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java
+++ b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java
@@ -62,11 +62,15 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Optional;
-import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
+import static com.google.common.base.Preconditions.checkState;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toList;
+
 /** Schema mapped onto a Cassandra column family. */
 public class CassandraSchema extends AbstractSchema {
   final CqlSession session;
@@ -131,14 +135,14 @@ RelProtoDataType getRelDataType(String columnFamily, boolean view) {
     if (view) {
       Optional<ViewMetadata> optionalViewMetadata = getKeyspace().getView(tableName);
       if (optionalViewMetadata.isPresent()) {
-        columns = optionalViewMetadata.get().getColumns();
+        columns = optionalViewMetadata.orElseThrow().getColumns();
       } else {
         throw new IllegalStateException("Unknown view " + tableName + " in keyspace " + keyspace);
       }
     } else {
       Optional<TableMetadata> optionalTableMetadata = getKeyspace().getTable(tableName);
       if (optionalTableMetadata.isPresent()) {
-        columns = optionalTableMetadata.get().getColumns();
+        columns = optionalTableMetadata.orElseThrow().getColumns();
       } else {
         throw new IllegalStateException("Unknown table " + tableName + " in keyspace " + keyspace);
       }
@@ -190,7 +194,7 @@ RelProtoDataType getRelDataType(String columnFamily, boolean view) {
                         new Pair<>(
                             Integer.toString(i + 1), // 1 indexed (as ARRAY)
                             typeFactory.createSqlType(CQL_TO_SQL_TYPE.lookup(typeArgs.get(i)))))
-                .collect(Collectors.toList());
+                .collect(toList());
 
         fieldInfo.add(columnName, typeFactory.createStructType(typesList)).nullable(true);
       } else {
@@ -212,7 +216,7 @@ List<String> getPartitionKeys(String columnFamily, boolean isView) {
     return table.getPartitionKey().stream()
         .map(ColumnMetadata::getName)
         .map(CqlIdentifier::asInternal)
-        .collect(Collectors.toList());
+        .collect(toList());
   }
 
   /**
@@ -225,7 +229,7 @@ List<String> getClusteringKeys(String columnFamily, boolean isView) {
     return table.getClusteringColumns().keySet().stream()
         .map(ColumnMetadata::getName)
         .map(CqlIdentifier::asInternal)
-        .collect(Collectors.toList());
+        .collect(toList());
   }
 
   /**
@@ -288,7 +292,7 @@ private void addMaterializedViews() {
       String columnsList =
           view.getColumns().values().stream()
               .map(c -> c.getName().asInternal())
-              .collect(Collectors.joining(", "));
+              .collect(joining(", "));
       queryBuilder.append(columnsList);
 
       queryBuilder.append(" FROM ").append(tableName);
@@ -302,7 +306,7 @@ private void addMaterializedViews() {
               + view.getName().asInternal()
               + "'";
 
-      Row whereClauseRow = Objects.requireNonNull(session.execute(whereQuery).one());
+      Row whereClauseRow = requireNonNull(session.execute(whereQuery).one());
 
       queryBuilder.append(" WHERE ").append(whereClauseRow.getString(0));
 
@@ -331,10 +335,11 @@ private void addMaterializedViews() {
       // Add the view for this query
       String viewName = "$" + getTableNames().size();
       SchemaPlus schema = parentSchema.getSubSchema(name);
-      if (schema == null) {
-        throw new IllegalStateException(
-            "Cannot find schema " + name + " in parent schema " + parentSchema.getName());
-      }
+      checkState(
+          schema != null,
+          "Cannot find schema %s in parent schema %s",
+          name,
+          parentSchema.getName());
       CalciteSchema calciteSchema = CalciteSchema.from(schema);
 
       List<String> viewPath = calciteSchema.path(viewName);
diff --git a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchemaFactory.java b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchemaFactory.java
index 24483183d..3b028616e 100644
--- a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchemaFactory.java
+++ b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchemaFactory.java
@@ -32,7 +32,8 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toMap;
 
 /** Factory that creates a {@link CassandraSchema}. */
 @SuppressWarnings("UnusedDeclaration")
@@ -94,7 +95,7 @@ private static Map<String, Object> projectMapOverKeys(
       Map<String, Object> map, Set<String> keysToKeep) {
     return map.entrySet().stream()
         .filter(e -> keysToKeep.contains(e.getKey()))
-        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+        .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));
   }
 
   private static int getPort(Map<String, Object> map) {
diff --git a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java
index 27b7b258b..c4e2e243d 100644
--- a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java
+++ b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraToEnumerableConverter.java
@@ -46,7 +46,8 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Relational expression representing a scan of a table in a Cassandra data source. */
 public class CassandraToEnumerableConverter extends ConverterImpl implements EnumerableRel {
@@ -99,7 +100,7 @@ protected CassandraToEnumerableConverter(
     final Expression table =
         list.append(
             "table",
-            Objects.requireNonNull(
+            requireNonNull(
                 cassandraImplementor.table.getExpression(CassandraTable.CassandraQueryable.class)));
     final Expression predicates =
         list.append(
diff --git a/core/src/main/java/org/apache/calcite/CalciteImmutable.java b/core/src/main/java/org/apache/calcite/CalciteImmutable.java
index f472d1022..d944e10b3 100644
--- a/core/src/main/java/org/apache/calcite/CalciteImmutable.java
+++ b/core/src/main/java/org/apache/calcite/CalciteImmutable.java
@@ -29,7 +29,7 @@
 @Value.Style(
     visibility = Value.Style.ImplementationVisibility.PACKAGE,
     defaults = @Value.Immutable(builder = true, singleton = true),
-    get = {"is*", "get*"},
+    get = {"get*", "is*"},
     init = "with*",
     passAnnotations = SuppressWarnings.class)
 public @interface CalciteImmutable {}
diff --git a/core/src/main/java/org/apache/calcite/adapter/clone/ArrayTable.java b/core/src/main/java/org/apache/calcite/adapter/clone/ArrayTable.java
index 0e23ff025..403e4227f 100644
--- a/core/src/main/java/org/apache/calcite/adapter/clone/ArrayTable.java
+++ b/core/src/main/java/org/apache/calcite/adapter/clone/ArrayTable.java
@@ -96,8 +96,8 @@ class ArrayTable extends AbstractQueryableTable implements ScannableTable {
   @Override public <T> Queryable<T> asQueryable(
       final QueryProvider queryProvider, SchemaPlus schema, String tableName) {
     return new AbstractTableQueryable<T>(queryProvider, schema, this, tableName) {
-      @SuppressWarnings("unchecked")
-      @Override public Enumerator<T> enumerator() {
+      @Override @SuppressWarnings("unchecked")
+      public Enumerator<T> enumerator() {
         final Content content = supplier.get();
         return content.enumerator();
       }
@@ -409,7 +409,7 @@ public static class ObjectDictionary implements Representation {
     }
 
     @Override public Object freeze(ColumnLoader.ValueSet valueSet, int @Nullable [] sources) {
-      final int n = valueSet.map.keySet().size();
+      final int n = valueSet.map.size();
       int extra = valueSet.containsNull ? 1 : 0;
       @SuppressWarnings("all")
       @Nullable
diff --git a/core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java b/core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
index 8e6763ecf..03b7a3c5c 100644
--- a/core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
+++ b/core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
@@ -189,7 +189,7 @@ private void load(final RelDataType elementType, List<ColumnMetaData.Rep> repLis
       for (Object o : list2) {
         valueSet.add((Comparable) o);
       }
-      if (sort != null && sort[0] < 0 && valueSet.map.keySet().size() == list.size()) {
+      if (sort != null && sort[0] < 0 && valueSet.map.size() == list.size()) {
         // We have discovered a the first unique key in the table.
         sort[0] = pair.i;
         // map.keySet().size() == list.size() above implies list contains only non-null elements
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java
index 88e3ac8bf..d800b6a56 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java
@@ -23,6 +23,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Represents internal state when implementing aggregate functions. */
 public class AggImpState {
   public final int aggIdx;
@@ -37,12 +39,11 @@ public AggImpState(int aggIdx, AggregateCall call, boolean windowContext) {
     this.aggIdx = aggIdx;
     this.call = call;
     AggImplementor implementor = RexImpTable.INSTANCE.get(call.getAggregation(), windowContext);
-    if (implementor == null) {
-      throw new IllegalArgumentException(
-          "Unable to get aggregate implementation for aggregate "
-              + call.getAggregation()
-              + (windowContext ? " in window context" : ""));
-    }
+    checkArgument(
+        implementor != null,
+        "Unable to get aggregate implementation for aggregate %s%s",
+        call.getAggregation(),
+        windowContext ? " in window context" : "");
     this.implementor = implementor;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
index 0f4a787bb..00a388fb2 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
@@ -82,6 +82,7 @@
 import java.util.function.Function;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.function.Function.identity;
 
 /** Utilities for generating programs in the Enumerable (functional) style. */
 public class EnumUtils {
@@ -847,7 +848,7 @@ private static class SessionizationEnumerator implements Enumerator<@Nullable Ob
     }
 
     @Override public boolean moveNext() {
-      return initialized ? list.size() > 0 : inputEnumerator.moveNext();
+      return initialized ? !list.isEmpty() : inputEnumerator.moveNext();
     }
 
     @Override public void reset() {
@@ -929,7 +930,7 @@ private void initialize() {
     }
 
     private static boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {
-      return !(b.left >= a.right);
+      return b.left < a.right;
     }
 
     private static Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {
@@ -992,7 +993,7 @@ private static class HopEnumerator implements Enumerator<@Nullable Object[]> {
     }
 
     @Override public @Nullable Object[] current() {
-      if (list.size() > 0) {
+      if (!list.isEmpty()) {
         return takeOne();
       } else {
         @Nullable Object[] current = inputEnumerator.current();
@@ -1013,7 +1014,7 @@ private static class HopEnumerator implements Enumerator<@Nullable Object[]> {
     }
 
     @Override public boolean moveNext() {
-      return list.size() > 0 || inputEnumerator.moveNext();
+      return !list.isEmpty() || inputEnumerator.moveNext();
     }
 
     @Override public void reset() {
@@ -1127,7 +1128,7 @@ public static Function<Object, Object> toExternal(RelDataType type, TimeZone tim
           return new Timestamp(v);
         };
       default:
-        return Function.identity();
+        return identity();
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java
index d65c5ea16..9ffe7817b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableInterpretable.java
@@ -57,9 +57,10 @@
 import java.lang.reflect.Modifier;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.concurrent.ExecutionException;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Relational expression that converts an enumerable input to interpretable calling convention.
  *
@@ -137,7 +138,7 @@ static Bindable getBindable(ClassDeclaration expr, String classBody, int fieldCo
           InvocationTargetException, InstantiationException, IllegalAccessException {
     ICompilerFactory compilerFactory;
     ClassLoader classLoader =
-        Objects.requireNonNull(EnumerableInterpretable.class.getClassLoader(), "classLoader");
+        requireNonNull(EnumerableInterpretable.class.getClassLoader(), "classLoader");
     try {
       compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory(classLoader);
     } catch (Exception e) {
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
index 148c14026..e48896665 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
@@ -93,7 +93,7 @@ protected EnumerableMergeJoin(
     }
 
     final List<RelCollation> collations = traits.getTraits(RelCollationTraitDef.INSTANCE);
-    assert collations != null && collations.size() > 0;
+    assert collations != null && !collations.isEmpty();
     ImmutableIntList rightKeys = joinInfo.rightKeys.incr(left.getRowType().getFieldCount());
     // Currently it has very limited ability to represent the equivalent traits
     // due to the flaw of RelCompositeTrait, so the following case is totally
@@ -368,12 +368,10 @@ private Mappings.TargetMapping buildMapping(boolean left2Right) {
       keyMap.put(sourceKeys.get(i), targetKeys.get(i));
     }
 
-    Mappings.TargetMapping mapping =
-        Mappings.target(
-            keyMap,
-            (left2Right ? left : right).getRowType().getFieldCount(),
-            (left2Right ? right : left).getRowType().getFieldCount());
-    return mapping;
+    return Mappings.target(
+        keyMap,
+        (left2Right ? left : right).getRowType().getFieldCount(),
+        (left2Right ? right : left).getRowType().getFieldCount());
   }
 
   /** This function extends collation by appending new collation fields defined on keys. */
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
index d9706b400..3d5f30b20 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
@@ -69,7 +69,7 @@ protected EnumerableMergeJoinRule(Config config) {
       // EnumerableMergeJoin only supports certain join types.
       return null;
     }
-    if (info.pairs().size() == 0) {
+    if (info.pairs().isEmpty()) {
       // EnumerableMergeJoin CAN support cartesian join, but disable it for now.
       return null;
     }
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeUnion.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeUnion.java
index dd8c129a4..aa50130e1 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeUnion.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeUnion.java
@@ -32,6 +32,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Implementation of {@link org.apache.calcite.rel.core.Union} in {@link
  * org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.
@@ -45,21 +47,17 @@ protected EnumerableMergeUnion(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
     super(cluster, traitSet, inputs, all);
     final RelCollation collation = traitSet.getCollation();
-    if (collation == null || collation.getFieldCollations().isEmpty()) {
-      throw new IllegalArgumentException("EnumerableMergeUnion with no collation");
-    }
+    checkArgument(
+        collation != null && !collation.getFieldCollations().isEmpty(),
+        "EnumerableMergeUnion with no collation");
     for (RelNode input : inputs) {
       final RelCollation inputCollation = input.getTraitSet().getCollation();
-      if (inputCollation == null || !inputCollation.satisfies(collation)) {
-        throw new IllegalArgumentException(
-            "EnumerableMergeUnion input does "
-                + "not satisfy collation. EnumerableMergeUnion collation: "
-                + collation
-                + ". Input collation: "
-                + inputCollation
-                + ". Input: "
-                + input);
-      }
+      checkArgument(
+          inputCollation != null && inputCollation.satisfies(collation),
+          "EnumerableMergeUnion input does not satisfy collation. EnumerableMergeUnion collation: %s. Input collation: %s. Input: %s",
+          collation,
+          inputCollation,
+          input);
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java
index 318ee5b92..cb838c2e2 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java
@@ -135,8 +135,7 @@ public static EnumerableNestedLoopJoin create(
 
     RelOptCost cost = planner.getCostFactory().makeCost(rowCount, 0, 0);
     // Give it some penalty
-    cost = cost.multiplyBy(10);
-    return cost;
+    return cost.multiplyBy(10);
   }
 
   @Override public @Nullable Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelFactories.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelFactories.java
index 97148be1e..b816b45c3 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelFactories.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelFactories.java
@@ -26,13 +26,13 @@
 import org.apache.calcite.rex.RexUtil;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Contains factory interface and default implementation for creating various rel nodes. */
 public class EnumerableRelFactories {
 
@@ -71,8 +71,7 @@ private static class ProjectFactoryImpl
         List<? extends RexNode> childExprs,
         @Nullable List<? extends @Nullable String> fieldNames,
         Set<CorrelationId> variablesSet) {
-      Preconditions.checkArgument(
-          variablesSet.isEmpty(), "EnumerableProject does not allow variables");
+      checkArgument(variablesSet.isEmpty(), "EnumerableProject does not allow variables");
       final RelDataType rowType =
           RexUtil.createStructType(
               input.getCluster().getTypeFactory(),
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
index 88ae5c1ff..9e1e1517d 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
@@ -62,7 +62,6 @@
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -178,11 +177,7 @@ public ClassDeclaration implementRoot(EnumerableRel rootRel, EnumerableRel.Prefe
                 Expressions.return_(
                     null, Expressions.constant(result.physType.getJavaRowType())))));
     return Expressions.classDecl(
-        Modifier.PUBLIC,
-        "Baz",
-        null,
-        Collections.singletonList(Bindable.class),
-        memberDeclarations);
+        Modifier.PUBLIC, "Baz", null, ImmutableList.of(Bindable.class), memberDeclarations);
   }
 
   private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordType type) {
@@ -254,7 +249,7 @@ private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordTyp
             Modifier.PUBLIC,
             boolean.class,
             "equals",
-            Collections.singletonList(oParameter),
+            ImmutableList.of(oParameter),
             blockBuilder2.toBlock()));
 
     // hashCode method:
@@ -282,11 +277,7 @@ private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordTyp
     blockBuilder3.add(Expressions.return_(null, hParameter));
     classDeclaration.memberDeclarations.add(
         Expressions.methodDecl(
-            Modifier.PUBLIC,
-            int.class,
-            "hashCode",
-            Collections.emptyList(),
-            blockBuilder3.toBlock()));
+            Modifier.PUBLIC, int.class, "hashCode", ImmutableList.of(), blockBuilder3.toBlock()));
 
     // compareTo method:
     //   public int compareTo(MyClass that) {
@@ -334,7 +325,7 @@ private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordTyp
             Modifier.PUBLIC,
             int.class,
             "compareTo",
-            Collections.singletonList(thatParameter),
+            ImmutableList.of(thatParameter),
             blockBuilder4.toBlock()));
 
     // toString method:
@@ -365,7 +356,7 @@ private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordTyp
             Modifier.PUBLIC,
             String.class,
             "toString",
-            Collections.emptyList(),
+            ImmutableList.of(),
             blockBuilder5.toBlock()));
 
     return classDeclaration;
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
index acc91f207..cef75bc5b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
@@ -57,6 +57,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.tree.Types.toClass;
 
 import static java.util.Objects.requireNonNull;
@@ -204,14 +206,11 @@ public static JavaRowFormat deduceFormat(RelOptTable table) {
 
   private Expression getExpression(PhysType physType) {
     final Expression expression = table.getExpression(Queryable.class);
-    if (expression == null) {
-      throw new IllegalStateException(
-          "Unable to implement "
-              + RelOptUtil.toString(this, SqlExplainLevel.ALL_ATTRIBUTES)
-              + ": "
-              + table
-              + ".getExpression(Queryable.class) returned null");
-    }
+    checkState(
+        expression != null,
+        "Unable to implement %s: %s.getExpression(Queryable.class) returned null",
+        RelOptUtil.toString(this, SqlExplainLevel.ALL_ATTRIBUTES),
+        table);
     final Expression expression2 = toEnumerable(expression);
     assert Types.isAssignableFrom(Enumerable.class, expression2.getType());
     return toRows(physType, expression2);
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTraitsUtils.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTraitsUtils.java
index be89fda9d..8269b80d7 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTraitsUtils.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTraitsUtils.java
@@ -43,7 +43,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Utilities for traits propagation. */
 @API(since = "1.24", status = API.Status.INTERNAL)
@@ -71,7 +72,7 @@ private static boolean isCollationOnTrivialExpr(
     if (node.isA(SqlKind.CAST)) {
       // Check whether it is a monotonic preserving cast
       final RexCall cast = (RexCall) node;
-      RelFieldCollation newFieldCollation = Objects.requireNonNull(RexUtil.apply(map, fc));
+      RelFieldCollation newFieldCollation = requireNonNull(RexUtil.apply(map, fc));
       final RexCallBinding binding =
           RexCallBinding.create(
               typeFactory, cast, ImmutableList.of(RelCollations.of(newFieldCollation)));
@@ -140,7 +141,7 @@ private static boolean isCollationOnTrivialExpr(
       }
     }
 
-    if (collationFieldsToDerive.size() > 0) {
+    if (!collationFieldsToDerive.isEmpty()) {
       final RelCollation newCollation = RelCollations.of(collationFieldsToDerive).apply(mapping);
       return Pair.of(
           currentTraits.replace(newCollation), ImmutableList.of(currentTraits.replace(collation)));
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
index ad07cc526..8adcdee8b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
@@ -29,10 +29,10 @@
 import org.apache.calcite.sql.type.MapSqlType;
 import org.apache.calcite.util.BuiltInMethod;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.primitives.Ints;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 import static org.apache.calcite.sql.type.NonNullableAccessors.getComponentTypeOrThrow;
@@ -54,7 +54,7 @@ public EnumerableUncollect(RelOptCluster cluster, RelTraitSet traitSet, RelNode
    */
   public EnumerableUncollect(
       RelOptCluster cluster, RelTraitSet traitSet, RelNode child, boolean withOrdinality) {
-    super(cluster, traitSet, child, withOrdinality, Collections.emptyList());
+    super(cluster, traitSet, child, withOrdinality, ImmutableList.of());
     assert getConvention() instanceof EnumerableConvention;
     assert getConvention() == child.getConvention();
   }
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
index f8f923134..23064eaa5 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableWindow.java
@@ -130,7 +130,7 @@ private WindowRelInputGetter(
     }
   }
 
-  @SuppressWarnings({"unused", "nullness"})
+  @SuppressWarnings({"nullness", "unused"})
   private static void sampleOfTheGeneratedWindowedAggregate() {
     // Here's overview of the generated code
     // For each list of rows that have the same partitioning key, evaluate
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java
index 1ff56c31c..c391bbdb9 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/PhysTypeImpl.java
@@ -221,8 +221,8 @@ static PhysType of(final JavaTypeFactory typeFactory, Type javaRowClass) {
         format);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public Expression convertTo(Expression exp, PhysType targetPhysType) {
+  @Override @SuppressWarnings("deprecation")
+  public Expression convertTo(Expression exp, PhysType targetPhysType) {
     return convertTo(exp, targetPhysType.getFormat());
   }
 
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
index 0887a4b1f..82338a8b3 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
@@ -89,16 +89,14 @@
 import java.math.RoundingMode;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.function.Supplier;
-import java.util.stream.Collectors;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 
 import static org.apache.calcite.adapter.enumerable.EnumUtils.generateCollatorExpression;
 import static org.apache.calcite.linq4j.tree.ExpressionType.Add;
@@ -429,6 +427,7 @@
 import static org.apache.calcite.sql.fun.SqlStdOperatorTable.USER;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Contains implementations of Rex operators as Java code.
@@ -1047,10 +1046,10 @@ private static RexCallImplementor wrapAsRexCallImplementor(final CallImplementor
   public @Nullable RexCallImplementor get(final SqlOperator operator) {
     if (operator instanceof SqlUserDefinedFunction) {
       org.apache.calcite.schema.Function udf = ((SqlUserDefinedFunction) operator).getFunction();
-      if (!(udf instanceof ImplementableFunction)) {
-        throw new IllegalStateException(
-            "User defined function " + operator + " must implement ImplementableFunction");
-      }
+      checkState(
+          (udf instanceof ImplementableFunction),
+          "User defined function %s must implement ImplementableFunction",
+          operator);
       CallImplementor implementor = ((ImplementableFunction) udf).getImplementor();
       return wrapAsRexCallImplementor(implementor);
     } else if (operator instanceof SqlTypeConstructorFunction) {
@@ -1063,10 +1062,10 @@ private static RexCallImplementor wrapAsRexCallImplementor(final CallImplementor
       final SqlAggFunction aggregation, boolean forWindowAggregate) {
     if (aggregation instanceof SqlUserDefinedAggFunction) {
       final SqlUserDefinedAggFunction udaf = (SqlUserDefinedAggFunction) aggregation;
-      if (!(udaf.function instanceof ImplementableAggFunction)) {
-        throw new IllegalStateException(
-            "User defined aggregation " + aggregation + " must implement ImplementableAggFunction");
-      }
+      checkState(
+          (udaf.function instanceof ImplementableAggFunction),
+          "User defined aggregation %s must implement ImplementableAggFunction",
+          aggregation);
       return ((ImplementableAggFunction) udaf.function).getImplementor(forWindowAggregate);
     }
     if (forWindowAggregate) {
@@ -1277,7 +1276,7 @@ static class CountWinImplementor extends StrictWinAggImplementor {
       }
       if (!hasNullable) {
         justFrameRowCount = true;
-        return Collections.emptyList();
+        return ImmutableList.of();
       }
       return super.getNotNullState(info);
     }
@@ -1761,7 +1760,7 @@ public UserDefinedAggReflectiveImplementor(AggregateFunctionImpl afi) {
 
     @Override public List<Type> getNotNullState(AggContext info) {
       if (afi.isStatic) {
-        return Collections.singletonList(afi.accumulatorType);
+        return ImmutableList.of(afi.accumulatorType);
       }
       return Arrays.asList(afi.accumulatorType, afi.declaringClass);
     }
@@ -1785,14 +1784,14 @@ public UserDefinedAggReflectiveImplementor(AggregateFunctionImpl afi) {
     private static NewExpression makeNew(AggregateFunctionImpl afi) {
       try {
         Constructor<?> constructor = afi.declaringClass.getConstructor();
-        Objects.requireNonNull(constructor, "constructor");
+        requireNonNull(constructor, "constructor");
         return Expressions.new_(afi.declaringClass);
       } catch (NoSuchMethodException e) {
         // ignore, and try next constructor
       }
       try {
         Constructor<?> constructor = afi.declaringClass.getConstructor(FunctionContext.class);
-        Objects.requireNonNull(constructor, "constructor");
+        requireNonNull(constructor, "constructor");
         return Expressions.new_(
             afi.declaringClass,
             Expressions.call(
@@ -1907,7 +1906,7 @@ protected FirstLastValueImplementor(SeekType seekType) {
     }
 
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -1951,7 +1950,7 @@ protected LastValueImplementor() {
   /** Implementor for the {@code NTH_VALUE} windowed aggregate function. */
   static class NthValueImplementor implements WinAggImplementor {
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2015,7 +2014,7 @@ protected LeadLagImplementor(boolean isLead) {
     }
 
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2095,7 +2094,7 @@ protected LagImplementor() {
   /** Implementor for the {@code NTILE} windowed aggregate function. */
   static class NtileImplementor implements WinAggImplementor {
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2130,7 +2129,7 @@ static class NtileImplementor implements WinAggImplementor {
   /** Implementor for the {@code ROW_NUMBER} windowed aggregate function. */
   static class RowNumberImplementor extends StrictWinAggImplementor {
     @Override public List<Type> getNotNullState(WinAggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override protected void implementNotNullAdd(WinAggContext info, WinAggAddContext add) {
@@ -2157,7 +2156,7 @@ static Supplier<JsonObjectAggImplementor> supplierFor(Method m) {
     }
 
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.singletonList(Map.class);
+      return ImmutableList.of(Map.class);
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2176,10 +2175,9 @@ static Supplier<JsonObjectAggImplementor> supplierFor(Method m) {
                   Expressions.call(
                       m,
                       Iterables.concat(
-                          Collections.singletonList(add.accumulator().get(0)),
+                          ImmutableList.of(add.accumulator().get(0)),
                           add.arguments(),
-                          Collections.singletonList(
-                              Expressions.constant(function.getNullClause()))))));
+                          ImmutableList.of(Expressions.constant(function.getNullClause()))))));
     }
 
     @Override public Expression implementResult(AggContext info, AggResultContext result) {
@@ -2200,7 +2198,7 @@ static Supplier<JsonArrayAggImplementor> supplierFor(Method m) {
     }
 
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.singletonList(List.class);
+      return ImmutableList.of(List.class);
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2220,10 +2218,9 @@ static Supplier<JsonArrayAggImplementor> supplierFor(Method m) {
                   Expressions.call(
                       m,
                       Iterables.concat(
-                          Collections.singletonList(add.accumulator().get(0)),
+                          ImmutableList.of(add.accumulator().get(0)),
                           add.arguments(),
-                          Collections.singletonList(
-                              Expressions.constant(function.getNullClause()))))));
+                          ImmutableList.of(Expressions.constant(function.getNullClause()))))));
     }
 
     @Override public Expression implementResult(AggContext info, AggResultContext result) {
@@ -2612,7 +2609,7 @@ private static class JsonValueImplementor extends MethodImplementor {
       Expression errorBehavior = Expressions.constant(SqlJsonValueEmptyOrErrorBehavior.NULL);
       Expression defaultValueOnError = Expressions.constant(null);
       // Patched up with user defines.
-      if (leftExprs.size() > 0) {
+      if (!leftExprs.isEmpty()) {
         for (int i = 0; i < leftExprs.size(); i++) {
           Expression expr = leftExprs.get(i);
           final Object exprVal = translator.getLiteralValue(expr);
@@ -2818,7 +2815,7 @@ private static class UnaryImplementor extends AbstractRexCallImplementor {
       // BigDecimal, we should call negate method of BigDecimal
       if (expressionType == ExpressionType.Negate
           && argValue.type == BigDecimal.class
-          && null != backupMethodName) {
+          && backupMethodName != null) {
         e = Expressions.call(argValue, backupMethodName);
       } else {
         e = Expressions.makeUnary(expressionType, argValue);
@@ -3739,7 +3736,7 @@ private List<Expression> unboxIfNecessary(final List<Expression> argValueList) {
         unboxValueList =
             argValueList.stream()
                 .map(AbstractRexCallImplementor::unboxExpression)
-                .collect(Collectors.toList());
+                .collect(toList());
       }
       if (nullPolicy == NullPolicy.ARG0 && !argValueList.isEmpty()) {
         final Expression unboxArg0 = unboxExpression(unboxValueList.get(0));
@@ -3795,7 +3792,7 @@ private static class LogicalAndImplementor extends AbstractRexCallImplementor {
               .map(
                   result ->
                       Expressions.condition(result.isNullVariable, TRUE_EXPR, result.valueVariable))
-              .collect(Collectors.toList());
+              .collect(toList());
       final Expression hasFalse = Expressions.not(Expressions.foldAnd(nullAsTrue));
       final Expression hasNull = Expressions.foldOr(argIsNullList);
       final Expression callExpression =
@@ -3857,7 +3854,7 @@ private static class LogicalOrImplementor extends AbstractRexCallImplementor {
                   result ->
                       Expressions.condition(
                           result.isNullVariable, FALSE_EXPR, result.valueVariable))
-              .collect(Collectors.toList());
+              .collect(toList());
       final Expression hasTrue = Expressions.foldOr(nullAsFalse);
       final Expression hasNull = Expressions.foldOr(argIsNullList);
       final Expression callExpression =
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
index 84af8160f..d2204d91b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
@@ -25,9 +25,10 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 
+import com.google.common.collect.ImmutableList;
+
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -83,7 +84,7 @@ public List<Type> getNotNullState(AggContext info) {
     Type type = info.returnType();
     type = EnumUtils.fromInternal(type);
     type = Primitive.unbox(type);
-    return Collections.singletonList(type);
+    return ImmutableList.of(type);
   }
 
   @Override public final void implementReset(AggContext info, AggResetContext reset) {
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggAddContextImpl.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggAddContextImpl.java
index 181dc6360..a3ae7f50c 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggAddContextImpl.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggAddContextImpl.java
@@ -37,8 +37,8 @@ protected WinAggAddContextImpl(
     super(block, accumulator, frame);
   }
 
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   protected WinAggAddContextImpl(
       BlockBuilder block,
       List<Expression> accumulator,
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggResultContextImpl.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggResultContextImpl.java
index bd4245b0f..190998496 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggResultContextImpl.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/impl/WinAggResultContextImpl.java
@@ -46,8 +46,8 @@ protected WinAggResultContextImpl(
     this.frame = frameContextBuilder;
   }
 
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   protected WinAggResultContextImpl(
       BlockBuilder block,
       List<Expression> accumulator,
diff --git a/core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java b/core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
index 493715381..87da4e9d2 100644
--- a/core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
+++ b/core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
@@ -48,8 +48,10 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
 
@@ -61,7 +63,6 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -102,8 +103,8 @@ public Object getTarget() {
     return target;
   }
 
-  @SuppressWarnings({"rawtypes", "unchecked"})
-  @Override protected Map<String, Table> getTableMap() {
+  @Override @SuppressWarnings({"rawtypes", "unchecked"})
+  protected Map<String, Table> getTableMap() {
     if (tableMap == null) {
       tableMap = createTableMap();
     }
@@ -142,7 +143,7 @@ private Map<String, Table> createTableMap() {
         table.statistic =
             Statistics.of(
                 ImmutableList.copyOf(
-                    Iterables.concat(referentialConstraints, Collections.singleton(rc))));
+                    Iterables.concat(referentialConstraints, ImmutableSet.of(rc))));
       }
     }
     return tableMap;
@@ -156,7 +157,7 @@ private Map<String, Table> createTableMap() {
   }
 
   private Multimap<String, Function> createFunctionMap() {
-    final ImmutableMultimap.Builder<String, Function> builder = ImmutableMultimap.builder();
+    final ImmutableMultimap.Builder<String, Function> builder = ImmutableListMultimap.builder();
     for (Method method : clazz.getMethods()) {
       final String methodName = method.getName();
       if (method.getDeclaringClass() == Object.class || methodName.equals("toString")) {
@@ -256,8 +257,8 @@ private static class ReflectiveTable extends AbstractQueryableTable
     @Override public <T> Queryable<T> asQueryable(
         QueryProvider queryProvider, SchemaPlus schema, String tableName) {
       return new AbstractTableQueryable<T>(queryProvider, schema, this, tableName) {
-        @SuppressWarnings("unchecked")
-        @Override public Enumerator<T> enumerator() {
+        @Override @SuppressWarnings("unchecked")
+        public Enumerator<T> enumerator() {
           return (Enumerator<T>) enumerable.enumerator();
         }
       };
diff --git a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java
index f7ebf1cce..5095dd2f9 100644
--- a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java
+++ b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java
@@ -60,8 +60,7 @@ public class JdbcCatalogSchema extends AbstractSchema {
 
   /** Sub-schemas by name, lazily initialized. */
   @SuppressWarnings("method.invocation.invalid")
-  final Supplier<SubSchemaMap> subSchemaMapSupplier =
-      Suppliers.memoize(() -> computeSubSchemaMap());
+  final Supplier<SubSchemaMap> subSchemaMapSupplier = Suppliers.memoize(this::computeSubSchemaMap);
 
   /** Creates a JdbcCatalogSchema. */
   public JdbcCatalogSchema(
diff --git a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java
index 85dd42fee..5daca74f5 100644
--- a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java
+++ b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcRules.java
@@ -71,7 +71,6 @@
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.trace.CalciteTrace;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
@@ -83,6 +82,8 @@
 import java.util.Set;
 import java.util.function.Consumer;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Rules and relational operators for {@link JdbcConvention} calling convention. */
@@ -93,7 +94,7 @@ private JdbcRules() {}
 
   static final RelFactories.ProjectFactory PROJECT_FACTORY =
       (input, hints, projects, fieldNames, variablesSet) -> {
-        Preconditions.checkArgument(variablesSet.isEmpty(), "JdbcProject does not allow variables");
+        checkArgument(variablesSet.isEmpty(), "JdbcProject does not allow variables");
         final RelOptCluster cluster = input.getCluster();
         final RelDataType rowType =
             RexUtil.createStructType(
@@ -103,7 +104,7 @@ private JdbcRules() {}
 
   static final RelFactories.FilterFactory FILTER_FACTORY =
       (input, condition, variablesSet) -> {
-        Preconditions.checkArgument(variablesSet.isEmpty(), "JdbcFilter does not allow variables");
+        checkArgument(variablesSet.isEmpty(), "JdbcFilter does not allow variables");
         return new JdbcFilter(input.getCluster(), input.getTraitSet(), input, condition);
       };
 
diff --git a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
index 3a09adad4..97a5c4bc7 100644
--- a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
+++ b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
@@ -41,9 +41,10 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
+import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
@@ -177,7 +178,7 @@ public static JdbcSchema create(
     String jdbcSchema = (String) operand.get("jdbcSchema");
     String sqlDialectFactory = (String) operand.get("sqlDialectFactory");
 
-    if (sqlDialectFactory == null || sqlDialectFactory.isEmpty()) {
+    if (Strings.isNullOrEmpty(sqlDialectFactory)) {
       return JdbcSchema.create(parentSchema, name, dataSource, jdbcCatalog, jdbcSchema);
     } else {
       SqlDialectFactory factory =
@@ -235,7 +236,7 @@ public DataSource getDataSource() {
 
   protected Multimap<String, Function> getFunctions() {
     // TODO: populate map from JDBC metadata
-    return ImmutableMultimap.of();
+    return ImmutableListMultimap.of();
   }
 
   @Override public final Collection<Function> getFunctions(String name) {
diff --git a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTableScan.java b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTableScan.java
index 5ce8862d3..fea63975b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTableScan.java
+++ b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcTableScan.java
@@ -27,7 +27,6 @@
 import com.google.common.collect.ImmutableList;
 
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
@@ -44,7 +43,7 @@ protected JdbcTableScan(
       JdbcTable jdbcTable,
       JdbcConvention jdbcConvention) {
     super(cluster, cluster.traitSetOf(jdbcConvention), hints, table);
-    this.jdbcTable = Objects.requireNonNull(jdbcTable, "jdbcTable");
+    this.jdbcTable = requireNonNull(jdbcTable, "jdbcTable");
   }
 
   @Override public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
diff --git a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java
index abe4ea7ff..e25b8de91 100644
--- a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java
+++ b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcToEnumerableConverter.java
@@ -59,12 +59,12 @@
 import java.util.Calendar;
 import java.util.List;
 import java.util.TimeZone;
-import java.util.stream.Collectors;
 import javax.sql.DataSource;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /** Relational expression representing a scan of a table in a JDBC data source. */
 public class JdbcToEnumerableConverter extends ConverterImpl implements EnumerableRel {
@@ -208,7 +208,7 @@ private static List<ConstantExpression> toIndexesTableExpression(SqlString sqlSt
             () -> "sqlString.getDynamicParameters() is null for " + sqlString)
         .stream()
         .map(Expressions::constant)
-        .collect(Collectors.toList());
+        .collect(toList());
   }
 
   private static UnaryExpression getTimeZoneExpression(EnumerableRelImplementor implementor) {
diff --git a/core/src/main/java/org/apache/calcite/config/Lex.java b/core/src/main/java/org/apache/calcite/config/Lex.java
index 16a681275..deb333c2f 100644
--- a/core/src/main/java/org/apache/calcite/config/Lex.java
+++ b/core/src/main/java/org/apache/calcite/config/Lex.java
@@ -21,9 +21,10 @@
 
 import com.google.common.collect.ImmutableSet;
 
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Named, built-in lexical policy. A lexical policy describes how identifiers are quoted, whether
  * they are converted to upper- or lower-case when they are read, and whether they are matched
@@ -97,9 +98,9 @@ public enum Lex {
       Casing quotedCasing,
       boolean caseSensitive,
       CharLiteralStyle... charLiteralStyles) {
-    this.quoting = Objects.requireNonNull(quoting, "quoting");
-    this.unquotedCasing = Objects.requireNonNull(unquotedCasing, "unquotedCasing");
-    this.quotedCasing = Objects.requireNonNull(quotedCasing, "quotedCasing");
+    this.quoting = requireNonNull(quoting, "quoting");
+    this.unquotedCasing = requireNonNull(unquotedCasing, "unquotedCasing");
+    this.quotedCasing = requireNonNull(quotedCasing, "quotedCasing");
     this.caseSensitive = caseSensitive;
     this.charLiteralStyles = ImmutableSet.copyOf(charLiteralStyles);
   }
diff --git a/core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java b/core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
index 86b4f629c..5cb6302de 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
@@ -44,6 +44,7 @@
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.Comparators;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -499,7 +500,7 @@ public static class BigDecimalSum {
     public BigDecimalSum() {}
 
     public BigDecimal init() {
-      return new BigDecimal("0");
+      return BigDecimal.ZERO;
     }
 
     public BigDecimal add(BigDecimal accumulator, BigDecimal v) {
@@ -593,7 +594,7 @@ public MinDouble() {
    */
   public static class MinBigDecimal extends NumericComparison<BigDecimal> {
     public MinBigDecimal() {
-      super(new BigDecimal(Double.MAX_VALUE), MinBigDecimal::min);
+      super(BigDecimal.valueOf(Double.MAX_VALUE), MinBigDecimal::min);
     }
 
     public static BigDecimal min(BigDecimal a, BigDecimal b) {
@@ -613,7 +614,7 @@ public Boolean init() {
     }
 
     public Boolean add(Boolean accumulator, Boolean value) {
-      return accumulator.compareTo(value) < 0 ? accumulator : value;
+      return Comparators.min(value, accumulator);
     }
 
     public Boolean merge(Boolean accumulator0, Boolean accumulator1) {
@@ -671,7 +672,7 @@ public MaxDouble() {
    */
   public static class MaxBigDecimal extends NumericComparison<BigDecimal> {
     public MaxBigDecimal() {
-      super(new BigDecimal(Double.MIN_VALUE), MaxBigDecimal::max);
+      super(BigDecimal.valueOf(Double.MIN_VALUE), MaxBigDecimal::max);
     }
 
     public static BigDecimal max(BigDecimal a, BigDecimal b) {
diff --git a/core/src/main/java/org/apache/calcite/interpreter/Bindables.java b/core/src/main/java/org/apache/calcite/interpreter/Bindables.java
index bafa900b8..9f668c4e7 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/Bindables.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/Bindables.java
@@ -76,7 +76,6 @@
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.ImmutableIntList;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
@@ -85,10 +84,13 @@
 
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 import java.util.SortedSet;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /** Utilities pertaining to {@link BindableRel} and {@link BindableConvention}. */
 @Value.Enclosing
 public class Bindables {
@@ -218,9 +220,9 @@ public static class BindableTableScan extends TableScan implements BindableRel {
         ImmutableList<RexNode> filters,
         ImmutableIntList projects) {
       super(cluster, traitSet, ImmutableList.of(), table);
-      this.filters = Objects.requireNonNull(filters, "filters");
-      this.projects = Objects.requireNonNull(projects, "projects");
-      Preconditions.checkArgument(canHandle(table));
+      this.filters = requireNonNull(filters, "filters");
+      this.projects = requireNonNull(projects, "projects");
+      checkArgument(canHandle(table));
     }
 
     /** Creates a BindableTableScan. */
diff --git a/core/src/main/java/org/apache/calcite/interpreter/Interpreter.java b/core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
index 81feb1e9f..4da8bbe04 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
@@ -43,10 +43,8 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.initialization.qual.NotOnlyInitialized;
@@ -84,7 +82,7 @@ public Interpreter(DataContext dataContext, RelNode rootRel) {
     @SuppressWarnings("method.invocation.invalid")
     Pair<RelNode, Map<RelNode, NodeInfo>> pair = compiler.visitRoot(rel);
     this.rootRel = pair.left;
-    this.nodes = ImmutableMap.copyOf(pair.right);
+    this.nodes = pair.right;
   }
 
   private static RelNode optimize(RelNode rootRel) {
@@ -99,8 +97,7 @@ private static RelNode optimize(RelNode rootRel) {
             .build();
     final HepPlanner planner = new HepPlanner(hepProgram);
     planner.setRoot(rootRel);
-    rootRel = planner.findBestExp();
-    return rootRel;
+    return planner.findBestExp();
   }
 
   @Override public Enumerator<@Nullable Object[]> enumerator() {
@@ -199,8 +196,8 @@ private ListSink(ArrayDeque<Row> list) {
 
     @Override public void end() throws InterruptedException {}
 
-    @SuppressWarnings("deprecation")
-    @Override public void setSourceEnumerable(Enumerable<Row> enumerable) throws InterruptedException {
+    @Override @SuppressWarnings("deprecation")
+    public void setSourceEnumerable(Enumerable<Row> enumerable) throws InterruptedException {
       // just copy over the source into the local list
       final Enumerator<Row> enumerator = enumerable.enumerator();
       while (enumerator.moveNext()) {
@@ -241,7 +238,7 @@ private static class DuplicatingSink implements Sink {
     private List<ArrayDeque<Row>> queues;
 
     private DuplicatingSink(List<ArrayDeque<Row>> queues) {
-      this.queues = ImmutableList.copyOf(queues);
+      this.queues = queues;
     }
 
     @Override public void send(Row row) throws InterruptedException {
@@ -252,8 +249,8 @@ private DuplicatingSink(List<ArrayDeque<Row>> queues) {
 
     @Override public void end() throws InterruptedException {}
 
-    @SuppressWarnings("deprecation")
-    @Override public void setSourceEnumerable(Enumerable<Row> enumerable) throws InterruptedException {
+    @Override @SuppressWarnings("deprecation")
+    public void setSourceEnumerable(Enumerable<Row> enumerable) throws InterruptedException {
       // just copy over the source into the local list
       final Enumerator<Row> enumerator = enumerable.enumerator();
       while (enumerator.moveNext()) {
@@ -317,7 +314,7 @@ Pair<RelNode, Map<RelNode, NodeInfo>> visitRoot(RelNode p) {
         if (parent != null) {
           List<RelNode> inputs = relInputs.get(parent);
           if (inputs == null) {
-            inputs = Lists.newArrayList(parent.getInputs());
+            inputs = new ArrayList<>(parent.getInputs());
             relInputs.put(parent, inputs);
           }
           inputs.set(ordinal, p);
diff --git a/core/src/main/java/org/apache/calcite/interpreter/JaninoRexCompiler.java b/core/src/main/java/org/apache/calcite/interpreter/JaninoRexCompiler.java
index 959bbd072..4017e6d63 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/JaninoRexCompiler.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/JaninoRexCompiler.java
@@ -54,7 +54,8 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Compiles a scalar expression ({@link RexNode}) to an expression that can be evaluated ({@link
@@ -213,7 +214,7 @@ static Scalar.Producer getScalar(ClassDeclaration expr, String s)
       throws CompileException, IOException {
     ICompilerFactory compilerFactory;
     ClassLoader classLoader =
-        Objects.requireNonNull(JaninoRexCompiler.class.getClassLoader(), "classLoader");
+        requireNonNull(JaninoRexCompiler.class.getClassLoader(), "classLoader");
     try {
       compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory(classLoader);
     } catch (Exception e) {
diff --git a/core/src/main/java/org/apache/calcite/interpreter/TableFunctionScanNode.java b/core/src/main/java/org/apache/calcite/interpreter/TableFunctionScanNode.java
index 850dc6616..097964024 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/TableFunctionScanNode.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/TableFunctionScanNode.java
@@ -54,7 +54,7 @@ private TableFunctionScanNode(Compiler compiler, TableFunctionScan rel) {
   @Override public void run() throws InterruptedException {
     final Object o = scalar.execute(context);
     if (o instanceof Enumerable) {
-      for (@SuppressWarnings({"unchecked", "rawtypes"})
+      for (@SuppressWarnings({"rawtypes", "unchecked"})
           final Enumerator<Row> enumerator = ((Enumerable) o).select(mapFn).enumerator();
           enumerator.moveNext(); ) {
         sink.send(enumerator.current());
diff --git a/core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java b/core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java
index c9934c6df..e8f561500 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java
@@ -42,13 +42,13 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
+import java.util.ArrayList;
 import java.util.List;
 
 import static org.apache.calcite.util.Static.RESOURCE;
@@ -173,7 +173,7 @@ private static TableScanNode createFilterable(
       @Nullable ImmutableIntList projects,
       FilterableTable filterableTable) {
     final DataContext root = compiler.getDataContext();
-    final List<RexNode> mutableFilters = Lists.newArrayList(filters);
+    final List<RexNode> mutableFilters = new ArrayList<>(filters);
     final Enumerable<@Nullable Object[]> enumerable = filterableTable.scan(root, mutableFilters);
     for (RexNode filter : mutableFilters) {
       if (!filters.contains(filter)) {
@@ -193,7 +193,7 @@ private static TableScanNode createProjectableFilterable(
     final DataContext root = compiler.getDataContext();
     final ImmutableIntList originalProjects = projects;
     for (; ; ) {
-      final List<RexNode> mutableFilters = Lists.newArrayList(filters);
+      final List<RexNode> mutableFilters = new ArrayList<>(filters);
       final int[] projectInts;
       if (projects == null || projects.equals(TableScan.identity(rel.getTable()))) {
         projectInts = null;
diff --git a/core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java b/core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java
index ee76e5bee..ad08f9f02 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java
@@ -22,6 +22,8 @@
 import java.util.Locale;
 import java.util.Map;
 
+import static java.util.Objects.requireNonNull;
+
 /** Interpreter node that implements a {@link org.apache.calcite.rel.core.Uncollect}. */
 public class UncollectNode extends AbstractSingleNode<Uncollect> {
 
@@ -33,9 +35,7 @@ public UncollectNode(Compiler compiler, Uncollect uncollect) {
     Row row = null;
     while ((row = source.receive()) != null) {
       for (Object value : row.getValues()) {
-        if (value == null) {
-          throw new NullPointerException("NULL value for unnest.");
-        }
+        requireNonNull(value, "NULL value for unnest.");
         int i = 1;
         if (value instanceof List) {
           List list = (List) value;
diff --git a/core/src/main/java/org/apache/calcite/jdbc/CalciteConnectionImpl.java b/core/src/main/java/org/apache/calcite/jdbc/CalciteConnectionImpl.java
index be25f1c27..c6c69f52b 100644
--- a/core/src/main/java/org/apache/calcite/jdbc/CalciteConnectionImpl.java
+++ b/core/src/main/java/org/apache/calcite/jdbc/CalciteConnectionImpl.java
@@ -68,7 +68,6 @@
 import org.apache.calcite.util.Holder;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
@@ -88,6 +87,8 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -147,7 +148,7 @@ protected CalciteConnectionImpl(
     }
     this.rootSchema =
         requireNonNull(rootSchema != null ? rootSchema : CalciteSchema.createRootSchema(true));
-    Preconditions.checkArgument(this.rootSchema.isRoot(), "must be root schema");
+    checkArgument(this.rootSchema.isRoot(), "must be root schema");
     this.properties.put(InternalProperty.CASE_SENSITIVE, cfg.caseSensitive());
     this.properties.put(InternalProperty.UNQUOTED_CASING, cfg.unquotedCasing());
     this.properties.put(InternalProperty.QUOTED_CASING, cfg.quotedCasing());
diff --git a/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java b/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
index c0cf8a567..9b51d9762 100644
--- a/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
+++ b/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
@@ -74,7 +74,6 @@
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -193,7 +192,7 @@ private <E> MetaResultSet createResultSet(
     //noinspection unchecked
     final Iterable<Object> iterable = (Iterable<Object>) (Iterable) enumerable;
     return createResultSet(
-        Collections.emptyMap(),
+        ImmutableMap.of(),
         columns,
         CursorFactory.record(clazz, fields, fieldNames),
         new Frame(0, true, iterable));
@@ -472,7 +471,7 @@ public Enumerable<MetaColumn> columns(final MetaTable table_) {
                   Optional.ofNullable(field.getType().getMeasureElementType())
                       .map(RelDataType::getSqlTypeName)
                       .map(SqlTypeName::getJdbcOrdinal)
-                      .orElse(field.getType().getSqlTypeName().getJdbcOrdinal());
+                      .orElseGet(() -> field.getType().getSqlTypeName().getJdbcOrdinal());
               return new MetaColumn(
                   table.tableCat,
                   table.tableSchem,
@@ -613,8 +612,8 @@ Iterable<Object> _createIterable(
     return h;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public ExecuteResult prepareAndExecute(
+  @Override @SuppressWarnings("deprecation")
+  public ExecuteResult prepareAndExecute(
       StatementHandle h, String sql, long maxRowCount, PrepareCallback callback)
       throws NoSuchStatementException {
     return prepareAndExecute(h, sql, maxRowCount, -1, callback);
@@ -703,8 +702,8 @@ private static CalcitePrepare.Query<Object> toQuery(Context context, String sql)
     return new Meta.Frame(offset, done, rows1);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public ExecuteResult execute(
+  @Override @SuppressWarnings("deprecation")
+  public ExecuteResult execute(
       StatementHandle h, List<TypedValue> parameterValues, long maxRowCount)
       throws NoSuchStatementException {
     return execute(h, parameterValues, Ints.saturatedCast(maxRowCount));
@@ -728,7 +727,7 @@ private static CalcitePrepare.Query<Object> toQuery(Context context, String sql)
     } else {
       // Don't populate the first frame.
       // It's not worth saving a round-trip, since we're local.
-      final Meta.Frame frame = new Meta.Frame(0, false, Collections.emptyList());
+      final Meta.Frame frame = new Meta.Frame(0, false, ImmutableList.of());
       metaResultSet = MetaResultSet.create(h.connectionId, h.id, false, signature, frame);
     }
 
@@ -854,8 +853,8 @@ abstract static class MetadataTable<E> extends AbstractQueryableTable {
       return Schema.TableType.SYSTEM_TABLE;
     }
 
-    @SuppressWarnings("unchecked")
-    @Override public Class<E> getElementType() {
+    @Override @SuppressWarnings("unchecked")
+    public Class<E> getElementType() {
       return (Class<E>) elementType;
     }
 
@@ -864,8 +863,8 @@ abstract static class MetadataTable<E> extends AbstractQueryableTable {
     @Override public <T> Queryable<T> asQueryable(
         QueryProvider queryProvider, SchemaPlus schema, String tableName) {
       return new AbstractTableQueryable<T>(queryProvider, schema, this, tableName) {
-        @SuppressWarnings("unchecked")
-        @Override public Enumerator<T> enumerator() {
+        @Override @SuppressWarnings("unchecked")
+        public Enumerator<T> enumerator() {
           return (Enumerator<T>)
               MetadataTable.this.enumerator(((CalciteConnectionImpl) queryProvider).meta());
         }
diff --git a/core/src/main/java/org/apache/calcite/jdbc/CalcitePrepare.java b/core/src/main/java/org/apache/calcite/jdbc/CalcitePrepare.java
index 95b80a515..07abb4fbb 100644
--- a/core/src/main/java/org/apache/calcite/jdbc/CalcitePrepare.java
+++ b/core/src/main/java/org/apache/calcite/jdbc/CalcitePrepare.java
@@ -47,7 +47,6 @@
 import org.apache.calcite.util.ImmutableIntList;
 
 import com.fasterxml.jackson.annotation.JsonIgnore;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -60,6 +59,8 @@
 import java.util.List;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -322,7 +323,7 @@ public AnalyzeViewResult(
       this.constraint = constraint;
       this.columnMapping = columnMapping;
       this.modifiable = modifiable;
-      Preconditions.checkArgument(modifiable == (table != null));
+      checkArgument(modifiable == (table != null));
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/jdbc/CalciteSchema.java b/core/src/main/java/org/apache/calcite/jdbc/CalciteSchema.java
index de3f550c7..1376749e7 100644
--- a/core/src/main/java/org/apache/calcite/jdbc/CalciteSchema.java
+++ b/core/src/main/java/org/apache/calcite/jdbc/CalciteSchema.java
@@ -35,7 +35,6 @@
 import org.apache.calcite.util.NameSet;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.ImmutableSortedSet;
@@ -49,10 +48,13 @@
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.NavigableSet;
-import java.util.Objects;
 import java.util.Set;
 import javax.sql.DataSource;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Schema.
  *
@@ -92,17 +94,17 @@ protected CalciteSchema(
     if (tableMap == null) {
       this.tableMap = new NameMap<>();
     } else {
-      this.tableMap = Objects.requireNonNull(tableMap, "tableMap");
+      this.tableMap = requireNonNull(tableMap, "tableMap");
     }
     if (latticeMap == null) {
       this.latticeMap = new NameMap<>();
     } else {
-      this.latticeMap = Objects.requireNonNull(latticeMap, "latticeMap");
+      this.latticeMap = requireNonNull(latticeMap, "latticeMap");
     }
     if (subSchemaMap == null) {
       this.subSchemaMap = new NameMap<>();
     } else {
-      this.subSchemaMap = Objects.requireNonNull(subSchemaMap, "subSchemaMap");
+      this.subSchemaMap = requireNonNull(subSchemaMap, "subSchemaMap");
     }
     if (functionMap == null) {
       this.functionMap = new NameMultimap<>();
@@ -111,14 +113,14 @@ protected CalciteSchema(
     } else {
       // If you specify functionMap, you must also specify functionNames and
       // nullaryFunctionMap.
-      this.functionMap = Objects.requireNonNull(functionMap, "functionMap");
-      this.functionNames = Objects.requireNonNull(functionNames, "functionNames");
-      this.nullaryFunctionMap = Objects.requireNonNull(nullaryFunctionMap, "nullaryFunctionMap");
+      this.functionMap = requireNonNull(functionMap, "functionMap");
+      this.functionNames = requireNonNull(functionNames, "functionNames");
+      this.nullaryFunctionMap = requireNonNull(nullaryFunctionMap, "nullaryFunctionMap");
     }
     if (typeMap == null) {
       this.typeMap = new NameMap<>();
     } else {
-      this.typeMap = Objects.requireNonNull(typeMap, "typeMap");
+      this.typeMap = requireNonNull(typeMap, "typeMap");
     }
     this.path = path;
   }
@@ -253,7 +255,7 @@ public List<String> path(@Nullable String name) {
         list.add(s.name);
       }
     }
-    return ImmutableList.copyOf(Lists.reverse(list));
+    return Lists.reverse(list);
   }
 
   public final @Nullable CalciteSchema getSubSchema(String schemaName, boolean caseSensitive) {
@@ -328,7 +330,7 @@ public final NavigableMap<String, CalciteSchema> getSubSchemaMap() {
     // Build a map of implicit sub-schemas first, then explicit sub-schemas.
     // If there are implicit and explicit with the same name, explicit wins.
     final ImmutableSortedMap.Builder<String, CalciteSchema> builder =
-        new ImmutableSortedMap.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedMap.orderedBy(NameSet.COMPARATOR);
     builder.putAll(subSchemaMap.map());
     addImplicitSubSchemaToBuilder(builder);
     return builder.build();
@@ -349,7 +351,7 @@ public NavigableMap<String, LatticeEntry> getLatticeMap() {
    */
   public final NavigableSet<String> getTableNames() {
     final ImmutableSortedSet.Builder<String> builder =
-        new ImmutableSortedSet.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedSet.orderedBy(NameSet.COMPARATOR);
     // Add explicit tables, case-sensitive.
     builder.addAll(tableMap.map().keySet());
     // Add implicit tables, case-sensitive.
@@ -360,7 +362,7 @@ public final NavigableSet<String> getTableNames() {
   /** Returns the set of all types names. */
   public final NavigableSet<String> getTypeNames() {
     final ImmutableSortedSet.Builder<String> builder =
-        new ImmutableSortedSet.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedSet.orderedBy(NameSet.COMPARATOR);
     // Add explicit types.
     builder.addAll(typeMap.map().keySet());
     // Add implicit types.
@@ -393,7 +395,7 @@ public final Collection<Function> getFunctions(String name, boolean caseSensitiv
   /** Returns the list of function names in this schema, both implicit and explicit, never null. */
   public final NavigableSet<String> getFunctionNames() {
     final ImmutableSortedSet.Builder<String> builder =
-        new ImmutableSortedSet.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedSet.orderedBy(NameSet.COMPARATOR);
     // Add explicit functions, case-sensitive.
     builder.addAll(functionMap.map().keySet());
     // Add implicit functions, case-sensitive.
@@ -404,7 +406,7 @@ public final NavigableSet<String> getFunctionNames() {
   /** Returns tables derived from explicit and implicit functions that take zero parameters. */
   public final NavigableMap<String, Table> getTablesBasedOnNullaryFunctions() {
     ImmutableSortedMap.Builder<String, Table> builder =
-        new ImmutableSortedMap.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedMap.orderedBy(NameSet.COMPARATOR);
     for (Map.Entry<String, FunctionEntry> entry : nullaryFunctionMap.map().entrySet()) {
       final Function function = entry.getValue().getFunction();
       if (function instanceof TableMacro) {
@@ -448,7 +450,7 @@ public final NavigableMap<String, Table> getTablesBasedOnNullaryFunctions() {
    * @return the schema snapshot.
    */
   public CalciteSchema createSnapshot(SchemaVersion version) {
-    Preconditions.checkArgument(this.isRoot(), "must be root schema");
+    checkArgument(this.isRoot(), "must be root schema");
     return snapshot(null, version);
   }
 
@@ -564,8 +566,8 @@ public abstract static class Entry {
     public final String name;
 
     protected Entry(CalciteSchema schema, String name) {
-      this.schema = Objects.requireNonNull(schema, "schema");
-      this.name = Objects.requireNonNull(name, "name");
+      this.schema = requireNonNull(schema, "schema");
+      this.name = requireNonNull(name, "name");
     }
 
     /** Returns this object's path. For example ["hr", "emps"]. */
@@ -580,7 +582,7 @@ public abstract static class TableEntry extends Entry {
 
     protected TableEntry(CalciteSchema schema, String name, ImmutableList<String> sqls) {
       super(schema, name);
-      this.sqls = Objects.requireNonNull(sqls, "sqls");
+      this.sqls = requireNonNull(sqls, "sqls");
     }
 
     public abstract Table getTable();
@@ -752,7 +754,7 @@ public static class TableEntryImpl extends TableEntry {
     public TableEntryImpl(
         CalciteSchema schema, String name, Table table, ImmutableList<String> sqls) {
       super(schema, name, sqls);
-      this.table = Objects.requireNonNull(table, "table");
+      this.table = requireNonNull(table, "table");
     }
 
     @Override public Table getTable() {
diff --git a/core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java b/core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java
index ddcc17881..010b6a595 100644
--- a/core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java
+++ b/core/src/main/java/org/apache/calcite/jdbc/JavaRecordType.java
@@ -24,6 +24,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Record type based on a Java class. The fields of the type are the fields of the class.
  *
@@ -35,7 +37,7 @@ public class JavaRecordType extends RelRecordType {
 
   public JavaRecordType(List<RelDataTypeField> fields, Class clazz) {
     super(fields);
-    this.clazz = Objects.requireNonNull(clazz, "clazz");
+    this.clazz = requireNonNull(clazz, "clazz");
   }
 
   @Override public boolean equals(@Nullable Object obj) {
diff --git a/core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java b/core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
index 5b3aa0340..31cb8c803 100644
--- a/core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
+++ b/core/src/main/java/org/apache/calcite/jdbc/JavaTypeFactoryImpl.java
@@ -49,9 +49,9 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Implementation of {@link JavaTypeFactory}.
@@ -245,7 +245,7 @@ public static RelDataType toSql(final RelDataTypeFactory typeFactory, RelDataTyp
           typeFactory.createStructType(
               type.getFieldList().stream()
                   .map(field -> toSql(typeFactory, field.getType()))
-                  .collect(Collectors.toList()),
+                  .collect(toList()),
               type.getFieldNames()),
           type.isNullable());
     } else if (type instanceof JavaType) {
diff --git a/core/src/main/java/org/apache/calcite/materialize/Lattice.java b/core/src/main/java/org/apache/calcite/materialize/Lattice.java
index b9ddf00bf..ba5d20607 100644
--- a/core/src/main/java/org/apache/calcite/materialize/Lattice.java
+++ b/core/src/main/java/org/apache/calcite/materialize/Lattice.java
@@ -57,7 +57,6 @@
 import org.apache.calcite.util.graph.TopologicalOrderIterator;
 import org.apache.calcite.util.mapping.IntPair;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSortedSet;
@@ -84,11 +83,13 @@
 import java.util.TreeSet;
 import java.util.function.Function;
 import java.util.function.IntFunction;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toCollection;
 
 /**
  * Structure that allows materialized views based upon a star schema to be recognized and
@@ -136,7 +137,7 @@ private Lattice(
       // [CALCITE-429] Add statistics SPI for lattice optimization algorithm
       rowCountEstimate = 1000d;
     }
-    Preconditions.checkArgument(rowCountEstimate > 0d);
+    checkArgument(rowCountEstimate > 0d);
     this.rowCountEstimate = rowCountEstimate;
     @SuppressWarnings("argument.type.incompatible")
     LatticeStatisticProvider statisticProvider =
@@ -149,7 +150,7 @@ public static Lattice create(CalciteSchema schema, String sql, boolean auto) {
     return builder(schema, sql).auto(auto).build();
   }
 
-  @RequiresNonNull({"rootNode", "defaultMeasures", "columns"})
+  @RequiresNonNull({"columns", "defaultMeasures", "rootNode"})
   private boolean isValid(@UnknownInitialization Lattice this, Litmus litmus) {
     if (!rootNode.isValid(litmus)) {
       return false;
@@ -480,7 +481,7 @@ Pair<Path, Integer> columnToPathOffset(BaseColumn c) {
   public Set<LatticeTable> tables() {
     return rootNode.descendants.stream()
         .map(n -> n.table)
-        .collect(Collectors.toCollection(LinkedHashSet::new));
+        .collect(toCollection(LinkedHashSet::new));
   }
 
   /**
@@ -730,7 +731,7 @@ public static class DerivedColumn extends Column {
     private DerivedColumn(int ordinal, String alias, RexNode e, List<String> tables) {
       super(ordinal, alias);
       this.e = e;
-      this.tables = ImmutableList.copyOf(tables);
+      this.tables = tables;
     }
 
     @Override public String toString() {
@@ -796,7 +797,7 @@ public static class Builder {
 
     public Builder(LatticeSpace space, CalciteSchema schema, String sql) {
       this.rootSchema = requireNonNull(schema.root());
-      Preconditions.checkArgument(rootSchema.isRoot(), "must be root schema");
+      checkArgument(rootSchema.isRoot(), "must be root schema");
       CalcitePrepare.ConvertResult parsed =
           Schemas.convert(
               MaterializedViewTable.MATERIALIZATION_CONNECTION, schema, schema.path(null), sql);
@@ -928,7 +929,7 @@ public Lattice build() {
               ? AvaticaUtils.instantiatePlugin(
                   LatticeStatisticProvider.Factory.class, this.statisticProvider)
               : Lattices.CACHED_SQL;
-      Preconditions.checkArgument(rootSchema.isRoot(), "must be root schema");
+      checkArgument(rootSchema.isRoot(), "must be root schema");
       final ImmutableList.Builder<Column> columnBuilder =
           ImmutableList.<Column>builder().addAll(baseColumns).addAll(derivedColumnsByName.values());
       return new Lattice(
@@ -974,7 +975,7 @@ public ImmutableList<Column> resolveArgs(@Nullable Object args) {
     /** Looks up a column in this lattice by alias. The alias must be unique within the lattice. */
     private Column resolveColumnByAlias(String name) {
       final ImmutableList<Column> list = columnsByAlias.get(name);
-      if (list == null || list.size() == 0) {
+      if (list == null || list.isEmpty()) {
         throw new RuntimeException("Unknown lattice column '" + name + "'");
       } else if (list.size() == 1) {
         return list.get(0);
@@ -1106,9 +1107,7 @@ private static class Fixer {
       int c;
 
       void fixUp(MutableNode node) {
-        if (!seen.add(node)) {
-          throw new IllegalArgumentException("cyclic query graph");
-        }
+        checkArgument(seen.add(node), "cyclic query graph");
         if (node.alias == null) {
           node.alias = Util.last(node.table.t.getQualifiedName());
         }
diff --git a/core/src/main/java/org/apache/calcite/materialize/LatticeNode.java b/core/src/main/java/org/apache/calcite/materialize/LatticeNode.java
index daa04c515..a457336a0 100644
--- a/core/src/main/java/org/apache/calcite/materialize/LatticeNode.java
+++ b/core/src/main/java/org/apache/calcite/materialize/LatticeNode.java
@@ -19,7 +19,6 @@
 import org.apache.calcite.plan.RelOptTable;
 import org.apache.calcite.util.mapping.IntPair;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.initialization.qual.Initialized;
@@ -27,6 +26,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -53,8 +54,8 @@ public abstract class LatticeNode {
     this.startCol = mutableNode.startCol;
     this.endCol = mutableNode.endCol;
     this.alias = mutableNode.alias;
-    Preconditions.checkArgument(startCol >= 0);
-    Preconditions.checkArgument(endCol > startCol);
+    checkArgument(startCol >= 0);
+    checkArgument(endCol > startCol);
 
     final StringBuilder sb = new StringBuilder().append(space.simpleName(table));
     if (parent != null) {
diff --git a/core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java b/core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java
index 26255094b..6d98d3ef1 100644
--- a/core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java
+++ b/core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java
@@ -32,10 +32,11 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 import java.util.TreeSet;
 
+import static java.util.Objects.requireNonNull;
+
 /** Space within which lattices exist. */
 class LatticeSpace {
   final SqlStatisticProvider statisticProvider;
@@ -54,7 +55,7 @@ class LatticeSpace {
   final Map<LatticeTable, List<RexNode>> tableExpressions = new HashMap<>();
 
   LatticeSpace(SqlStatisticProvider statisticProvider) {
-    this.statisticProvider = Objects.requireNonNull(statisticProvider, "statisticProvider");
+    this.statisticProvider = requireNonNull(statisticProvider, "statisticProvider");
   }
 
   /** Derives a unique name for a table, qualifying with schema name only if necessary. */
@@ -73,11 +74,11 @@ String simpleName(List<String> table) {
     }
     final String name2 = Util.last(table);
     if (simpleNames.add(name2)) {
-      simpleTableNames.put(ImmutableList.copyOf(table), name2);
+      simpleTableNames.put(table, name2);
       return name2;
     }
     final String name3 = table.toString();
-    simpleTableNames.put(ImmutableList.copyOf(table), name3);
+    simpleTableNames.put(table, name3);
     return name3;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java b/core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java
index 16955d3b6..bec798de8 100644
--- a/core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java
+++ b/core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java
@@ -105,7 +105,7 @@ public LatticeSuggester(FrameworkConfig config) {
   public Set<Lattice> getLatticeSet() {
     final Set<Lattice> set = new LinkedHashSet<>(latticeMap.values());
     set.removeAll(obsoleteLatticeMap.keySet());
-    return ImmutableSet.copyOf(set);
+    return set;
   }
 
   /** Converts a column reference to an expression. */
@@ -142,7 +142,7 @@ public List<Lattice> addQuery(RelNode r) {
     frames(frameList, q, r2);
     final List<Lattice> lattices = new ArrayList<>();
     frameList.forEach(frame -> addFrame(q, frame, lattices));
-    return ImmutableList.copyOf(lattices);
+    return lattices;
   }
 
   private void addFrame(Query q, Frame frame, List<Lattice> lattices) {
@@ -604,8 +604,8 @@ abstract static class Frame {
         List<Hop> hops,
         List<MutableMeasure> measures,
         Collection<TableRef> tableRefs) {
-      this.hops = ImmutableList.copyOf(hops);
-      this.measures = ImmutableList.copyOf(measures);
+      this.hops = hops;
+      this.measures = measures;
       this.tableRefs = ImmutableSet.copyOf(tableRefs);
       this.columnCount = columnCount;
     }
diff --git a/core/src/main/java/org/apache/calcite/materialize/LatticeTable.java b/core/src/main/java/org/apache/calcite/materialize/LatticeTable.java
index d57df1c14..2d740d8ba 100644
--- a/core/src/main/java/org/apache/calcite/materialize/LatticeTable.java
+++ b/core/src/main/java/org/apache/calcite/materialize/LatticeTable.java
@@ -22,7 +22,7 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** Table registered in the graph. */
 public class LatticeTable {
@@ -30,8 +30,8 @@ public class LatticeTable {
   public final String alias;
 
   LatticeTable(RelOptTable table) {
-    t = Objects.requireNonNull(table, "table");
-    alias = Objects.requireNonNull(Util.last(table.getQualifiedName()));
+    t = requireNonNull(table, "table");
+    alias = requireNonNull(Util.last(table.getQualifiedName()));
   }
 
   @Override public int hashCode() {
diff --git a/core/src/main/java/org/apache/calcite/materialize/MaterializationActor.java b/core/src/main/java/org/apache/calcite/materialize/MaterializationActor.java
index c3b7bfb25..89883eb29 100644
--- a/core/src/main/java/org/apache/calcite/materialize/MaterializationActor.java
+++ b/core/src/main/java/org/apache/calcite/materialize/MaterializationActor.java
@@ -19,7 +19,6 @@
 import org.apache.calcite.jdbc.CalciteSchema;
 import org.apache.calcite.rel.type.RelDataType;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.Multimap;
 
@@ -30,6 +29,10 @@
 import java.util.Map;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /** Actor that manages the state of materializations in the system. */
 class MaterializationActor {
   // Not an actor yet -- TODO make members private and add request/response
@@ -77,8 +80,8 @@ static class Materialization {
         RelDataType rowType,
         @Nullable List<String> viewSchemaPath) {
       this.key = key;
-      this.rootSchema = Objects.requireNonNull(rootSchema, "rootSchema");
-      Preconditions.checkArgument(rootSchema.isRoot(), "must be root schema");
+      this.rootSchema = requireNonNull(rootSchema, "rootSchema");
+      checkArgument(rootSchema.isRoot(), "must be root schema");
       this.materializedTable = materializedTable; // may be null
       this.sql = sql;
       this.rowType = rowType;
diff --git a/core/src/main/java/org/apache/calcite/materialize/MaterializationKey.java b/core/src/main/java/org/apache/calcite/materialize/MaterializationKey.java
index 2f4541b3e..3884935cb 100644
--- a/core/src/main/java/org/apache/calcite/materialize/MaterializationKey.java
+++ b/core/src/main/java/org/apache/calcite/materialize/MaterializationKey.java
@@ -21,6 +21,8 @@
 import java.io.Serializable;
 import java.util.UUID;
 
+import static java.util.UUID.randomUUID;
+
 /**
  * Unique identifier for a materialization.
  *
@@ -28,7 +30,7 @@
  * communicating with the service.
  */
 public class MaterializationKey implements Serializable {
-  private final UUID uuid = UUID.randomUUID();
+  private final UUID uuid = randomUUID();
 
   @Override public int hashCode() {
     return uuid.hashCode();
diff --git a/core/src/main/java/org/apache/calcite/materialize/MutableNode.java b/core/src/main/java/org/apache/calcite/materialize/MutableNode.java
index a846e561e..c8c169a07 100644
--- a/core/src/main/java/org/apache/calcite/materialize/MutableNode.java
+++ b/core/src/main/java/org/apache/calcite/materialize/MutableNode.java
@@ -30,6 +30,8 @@
 import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /** Mutable version of {@link LatticeNode}, used while a graph is being built. */
 class MutableNode {
   final LatticeTable table;
@@ -69,7 +71,7 @@ class MutableNode {
   /** Creates a non-root node. */
   @SuppressWarnings("argument.type.incompatible")
   MutableNode(LatticeTable table, @Nullable MutableNode parent, @Nullable Step step) {
-    this.table = Objects.requireNonNull(table, "table");
+    this.table = requireNonNull(table, "table");
     this.parent = parent;
     this.step = step;
     if (parent != null) {
diff --git a/core/src/main/java/org/apache/calcite/materialize/Path.java b/core/src/main/java/org/apache/calcite/materialize/Path.java
index 6c740411a..58608dce9 100644
--- a/core/src/main/java/org/apache/calcite/materialize/Path.java
+++ b/core/src/main/java/org/apache/calcite/materialize/Path.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.materialize;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
@@ -31,7 +29,7 @@ class Path {
   private final int id;
 
   Path(List<Step> steps, int id) {
-    this.steps = ImmutableList.copyOf(steps);
+    this.steps = steps;
     this.id = id;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java b/core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
index 8a0152128..4e92c9f87 100644
--- a/core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
+++ b/core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
@@ -32,9 +32,10 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Objects;
 import java.util.function.Supplier;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Implementation of {@link LatticeStatisticProvider} that uses a {@link
  * org.apache.calcite.profile.Profiler}.
@@ -46,7 +47,7 @@ class ProfilerLatticeStatisticProvider implements LatticeStatisticProvider {
 
   /** Creates a ProfilerLatticeStatisticProvider. */
   private ProfilerLatticeStatisticProvider(Lattice lattice) {
-    Objects.requireNonNull(lattice, "lattice");
+    requireNonNull(lattice, "lattice");
     this.profile =
         Suppliers.memoize(
                 () -> {
@@ -86,8 +87,8 @@ private ProfilerLatticeStatisticProvider(Lattice lattice) {
 
   @Override public double cardinality(List<Lattice.Column> columns) {
     final ImmutableBitSet build = Lattice.Column.toBitSet(columns);
-    final double cardinality = profile.get().cardinality(build);
+    return profile.get().cardinality(build);
     //    System.out.println(columns + ": " + cardinality);
-    return cardinality;
+
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/materialize/Step.java b/core/src/main/java/org/apache/calcite/materialize/Step.java
index 64cca5892..5faad338c 100644
--- a/core/src/main/java/org/apache/calcite/materialize/Step.java
+++ b/core/src/main/java/org/apache/calcite/materialize/Step.java
@@ -21,7 +21,6 @@
 import org.apache.calcite.util.graph.DefaultEdge;
 import org.apache.calcite.util.mapping.IntPair;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Ordering;
 
 import org.checkerframework.checker.initialization.qual.NotOnlyInitialized;
@@ -31,6 +30,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Edge in the join graph.
  *
@@ -51,8 +52,8 @@ class Step extends DefaultEdge {
 
   private Step(LatticeTable source, LatticeTable target, List<IntPair> keys, String keyString) {
     super(source, target);
-    this.keys = ImmutableList.copyOf(keys);
-    this.keyString = Objects.requireNonNull(keyString, "keyString");
+    this.keys = keys;
+    this.keyString = requireNonNull(keyString, "keyString");
     assert IntPair.ORDERING.isStrictlyOrdered(keys); // ordered and unique
   }
 
@@ -149,7 +150,7 @@ static class Factory
 
     @SuppressWarnings("type.argument.type.incompatible")
     Factory(@UnderInitialization LatticeSpace space) {
-      this.space = Objects.requireNonNull(space, "space");
+      this.space = requireNonNull(space, "space");
     }
 
     @Override public Step createEdge(LatticeTable source, LatticeTable target) {
diff --git a/core/src/main/java/org/apache/calcite/model/JsonSchema.java b/core/src/main/java/org/apache/calcite/model/JsonSchema.java
index ba56b3ed4..221ceaa0e 100644
--- a/core/src/main/java/org/apache/calcite/model/JsonSchema.java
+++ b/core/src/main/java/org/apache/calcite/model/JsonSchema.java
@@ -33,9 +33,9 @@
  */
 @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type", defaultImpl = JsonMapSchema.class)
 @JsonSubTypes({
-  @JsonSubTypes.Type(value = JsonMapSchema.class, name = "map"),
+  @JsonSubTypes.Type(value = JsonCustomSchema.class, name = "custom"),
   @JsonSubTypes.Type(value = JsonJdbcSchema.class, name = "jdbc"),
-  @JsonSubTypes.Type(value = JsonCustomSchema.class, name = "custom")
+  @JsonSubTypes.Type(value = JsonMapSchema.class, name = "map")
 })
 public abstract class JsonSchema {
   /**
diff --git a/core/src/main/java/org/apache/calcite/model/JsonView.java b/core/src/main/java/org/apache/calcite/model/JsonView.java
index 22e9d1123..fd0276691 100644
--- a/core/src/main/java/org/apache/calcite/model/JsonView.java
+++ b/core/src/main/java/org/apache/calcite/model/JsonView.java
@@ -22,7 +22,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * View schema element.
@@ -98,7 +99,7 @@ public JsonView(
       @JsonProperty("path") @Nullable List<String> path,
       @JsonProperty("modifiable") @Nullable Boolean modifiable) {
     super(name, stream);
-    this.sql = Objects.requireNonNull(sql, "sql");
+    this.sql = requireNonNull(sql, "sql");
     this.path = path;
     this.modifiable = modifiable;
   }
diff --git a/core/src/main/java/org/apache/calcite/model/ModelHandler.java b/core/src/main/java/org/apache/calcite/model/ModelHandler.java
index dcae5ef61..fe56df0b7 100644
--- a/core/src/main/java/org/apache/calcite/model/ModelHandler.java
+++ b/core/src/main/java/org/apache/calcite/model/ModelHandler.java
@@ -48,6 +48,7 @@
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;
+import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
@@ -57,7 +58,6 @@
 import java.io.IOException;
 import java.sql.SQLException;
 import java.util.ArrayDeque;
-import java.util.Collections;
 import java.util.Deque;
 import java.util.List;
 import java.util.Locale;
@@ -321,7 +321,7 @@ public void visit(JsonJdbcSchema jsonSchema) {
             jsonSchema.jdbcUser,
             jsonSchema.jdbcPassword);
     final JdbcSchema schema;
-    if (jsonSchema.sqlDialectFactory == null || jsonSchema.sqlDialectFactory.isEmpty()) {
+    if (Strings.isNullOrEmpty(jsonSchema.sqlDialectFactory)) {
       schema =
           JdbcSchema.create(
               parentSchema,
@@ -449,7 +449,7 @@ public void visit(JsonView jsonView) {
   }
 
   private List<String> currentSchemaPath() {
-    return Collections.singletonList(currentSchemaName());
+    return ImmutableList.of(currentSchemaName());
   }
 
   private Pair<? extends @Nullable String, SchemaPlus> nameAndSchema() {
diff --git a/core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java b/core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
index 777a01060..135c617ca 100644
--- a/core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
+++ b/core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
@@ -43,13 +43,14 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Pattern;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /** Abstract base for implementations of the {@link RelOptPlanner} interface. */
 public abstract class AbstractRelOptPlanner implements RelOptPlanner {
   // ~ Static fields/initializers ---------------------------------------------
@@ -85,7 +86,7 @@ public abstract class AbstractRelOptPlanner implements RelOptPlanner {
 
   /** Creates an AbstractRelOptPlanner. */
   protected AbstractRelOptPlanner(RelOptCostFactory costFactory, @Nullable Context context) {
-    this.costFactory = Objects.requireNonNull(costFactory, "costFactory");
+    this.costFactory = requireNonNull(costFactory, "costFactory");
     if (context == null) {
       context = Contexts.empty();
     }
@@ -121,8 +122,8 @@ protected AbstractRelOptPlanner(RelOptCostFactory costFactory, @Nullable Context
     return costFactory;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public void setCancelFlag(CancelFlag cancelFlag) {
+  @Override @SuppressWarnings("deprecation")
+  public void setCancelFlag(CancelFlag cancelFlag) {
     // ignored
   }
 
@@ -287,7 +288,7 @@ protected void onNewClass(RelNode node) {
 
   protected void dumpRuleAttemptsInfo() {
     if (this.ruleAttemptsListener != null) {
-      RULE_ATTEMPTS_LOGGER.debug("Rule Attempts Info for " + this.getClass().getSimpleName());
+      RULE_ATTEMPTS_LOGGER.debug("Rule Attempts Info for {}", this.getClass().getSimpleName());
       RULE_ATTEMPTS_LOGGER.debug(this.ruleAttemptsListener.dump());
     }
   }
diff --git a/core/src/main/java/org/apache/calcite/plan/Contexts.java b/core/src/main/java/org/apache/calcite/plan/Contexts.java
index f0b07f5ec..9bdb50758 100644
--- a/core/src/main/java/org/apache/calcite/plan/Contexts.java
+++ b/core/src/main/java/org/apache/calcite/plan/Contexts.java
@@ -24,7 +24,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Utilities for {@link Context}. */
 public class Contexts {
@@ -115,7 +116,7 @@ private static class WrapContext implements Context {
     final Object target;
 
     WrapContext(Object target) {
-      this.target = Objects.requireNonNull(target, "target");
+      this.target = requireNonNull(target, "target");
     }
 
     @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
@@ -138,7 +139,7 @@ private static final class ChainContext implements Context {
     final ImmutableList<Context> contexts;
 
     ChainContext(ImmutableList<Context> contexts) {
-      this.contexts = Objects.requireNonNull(contexts, "contexts");
+      this.contexts = requireNonNull(contexts, "contexts");
       for (Context context : contexts) {
         assert !(context instanceof ChainContext) : "must be flat";
       }
diff --git a/core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java b/core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java
index 03872a24d..9080da045 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelCompositeTrait.java
@@ -23,7 +23,8 @@
 
 import java.util.Arrays;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * A trait that consists of a list of traits, all of the same type.
@@ -42,7 +43,7 @@ class RelCompositeTrait<T extends RelMultipleTrait> implements RelTrait {
   // Must remain private. Does not copy the array.
   private RelCompositeTrait(RelTraitDef traitDef, T[] traits) {
     this.traitDef = traitDef;
-    this.traits = Objects.requireNonNull(traits, "traits");
+    this.traits = requireNonNull(traits, "traits");
     //noinspection unchecked
     assert Ordering.natural().isStrictlyOrdered(Arrays.asList((Comparable[]) traits))
         : Arrays.toString(traits);
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java b/core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java
index e73a123f8..8f0df52c0 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java
@@ -33,7 +33,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 
 /** Partial implementation of {@link RelOptTable}. */
@@ -76,7 +75,7 @@ public String getName() {
 
   // Override to define collations.
   @Override public @Nullable List<RelCollation> getCollationList() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Override public @Nullable RelDistribution getDistribution() {
@@ -94,12 +93,12 @@ public String getName() {
 
   // Override to get unique keys
   @Override public @Nullable List<ImmutableBitSet> getKeys() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   // Override to define foreign keys
   @Override public @Nullable List<RelReferentialConstraint> getReferentialConstraints() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Override public RelNode toRel(ToRelContext context) {
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptCluster.java b/core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
index 1dcab340e..e90d3649c 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptCluster.java
@@ -35,12 +35,13 @@
 
 import java.util.HashMap;
 import java.util.Map;
-import java.util.Objects;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Supplier;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /** An environment for related relational expressions during the optimization of a query. */
 public class RelOptCluster {
   // ~ Instance fields --------------------------------------------------------
@@ -84,8 +85,8 @@ public class RelOptCluster {
       Map<String, RelNode> mapCorrelToRel) {
     this.nextCorrel = nextCorrel;
     this.mapCorrelToRel = mapCorrelToRel;
-    this.planner = Objects.requireNonNull(planner, "planner");
-    this.typeFactory = Objects.requireNonNull(typeFactory, "typeFactory");
+    this.planner = requireNonNull(planner, "planner");
+    this.typeFactory = requireNonNull(typeFactory, "typeFactory");
     this.rexBuilder = rexBuilder;
     this.originalExpression = rexBuilder.makeLiteral("?");
 
@@ -141,7 +142,7 @@ public RexBuilder getRexBuilder() {
    *
    * @param metadataProvider custom provider
    */
-  @EnsuresNonNull({"this.metadataProvider", "this.metadataFactory"})
+  @EnsuresNonNull({"this.metadataFactory", "this.metadataProvider"})
   @SuppressWarnings("deprecation")
   public void setMetadataProvider(
       @UnknownInitialization RelOptCluster this, RelMetadataProvider metadataProvider) {
@@ -217,7 +218,7 @@ public void invalidateMetadataQuery() {
    * @param hintStrategies The specified hint strategies to override the default one(empty)
    */
   public void setHintStrategies(HintStrategyTable hintStrategies) {
-    Objects.requireNonNull(hintStrategies, "hintStrategies");
+    requireNonNull(hintStrategies, "hintStrategies");
     this.hintStrategies = hintStrategies;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptCostImpl.java b/core/src/main/java/org/apache/calcite/plan/RelOptCostImpl.java
index bccd16ab3..42fb9e182 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptCostImpl.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptCostImpl.java
@@ -73,8 +73,8 @@ public RelOptCostImpl(double value) {
   }
 
   // implement RelOptCost
-  @SuppressWarnings("NonOverridingEquals")
-  @Override public boolean equals(RelOptCost other) {
+  @Override @SuppressWarnings("NonOverridingEquals")
+  public boolean equals(RelOptCost other) {
     return getRows() == other.getRows();
   }
 
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptMaterialization.java b/core/src/main/java/org/apache/calcite/plan/RelOptMaterialization.java
index c7de3b0a9..f6dddae38 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptMaterialization.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptMaterialization.java
@@ -46,6 +46,8 @@
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /** Records that a particular query is materialized by a particular table. */
 public class RelOptMaterialization {
   public final RelNode tableRel;
@@ -62,8 +64,8 @@ public RelOptMaterialization(
       List<String> qualifiedTableName) {
     this.tableRel =
         RelOptUtil.createCastRel(
-            Objects.requireNonNull(tableRel, "tableRel"),
-            Objects.requireNonNull(queryRel, "queryRel").getRowType(),
+            requireNonNull(tableRel, "tableRel"),
+            requireNonNull(queryRel, "queryRel").getRowType(),
             false);
     this.starRelOptTable = starRelOptTable;
     if (starRelOptTable == null) {
@@ -121,7 +123,7 @@ public RelOptMaterialization(
                       try {
                         match(left, right, join.getCluster());
                       } catch (Util.FoundOne e) {
-                        return (RelNode) Objects.requireNonNull(e.getNode(), "FoundOne.getNode");
+                        return (RelNode) requireNonNull(e.getNode(), "FoundOne.getNode");
                       }
                     }
                   }
@@ -216,7 +218,7 @@ private ProjectFilterTable(
         @Nullable RexNode condition, Mappings.@Nullable TargetMapping mapping, TableScan scan) {
       this.condition = condition;
       this.mapping = mapping;
-      this.scan = Objects.requireNonNull(scan, "scan");
+      this.scan = requireNonNull(scan, "scan");
     }
 
     static @Nullable ProjectFilterTable of(RelNode node) {
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java b/core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java
index 0ce697701..4e8d444b7 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java
@@ -224,12 +224,7 @@ private static List<RelNode> substitute(
     hepPlanner.setRoot(root);
     root = hepPlanner.findBestExp();
 
-    return new SubstitutionVisitor(
-            target,
-            root,
-            ImmutableList.<SubstitutionVisitor.UnifyRule>builder()
-                .addAll(materializationRules)
-                .build())
+    return new SubstitutionVisitor(target, root, ImmutableList.copyOf(materializationRules))
         .go(materialization.tableRel);
   }
 
@@ -237,7 +232,7 @@ private static List<RelNode> substitute(
   private static RelNode trimUnusedfields(RelNode relNode) {
     final List<RelOptTable> relOptTables = RelOptUtil.findAllTables(relNode);
     RelOptSchema relOptSchema = null;
-    if (relOptTables.size() != 0) {
+    if (!relOptTables.isEmpty()) {
       relOptSchema = relOptTables.get(0).getRelOptSchema();
     }
     final RelBuilder relBuilder =
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptPredicateList.java b/core/src/main/java/org/apache/calcite/plan/RelOptPredicateList.java
index 003f92da2..a34544234 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptPredicateList.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptPredicateList.java
@@ -29,7 +29,8 @@
 
 import java.util.Collection;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Predicates that are known to hold in the output of a particular relational expression.
@@ -97,12 +98,11 @@ private RelOptPredicateList(
       ImmutableList<RexNode> leftInferredPredicates,
       ImmutableList<RexNode> rightInferredPredicates,
       ImmutableMap<RexNode, RexNode> constantMap) {
-    this.pulledUpPredicates = Objects.requireNonNull(pulledUpPredicates, "pulledUpPredicates");
-    this.leftInferredPredicates =
-        Objects.requireNonNull(leftInferredPredicates, "leftInferredPredicates");
+    this.pulledUpPredicates = requireNonNull(pulledUpPredicates, "pulledUpPredicates");
+    this.leftInferredPredicates = requireNonNull(leftInferredPredicates, "leftInferredPredicates");
     this.rightInferredPredicates =
-        Objects.requireNonNull(rightInferredPredicates, "rightInferredPredicates");
-    this.constantMap = Objects.requireNonNull(constantMap, "constantMap");
+        requireNonNull(rightInferredPredicates, "rightInferredPredicates");
+    this.constantMap = requireNonNull(constantMap, "constantMap");
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptRule.java b/core/src/main/java/org/apache/calcite/plan/RelOptRule.java
index 539bc689e..a63059c4b 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptRule.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptRule.java
@@ -31,9 +31,10 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 import java.util.function.Predicate;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A <code>RelOptRule</code> transforms an expression into another. It has a list of {@link
  * RelOptRuleOperand}s, which determine whether the rule can be applied to a particular section of
@@ -98,8 +99,8 @@ protected RelOptRule(
       RelOptRuleOperand operand,
       RelBuilderFactory relBuilderFactory,
       @Nullable String description) {
-    this.operand = Objects.requireNonNull(operand, "operand");
-    this.relBuilderFactory = Objects.requireNonNull(relBuilderFactory, "relBuilderFactory");
+    this.operand = requireNonNull(operand, "operand");
+    this.relBuilderFactory = requireNonNull(relBuilderFactory, "relBuilderFactory");
     if (description == null) {
       description = guessDescription(getClass().getName());
     }
@@ -167,8 +168,8 @@ public static <R extends RelNode> RelOptRuleOperand operandJ(
 
   // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #operandJ} */
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   public static <R extends RelNode> RelOptRuleOperand operand(
       Class<R> clazz,
       RelTrait trait,
@@ -199,8 +200,8 @@ public static <R extends RelNode> RelOptRuleOperand operandJ(
     return operandJ(clazz, trait, predicate, some(first, rest));
   }
 
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   public static <R extends RelNode> RelOptRuleOperand operand(
       Class<R> clazz,
       RelTrait trait,
@@ -249,8 +250,8 @@ protected static <R extends RelNode> ConverterRelOptRuleOperand convertOperand(
 
   // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #convertOperand(Class, Predicate, RelTrait)}. */
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   protected static <R extends RelNode> ConverterRelOptRuleOperand convertOperand(
       Class<R> clazz, com.google.common.base.Predicate<? super R> predicate, RelTrait trait) {
     return new ConverterRelOptRuleOperand(clazz, trait, predicate::apply);
@@ -358,7 +359,7 @@ private List<RelOptRuleOperand> flattenOperands(
     rootOperand.ordinalInRule = operandList.size();
     operandList.add(rootOperand);
     flattenRecurse(operandList, rootOperand);
-    return ImmutableList.copyOf(operandList);
+    return operandList;
   }
 
   /**
@@ -426,7 +427,7 @@ public RelOptRuleOperand getOperand() {
    * @return flattened list of operands
    */
   public List<RelOptRuleOperand> getOperands() {
-    return ImmutableList.copyOf(operands);
+    return operands;
   }
 
   @Override public int hashCode() {
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java b/core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java
index d1ec1b15f..411e039cc 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java
@@ -29,6 +29,8 @@
 import java.util.Objects;
 import java.util.function.Predicate;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Operand that determines whether a {@link RelOptRule} can be applied to a particular expression.
  *
@@ -109,19 +111,19 @@ <R extends RelNode> RelOptRuleOperand(
       case ANY:
         break;
       case LEAF:
-        assert children.size() == 0;
+        assert children.isEmpty();
         break;
       case UNORDERED:
         assert children.size() == 1;
         break;
       default:
-        assert children.size() > 0;
+        assert !children.isEmpty();
     }
     this.childPolicy = childPolicy;
-    this.clazz = Objects.requireNonNull(clazz, "clazz");
+    this.clazz = requireNonNull(clazz, "clazz");
     this.trait = trait;
     //noinspection unchecked
-    this.predicate = Objects.requireNonNull((Predicate) predicate);
+    this.predicate = requireNonNull((Predicate) predicate);
     this.children = children;
     for (RelOptRuleOperand child : this.children) {
       assert child.parent == null : "cannot re-use operands";
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptUtil.java b/core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
index 0bcdbfa4f..cd6929bd1 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
@@ -106,7 +106,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.initialization.qual.NotOnlyInitialized;
@@ -121,7 +120,6 @@
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collection;
-import java.util.Comparator;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -133,11 +131,14 @@
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.function.Supplier;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.rel.type.RelDataTypeImpl.NON_NULLABLE_SUFFIX;
 
+import static java.util.Comparator.comparingInt;
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * <code>RelOptUtil</code> defines static utility methods for use in optimizing {@link RelNode}s.
@@ -212,7 +213,7 @@ public static List<RelOptTable> findAllTables(RelNode rel) {
   public static List<String> findAllTableQualifiedNames(RelNode rel) {
     return findAllTables(rel).stream()
         .map(table -> table.getQualifiedName().toString())
-        .collect(Collectors.toList());
+        .collect(toList());
   }
 
   /** Returns a list of variables set by a relational expression or its descendants. */
@@ -226,11 +227,11 @@ public static Set<CorrelationId> getVariablesSet(RelNode rel) {
   @SuppressWarnings("MixedMutabilityReturnType")
   public static List<CorrelationId> getVariablesSetAndUsed(RelNode rel0, RelNode rel1) {
     Set<CorrelationId> set = getVariablesSet(rel0);
-    if (set.size() == 0) {
+    if (set.isEmpty()) {
       return ImmutableList.of();
     }
     Set<CorrelationId> used = getVariablesUsed(rel1);
-    if (used.size() == 0) {
+    if (used.isEmpty()) {
       return ImmutableList.of();
     }
     final List<CorrelationId> result = new ArrayList<>();
@@ -357,7 +358,7 @@ public static void verifyTypeEquivalence(
             + "\nexpression type is "
             + actualRowType.getFullTypeString()
             + "\nset is "
-            + equivalenceClass.toString()
+            + equivalenceClass
             + "\nexpression is "
             + RelOptUtil.toString(newRel)
             + getFullTypeDifferenceString(
@@ -393,7 +394,7 @@ public static void verifyTypeEquivalence(
    */
   @Experimental
   public static RelNode propagateRelHints(RelNode originalRel, RelNode equiv) {
-    if (!(originalRel instanceof Hintable) || ((Hintable) originalRel).getHints().size() == 0) {
+    if (!(originalRel instanceof Hintable) || ((Hintable) originalRel).getHints().isEmpty()) {
       return equiv;
     }
     final RelShuttle shuttle =
@@ -451,7 +452,7 @@ public static RelNode copyRelHints(RelNode originalRel, RelNode newRel, boolean
 
     if (originalRel instanceof Hintable
         && newRel instanceof Hintable
-        && ((Hintable) originalRel).getHints().size() > 0) {
+        && !((Hintable) originalRel).getHints().isEmpty()) {
       final List<RelHint> hints = ((Hintable) originalRel).getHints();
       if (filterHints) {
         HintStrategyTable hintStrategies = originalRel.getCluster().getHintStrategies();
@@ -534,7 +535,7 @@ public static RelNode createExistsPlan(
     assert extraExpr == null || extraName != null;
     RelNode ret = seekRel;
 
-    if ((conditions != null) && (conditions.size() > 0)) {
+    if ((conditions != null) && !conditions.isEmpty()) {
       RexNode conditionExp = RexUtil.composeConjunction(cluster.getRexBuilder(), conditions, true);
 
       if (conditionExp != null) {
@@ -797,15 +798,11 @@ public static RelNode createCastRel(
       // nothing to do
       return rel;
     }
-    if (rowType.getFieldCount() != castRowType.getFieldCount()) {
-      throw new IllegalArgumentException(
-          "Field counts are not equal: "
-              + "rowType ["
-              + rowType
-              + "] castRowType ["
-              + castRowType
-              + "]");
-    }
+    checkArgument(
+        rowType.getFieldCount() == castRowType.getFieldCount(),
+        "Field counts are not equal: rowType [%s] castRowType [%s]",
+        rowType,
+        castRowType);
     final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();
     List<RexNode> castExps;
     RelNode input;
@@ -921,13 +918,13 @@ public static boolean analyzeSimpleEquiJoin(LogicalJoin join, int[] joinFieldOrd
 
     final int leftFieldCount = join.getLeft().getRowType().getFieldCount();
     RexInputRef leftFieldAccess = (RexInputRef) leftComparand;
-    if (!(leftFieldAccess.getIndex() < leftFieldCount)) {
+    if (leftFieldAccess.getIndex() >= leftFieldCount) {
       // left field must access left side of join
       return false;
     }
 
     RexInputRef rightFieldAccess = (RexInputRef) rightComparand;
-    if (!(rightFieldAccess.getIndex() >= leftFieldCount)) {
+    if (rightFieldAccess.getIndex() < leftFieldCount) {
       // right field must access right side of join
       return false;
     }
@@ -1019,7 +1016,7 @@ public static boolean isEqui(RelNode left, RelNode right, RexNode condition) {
         rightKeys,
         filterNulls,
         nonEquiList);
-    return nonEquiList.size() == 0;
+    return nonEquiList.isEmpty();
   }
 
   /**
@@ -2199,8 +2196,7 @@ public static RelNode renameIfNecessary(RelNode rel, RelDataType desiredRowType)
       // The row types are different ignoring names. Nothing we can do.
       return rel;
     }
-    rel = createRename(rel, desiredRowType.getFieldNames());
-    return rel;
+    return createRename(rel, desiredRowType.getFieldNames());
   }
 
   public static String dumpType(RelDataType type) {
@@ -3587,7 +3583,7 @@ private static RexNode pushDownEqualJoinConditions(
       case AND:
         final RexCall call = (RexCall) node;
         final List<RexNode> list = new ArrayList<>();
-        List<RexNode> operands = Lists.newArrayList(call.getOperands());
+        List<RexNode> operands = new ArrayList<>(call.getOperands());
         for (int i = 0; i < operands.size(); i++) {
           RexNode operand = operands.get(i);
           if (operand instanceof RexCall) {
@@ -3793,7 +3789,7 @@ private static class RelHintPropagateShuttle extends RelHomogeneousShuttle {
      */
     private RelNode visitHintable(RelNode node) {
       final List<RelHint> topHints = ((Hintable) node).getHints();
-      final boolean hasHints = topHints != null && topHints.size() > 0;
+      final boolean hasHints = topHints != null && !topHints.isEmpty();
       final boolean hasQueryHints = hasHints && !(node instanceof TableScan);
       if (hasQueryHints) {
         inheritPaths.push(Pair.of(topHints, new ArrayDeque<>()));
@@ -3807,10 +3803,10 @@ private RelNode visitHintable(RelNode node) {
 
     private RelNode attachHints(RelNode original) {
       assert original instanceof Hintable;
-      if (inheritPaths.size() > 0) {
+      if (!inheritPaths.isEmpty()) {
         final List<RelHint> hints =
             inheritPaths.stream()
-                .sorted(Comparator.comparingInt(o -> o.right.size()))
+                .sorted(comparingInt(o -> o.right.size()))
                 .map(path -> copyWithInheritPath(path.left, path.right))
                 .reduce(
                     new ArrayList<>(),
@@ -3819,7 +3815,7 @@ private RelNode attachHints(RelNode original) {
                       return acc;
                     });
         final List<RelHint> filteredHints = hintStrategies.apply(hints, original);
-        if (filteredHints.size() > 0) {
+        if (!filteredHints.isEmpty()) {
           return ((Hintable) original).attachHints(filteredHints);
         }
       }
@@ -3834,7 +3830,7 @@ private static List<RelHint> copyWithInheritPath(
       while (iterator.hasNext()) {
         path.add(iterator.next());
       }
-      return hints.stream().map(hint -> hint.copy(path)).collect(Collectors.toList());
+      return hints.stream().map(hint -> hint.copy(path)).collect(toList());
     }
   }
 
@@ -3922,7 +3918,7 @@ private static class SubTreeHintPropagateShuttle extends RelHomogeneousShuttle {
      */
     private RelNode visitHintable(RelNode node) {
       final List<RelHint> topHints = ((Hintable) node).getHints();
-      final boolean hasHints = topHints != null && topHints.size() > 0;
+      final boolean hasHints = topHints != null && !topHints.isEmpty();
       if (hasHints) {
         // This node is definitely not created by the planner, returns early.
         return node;
@@ -3937,18 +3933,16 @@ private RelNode visitHintable(RelNode node) {
     private RelNode attachHints(RelNode original) {
       assert original instanceof Hintable;
       final List<RelHint> hints =
-          this.hints.stream()
-              .map(hint -> copyWithAppendPath(hint, appendPath))
-              .collect(Collectors.toList());
+          this.hints.stream().map(hint -> copyWithAppendPath(hint, appendPath)).collect(toList());
       final List<RelHint> filteredHints = hintStrategies.apply(hints, original);
-      if (filteredHints.size() > 0) {
+      if (!filteredHints.isEmpty()) {
         return ((Hintable) original).attachHints(filteredHints);
       }
       return original;
     }
 
     private static RelHint copyWithAppendPath(RelHint hint, List<Integer> appendPaths) {
-      if (appendPaths.size() == 0) {
+      if (appendPaths.isEmpty()) {
         return hint;
       } else {
         List<Integer> newPath = new ArrayList<>(hint.inheritPath);
@@ -3984,11 +3978,11 @@ private static class ResetHintsShuttle extends RelHomogeneousShuttle {
     }
 
     private static RelNode resetHints(Hintable hintable) {
-      if (hintable.getHints().size() > 0) {
+      if (!hintable.getHints().isEmpty()) {
         final List<RelHint> resetHints =
             hintable.getHints().stream()
-                .filter(hint -> hint.inheritPath.size() == 0)
-                .collect(Collectors.toList());
+                .filter(hint -> hint.inheritPath.isEmpty())
+                .collect(toList());
         return hintable.withHints(resetHints);
       } else {
         return (RelNode) hintable;
diff --git a/core/src/main/java/org/apache/calcite/plan/RelRule.java b/core/src/main/java/org/apache/calcite/plan/RelRule.java
index cc1f98da5..ff3aff199 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelRule.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelRule.java
@@ -16,15 +16,10 @@
  */
 package org.apache.calcite.plan;
 
-import org.apache.calcite.rel.RelNode;
-import org.apache.calcite.rel.core.RelFactories;
-import org.apache.calcite.tools.RelBuilderFactory;
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.ImmutableList;
-
-import org.checkerframework.checker.nullness.qual.Nullable;
-import org.immutables.value.Value;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
@@ -32,6 +27,11 @@
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
+import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.RelFactories;
+import org.apache.calcite.tools.RelBuilderFactory;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.immutables.value.Value;
 
 /**
  * Rule that is parameterized via a configuration.
@@ -236,11 +236,9 @@ private static class OperandBuilderImpl implements OperandBuilder {
     static RelOptRuleOperand operand(OperandTransform transform) {
       final OperandBuilderImpl b = new OperandBuilderImpl();
       final Done done = transform.apply(b);
-      Objects.requireNonNull(done, "done");
-      if (b.operands.size() != 1) {
-        throw new IllegalArgumentException("operand supplier must call one of "
+      requireNonNull(done, "done");
+      checkArgument(b.operands.size() == 1, "operand supplier must call one of "
             + "the following methods: operand or exactly");
-      }
       return b.operands.get(0);
     }
 
@@ -266,12 +264,12 @@ private static class OperandDetailBuilderImpl<R extends RelNode>
     private Predicate<? super R> predicate = r -> true;
 
     OperandDetailBuilderImpl(OperandBuilderImpl parent, Class<R> relClass) {
-      this.parent = Objects.requireNonNull(parent, "parent");
-      this.relClass = Objects.requireNonNull(relClass, "relClass");
+      this.parent = requireNonNull(parent, "parent");
+      this.relClass = requireNonNull(relClass, "relClass");
     }
 
     @Override public OperandDetailBuilderImpl<R> trait(RelTrait trait) {
-      this.trait = Objects.requireNonNull(trait, "trait");
+      this.trait = requireNonNull(trait, "trait");
       return this;
     }
 
@@ -304,14 +302,14 @@ Done done(RelOptRuleOperandChildPolicy childPolicy) {
 
     @Override public Done oneInput(OperandTransform transform) {
       final Done done = transform.apply(inputBuilder);
-      Objects.requireNonNull(done, "done");
+      requireNonNull(done, "done");
       return done(RelOptRuleOperandChildPolicy.SOME);
     }
 
     @Override public Done inputs(OperandTransform... transforms) {
       for (OperandTransform transform : transforms) {
         final Done done = transform.apply(inputBuilder);
-        Objects.requireNonNull(done, "done");
+        requireNonNull(done, "done");
       }
       return done(RelOptRuleOperandChildPolicy.SOME);
     }
@@ -319,7 +317,7 @@ Done done(RelOptRuleOperandChildPolicy childPolicy) {
     @Override public Done unorderedInputs(OperandTransform... transforms) {
       for (OperandTransform transform : transforms) {
         final Done done = transform.apply(inputBuilder);
-        Objects.requireNonNull(done, "done");
+        requireNonNull(done, "done");
       }
       return done(RelOptRuleOperandChildPolicy.UNORDERED);
     }
diff --git a/core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java b/core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
index 56c788669..f7dce61d1 100644
--- a/core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
+++ b/core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
@@ -217,7 +217,7 @@ private boolean implies2(RexNode first, RexNode second) {
         firstUsageFinder.usageMap.entrySet()) {
       ImmutableSet.Builder<Pair<RexInputRef, @Nullable RexNode>> usageBuilder =
           ImmutableSet.builder();
-      if (entry.getValue().usageList.size() > 0) {
+      if (!entry.getValue().usageList.isEmpty()) {
         entry
             .getValue()
             .usageList
@@ -381,13 +381,13 @@ private static boolean isEquivalentOp(@Nullable SqlKind fKind, SqlKind sKind) {
     switch (sKind) {
       case GREATER_THAN:
       case GREATER_THAN_OR_EQUAL:
-        if (!(fKind == SqlKind.GREATER_THAN) && !(fKind == SqlKind.GREATER_THAN_OR_EQUAL)) {
+        if (fKind != SqlKind.GREATER_THAN && fKind != SqlKind.GREATER_THAN_OR_EQUAL) {
           return false;
         }
         break;
       case LESS_THAN:
       case LESS_THAN_OR_EQUAL:
-        if (!(fKind == SqlKind.LESS_THAN) && !(fKind == SqlKind.LESS_THAN_OR_EQUAL)) {
+        if (fKind != SqlKind.LESS_THAN && fKind != SqlKind.LESS_THAN_OR_EQUAL) {
           return false;
         }
         break;
@@ -402,13 +402,13 @@ private static boolean isOppositeOp(SqlKind fKind, SqlKind sKind) {
     switch (sKind) {
       case GREATER_THAN:
       case GREATER_THAN_OR_EQUAL:
-        if (!(fKind == SqlKind.LESS_THAN) && !(fKind == SqlKind.LESS_THAN_OR_EQUAL)) {
+        if (fKind != SqlKind.LESS_THAN && fKind != SqlKind.LESS_THAN_OR_EQUAL) {
           return false;
         }
         break;
       case LESS_THAN:
       case LESS_THAN_OR_EQUAL:
-        if (!(fKind == SqlKind.GREATER_THAN) && !(fKind == SqlKind.GREATER_THAN_OR_EQUAL)) {
+        if (fKind != SqlKind.GREATER_THAN && fKind != SqlKind.GREATER_THAN_OR_EQUAL) {
           return false;
         }
         break;
diff --git a/core/src/main/java/org/apache/calcite/plan/RuleEventLogger.java b/core/src/main/java/org/apache/calcite/plan/RuleEventLogger.java
index b74414460..7d3d3826d 100644
--- a/core/src/main/java/org/apache/calcite/plan/RuleEventLogger.java
+++ b/core/src/main/java/org/apache/calcite/plan/RuleEventLogger.java
@@ -24,7 +24,8 @@
 import org.slf4j.MarkerFactory;
 
 import java.util.Arrays;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.joining;
 
 /** Listener for logging useful debugging information on certain rule events. */
 public class RuleEventLogger implements RelOptListener {
@@ -39,7 +40,7 @@ public class RuleEventLogger implements RelOptListener {
       String ruleArgs =
           Arrays.stream(call.rels)
               .map(rel -> "rel#" + rel.getId() + ":" + rel.getRelTypeName())
-              .collect(Collectors.joining(","));
+              .collect(joining(","));
       LOG.debug("call#{}: Apply rule [{}] to [{}]", call.id, call.getRule(), ruleArgs);
     }
   }
diff --git a/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java b/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
index 15934f701..e75fb72b8 100644
--- a/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
+++ b/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
@@ -204,13 +204,13 @@ public SubstitutionVisitor(
     // Leaves are all nodes that are not parents.
     // For determinism, it is important that the list is in scan order.
     allNodes.removeAll(parents);
-    targetLeaves = ImmutableList.copyOf(allNodes);
+    targetLeaves = allNodes;
 
     allNodes.clear();
     parents.clear();
     visitor.go(query);
     allNodes.removeAll(parents);
-    queryLeaves = ImmutableList.copyOf(allNodes);
+    queryLeaves = allNodes;
   }
 
   void register(MutableRel result, MutableRel query) {}
@@ -346,9 +346,7 @@ private static RexNode canonizeNode(RexBuilder rexBuilder, RexNode condition) {
             return call;
           }
           final RexNode result = RexUtil.invert(rexBuilder, call);
-          if (result == null) {
-            throw new NullPointerException("RexUtil.invert returned null for " + call);
-          }
+          requireNonNull(result, "RexUtil.invert returned null for " + call);
           return result;
         }
       case SEARCH:
@@ -591,7 +589,7 @@ private List<List<Replacement>> go(MutableRel replacement) {
                         : rule + "should have returned a result containing the target.";
                     attempted.add(r);
                   }
-                  substitutions.add(ImmutableList.copyOf(attempted));
+                  substitutions.add(attempted);
                   attempted.clear();
                   queryDescendant = next;
                   continue outer;
@@ -773,10 +771,8 @@ private static void reverseSubstitute(
                     + rule
                     + "\nQuery:\n"
                     + queryParent.deep()
-                    + (x.call.query != queryParent
-                        ? "\nQuery (original):\n"
-  + queryParent.toString()
-                        : "")
+                    + (x.call.query != queryParent ? "\nQuery (original):\n"
+  + queryParent : "")
                     + "\nTarget:\n"
                     + target.deep()
                     + "\nResult:\n"
@@ -791,7 +787,7 @@ private static void reverseSubstitute(
       System.out.println(
           "Unify failed:" + "\nQuery:\n"
   + queryParent + "\nTarget:\n"
-  + target.toString() + "\n");
+  + target + "\n");
     }
     return null;
   }
@@ -1402,8 +1398,8 @@ private AggregateOnCalcToAggregateUnifyRule() {
           1);
     }
 
-    @SuppressWarnings("MapEntryComparingByKey")
-    @Override protected @Nullable UnifyResult apply(UnifyRuleCall call) {
+    @Override @SuppressWarnings("MapEntryComparingByKey")
+    protected @Nullable UnifyResult apply(UnifyRuleCall call) {
       final MutableAggregate query = (MutableAggregate) call.query;
       final MutableCalc qInput = (MutableCalc) query.getInput();
       final Pair<RexNode, List<RexNode>> qInputExplained = explainCalc(qInput);
@@ -1462,8 +1458,8 @@ private AggregateOnCalcToAggregateUnifyRule() {
           pairs.add(mapping.getTarget(groupings.get(i)), i);
         }
         pairs.sort(
-            Comparator.<Map.Entry<Integer, Integer>>comparingInt(Map.Entry::getKey)
-                .thenComparingInt(Map.Entry::getValue));
+            Comparator.<Map.Entry<Integer, Integer>, Integer>comparing(Map.Entry::getKey)
+                .thenComparing(Map.Entry::getValue));
         final List<Integer> posList = new ArrayList<>(pairs.rightList());
         for (int i = posList.size(); i < fieldCount; i++) {
           posList.add(i);
@@ -1700,9 +1696,7 @@ public static Pair<RexNode, List<RexNode>> explainCalc(MutableCalc calc) {
     final RexShuttle shuttle = getExpandShuttle(calc.program);
     final RexNode condition = shuttle.apply(calc.program.getCondition());
     final List<RexNode> projects = new ArrayList<>();
-    for (RexNode rex : shuttle.apply(calc.program.getProjectList())) {
-      projects.add(rex);
-    }
+    projects.addAll(shuttle.apply(calc.program.getProjectList()));
     if (condition == null) {
       return Pair.of(calc.cluster.getRexBuilder().makeLiteral(true), projects);
     } else {
@@ -1965,7 +1959,7 @@ public static MutableAggregate permute(
       newArgList.add(newArgIndex);
     }
     final boolean isAllowBuild;
-    if (newArgList.size() == 0) {
+    if (newArgList.isEmpty()) {
       // Size of agg-call's args is empty, we stop to build a new agg-call,
       // eg: count(1) or count(*).
       isAllowBuild = false;
diff --git a/core/src/main/java/org/apache/calcite/plan/TableAccessMap.java b/core/src/main/java/org/apache/calcite/plan/TableAccessMap.java
index 7e0e1c14f..11ded715a 100644
--- a/core/src/main/java/org/apache/calcite/plan/TableAccessMap.java
+++ b/core/src/main/java/org/apache/calcite/plan/TableAccessMap.java
@@ -22,12 +22,13 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import static java.util.Collections.EMPTY_MAP;
+
 // TODO jvs 9-Mar-2006:  move this class to another package; it
 // doesn't really belong here.  Also, use a proper class for table
 // names instead of List<String>.
@@ -67,7 +68,7 @@ public enum Mode {
 
   /** Constructs a permanently empty TableAccessMap. */
   public TableAccessMap() {
-    accessMap = Collections.EMPTY_MAP;
+    accessMap = EMPTY_MAP;
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java b/core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
index e02c007dc..7d5aaba25 100644
--- a/core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
+++ b/core/src/main/java/org/apache/calcite/plan/hep/HepPlanner.java
@@ -58,7 +58,6 @@
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -72,6 +71,7 @@
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Collections.reverse;
 import static java.util.Objects.requireNonNull;
 
 /** HepPlanner is a heuristic implementation of the {@link RelOptPlanner} interface. */
@@ -474,7 +474,7 @@ private Iterator<HepRelVertex> getGraphIterator(
         for (HepRelVertex vertex : TopologicalOrderIterator.of(graph)) {
           list.add(vertex);
         }
-        Collections.reverse(list);
+        reverse(list);
         return list.iterator();
     }
   }
diff --git a/core/src/main/java/org/apache/calcite/plan/hep/HepRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/plan/hep/HepRelMetadataProvider.java
index 927ee3507..1ca11a30e 100644
--- a/core/src/main/java/org/apache/calcite/plan/hep/HepRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/plan/hep/HepRelMetadataProvider.java
@@ -24,7 +24,7 @@
 import org.apache.calcite.rel.metadata.UnboundMetadata;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -68,7 +68,7 @@ class HepRelMetadataProvider implements RelMetadataProvider {
 
   @Deprecated // to be removed before 2.0
   @Override public <M extends Metadata> Multimap<Method, MetadataHandler<M>> handlers(MetadataDef<M> def) {
-    return ImmutableMultimap.of();
+    return ImmutableListMultimap.of();
   }
 
   @Override public List<MetadataHandler<?>> handlers(Class<? extends MetadataHandler<?>> handlerClass) {
diff --git a/core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java b/core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java
index e22521601..9d620ea58 100644
--- a/core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java
+++ b/core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java
@@ -20,12 +20,13 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
+import static java.util.Collections.unmodifiableMap;
+
 /** Helper class to create the node update. */
 class NodeUpdateHelper {
 
@@ -60,7 +61,7 @@ void updateAttribute(final String attr, final Object newValue) {
       update = new NodeUpdateInfo();
     }
 
-    if (newValue instanceof List && ((List<?>) newValue).size() == 0 && !update.containsKey(attr)) {
+    if (newValue instanceof List && ((List<?>) newValue).isEmpty() && !update.containsKey(attr)) {
       return;
     }
 
@@ -87,7 +88,7 @@ Object getAndResetUpdate() {
   }
 
   Map<String, Object> getState() {
-    return Collections.unmodifiableMap(this.state);
+    return unmodifiableMap(this.state);
   }
 
   /** Get the current value for the attribute. */
diff --git a/core/src/main/java/org/apache/calcite/plan/visualizer/RuleMatchVisualizer.java b/core/src/main/java/org/apache/calcite/plan/visualizer/RuleMatchVisualizer.java
index dcc80233c..d16074fbc 100644
--- a/core/src/main/java/org/apache/calcite/plan/visualizer/RuleMatchVisualizer.java
+++ b/core/src/main/java/org/apache/calcite/plan/visualizer/RuleMatchVisualizer.java
@@ -38,7 +38,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UncheckedIOException;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
@@ -52,11 +51,13 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 
 import static org.apache.calcite.util.Util.transform;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Objects.requireNonNull;
+
 /**
  * This is a tool to visualize the rule match process of a RelOptPlanner.
  *
@@ -107,8 +108,8 @@ public class RuleMatchVisualizer implements RelOptListener {
    * <p>Note: when using HepPlanner, {@link #writeToFile()} needs to be called manually.
    */
   public RuleMatchVisualizer(String outputDirectory, String outputSuffix) {
-    this.outputDirectory = Objects.requireNonNull(outputDirectory, "outputDirectory");
-    this.outputSuffix = Objects.requireNonNull(outputSuffix, "outputSuffix");
+    this.outputDirectory = requireNonNull(outputDirectory, "outputDirectory");
+    this.outputSuffix = requireNonNull(outputSuffix, "outputSuffix");
   }
 
   /** Use this constructor when the result shall not be written to disk. */
@@ -370,7 +371,7 @@ public void writeToFile() {
       assert cl != null;
       InputStream resourceAsStream = cl.getResourceAsStream(templatePath);
       assert resourceAsStream != null;
-      String htmlTemplate = IOUtils.toString(resourceAsStream, StandardCharsets.UTF_8);
+      String htmlTemplate = IOUtils.toString(resourceAsStream, UTF_8);
 
       String htmlFileName = "planner-viz" + outputSuffix + ".html";
       String dataFileName = "planner-viz-data" + outputSuffix + ".js";
diff --git a/core/src/main/java/org/apache/calcite/plan/visualizer/StepInfo.java b/core/src/main/java/org/apache/calcite/plan/visualizer/StepInfo.java
index 632807ce4..f0574fec5 100644
--- a/core/src/main/java/org/apache/calcite/plan/visualizer/StepInfo.java
+++ b/core/src/main/java/org/apache/calcite/plan/visualizer/StepInfo.java
@@ -16,9 +16,6 @@
  */
 package org.apache.calcite.plan.visualizer;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-
 import java.util.List;
 import java.util.Map;
 
@@ -30,8 +27,8 @@ class StepInfo {
 
   StepInfo(final String id, final Map<String, Object> updates, final List<String> matchedRels) {
     this.id = id;
-    this.updates = ImmutableMap.copyOf(updates);
-    this.matchedRels = ImmutableList.copyOf(matchedRels);
+    this.updates = updates;
+    this.matchedRels = matchedRels;
   }
 
   public String getId() {
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/Dumpers.java b/core/src/main/java/org/apache/calcite/plan/volcano/Dumpers.java
index 42006dd6c..71b1d04ea 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/Dumpers.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/Dumpers.java
@@ -32,13 +32,13 @@
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import static java.util.Comparator.comparingInt;
 import static java.util.Objects.requireNonNull;
 
 /** Utility class to dump state of <code>VolcanoPlanner</code>. */
@@ -117,7 +117,7 @@ private static void provenanceRecurse(
   }
 
   static void dumpSets(VolcanoPlanner planner, PrintWriter pw) {
-    Ordering<RelSet> ordering = Ordering.from(Comparator.comparingInt(o -> o.id));
+    Ordering<RelSet> ordering = Ordering.from(comparingInt(o -> o.id));
     for (RelSet set : ordering.immutableSortedCopy(planner.allSets)) {
       pw.println("Set#" + set.id + ", type: " + set.subsets.get(0).getRowType());
       int j = -1;
@@ -164,7 +164,7 @@ static void dumpSets(VolcanoPlanner planner, PrintWriter pw) {
   }
 
   static void dumpGraphviz(VolcanoPlanner planner, PrintWriter pw) {
-    Ordering<RelSet> ordering = Ordering.from(Comparator.comparingInt(o -> o.id));
+    Ordering<RelSet> ordering = Ordering.from(comparingInt(o -> o.id));
     Set<RelNode> activeRels = new HashSet<>();
     for (VolcanoRuleCall volcanoRuleCall : planner.ruleCallStack) {
       activeRels.addAll(Arrays.asList(volcanoRuleCall.rels));
@@ -195,7 +195,7 @@ static void dumpGraphviz(VolcanoPlanner planner, PrintWriter pw) {
           pw.append("no subset found for rel");
           continue;
         }
-        String traits = "." + relSubset.getTraitSet().toString();
+        String traits = "." + relSubset.getTraitSet();
         String title = rel.toString().replace(traits, "");
         if (title.endsWith(")")) {
           int openParen = title.indexOf('(');
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java b/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
index fe567e764..3631ad96f 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
@@ -40,11 +40,11 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * A <code>RelSet</code> is an equivalence-set of expressions; that is, a set of expressions which
@@ -175,9 +175,7 @@ public RelSubset add(RelNode rel) {
   void addConverters(RelSubset subset, boolean required, boolean useAbstractConverter) {
     RelOptCluster cluster = subset.getCluster();
     List<RelSubset> others =
-        subsets.stream()
-            .filter(n -> required ? n.isDelivered() : n.isRequired())
-            .collect(Collectors.toList());
+        subsets.stream().filter(n -> required ? n.isDelivered() : n.isRequired()).collect(toList());
 
     for (RelSubset other : others) {
       assert other.getTraitSet().size() == subset.getTraitSet().size();
@@ -391,7 +389,7 @@ void mergeWith(VolcanoPlanner planner, RelSet otherSet) {
     // fact that the child has been renamed.
     //
     // Copy array to prevent ConcurrentModificationException.
-    final List<RelNode> previousParents = ImmutableList.copyOf(otherSet.getParentRels());
+    final List<RelNode> previousParents = otherSet.getParentRels();
     for (RelNode parentRel : previousParents) {
       planner.rename(parentRel);
     }
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java b/core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
index 4dea98e70..957db3aae 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
@@ -50,20 +50,22 @@
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.function.Function;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Comparator.comparing;
 import static java.util.Objects.requireNonNull;
+import static java.util.function.Function.identity;
+import static java.util.stream.Collectors.counting;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.joining;
 
 /**
  * Subset of an equivalence class where all relational expressions have the same physical
@@ -573,7 +575,7 @@ private static String traitDiff(RelTraitSet original, RelTraitSet desired) {
       return Pair.zip(original, desired).stream()
           .filter(p -> !p.left.satisfies(p.right))
           .map(p -> p.left.getTraitDef().getSimpleName() + ": " + p.left + " -> " + p.right)
-          .collect(Collectors.joining(", ", "[", "]"));
+          .collect(joining(", ", "[", "]"));
     }
 
     @SuppressWarnings("MapEntryComparingByValue")
@@ -619,14 +621,14 @@ public RelNode visit(RelNode p, int ordinal, @Nullable RelNode parent) {
                           return original.getClass().getSimpleName()
                               + traitDiff(original.getTraitSet(), x.getTraitSet());
                         })
-                    .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+                    .collect(groupingBy(identity(), counting()));
             // Sort problems from most often to less often ones
             String problems =
                 problemCounts.entrySet().stream()
-                    .sorted(Comparator.comparingLong(Map.Entry<String, Long>::getValue).reversed())
+                    .sorted(comparing(Map.Entry<String, Long>::getValue).reversed())
                     .map(
                         e -> e.getKey() + (e.getValue() > 1 ? " (" + e.getValue() + " cases)" : ""))
-                    .collect(Collectors.joining(", "));
+                    .collect(joining(", "));
             pw.println();
             pw.print("Missing conversion");
             pw.print(finder.deadEnds.size() == 1 ? " is " : "s are ");
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoCost.java b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoCost.java
index 58b732067..17133306e 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoCost.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoCost.java
@@ -119,8 +119,8 @@ class VolcanoCost implements RelOptCost {
     return Objects.hash(rowCount, cpu, io);
   }
 
-  @SuppressWarnings("NonOverridingEquals")
-  @Override public boolean equals(RelOptCost other) {
+  @Override @SuppressWarnings("NonOverridingEquals")
+  public boolean equals(RelOptCost other) {
     return this == other
         || other instanceof VolcanoCost
             && (this.rowCount == ((VolcanoCost) other).rowCount)
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
index 94cfaa2bd..e2d599392 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
@@ -84,6 +84,9 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -252,13 +255,13 @@ public void setTopDownOpt(boolean value) {
     ensureRootConverters();
   }
 
-  @Pure
-  @Override public @Nullable RelNode getRoot() {
+  @Override @Pure
+  public @Nullable RelNode getRoot() {
     return root;
   }
 
   @Override public List<RelOptMaterialization> getMaterializations() {
-    return ImmutableList.copyOf(materializations);
+    return materializations;
   }
 
   @Override public void addMaterialization(RelOptMaterialization materialization) {
@@ -547,11 +550,10 @@ void ensureRootConverters() {
     } else {
       final RelDataType relType = rel.getRowType();
       final RelDataType equivRelType = equivRel.getRowType();
-      if (!RelOptUtil.areRowTypesEqual(relType, equivRelType, false)) {
-        throw new IllegalArgumentException(
-            RelOptUtil.getFullTypeDifferenceString(
-                "rel rowtype", relType, "equiv rowtype", equivRelType));
-      }
+      checkArgument(
+          RelOptUtil.areRowTypesEqual(relType, equivRelType, false),
+          RelOptUtil.getFullTypeDifferenceString(
+              "rel rowtype", relType, "equiv rowtype", equivRelType));
       equivRel = ensureRegistered(equivRel, null);
       set = getSet(equivRel);
     }
@@ -1116,9 +1118,7 @@ private RelSet merge(RelSet set1, RelSet set2) {
     // Merge.
     set1.mergeWith(this, set2);
 
-    if (root == null) {
-      throw new IllegalStateException("root must not be null");
-    }
+    checkState(root != null, "root must not be null");
 
     // Was the set we merged with the root? If so, the result is the new
     // root.
@@ -1159,8 +1159,7 @@ static RelSet equivRoot(RelSet s) {
   /** Moves forward two links, checking for a cycle at each. */
   private static @Nullable RelSet forward2(RelSet s, @Nullable RelSet p) {
     p = forward1(s, p);
-    p = forward1(s, p);
-    return p;
+    return forward1(s, p);
   }
 
   /** Moves forward one link, checking for a cycle. */
@@ -1244,11 +1243,10 @@ private RelSubset registerImpl(RelNode rel, @Nullable RelSet set) {
       // The same rel is already registered, so return its subset
       return getSubsetNonNull(equivExp);
     } else {
-      if (!RelOptUtil.areRowTypesEqual(equivExp.getRowType(), rel.getRowType(), false)) {
-        throw new IllegalArgumentException(
-            RelOptUtil.getFullTypeDifferenceString(
-                "equiv rowtype", equivExp.getRowType(), "rel rowtype", rel.getRowType()));
-      }
+      checkArgument(
+          RelOptUtil.areRowTypesEqual(equivExp.getRowType(), rel.getRowType(), false),
+          RelOptUtil.getFullTypeDifferenceString(
+              "equiv rowtype", equivExp.getRowType(), "rel rowtype", rel.getRowType()));
       checkPruned(equivExp, rel);
 
       RelSet equivSet = getSet(equivExp);
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRelMetadataProvider.java
index 98efda013..e6fb49d91 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRelMetadataProvider.java
@@ -24,7 +24,7 @@
 import org.apache.calcite.rel.metadata.UnboundMetadata;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -121,7 +121,7 @@ public class VolcanoRelMetadataProvider implements RelMetadataProvider {
 
   @Deprecated
   @Override public <M extends Metadata> Multimap<Method, MetadataHandler<M>> handlers(MetadataDef<M> def) {
-    return ImmutableMultimap.of();
+    return ImmutableListMultimap.of();
   }
 
   @Override public List<MetadataHandler<?>> handlers(Class<? extends MetadataHandler<?>> handlerClass) {
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
index 9bd6ee3ab..d57de5902 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
@@ -28,7 +28,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -39,11 +38,11 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * <code>VolcanoRuleCall</code> implements the {@link RelOptRuleCall} interface for VolcanoPlanner.
@@ -282,7 +281,7 @@ private void matchRecurse(int solve) {
             successors =
                 inputs.stream()
                     .flatMap(subset -> ((RelSubset) subset).getSubsetsSatisfyingThis())
-                    .collect(Collectors.toList());
+                    .collect(toList());
           } else {
             List<RelNode> allRelsInAllSubsets = new ArrayList<>();
             Set<RelNode> duplicates = new HashSet<>();
@@ -308,7 +307,7 @@ private void matchRecurse(int solve) {
           final RelSubset subset = (RelSubset) inputs.get(operand.ordinalInParent);
           if (operand.getMatchedClass() == RelSubset.class) {
             // Find all the sibling subsets that satisfy this subset'straitSet
-            successors = subset.getSubsetsSatisfyingThis().collect(Collectors.toList());
+            successors = subset.getSubsetsSatisfyingThis().collect(toList());
           } else {
             successors = subset.getRelList();
           }
@@ -355,13 +354,13 @@ private void matchRecurse(int solve) {
             // RelSubsets? Random relations from those subsets?
             // For now, Calcite code does not use getChildRels, so the bug is just waiting its day
             if (ascending) {
-              final List<RelNode> inputs = Lists.newArrayList(rel.getInputs());
+              final List<RelNode> inputs = new ArrayList<>(rel.getInputs());
               inputs.set(previousOperand.ordinalInParent, previous);
               setChildRels(rel, inputs);
             } else {
               List<RelNode> inputs = getChildRels(previous);
               if (inputs == null) {
-                inputs = Lists.newArrayList(previous.getInputs());
+                inputs = new ArrayList<>(previous.getInputs());
               }
               inputs.set(operand.ordinalInParent, rel);
               setChildRels(previous, inputs);
diff --git a/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java b/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
index b772fce01..c4184ad48 100644
--- a/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
+++ b/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
@@ -73,10 +73,11 @@
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableSet;
-import java.util.Objects;
 import java.util.function.Function;
 import java.util.function.Predicate;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Implementation of {@link org.apache.calcite.prepare.Prepare.CatalogReader} and also {@link
  * org.apache.calcite.sql.SqlOperatorTable} based on tables and functions defined schemas.
@@ -96,8 +97,7 @@ public CalciteCatalogReader(
     this(
         rootSchema,
         SqlNameMatchers.withCaseSensitive(config != null && config.caseSensitive()),
-        ImmutableList.of(
-            Objects.requireNonNull(defaultSchema, "defaultSchema"), ImmutableList.of()),
+        ImmutableList.of(requireNonNull(defaultSchema, "defaultSchema"), ImmutableList.of()),
         typeFactory,
         config);
   }
@@ -108,7 +108,7 @@ protected CalciteCatalogReader(
       List<List<String>> schemaPaths,
       RelDataTypeFactory typeFactory,
       CalciteConnectionConfig config) {
-    this.rootSchema = Objects.requireNonNull(rootSchema, "rootSchema");
+    this.rootSchema = requireNonNull(rootSchema, "rootSchema");
     this.nameMatcher = nameMatcher;
     this.schemaPaths =
         Util.immutableCopy(
@@ -194,7 +194,7 @@ private Collection<org.apache.calcite.schema.Function> getFunctionsFrom(List<Str
     if (schema == null) {
       return ImmutableList.of();
     }
-    final ImmutableList.Builder<SqlMoniker> result = new ImmutableList.Builder<>();
+    final ImmutableList.Builder<SqlMoniker> result = ImmutableList.builder();
 
     // Add root schema if not anonymous
     if (!schema.name.equals("")) {
@@ -235,13 +235,13 @@ private static SqlMonikerImpl moniker(
     return getTable(names);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public @Nullable RelDataTypeField field(RelDataType rowType, String alias) {
+  @Override @SuppressWarnings("deprecation")
+  public @Nullable RelDataTypeField field(RelDataType rowType, String alias) {
     return nameMatcher.field(rowType, alias);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public boolean matches(String string, String name) {
+  @Override @SuppressWarnings("deprecation")
+  public boolean matches(String string, String name) {
     return nameMatcher.matches(string, name);
   }
 
@@ -447,8 +447,8 @@ private static RelDataType toSql(RelDataTypeFactory typeFactory, RelDataType typ
 
   @Override public void registerRules(RelOptPlanner planner) {}
 
-  @SuppressWarnings("deprecation")
-  @Override public boolean isCaseSensitive() {
+  @Override @SuppressWarnings("deprecation")
+  public boolean isCaseSensitive() {
     return nameMatcher.isCaseSensitive();
   }
 
diff --git a/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java b/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
index 44511ff12..2cf716e4c 100644
--- a/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
+++ b/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
@@ -454,7 +454,7 @@ protected RelOptCluster createCluster(RelOptPlanner planner, RexBuilder rexBuild
    * #createPlanner(org.apache.calcite.jdbc.CalcitePrepare.Context)}.
    */
   protected List<Function1<Context, RelOptPlanner>> createPlannerFactories() {
-    return Collections.singletonList(context -> createPlanner(context, null, null));
+    return ImmutableList.of(context -> createPlanner(context, null, null));
   }
 
   /** Creates a query planner and initializes it with a default set of rules. */
@@ -1288,7 +1288,7 @@ private static List<Expression> simpleList(BlockStatement statement) {
         NewExpression newExpression = (NewExpression) simple;
         return newExpression.arguments;
       } else {
-        return Collections.singletonList(simple);
+        return ImmutableList.of(simple);
       }
     }
 
diff --git a/core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java b/core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java
index b33700242..c3042a190 100644
--- a/core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java
+++ b/core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java
@@ -43,7 +43,6 @@
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 import static java.util.Objects.requireNonNull;
@@ -153,7 +152,7 @@ private static Type getElementType(MethodCallExpression call) {
 
   private List<RexNode> toRex(RelNode child, FunctionExpression expression) {
     RexBuilder rexBuilder = cluster.getRexBuilder();
-    List<RexNode> list = Collections.singletonList(rexBuilder.makeRangeReference(child));
+    List<RexNode> list = ImmutableList.of(rexBuilder.makeRangeReference(child));
     CalcitePrepareImpl.ScalarTranslator translator =
         CalcitePrepareImpl.EmptyScalarTranslator.empty(rexBuilder)
             .bind(getParameterList(expression), list);
diff --git a/core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java b/core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
index c99f9d0ec..f762f9313 100644
--- a/core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
+++ b/core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
@@ -66,6 +66,8 @@
 import java.io.Reader;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Implementation of {@link org.apache.calcite.tools.Planner}. */
@@ -150,9 +152,8 @@ private void ensure(State state) {
     if (state == this.state) {
       return;
     }
-    if (state.ordinal() < this.state.ordinal()) {
-      throw new IllegalArgumentException("cannot move to " + state + " from " + this.state);
-    }
+    checkArgument(
+        state.ordinal() >= this.state.ordinal(), "cannot move to %s from %s", state, this.state);
     state.from(this);
   }
 
@@ -248,8 +249,8 @@ private void ready() {
         .getParameterRowType(requireNonNull(validatedSqlNode, "validatedSqlNode"));
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public final RelNode convert(SqlNode sql) {
+  @Override @SuppressWarnings("deprecation")
+  public final RelNode convert(SqlNode sql) {
     return rel(sql).rel;
   }
 
@@ -365,8 +366,8 @@ private RexBuilder createRexBuilder() {
     return requireNonNull(typeFactory, "typeFactory");
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelNode transform(int ruleSetIndex, RelTraitSet requiredOutputTraits, RelNode rel) {
+  @Override @SuppressWarnings("deprecation")
+  public RelNode transform(int ruleSetIndex, RelTraitSet requiredOutputTraits, RelNode rel) {
     ensure(State.STATE_5_CONVERTED);
     rel.getCluster()
         .setMetadataProvider(
diff --git a/core/src/main/java/org/apache/calcite/prepare/Prepare.java b/core/src/main/java/org/apache/calcite/prepare/Prepare.java
index 1f9180bb4..6f4d58fc0 100644
--- a/core/src/main/java/org/apache/calcite/prepare/Prepare.java
+++ b/core/src/main/java/org/apache/calcite/prepare/Prepare.java
@@ -394,8 +394,8 @@ public interface PreparingTable extends RelOptTable, SqlValidatorTable {}
    * #columnHasDefaultValue}.
    */
   public abstract static class AbstractPreparingTable implements PreparingTable {
-    @SuppressWarnings("deprecation")
-    @Override public boolean columnHasDefaultValue(
+    @Override @SuppressWarnings("deprecation")
+    public boolean columnHasDefaultValue(
         RelDataType rowType, int ordinal, InitializerContext initializerContext) {
       // This method is no longer used
       final Table table = this.unwrap(Table.class);
@@ -499,7 +499,7 @@ protected PreparedExplain(
     }
 
     @Override public List<@Nullable List<String>> getFieldOrigins() {
-      return Collections.singletonList(Collections.nCopies(4, null));
+      return ImmutableList.of(Collections.nCopies(4, null));
     }
   }
 
@@ -559,7 +559,7 @@ protected PreparedResultImpl(
       this.rowType = requireNonNull(rowType, "rowType");
       this.parameterRowType = requireNonNull(parameterRowType, "parameterRowType");
       this.fieldOrigins = requireNonNull(fieldOrigins, "fieldOrigins");
-      this.collations = ImmutableList.copyOf(collations);
+      this.collations = collations;
       this.rootRel = requireNonNull(rootRel, "rootRel");
       this.tableModOp = tableModOp;
       this.isDml = isDml;
diff --git a/core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java b/core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java
index ab4629980..a88e08f6c 100644
--- a/core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java
+++ b/core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java
@@ -27,8 +27,6 @@
 import org.apache.calcite.util.PartiallyOrderedSet;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
@@ -37,7 +35,6 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.nio.ByteBuffer;
-import java.nio.charset.StandardCharsets;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -57,9 +54,12 @@
 import java.util.TreeSet;
 import java.util.function.Predicate;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.profile.ProfilerImpl.CompositeCollector.OF;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -95,8 +95,8 @@ public static Builder builder() {
    */
   ProfilerImpl(
       int combinationsPerPass, int interestingCount, Predicate<Pair<Space, Column>> predicate) {
-    Preconditions.checkArgument(combinationsPerPass > 2);
-    Preconditions.checkArgument(interestingCount > 2);
+    checkArgument(combinationsPerPass > 2);
+    checkArgument(interestingCount > 2);
     this.combinationsPerPass = combinationsPerPass;
     this.interestingCount = interestingCount;
     this.predicate = predicate;
@@ -163,11 +163,9 @@ class Run {
      *     they may be interesting
      */
     Run(final List<Column> columns, Collection<ImmutableBitSet> initialGroups) {
-      this.columns = ImmutableList.copyOf(columns);
+      this.columns = columns;
       for (Ord<Column> column : Ord.zip(columns)) {
-        if (column.e.ordinal != column.i) {
-          throw new IllegalArgumentException();
-        }
+        checkArgument(column.e.ordinal == column.i);
       }
       this.singletonSpaces = new ArrayList<>(Collections.nCopies(columns.size(), (Space) null));
       if (combinationsPerPass > Math.pow(2D, columns.size())) {
@@ -462,7 +460,7 @@ private double expectedCardinality(double rowCount, ImmutableBitSet columns) {
 
     private ImmutableSortedSet<Column> toColumns(Iterable<Integer> ordinals) {
       //noinspection Convert2MethodRef
-      return ImmutableSortedSet.copyOf(Util.transform(ordinals, idx -> columns.get(idx)));
+      return ImmutableSortedSet.copyOf(Util.transform(ordinals, columns::get));
     }
   }
 
@@ -736,7 +734,7 @@ static class HllCompositeCollector extends HllCollector {
           }
           buf.put((byte) 0);
         } else if (value instanceof String) {
-          buf.put((byte) 1).put(((String) value).getBytes(StandardCharsets.UTF_8));
+          buf.put((byte) 1).put(((String) value).getBytes(UTF_8));
         } else if (value instanceof Double) {
           buf.put((byte) 2).putDouble((Double) value);
         } else if (value instanceof Float) {
@@ -748,7 +746,7 @@ static class HllCompositeCollector extends HllCollector {
         } else if (value instanceof Boolean) {
           buf.put((Boolean) value ? (byte) 6 : (byte) 7);
         } else {
-          buf.put((byte) 8).put(value.toString().getBytes(StandardCharsets.UTF_8));
+          buf.put((byte) 8).put(value.toString().getBytes(UTF_8));
         }
       }
       sketch.update(Arrays.copyOf(buf.array(), buf.position()));
@@ -769,12 +767,12 @@ static class SurpriseQueue {
     SurpriseQueue(int warmUpCount, int size) {
       this.warmUpCount = warmUpCount;
       this.size = size;
-      Preconditions.checkArgument(warmUpCount > 3);
-      Preconditions.checkArgument(size > 0);
+      checkArgument(warmUpCount > 3);
+      checkArgument(size > 0);
     }
 
     @Override public String toString() {
-      return "min: " + priorityQueue.peek() + ", contents: " + deque.toString();
+      return "min: " + priorityQueue.peek() + ", contents: " + deque;
     }
 
     boolean isValid() {
diff --git a/core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java b/core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java
index 7452374b1..e7a346287 100644
--- a/core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java
+++ b/core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java
@@ -44,6 +44,8 @@
 import java.util.SortedSet;
 import java.util.TreeSet;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Basic implementation of {@link Profiler}. */
@@ -106,9 +108,7 @@ static class Run {
 
     Run(final List<Column> columns) {
       for (Ord<Column> column : Ord.zip(columns)) {
-        if (column.e.ordinal != column.i) {
-          throw new IllegalArgumentException();
-        }
+        checkArgument(column.e.ordinal == column.i);
       }
       this.columns = columns;
       this.singletonSpaces = new ArrayList<>(Collections.nCopies(columns.size(), null));
@@ -292,7 +292,7 @@ private boolean hasNull(ImmutableBitSet columnOrdinals) {
     private ImmutableSortedSet<Column> toColumns(
         @UnknownInitialization Run this, Iterable<Integer> ordinals) {
       //noinspection Convert2MethodRef
-      return ImmutableSortedSet.copyOf(Util.transform(ordinals, idx -> columns.get(idx)));
+      return ImmutableSortedSet.copyOf(Util.transform(ordinals, columns::get));
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java b/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
index 1f01198ff..3369efab7 100644
--- a/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
+++ b/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
@@ -39,6 +39,7 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
 import org.apiguardian.api.API;
@@ -48,7 +49,6 @@
 import org.checkerframework.dataflow.qual.Pure;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -121,8 +121,8 @@ protected static <T> T sole(List<T> collection) {
     return cluster;
   }
 
-  @Pure
-  @Override public final @Nullable Convention getConvention(@UnknownInitialization AbstractRelNode this) {
+  @Override @Pure
+  public final @Nullable Convention getConvention(@UnknownInitialization AbstractRelNode this) {
     return traitSet == null ? null : traitSet.getTrait(ConventionTraitDef.INSTANCE);
   }
 
@@ -182,7 +182,7 @@ protected RelDataType deriveRowType() {
   }
 
   @Override public List<RelNode> getInputs() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Override public double estimateRowCount(RelMetadataQuery mq) {
diff --git a/core/src/main/java/org/apache/calcite/rel/RelCollationImpl.java b/core/src/main/java/org/apache/calcite/rel/RelCollationImpl.java
index 91c66d39f..b600966ab 100644
--- a/core/src/main/java/org/apache/calcite/rel/RelCollationImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/RelCollationImpl.java
@@ -26,7 +26,6 @@
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.UnmodifiableIterator;
 
@@ -35,6 +34,8 @@
 import java.util.Iterator;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Simple implementation of {@link RelCollation}. */
 public class RelCollationImpl implements RelCollation {
   // ~ Static fields/initializers ---------------------------------------------
@@ -53,7 +54,7 @@ public class RelCollationImpl implements RelCollation {
 
   protected RelCollationImpl(ImmutableList<RelFieldCollation> fieldCollations) {
     this.fieldCollations = fieldCollations;
-    Preconditions.checkArgument(
+    checkArgument(
         Util.isDistinct(RelCollations.ordinals(fieldCollations)), "fields must be distinct");
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/RelCollations.java b/core/src/main/java/org/apache/calcite/rel/RelCollations.java
index 1278c32e4..236815b0c 100644
--- a/core/src/main/java/org/apache/calcite/rel/RelCollations.java
+++ b/core/src/main/java/org/apache/calcite/rel/RelCollations.java
@@ -29,9 +29,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Utilities concerning {@link org.apache.calcite.rel.RelCollation} and {@link
@@ -87,7 +87,7 @@ public static RelCollation of(int fieldIndex) {
   /** Creates a collation containing multiple fields. */
   public static RelCollation of(ImmutableIntList keys) {
     List<RelFieldCollation> cols =
-        keys.stream().map(k -> new RelFieldCollation(k)).collect(Collectors.toList());
+        keys.stream().map(k -> new RelFieldCollation(k)).collect(toList());
     return of(cols);
   }
 
@@ -208,7 +208,7 @@ public static boolean containsOrderless(List<Integer> keys, RelCollation collati
     if (colKeys.size() > distinctKeys.size()) {
       return false;
     } else {
-      return colKeys.stream().allMatch(i -> distinctKeys.contains(i));
+      return colKeys.stream().allMatch(distinctKeys::contains);
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/RelDistributions.java b/core/src/main/java/org/apache/calcite/rel/RelDistributions.java
index 7ba81dd23..2d1c505c4 100644
--- a/core/src/main/java/org/apache/calcite/rel/RelDistributions.java
+++ b/core/src/main/java/org/apache/calcite/rel/RelDistributions.java
@@ -32,6 +32,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /** Utilities concerning {@link org.apache.calcite.rel.RelDistribution}. */
 public class RelDistributions {
   public static final ImmutableIntList EMPTY = ImmutableIntList.of();
@@ -91,7 +93,7 @@ private static class RelDistributionImpl implements RelDistribution {
     private final ImmutableIntList keys;
 
     private RelDistributionImpl(Type type, ImmutableIntList keys) {
-      this.type = Objects.requireNonNull(type, "type");
+      this.type = requireNonNull(type, "type");
       this.keys = ImmutableIntList.copyOf(keys);
       assert type != Type.HASH_DISTRIBUTED || keys.size() < 2 || Ordering.natural().isOrdered(keys)
           : "key columns of hash distribution must be in order";
diff --git a/core/src/main/java/org/apache/calcite/rel/RelFieldCollation.java b/core/src/main/java/org/apache/calcite/rel/RelFieldCollation.java
index 6b3b726ad..32f9d65b7 100644
--- a/core/src/main/java/org/apache/calcite/rel/RelFieldCollation.java
+++ b/core/src/main/java/org/apache/calcite/rel/RelFieldCollation.java
@@ -22,6 +22,8 @@
 
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Definition of the ordering of one field of a {@link RelNode} whose output is to be sorted.
  *
@@ -207,8 +209,8 @@ public RelFieldCollation(int fieldIndex, Direction direction) {
   /** Creates a field collation. */
   public RelFieldCollation(int fieldIndex, Direction direction, NullDirection nullDirection) {
     this.fieldIndex = fieldIndex;
-    this.direction = Objects.requireNonNull(direction, "direction");
-    this.nullDirection = Objects.requireNonNull(nullDirection, "nullDirection");
+    this.direction = requireNonNull(direction, "direction");
+    this.nullDirection = requireNonNull(nullDirection, "nullDirection");
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/rel/RelReferentialConstraintImpl.java b/core/src/main/java/org/apache/calcite/rel/RelReferentialConstraintImpl.java
index a4485d2dd..f97a3698a 100644
--- a/core/src/main/java/org/apache/calcite/rel/RelReferentialConstraintImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/RelReferentialConstraintImpl.java
@@ -18,8 +18,6 @@
 
 import org.apache.calcite.util.mapping.IntPair;
 
-import com.google.common.collect.ImmutableList;
-
 import java.util.List;
 
 /** RelOptReferentialConstraint base implementation. */
@@ -33,9 +31,9 @@ private RelReferentialConstraintImpl(
       List<String> sourceQualifiedName,
       List<String> targetQualifiedName,
       List<IntPair> columnPairs) {
-    this.sourceQualifiedName = ImmutableList.copyOf(sourceQualifiedName);
-    this.targetQualifiedName = ImmutableList.copyOf(targetQualifiedName);
-    this.columnPairs = ImmutableList.copyOf(columnPairs);
+    this.sourceQualifiedName = sourceQualifiedName;
+    this.targetQualifiedName = targetQualifiedName;
+    this.columnPairs = columnPairs;
   }
 
   @Override public List<String> getSourceQualifiedName() {
diff --git a/core/src/main/java/org/apache/calcite/rel/RelRoot.java b/core/src/main/java/org/apache/calcite/rel/RelRoot.java
index 1dab60bdb..352a36087 100644
--- a/core/src/main/java/org/apache/calcite/rel/RelRoot.java
+++ b/core/src/main/java/org/apache/calcite/rel/RelRoot.java
@@ -31,7 +31,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Root of a tree of {@link RelNode}.
@@ -114,7 +115,7 @@ public RelRoot(
     this.validatedRowType = validatedRowType;
     this.kind = kind;
     this.fields = ImmutableList.copyOf(fields);
-    this.collation = Objects.requireNonNull(collation, "collation");
+    this.collation = requireNonNull(collation, "collation");
     this.hints = ImmutableList.copyOf(hints);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java b/core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java
index 204fa6167..e9c801d8b 100644
--- a/core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/convert/ConverterRule.java
@@ -35,6 +35,8 @@
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Abstract base class for a rule which converts from one calling convention to another without
  * changing semantics.
@@ -52,8 +54,8 @@ public abstract class ConverterRule extends RelRule<ConverterRule.Config> {
   /** Creates a <code>ConverterRule</code>. */
   protected ConverterRule(Config config) {
     super(config);
-    this.inTrait = Objects.requireNonNull(config.inTrait());
-    this.outTrait = Objects.requireNonNull(config.outTrait());
+    this.inTrait = requireNonNull(config.inTrait());
+    this.outTrait = requireNonNull(config.outTrait());
 
     // Source and target traits must have same type
     assert inTrait.getTraitDef() == outTrait.getTraitDef();
@@ -78,8 +80,8 @@ protected ConverterRule(
     this(Config.INSTANCE.withConversion(clazz, in, out, descriptionPrefix));
   }
 
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   protected <R extends RelNode> ConverterRule(
       Class<R> clazz,
       com.google.common.base.Predicate<? super R> predicate,
@@ -117,8 +119,8 @@ protected <R extends RelNode> ConverterRule(
             .withConversion(clazz, predicate, in, out, descriptionPrefix));
   }
 
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   protected <R extends RelNode> ConverterRule(
       Class<R> clazz,
       com.google.common.base.Predicate<? super R> predicate,
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Aggregate.java b/core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
index 214306640..12536e839 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
@@ -52,13 +52,13 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Collections.reverse;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -151,7 +151,7 @@ protected Aggregate(
       List<AggregateCall> aggCalls) {
     super(cluster, traitSet, input);
     this.hints = ImmutableList.copyOf(hints);
-    this.aggCalls = ImmutableList.copyOf(aggCalls);
+    this.aggCalls = aggCalls;
     this.groupSet = requireNonNull(groupSet, "groupSet");
     if (groupSets == null) {
       this.groupSets = ImmutableList.of(groupSet);
@@ -485,9 +485,8 @@ public enum Group {
     OTHER;
 
     public static Group induce(ImmutableBitSet groupSet, List<ImmutableBitSet> groupSets) {
-      if (!ImmutableBitSet.ORDERING.isStrictlyOrdered(groupSets)) {
-        throw new IllegalArgumentException("must be sorted: " + groupSets);
-      }
+      checkArgument(
+          ImmutableBitSet.ORDERING.isStrictlyOrdered(groupSets), "must be sorted: %s", groupSets);
       if (groupSets.size() == 1 && groupSets.get(0).equals(groupSet)) {
         return SIMPLE;
       }
@@ -558,8 +557,8 @@ public static List<Integer> getRollup(List<ImmutableBitSet> groupSets) {
         }
         g = bitSet;
       }
-      Collections.reverse(rollUpBits);
-      return ImmutableList.copyOf(rollUpBits);
+      reverse(rollUpBits);
+      return rollUpBits;
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java b/core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
index ff7fad064..da84ad4e1 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
@@ -32,7 +32,6 @@
 import org.apache.calcite.util.mapping.Mapping;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -40,6 +39,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Call to an aggregate function within an {@link org.apache.calcite.rel.core.Aggregate}. */
@@ -125,17 +126,17 @@ private AggregateCall(
     this.name = name;
     this.aggFunction = requireNonNull(aggFunction, "aggFunction");
     this.argList = ImmutableList.copyOf(argList);
-    this.rexList = ImmutableList.copyOf(rexList);
+    this.rexList = rexList;
     this.distinctKeys = distinctKeys;
     this.filterArg = filterArg;
     this.collation = requireNonNull(collation, "collation");
     this.distinct = distinct;
     this.approximate = approximate;
     this.ignoreNulls = ignoreNulls;
-    Preconditions.checkArgument(
+    checkArgument(
         aggFunction.getDistinctOptionality() != Optionality.IGNORED || !distinct,
         "DISTINCT has no effect for this aggregate function, so must be false");
-    Preconditions.checkArgument(filterArg < 0 || aggFunction.allowsFilter());
+    checkArgument(filterArg < 0 || aggFunction.allowsFilter());
   }
 
   // ~ Methods ----------------------------------------------------------------
@@ -652,7 +653,7 @@ public AggregateCall rename(@Nullable String name) {
       buf.append("APPROXIMATE ");
     }
     if (distinct) {
-      buf.append((argList.size() == 0) ? "DISTINCT" : "DISTINCT ");
+      buf.append(argList.isEmpty() ? "DISTINCT" : "DISTINCT ");
     }
     int i = -1;
     for (RexNode rexNode : rexList) {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/EquiJoin.java b/core/src/main/java/org/apache/calcite/rel/core/EquiJoin.java
index 24f845ed5..268a80359 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/EquiJoin.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/EquiJoin.java
@@ -24,9 +24,10 @@
 
 import com.google.common.collect.ImmutableList;
 
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Base class for any join whose condition is based on column equality.
  *
@@ -59,8 +60,8 @@ protected EquiJoin(
       Set<CorrelationId> variablesSet,
       JoinRelType joinType) {
     super(cluster, traits, ImmutableList.of(), left, right, condition, variablesSet, joinType);
-    this.leftKeys = Objects.requireNonNull(joinInfo.leftKeys);
-    this.rightKeys = Objects.requireNonNull(joinInfo.rightKeys);
+    this.leftKeys = requireNonNull(joinInfo.leftKeys);
+    this.rightKeys = requireNonNull(joinInfo.rightKeys);
     assert joinInfo.isEqui() : "Create EquiJoin with non-equi join condition.";
   }
 
@@ -77,8 +78,8 @@ protected EquiJoin(
       Set<CorrelationId> variablesSet,
       JoinRelType joinType) {
     super(cluster, traits, ImmutableList.of(), left, right, condition, variablesSet, joinType);
-    this.leftKeys = Objects.requireNonNull(leftKeys, "leftKeys");
-    this.rightKeys = Objects.requireNonNull(rightKeys, "rightKeys");
+    this.leftKeys = requireNonNull(leftKeys, "leftKeys");
+    this.rightKeys = requireNonNull(rightKeys, "rightKeys");
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Exchange.java b/core/src/main/java/org/apache/calcite/rel/core/Exchange.java
index c987e1c77..85d1bfc6f 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Exchange.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Exchange.java
@@ -33,7 +33,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression that imposes a particular distribution on its input without otherwise
@@ -59,7 +60,7 @@ public abstract class Exchange extends SingleRel {
   protected Exchange(
       RelOptCluster cluster, RelTraitSet traitSet, RelNode input, RelDistribution distribution) {
     super(cluster, traitSet, input);
-    this.distribution = Objects.requireNonNull(distribution, "distribution");
+    this.distribution = requireNonNull(distribution, "distribution");
 
     assert traitSet.containsIfApplicable(distribution)
         : "traits=" + traitSet + ", distribution=" + distribution;
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Intersect.java b/core/src/main/java/org/apache/calcite/rel/core/Intersect.java
index 9b5ed4d4c..3a47ac2a6 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Intersect.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Intersect.java
@@ -24,7 +24,8 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.sql.SqlKind;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -47,7 +48,7 @@ public Intersect(
   /** Creates an Intersect. */
   protected Intersect(
       RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, boolean all) {
-    this(cluster, traits, Collections.emptyList(), inputs, all);
+    this(cluster, traits, ImmutableList.of(), inputs, all);
   }
 
   /** Creates an Intersect by parsing serialized output. */
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Join.java b/core/src/main/java/org/apache/calcite/rel/core/Join.java
index 2c4d13682..b9383c8c8 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Join.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Join.java
@@ -45,11 +45,12 @@
 import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Relational expression that combines two relational expressions according to some condition.
  *
@@ -96,9 +97,9 @@ protected Join(
       Set<CorrelationId> variablesSet,
       JoinRelType joinType) {
     super(cluster, traitSet, left, right);
-    this.condition = Objects.requireNonNull(condition, "condition");
+    this.condition = requireNonNull(condition, "condition");
     this.variablesSet = ImmutableSet.copyOf(variablesSet);
-    this.joinType = Objects.requireNonNull(joinType, "joinType");
+    this.joinType = requireNonNull(joinType, "joinType");
     this.joinInfo = JoinInfo.of(left, right, condition);
     this.hints = ImmutableList.copyOf(hints);
   }
@@ -286,7 +287,7 @@ public boolean isSemiJoin() {
    * @return list of system fields
    */
   public List<RelDataTypeField> getSystemFieldList() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/core/JoinInfo.java b/core/src/main/java/org/apache/calcite/rel/core/JoinInfo.java
index 5403f172e..5a96bbd9c 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/JoinInfo.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/JoinInfo.java
@@ -30,7 +30,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * An analyzed join condition.
@@ -52,9 +53,9 @@ protected JoinInfo(
       ImmutableIntList leftKeys,
       ImmutableIntList rightKeys,
       ImmutableList<RexNode> nonEquiConditions) {
-    this.leftKeys = Objects.requireNonNull(leftKeys, "leftKeys");
-    this.rightKeys = Objects.requireNonNull(rightKeys, "rightKeys");
-    this.nonEquiConditions = Objects.requireNonNull(nonEquiConditions, "nonEquiConditions");
+    this.leftKeys = requireNonNull(leftKeys, "leftKeys");
+    this.rightKeys = requireNonNull(rightKeys, "rightKeys");
+    this.nonEquiConditions = requireNonNull(nonEquiConditions, "nonEquiConditions");
     assert leftKeys.size() == rightKeys.size();
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Match.java b/core/src/main/java/org/apache/calcite/rel/core/Match.java
index fda9c9cee..480b11c2e 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Match.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Match.java
@@ -35,7 +35,6 @@
 import org.apache.calcite.sql.fun.SqlSumEmptyIsZeroAggFunction;
 import org.apache.calcite.util.ImmutableBitSet;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.ImmutableSortedSet;
@@ -46,12 +45,15 @@
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableSet;
-import java.util.Objects;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeMap;
 import java.util.TreeSet;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Relational expression that represent a MATCH_RECOGNIZE node.
  *
@@ -112,18 +114,18 @@ protected Match(
       RelCollation orderKeys,
       @Nullable RexNode interval) {
     super(cluster, traitSet, input);
-    this.rowType = Objects.requireNonNull(rowType, "rowType");
-    this.pattern = Objects.requireNonNull(pattern, "pattern");
-    Preconditions.checkArgument(patternDefinitions.size() > 0);
+    this.rowType = requireNonNull(rowType, "rowType");
+    this.pattern = requireNonNull(pattern, "pattern");
+    checkArgument(patternDefinitions.size() > 0);
     this.strictStart = strictStart;
     this.strictEnd = strictEnd;
     this.patternDefinitions = ImmutableMap.copyOf(patternDefinitions);
     this.measures = ImmutableMap.copyOf(measures);
-    this.after = Objects.requireNonNull(after, "after");
+    this.after = requireNonNull(after, "after");
     this.subsets = copyMap(subsets);
     this.allRows = allRows;
-    this.partitionKeys = Objects.requireNonNull(partitionKeys, "partitionKeys");
-    this.orderKeys = Objects.requireNonNull(orderKeys, "orderKeys");
+    this.partitionKeys = requireNonNull(partitionKeys, "partitionKeys");
+    this.orderKeys = requireNonNull(orderKeys, "orderKeys");
     this.interval = interval;
 
     final AggregateFinder aggregateFinder = new AggregateFinder();
@@ -257,7 +259,7 @@ private static class AggregateFinder extends RexVisitorImpl<Void> {
                 aggFunction, call.getType(), call.getOperands(), aggregateCalls.size());
         aggregateCalls.add(aggCall);
         Set<String> pv = new PatternVarFinder().go(call.getOperands());
-        if (pv.size() == 0) {
+        if (pv.isEmpty()) {
           pv.add(STAR);
         }
         for (String alpha : pv) {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Minus.java b/core/src/main/java/org/apache/calcite/rel/core/Minus.java
index e0d51f2f5..72d8fe800 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Minus.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Minus.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.sql.SqlKind;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -49,7 +50,7 @@ public Minus(
   }
 
   protected Minus(RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, boolean all) {
-    this(cluster, traits, Collections.emptyList(), inputs, all);
+    this(cluster, traits, ImmutableList.of(), inputs, all);
   }
 
   /** Creates a Minus by parsing serialized output. */
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Project.java b/core/src/main/java/org/apache/calcite/rel/core/Project.java
index d535bbae1..8a223819b 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Project.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Project.java
@@ -55,10 +55,10 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Objects;
-import java.util.Optional;
 import java.util.Set;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.Objects.requireNonNullElse;
 
 /**
  * Relational expression that computes a set of 'select expressions' from its input relational
@@ -151,8 +151,7 @@ protected Project(RelInput input) {
         input.getRowType("exprs", "fields"),
         ImmutableSet.copyOf(
             Util.transform(
-                Optional.ofNullable(input.getIntegerList("variablesSet"))
-                    .orElse(ImmutableList.of()),
+                requireNonNullElse(input.getIntegerList("variablesSet"), ImmutableList.of()),
                 id -> new CorrelationId(id))));
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java b/core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java
index 271f77338..80ca4f97c 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java
@@ -31,7 +31,10 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression that computes a repeat union (recursive union in SQL terminology).
@@ -77,7 +80,7 @@ protected RepeatUnion(
     this.all = all;
     this.transientTable = transientTable;
     if (transientTable != null) {
-      Objects.requireNonNull(transientTable.unwrap(TransientTable.class));
+      requireNonNull(transientTable.unwrap(TransientTable.class));
     }
   }
 
@@ -114,12 +117,10 @@ public RelNode getIterativeRel() {
   @Override protected RelDataType deriveRowType() {
     final List<RelDataType> inputRowTypes = Util.transform(getInputs(), RelNode::getRowType);
     final RelDataType rowType = getCluster().getTypeFactory().leastRestrictive(inputRowTypes);
-    if (rowType == null) {
-      throw new IllegalArgumentException(
-          "Cannot compute compatible row type "
-              + "for arguments: "
-              + Util.sepList(inputRowTypes, ", "));
-    }
+    checkArgument(
+        rowType != null,
+        "Cannot compute compatible row type for arguments: %s",
+        Util.sepList(inputRowTypes, ", "));
     return rowType;
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/rel/core/SetOp.java b/core/src/main/java/org/apache/calcite/rel/core/SetOp.java
index 53a8874c9..d9e7aaf96 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/SetOp.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/SetOp.java
@@ -30,13 +30,13 @@
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * <code>SetOp</code> is an abstract base for relational set operators such as UNION, MINUS (aka
  * EXCEPT), and INTERSECT.
@@ -60,8 +60,7 @@ protected SetOp(
       SqlKind kind,
       boolean all) {
     super(cluster, traits);
-    Preconditions.checkArgument(
-        kind == SqlKind.UNION || kind == SqlKind.INTERSECT || kind == SqlKind.EXCEPT);
+    checkArgument(kind == SqlKind.UNION || kind == SqlKind.INTERSECT || kind == SqlKind.EXCEPT);
     this.kind = kind;
     this.inputs = ImmutableList.copyOf(inputs);
     this.all = all;
@@ -71,7 +70,7 @@ protected SetOp(
   /** Creates a SetOp. */
   protected SetOp(
       RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, SqlKind kind, boolean all) {
-    this(cluster, traits, Collections.emptyList(), inputs, kind, all);
+    this(cluster, traits, ImmutableList.of(), inputs, kind, all);
   }
 
   /** Creates a SetOp by parsing serialized output. */
@@ -79,7 +78,7 @@ protected SetOp(RelInput input) {
     this(
         input.getCluster(),
         input.getTraitSet(),
-        Collections.emptyList(),
+        ImmutableList.of(),
         input.getInputs(),
         SqlKind.UNION,
         input.getBoolean("all", false));
@@ -115,12 +114,10 @@ protected SetOp(RelInput input) {
   @Override protected RelDataType deriveRowType() {
     final List<RelDataType> inputRowTypes = Util.transform(inputs, RelNode::getRowType);
     final RelDataType rowType = getCluster().getTypeFactory().leastRestrictive(inputRowTypes);
-    if (rowType == null) {
-      throw new IllegalArgumentException(
-          "Cannot compute compatible row type "
-              + "for arguments to set op: "
-              + Util.sepList(inputRowTypes, ", "));
-    }
+    checkArgument(
+        rowType != null,
+        "Cannot compute compatible row type for arguments to set op: %s",
+        Util.sepList(inputRowTypes, ", "));
     return rowType;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Snapshot.java b/core/src/main/java/org/apache/calcite/rel/core/Snapshot.java
index befa52292..8fea91ccf 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Snapshot.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Snapshot.java
@@ -35,7 +35,6 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
 
 import static java.util.Objects.requireNonNull;
 
@@ -85,7 +84,7 @@ protected Snapshot(
       RelNode input,
       RexNode period) {
     super(cluster, traitSet, input);
-    this.period = Objects.requireNonNull(period, "period");
+    this.period = requireNonNull(period, "period");
     this.hints = ImmutableList.copyOf(hints);
     assert isValid(Litmus.THROW, null);
   }
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Sort.java b/core/src/main/java/org/apache/calcite/rel/core/Sort.java
index a92540fe2..fe8f9993d 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Sort.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Sort.java
@@ -40,9 +40,9 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression that imposes a particular sort order on its input without otherwise
@@ -97,7 +97,7 @@ protected Sort(
    * @param collation array of sort specifications
    */
   protected Sort(RelOptCluster cluster, RelTraitSet traits, RelNode child, RelCollation collation) {
-    this(cluster, traits, Collections.emptyList(), child, collation, null, null);
+    this(cluster, traits, ImmutableList.of(), child, collation, null, null);
   }
 
   /**
@@ -117,7 +117,7 @@ protected Sort(
       RelCollation collation,
       @Nullable RexNode offset,
       @Nullable RexNode fetch) {
-    this(cluster, traits, Collections.emptyList(), child, collation, offset, fetch);
+    this(cluster, traits, ImmutableList.of(), child, collation, offset, fetch);
   }
 
   /** Creates a Sort by parsing serialized output. */
@@ -222,7 +222,7 @@ public abstract Sort copy(
   }
 
   @Override public boolean isEnforcer() {
-    return offset == null && fetch == null && collation.getFieldCollations().size() > 0;
+    return offset == null && fetch == null && !collation.getFieldCollations().isEmpty();
   }
 
   /**
@@ -247,7 +247,7 @@ public List<RexNode> getSortExps() {
         field ->
             getCluster()
                 .getRexBuilder()
-                .makeInputRef(input, Objects.requireNonNull(field, "field").getFieldIndex()));
+                .makeInputRef(input, requireNonNull(field, "field").getFieldIndex()));
   }
 
   @Override public RelWriter explainTerms(RelWriter pw) {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/SortExchange.java b/core/src/main/java/org/apache/calcite/rel/core/SortExchange.java
index 975efdfc9..29179698a 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/SortExchange.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/SortExchange.java
@@ -26,7 +26,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelWriter;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression that performs {@link Exchange} and {@link Sort} simultaneously.
@@ -58,7 +58,7 @@ protected SortExchange(
       RelDistribution distribution,
       RelCollation collation) {
     super(cluster, traitSet, input, distribution);
-    this.collation = Objects.requireNonNull(collation, "collation");
+    this.collation = requireNonNull(collation, "collation");
 
     assert traitSet.containsIfApplicable(collation)
         : "traits=" + traitSet + ", collation=" + collation;
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Spool.java b/core/src/main/java/org/apache/calcite/rel/core/Spool.java
index c1cf86b39..9a16127a3 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Spool.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Spool.java
@@ -24,7 +24,8 @@
 import org.apache.calcite.rel.SingleRel;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression that iterates over its input and, in addition to returning its results,
@@ -67,8 +68,8 @@ public enum Type {
   protected Spool(
       RelOptCluster cluster, RelTraitSet traitSet, RelNode input, Type readType, Type writeType) {
     super(cluster, traitSet, input);
-    this.readType = Objects.requireNonNull(readType, "readType");
-    this.writeType = Objects.requireNonNull(writeType, "writeType");
+    this.readType = requireNonNull(readType, "readType");
+    this.writeType = requireNonNull(writeType, "writeType");
   }
 
   @Override public final RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java b/core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
index dc28ea56d..cdafa46ef 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
@@ -38,7 +38,6 @@
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -132,7 +131,7 @@ protected TableFunctionScan(RelInput input) {
     this(
         input.getCluster(),
         input.getTraitSet(),
-        Collections.emptyList(),
+        ImmutableList.of(),
         input.getInputs(),
         requireNonNull(input.getExpression("invocation"), "invocation"),
         (Type) input.get("elementType"),
@@ -190,7 +189,7 @@ public abstract TableFunctionScan copy(
     // for a no-input UDX, behave like an AbstractRelNode; for a one-input
     // UDX, behave like a SingleRel; for a multi-input UDX, behave like
     // UNION ALL.  TODO jvs 10-Sep-2007: UDX-supplied costing metadata.
-    if (inputs.size() == 0) {
+    if (inputs.isEmpty()) {
       return super.estimateRowCount(mq);
     }
     double nRows = 0.0;
diff --git a/core/src/main/java/org/apache/calcite/rel/core/TableModify.java b/core/src/main/java/org/apache/calcite/rel/core/TableModify.java
index a871b66c3..c6e1a248d 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/TableModify.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/TableModify.java
@@ -36,13 +36,13 @@
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.type.SqlTypeUtil;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -127,14 +127,14 @@ protected TableModify(
     if (operation == Operation.UPDATE) {
       requireNonNull(updateColumnList, "updateColumnList");
       requireNonNull(sourceExpressionList, "sourceExpressionList");
-      Preconditions.checkArgument(sourceExpressionList.size() == updateColumnList.size());
+      checkArgument(sourceExpressionList.size() == updateColumnList.size());
     } else {
       if (operation == Operation.MERGE) {
         requireNonNull(updateColumnList, "updateColumnList");
       } else {
-        Preconditions.checkArgument(updateColumnList == null);
+        checkArgument(updateColumnList == null);
       }
-      Preconditions.checkArgument(sourceExpressionList == null);
+      checkArgument(sourceExpressionList == null);
     }
     RelOptSchema relOptSchema = table.getRelOptSchema();
     if (relOptSchema != null) {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/TableScan.java b/core/src/main/java/org/apache/calcite/rel/core/TableScan.java
index 3e6d757b5..fe3833a3b 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/TableScan.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/TableScan.java
@@ -44,9 +44,10 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /** Relational operator that returns the contents of a table. */
 public abstract class TableScan extends AbstractRelNode implements Hintable {
   // ~ Instance fields --------------------------------------------------------
@@ -62,7 +63,7 @@ public abstract class TableScan extends AbstractRelNode implements Hintable {
   protected TableScan(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelHint> hints, RelOptTable table) {
     super(cluster, traitSet);
-    this.table = Objects.requireNonNull(table, "table");
+    this.table = requireNonNull(table, "table");
     RelOptSchema relOptSchema = table.getRelOptSchema();
     if (relOptSchema != null) {
       cluster.getPlanner().registerSchema(relOptSchema);
diff --git a/core/src/main/java/org/apache/calcite/rel/core/TableSpool.java b/core/src/main/java/org/apache/calcite/rel/core/TableSpool.java
index 3bef3abd2..2f830a169 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/TableSpool.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/TableSpool.java
@@ -23,7 +23,7 @@
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelWriter;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Spool that writes into a table.
@@ -43,7 +43,7 @@ protected TableSpool(
       Type writeType,
       RelOptTable table) {
     super(cluster, traitSet, input, readType, writeType);
-    this.table = Objects.requireNonNull(table, "table");
+    this.table = requireNonNull(table, "table");
   }
 
   @Override public RelOptTable getTable() {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Uncollect.java b/core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
index b27284ea0..1a21e6d65 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
@@ -32,7 +32,6 @@
 
 import com.google.common.collect.ImmutableList;
 
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -60,7 +59,7 @@ public class Uncollect extends SingleRel {
 
   @Deprecated // to be removed before 2.0
   public Uncollect(RelOptCluster cluster, RelTraitSet traitSet, RelNode child) {
-    this(cluster, traitSet, child, false, Collections.emptyList());
+    this(cluster, traitSet, child, false, ImmutableList.of());
   }
 
   /**
@@ -77,7 +76,7 @@ public Uncollect(
       List<String> itemAliases) {
     super(cluster, traitSet, input);
     this.withOrdinality = withOrdinality;
-    this.itemAliases = ImmutableList.copyOf(itemAliases);
+    this.itemAliases = itemAliases;
     assert deriveRowType() != null : "invalid child rowtype";
   }
 
@@ -88,7 +87,7 @@ public Uncollect(RelInput input) {
         input.getTraitSet(),
         input.getInput(),
         input.getBoolean("withOrdinality", false),
-        Collections.emptyList());
+        ImmutableList.of());
   }
 
   /**
@@ -164,7 +163,7 @@ public static RelDataType deriveUncollectRowType(
         builder.add(SqlUnnestOperator.MAP_VALUE_COLUMN_NAME, mapType.getValueType());
       } else {
         RelDataType ret = field.getType().getComponentType();
-        assert null != ret;
+        assert ret != null;
 
         if (requireAlias) {
           builder.add(itemAliases.get(i), ret);
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Union.java b/core/src/main/java/org/apache/calcite/rel/core/Union.java
index bae3b5306..146e6544b 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Union.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Union.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.sql.SqlKind;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -47,7 +48,7 @@ protected Union(
   }
 
   protected Union(RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, boolean all) {
-    super(cluster, traits, Collections.emptyList(), inputs, SqlKind.UNION, all);
+    super(cluster, traits, ImmutableList.of(), inputs, SqlKind.UNION, all);
   }
 
   /** Creates a Union by parsing serialized output. */
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Values.java b/core/src/main/java/org/apache/calcite/rel/core/Values.java
index 9ca0c9659..8c0879562 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Values.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Values.java
@@ -39,10 +39,10 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Predicate;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.joining;
 
 /** Relational expression whose value is a sequence of zero or more literal row values. */
 public abstract class Values extends AbstractRelNode implements Hintable {
@@ -109,7 +109,7 @@ protected Values(
       RelDataType rowType,
       ImmutableList<ImmutableList<RexLiteral>> tuples,
       RelTraitSet traits) {
-    this(cluster, Collections.emptyList(), rowType, tuples, traits);
+    this(cluster, ImmutableList.of(), rowType, tuples, traits);
   }
 
   /** Creates a Values by parsing serialized output. */
@@ -216,8 +216,8 @@ private boolean assertRowType() {
                   row ->
                       row.stream()
                           .map(lit -> lit.computeDigest(RexDigestIncludeType.NO_TYPE))
-                          .collect(Collectors.joining(", ", "{ ", " }")))
-              .collect(Collectors.joining(", ", "[", "]")));
+                          .collect(joining(", ", "{ ", " }")))
+              .collect(joining(", ", "[", "]")));
     }
     return relWriter;
   }
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Window.java b/core/src/main/java/org/apache/calcite/rel/core/Window.java
index b05d87b8f..c09aced21 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Window.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Window.java
@@ -52,10 +52,11 @@
 import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 import java.util.AbstractList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A relational expression representing a set of window aggregates.
  *
@@ -117,7 +118,7 @@ public Window(
       List<RexLiteral> constants,
       RelDataType rowType,
       List<Group> groups) {
-    this(cluster, traitSet, Collections.emptyList(), input, constants, rowType, groups);
+    this(cluster, traitSet, ImmutableList.of(), input, constants, rowType, groups);
   }
 
   @Override public boolean isValid(Litmus litmus, @Nullable Context context) {
@@ -262,11 +263,11 @@ public Group(
         RexWindowBound upperBound,
         RelCollation orderKeys,
         List<RexWinAggCall> aggCalls) {
-      this.keys = Objects.requireNonNull(keys, "keys");
+      this.keys = requireNonNull(keys, "keys");
       this.isRows = isRows;
-      this.lowerBound = Objects.requireNonNull(lowerBound, "lowerBound");
-      this.upperBound = Objects.requireNonNull(upperBound, "upperBound");
-      this.orderKeys = Objects.requireNonNull(orderKeys, "orderKeys");
+      this.lowerBound = requireNonNull(lowerBound, "lowerBound");
+      this.upperBound = requireNonNull(upperBound, "upperBound");
+      this.orderKeys = requireNonNull(orderKeys, "orderKeys");
       this.aggCalls = ImmutableList.copyOf(aggCalls);
       this.digest = computeString();
     }
@@ -275,7 +276,7 @@ public Group(
       return digest;
     }
 
-    @RequiresNonNull({"keys", "orderKeys", "lowerBound", "upperBound", "aggCalls"})
+    @RequiresNonNull({"aggCalls", "keys", "lowerBound", "orderKeys", "upperBound"})
     private String computeString(@UnderInitialization Group this) {
       final StringBuilder buf = new StringBuilder("window(");
       final int i = buf.length();
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
index 75adc54ac..fadefb7c9 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
@@ -651,10 +651,10 @@ public Object toJson(RexNode node) {
 
   private Object toJson(RexWindow window) {
     final Map<String, @Nullable Object> map = jsonBuilder().map();
-    if (window.partitionKeys.size() > 0) {
+    if (!window.partitionKeys.isEmpty()) {
       map.put("partition", toJson(window.partitionKeys));
     }
-    if (window.orderKeys.size() > 0) {
+    if (!window.orderKeys.isEmpty()) {
       map.put("order", toJson(window.orderKeys));
     }
     if (window.getLowerBound() == null) {
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
index 9a701f4a4..0c936eb6c 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
@@ -165,7 +165,7 @@ private void readRel(final Map<String, Object> jsonRel) {
             if (jsonInputs == null) {
               return ImmutableList.of(requireNonNull(lastRel, "lastRel"));
             }
-            final ImmutableList.Builder<RelNode> inputs = new ImmutableList.Builder<>();
+            final ImmutableList.Builder<RelNode> inputs = ImmutableList.builder();
             for (String jsonInput : jsonInputs) {
               inputs.add(lookupInput(jsonInput));
             }
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java
index db31051ca..668a6e58d 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java
@@ -22,8 +22,6 @@
 import org.apache.calcite.util.JsonBuilder;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.ArrayList;
@@ -127,7 +125,7 @@ private void put(Map<String, @Nullable Object> map, String name, @Nullable Objec
   }
 
   @Override public RelWriter done(RelNode node) {
-    final List<Pair<String, @Nullable Object>> valuesCopy = ImmutableList.copyOf(values);
+    final List<Pair<String, @Nullable Object>> valuesCopy = values;
     values.clear();
     explain_(node, valuesCopy);
     return this;
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java
index a1b1b0d11..e6810741a 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java
@@ -24,8 +24,6 @@
 import org.apache.calcite.sql.SqlExplainLevel;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.io.PrintWriter;
@@ -137,7 +135,7 @@ private void explainInputs(List<RelNode> inputs) {
 
   @Override public RelWriter done(RelNode node) {
     assert checkInputsPresentInExplain(node);
-    final List<Pair<String, @Nullable Object>> valuesCopy = ImmutableList.copyOf(values);
+    final List<Pair<String, @Nullable Object>> valuesCopy = values;
     values.clear();
     explain_(node, valuesCopy);
     pw.flush();
@@ -146,7 +144,7 @@ private void explainInputs(List<RelNode> inputs) {
 
   private boolean checkInputsPresentInExplain(RelNode node) {
     int i = 0;
-    if (values.size() > 0 && values.get(0).left.equals("subset")) {
+    if (!values.isEmpty() && values.get(0).left.equals("subset")) {
       ++i;
     }
     for (RelNode input : node.getInputs()) {
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java
index 1afbf3d43..6b1007524 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java
@@ -26,7 +26,6 @@
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 
 /** Callback for a relational expression to dump in XML format. */
 public class RelXmlWriter extends RelWriterImpl {
@@ -144,7 +143,7 @@ private void explainSpecific(RelNode rel, List<Pair<String, @Nullable Object>> v
       if (value.right instanceof RelNode) {
         continue;
       }
-      xmlOutput.attribute(value.left, Objects.toString(value.right));
+      xmlOutput.attribute(value.left, String.valueOf(value.right));
     }
     xmlOutput.endBeginTag(tagName);
     spacer.add(2);
diff --git a/core/src/main/java/org/apache/calcite/rel/hint/HintStrategy.java b/core/src/main/java/org/apache/calcite/rel/hint/HintStrategy.java
index 45eb9c25e..6e6fe8c5f 100644
--- a/core/src/main/java/org/apache/calcite/rel/hint/HintStrategy.java
+++ b/core/src/main/java/org/apache/calcite/rel/hint/HintStrategy.java
@@ -23,7 +23,7 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Represents a hint strategy entry of {@link HintStrategyTable}.
@@ -84,14 +84,14 @@ public static class Builder {
     private ImmutableSet<ConverterRule> converterRules;
 
     private Builder(HintPredicate predicate) {
-      this.predicate = Objects.requireNonNull(predicate, "predicate");
+      this.predicate = requireNonNull(predicate, "predicate");
       this.excludedRules = ImmutableSet.of();
       this.converterRules = ImmutableSet.of();
     }
 
     /** Registers a hint option checker to validate the hint options. */
     public Builder optionChecker(HintOptionChecker optionChecker) {
-      this.optionChecker = Objects.requireNonNull(optionChecker, "optionChecker");
+      this.optionChecker = requireNonNull(optionChecker, "optionChecker");
       return this;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java b/core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java
index e64c53a82..7a24616b9 100644
--- a/core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java
+++ b/core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java
@@ -32,9 +32,9 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * A collection of {@link HintStrategy}s.
@@ -66,7 +66,7 @@ public class HintStrategyTable {
   private final Litmus errorHandler;
 
   private HintStrategyTable(Map<Key, HintStrategy> strategies, Litmus litmus) {
-    this.strategies = ImmutableMap.copyOf(strategies);
+    this.strategies = strategies;
     this.errorHandler = litmus;
   }
 
@@ -81,7 +81,7 @@ private HintStrategyTable(Map<Key, HintStrategy> strategies, Litmus litmus) {
    * @return A hint list that can be attached to the {@code rel}
    */
   public List<RelHint> apply(List<RelHint> hints, RelNode rel) {
-    return hints.stream().filter(relHint -> canApply(relHint, rel)).collect(Collectors.toList());
+    return hints.stream().filter(relHint -> canApply(relHint, rel)).collect(toList());
   }
 
   private boolean canApply(RelHint hint, RelNode rel) {
@@ -119,7 +119,7 @@ public boolean validateHint(RelHint hint) {
    */
   public boolean isRuleExcluded(Hintable hintable, RelOptRule rule) {
     final List<RelHint> hints = hintable.getHints();
-    if (hints.size() == 0) {
+    if (hints.isEmpty()) {
       return false;
     }
 
@@ -142,7 +142,7 @@ public boolean isRuleExcluded(Hintable hintable, RelOptRule rule) {
   private static boolean isDesiredConversionPossible(
       Set<ConverterRule> converterRules, Hintable hintable) {
     // If no converter rules are specified, we assume the conversion is possible.
-    return converterRules.size() == 0
+    return converterRules.isEmpty()
         || converterRules.stream()
             .anyMatch(converterRule -> converterRule.convert((RelNode) hintable) != null);
   }
diff --git a/core/src/main/java/org/apache/calcite/rel/hint/Hintable.java b/core/src/main/java/org/apache/calcite/rel/hint/Hintable.java
index cb6bfe726..a9ec2e3d9 100644
--- a/core/src/main/java/org/apache/calcite/rel/hint/Hintable.java
+++ b/core/src/main/java/org/apache/calcite/rel/hint/Hintable.java
@@ -24,9 +24,10 @@
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * {@link Hintable} is a kind of {@link RelNode} that can attach {@link RelHint}s.
  *
@@ -57,7 +58,7 @@ public interface Hintable {
    * @return Relational expression with the hints {@code hintList} attached
    */
   default RelNode attachHints(List<RelHint> hintList) {
-    Objects.requireNonNull(hintList, "hintList");
+    requireNonNull(hintList, "hintList");
     final Set<RelHint> hints = new LinkedHashSet<>(getHints());
     hints.addAll(hintList);
     return withHints(new ArrayList<>(hints));
diff --git a/core/src/main/java/org/apache/calcite/rel/hint/RelHint.java b/core/src/main/java/org/apache/calcite/rel/hint/RelHint.java
index 823d2d559..eadd1b7c8 100644
--- a/core/src/main/java/org/apache/calcite/rel/hint/RelHint.java
+++ b/core/src/main/java/org/apache/calcite/rel/hint/RelHint.java
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.rel.hint;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
@@ -29,6 +28,10 @@
 import java.util.Map;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkState;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Hint attached to a relation expression.
  *
@@ -110,12 +113,12 @@ private RelHint(
       String hintName,
       @Nullable List<String> listOption,
       @Nullable Map<String, String> kvOptions) {
-    Objects.requireNonNull(inheritPath, "inheritPath");
-    Objects.requireNonNull(hintName, "hintName");
+    requireNonNull(inheritPath, "inheritPath");
+    requireNonNull(hintName, "hintName");
     this.inheritPath = ImmutableList.copyOf(inheritPath);
     this.hintName = hintName;
-    this.listOptions = listOption == null ? ImmutableList.of() : ImmutableList.copyOf(listOption);
-    this.kvOptions = kvOptions == null ? ImmutableMap.of() : ImmutableMap.copyOf(kvOptions);
+    this.listOptions = listOption == null ? ImmutableList.of() : listOption;
+    this.kvOptions = kvOptions == null ? ImmutableMap.of() : kvOptions;
   }
 
   // ~ Methods ----------------------------------------------------------------
@@ -132,7 +135,7 @@ public static Builder builder(String hintName) {
    * @return the new {@code RelHint}
    */
   public RelHint copy(List<Integer> inheritPath) {
-    Objects.requireNonNull(inheritPath, "inheritPath");
+    requireNonNull(inheritPath, "inheritPath");
     return new RelHint(inheritPath, hintName, listOptions, kvOptions);
   }
 
@@ -157,12 +160,12 @@ public RelHint copy(List<Integer> inheritPath) {
   @Override public String toString() {
     StringBuilder builder = new StringBuilder();
     builder.append("[").append(this.hintName).append(" inheritPath:").append(this.inheritPath);
-    if (this.listOptions.size() > 0 || this.kvOptions.size() > 0) {
+    if (!this.listOptions.isEmpty() || this.kvOptions.size() > 0) {
       builder.append(" options:");
-      if (this.listOptions.size() > 0) {
-        builder.append(this.listOptions.toString());
+      if (!this.listOptions.isEmpty()) {
+        builder.append(this.listOptions);
       } else {
-        builder.append(this.kvOptions.toString());
+        builder.append(this.kvOptions);
       }
     }
     builder.append("]");
@@ -188,7 +191,7 @@ private Builder(String hintName) {
 
     /** Sets up the inherit path with given integer list. */
     public Builder inheritPath(Iterable<Integer> inheritPath) {
-      this.inheritPath = ImmutableList.copyOf(Objects.requireNonNull(inheritPath, "inheritPath"));
+      this.inheritPath = ImmutableList.copyOf(requireNonNull(inheritPath, "inheritPath"));
       return this;
     }
 
@@ -200,8 +203,8 @@ public Builder inheritPath(Integer... inheritPath) {
 
     /** Add a hint option as string. */
     public Builder hintOption(String hintOption) {
-      Objects.requireNonNull(hintOption, "hintOption");
-      Preconditions.checkState(
+      requireNonNull(hintOption, "hintOption");
+      checkState(
           this.kvOptions.size() == 0, "List options and key value options can not be mixed in");
       this.listOptions.add(hintOption);
       return this;
@@ -209,8 +212,8 @@ public Builder hintOption(String hintOption) {
 
     /** Add multiple string hint options. */
     public Builder hintOptions(Iterable<String> hintOptions) {
-      Objects.requireNonNull(hintOptions, "hintOptions");
-      Preconditions.checkState(
+      requireNonNull(hintOptions, "hintOptions");
+      checkState(
           this.kvOptions.size() == 0, "List options and key value options can not be mixed in");
       this.listOptions = ImmutableList.copyOf(hintOptions);
       return this;
@@ -218,19 +221,19 @@ public Builder hintOptions(Iterable<String> hintOptions) {
 
     /** Add a hint option as string key-value pair. */
     public Builder hintOption(String optionKey, String optionValue) {
-      Objects.requireNonNull(optionKey, "optionKey");
-      Objects.requireNonNull(optionValue, "optionValue");
-      Preconditions.checkState(
-          this.listOptions.size() == 0, "List options and key value options can not be mixed in");
+      requireNonNull(optionKey, "optionKey");
+      requireNonNull(optionValue, "optionValue");
+      checkState(
+          this.listOptions.isEmpty(), "List options and key value options can not be mixed in");
       this.kvOptions.put(optionKey, optionValue);
       return this;
     }
 
     /** Add multiple string key-value pair hint options. */
     public Builder hintOptions(Map<String, String> kvOptions) {
-      Objects.requireNonNull(kvOptions, "kvOptions");
-      Preconditions.checkState(
-          this.listOptions.size() == 0, "List options and key value options can not be mixed in");
+      requireNonNull(kvOptions, "kvOptions");
+      checkState(
+          this.listOptions.isEmpty(), "List options and key value options can not be mixed in");
       this.kvOptions = kvOptions;
       return this;
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java
index 5cb9a4066..466fa90a4 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java
@@ -130,7 +130,7 @@ public static LogicalCalc create(final RelNode input, final RexProgram program)
   }
 
   @Override public RelNode withHints(List<RelHint> hintList) {
-    return new LogicalCalc(getCluster(), traitSet, ImmutableList.copyOf(hintList), input, program);
+    return new LogicalCalc(getCluster(), traitSet, hintList, input, program);
   }
 
   @Override public RelNode accept(RelShuttle shuttle) {
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalFilter.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalFilter.java
index 3fc34a647..540cf3f2b 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalFilter.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalFilter.java
@@ -42,6 +42,8 @@
 import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Sub-class of {@link org.apache.calcite.rel.core.Filter} not targeted at any particular engine or
  * calling convention.
@@ -70,7 +72,7 @@ public LogicalFilter(
       RexNode condition,
       ImmutableSet<CorrelationId> variablesSet) {
     super(cluster, traitSet, hints, child, condition);
-    this.variablesSet = Objects.requireNonNull(variablesSet, "variablesSet");
+    this.variablesSet = requireNonNull(variablesSet, "variablesSet");
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalIntersect.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalIntersect.java
index 4a78f0643..735ae0968 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalIntersect.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalIntersect.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.core.Intersect;
 import org.apache.calcite.rel.hint.RelHint;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -56,7 +57,7 @@ public LogicalIntersect(
    */
   public LogicalIntersect(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
-    this(cluster, traitSet, Collections.emptyList(), inputs, all);
+    this(cluster, traitSet, ImmutableList.of(), inputs, all);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalMinus.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalMinus.java
index 55fc1af79..5354b12ca 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalMinus.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalMinus.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.core.Minus;
 import org.apache.calcite.rel.hint.RelHint;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -56,7 +57,7 @@ public LogicalMinus(
    */
   public LogicalMinus(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
-    this(cluster, traitSet, Collections.emptyList(), inputs, all);
+    this(cluster, traitSet, ImmutableList.of(), inputs, all);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java
index 8813985a3..f74a31473 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java
@@ -28,9 +28,10 @@
 import org.apache.calcite.rel.hint.RelHint;
 import org.apache.calcite.rex.RexNode;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -45,7 +46,7 @@ private LogicalSort(
       RelCollation collation,
       @Nullable RexNode offset,
       @Nullable RexNode fetch) {
-    this(cluster, traitSet, Collections.emptyList(), input, collation, offset, fetch);
+    this(cluster, traitSet, ImmutableList.of(), input, collation, offset, fetch);
   }
 
   private LogicalSort(
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java
index 3c6c4ba4f..72bfc49b9 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java
@@ -30,10 +30,11 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Type;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -90,7 +91,7 @@ public LogicalTableFunctionScan(
     this(
         cluster,
         traitSet,
-        Collections.emptyList(),
+        ImmutableList.of(),
         inputs,
         rexCall,
         elementType,
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalUnion.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalUnion.java
index a2782e60e..80ddaa869 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalUnion.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalUnion.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.core.Union;
 import org.apache.calcite.rel.hint.RelHint;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -56,7 +57,7 @@ public LogicalUnion(
    */
   public LogicalUnion(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
-    this(cluster, traitSet, Collections.emptyList(), inputs, all);
+    this(cluster, traitSet, ImmutableList.of(), inputs, all);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java
index f02645946..c06f6e3fd 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java
@@ -36,7 +36,6 @@
 import com.google.common.collect.ImmutableList;
 
 import java.math.BigDecimal;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -81,7 +80,7 @@ public LogicalValues(
       RelTraitSet traitSet,
       RelDataType rowType,
       ImmutableList<ImmutableList<RexLiteral>> tuples) {
-    this(cluster, traitSet, Collections.emptyList(), rowType, tuples);
+    this(cluster, traitSet, ImmutableList.of(), rowType, tuples);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
index a9c5c463b..594356850 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
@@ -40,6 +40,7 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.LinkedListMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
@@ -49,7 +50,6 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
 import java.util.List;
@@ -104,7 +104,7 @@ public LogicalWindow(
       List<RexLiteral> constants,
       RelDataType rowType,
       List<Group> groups) {
-    this(cluster, traitSet, Collections.emptyList(), input, constants, rowType, groups);
+    this(cluster, traitSet, ImmutableList.of(), input, constants, rowType, groups);
   }
 
   @Override public LogicalWindow copy(RelTraitSet traitSet, List<RelNode> inputs) {
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/ToLogicalConverter.java b/core/src/main/java/org/apache/calcite/rel/logical/ToLogicalConverter.java
index 5cc9dccbc..2e2554231 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/ToLogicalConverter.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/ToLogicalConverter.java
@@ -41,7 +41,7 @@
 import org.apache.calcite.rel.core.Window;
 import org.apache.calcite.tools.RelBuilder;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
 
 /** Shuttle to convert any rel plan to a plan with all logical nodes. */
 public class ToLogicalConverter extends RelShuttleImpl {
@@ -178,7 +178,7 @@ public ToLogicalConverter(RelBuilder relBuilder) {
       final Uncollect uncollect = (Uncollect) relNode;
       final RelNode input = visit(uncollect.getInput());
       return Uncollect.create(
-          input.getTraitSet(), input, uncollect.withOrdinality, Collections.emptyList());
+          input.getTraitSet(), input, uncollect.withOrdinality, ImmutableList.of());
     }
 
     throw new AssertionError(
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java
index 6873fcaf2..82f533b25 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java
@@ -20,6 +20,7 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 
@@ -102,7 +103,7 @@ protected ChainedRelMetadataProvider(ImmutableList<RelMetadataProvider> provider
   @Deprecated // to be removed before 2.0
   @Override public <M extends Metadata> Multimap<Method, MetadataHandler<M>> handlers(MetadataDef<M> def) {
     final ImmutableMultimap.Builder<Method, MetadataHandler<M>> builder =
-        ImmutableMultimap.builder();
+        ImmutableListMultimap.builder();
     for (RelMetadataProvider provider : providers.reverse()) {
       builder.putAll(provider.handlers(def));
     }
@@ -130,7 +131,7 @@ private static class ChainedInvocationHandler implements InvocationHandler {
     private final List<Metadata> metadataList;
 
     ChainedInvocationHandler(List<Metadata> metadataList) {
-      this.metadataList = ImmutableList.copyOf(metadataList);
+      this.metadataList = metadataList;
     }
 
     @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java
index b10e09a5a..635aeba59 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/JaninoRelMetadataProvider.java
@@ -42,11 +42,10 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.List;
-import java.util.Objects;
 import java.util.concurrent.ExecutionException;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Implementation of the {@link RelMetadataProvider} interface that generates a class that
@@ -128,7 +127,7 @@ private static <MH extends MetadataHandler<?>> MH generateCompileAndInstantiate(
       Class<MH> handlerClass, List<? extends MetadataHandler<? extends Metadata>> handlers) {
 
     final List<? extends MetadataHandler<? extends Metadata>> uniqueHandlers =
-        handlers.stream().distinct().collect(Collectors.toList());
+        handlers.stream().distinct().collect(toList());
     RelMetadataHandlerGeneratorUtil.HandlerNameAndGeneratedCode handlerNameAndGeneratedCode =
         RelMetadataHandlerGeneratorUtil.generateHandler(handlerClass, uniqueHandlers);
 
@@ -153,7 +152,7 @@ static <MH extends MetadataHandler<?>> MH compile(
       throws CompileException, IOException {
     final ICompilerFactory compilerFactory;
     ClassLoader classLoader =
-        Objects.requireNonNull(JaninoRelMetadataProvider.class.getClassLoader(), "classLoader");
+        requireNonNull(JaninoRelMetadataProvider.class.getClassLoader(), "classLoader");
     try {
       compilerFactory = CompilerFactoryFactory.getDefaultCompilerFactory(classLoader);
     } catch (Exception e) {
@@ -236,8 +235,8 @@ private Key(Class<? extends MetadataHandler<?>> handlerClass, RelMetadataProvide
     }
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public <MH extends MetadataHandler<?>> MH handler(final Class<MH> handlerClass) {
+  @Override @SuppressWarnings("deprecation")
+  public <MH extends MetadataHandler<?>> MH handler(final Class<MH> handlerClass) {
     return handlerClass.cast(
         Proxy.newProxyInstance(
             RelMetadataQuery.class.getClassLoader(),
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/MetadataDef.java b/core/src/main/java/org/apache/calcite/rel/metadata/MetadataDef.java
index 9d8ce59f6..49dbb5734 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/MetadataDef.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/MetadataDef.java
@@ -24,12 +24,13 @@
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Comparator;
 import java.util.List;
 import java.util.SortedMap;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
+import static java.util.Comparator.comparing;
+
 /**
  * Definition of metadata.
  *
@@ -45,9 +46,7 @@ private MetadataDef(
     this.metadataClass = metadataClass;
     this.handlerClass = handlerClass;
     this.methods =
-        Arrays.stream(methods)
-            .sorted(Comparator.comparing(Method::getName))
-            .collect(Util.toImmutableList());
+        Arrays.stream(methods).sorted(comparing(Method::getName)).collect(Util.toImmutableList());
     final SortedMap<String, Method> handlerMethods = MetadataHandler.handlerMethods(handlerClass);
 
     // Handler must have the same methods as Metadata, each method having
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/ProxyingMetadataHandlerProvider.java b/core/src/main/java/org/apache/calcite/rel/metadata/ProxyingMetadataHandlerProvider.java
index d77e6ae46..a838e18a8 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/ProxyingMetadataHandlerProvider.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/ProxyingMetadataHandlerProvider.java
@@ -29,9 +29,9 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toMap;
 
 /**
  * A MetadataHandlerProvider built on a RelMetadataProvider.
@@ -51,8 +51,8 @@ public ProxyingMetadataHandlerProvider(RelMetadataProvider provider) {
     this.provider = provider;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public <MH extends MetadataHandler<?>> MH handler(Class<MH> handlerClass) {
+  @Override @SuppressWarnings("deprecation")
+  public <MH extends MetadataHandler<?>> MH handler(Class<MH> handlerClass) {
 
     Type[] types = handlerClass.getGenericInterfaces();
     if (types.length != 1 || !(types[0] instanceof ParameterizedType)) {
@@ -76,8 +76,7 @@ public ProxyingMetadataHandlerProvider(RelMetadataProvider provider) {
     }
 
     List<Method> methods = def.methods;
-    Map<String, Method> methodMap =
-        methods.stream().collect(Collectors.toMap(Method::getName, f -> f));
+    Map<String, Method> methodMap = methods.stream().collect(toMap(Method::getName, f -> f));
     InvocationHandler handler =
         (proxy, method, args) -> {
           Method metadataMethod =
@@ -88,7 +87,7 @@ public ProxyingMetadataHandlerProvider(RelMetadataProvider provider) {
           // using deprecated RelMetadataProvider method here as the non-deprecated methods
           // completely
           // sidestep the purpose of RelMetadataProvider reflection-based functionality.
-          @SuppressWarnings({"unchecked", "rawtypes"})
+          @SuppressWarnings({"rawtypes", "unchecked"})
           UnboundMetadata metadata =
               provider.apply(rel.getClass(), (Class<? extends Metadata>) metadataType);
 
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
index 8b64ad606..dcab71152 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
@@ -25,8 +25,8 @@
 import org.apache.calcite.util.ReflectiveVisitor;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 
@@ -43,11 +43,14 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Implementation of the {@link RelMetadataProvider} interface that dispatches metadata methods to
  * methods on a given object via reflection.
@@ -85,12 +88,12 @@ protected ReflectiveRelMetadataProvider(
       Class<? extends Metadata> metadataClass0,
       Multimap<Method, MetadataHandler<?>> handlerMap,
       Class<? extends MetadataHandler<?>> handlerClass) {
-    Preconditions.checkArgument(
+    checkArgument(
         !map.isEmpty(),
         "ReflectiveRelMetadataProvider " + "methods map is empty; are your methods named wrong?");
     this.map = map;
     this.metadataClass0 = metadataClass0;
-    this.handlerMap = ImmutableMultimap.copyOf(handlerMap);
+    this.handlerMap = ImmutableListMultimap.copyOf(handlerMap);
     this.handlerClass = handlerClass;
     this.handlers = ImmutableList.copyOf(handlerMap.values());
   }
@@ -222,7 +225,7 @@ private static RelMetadataProvider reflectiveSource(
   @Deprecated // to be removed before 2.0
   @Override public <M extends Metadata> Multimap<Method, MetadataHandler<M>> handlers(MetadataDef<M> def) {
     final ImmutableMultimap.Builder<Method, MetadataHandler<M>> builder =
-        ImmutableMultimap.builder();
+        ImmutableListMultimap.builder();
     for (Map.Entry<Method, MetadataHandler> entry : handlerMap.entries()) {
       if (def.methods.contains(entry.getKey())) {
         //noinspection unchecked
@@ -266,8 +269,8 @@ private static boolean couldImplement(Method handlerMethod, Method method) {
     }
   }
 
-  @SuppressWarnings({"unchecked", "SuspiciousMethodCalls"})
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings({"SuspiciousMethodCalls", "unchecked"}) // to be removed before 2.0
   public <@Nullable M extends @Nullable Metadata> @Nullable UnboundMetadata<M> apply(
       Class<? extends RelNode> relClass) {
     List<Class<? extends RelNode>> newSources = new ArrayList<>();
@@ -309,7 +312,7 @@ static class Space {
     final ImmutableMultimap<Method, MetadataHandler<?>> providerMap;
 
     Space(Multimap<Method, MetadataHandler<?>> providerMap) {
-      this.providerMap = ImmutableMultimap.copyOf(providerMap);
+      this.providerMap = ImmutableListMultimap.copyOf(providerMap);
 
       // Find the distinct set of RelNode classes handled by this provider,
       // ordered base-class first.
@@ -332,9 +335,9 @@ static class Space {
      * Finds an implementation of a method for {@code relNodeClass} or its nearest base class.
      * Assumes that base classes have already been added to {@code map}.
      */
-    @SuppressWarnings({"unchecked", "SuspiciousMethodCalls"})
+    @SuppressWarnings({"SuspiciousMethodCalls", "unchecked"})
     Method find(final Class<? extends RelNode> relNodeClass, Method method) {
-      Objects.requireNonNull(relNodeClass, "relNodeClass");
+      requireNonNull(relNodeClass, "relNodeClass");
       for (Class r = relNodeClass; ; ) {
         Method implementingMethod = handlerMap.get(Pair.of(r, method));
         if (implementingMethod != null) {
@@ -349,14 +352,11 @@ Method find(final Class<? extends RelNode> relNodeClass, Method method) {
           }
         }
         r = r.getSuperclass();
-        if (r == null || !RelNode.class.isAssignableFrom(r)) {
-          throw new IllegalArgumentException(
-              "No handler for method ["
-                  + method
-                  + "] applied to argument of type ["
-                  + relNodeClass
-                  + "]; we recommend you create a catch-all (RelNode) handler");
-        }
+        checkArgument(
+            r != null && RelNode.class.isAssignableFrom(r),
+            "No handler for method [%s] applied to argument of type [%s]; we recommend you create a catch-all (RelNode) handler",
+            method,
+            relNodeClass);
       }
     }
   }
@@ -374,7 +374,7 @@ static class Space2 extends Space {
 
     @Deprecated // to be removed before 2.0
     public static Space2 create(MetadataHandler<?> target, ImmutableList<Method> methods) {
-      assert methods.size() > 0;
+      assert !methods.isEmpty();
       final Method method0 = methods.get(0);
       //noinspection unchecked
       Class<Metadata> metadataClass0 = (Class) method0.getDeclaringClass();
@@ -384,7 +384,7 @@ public static Space2 create(MetadataHandler<?> target, ImmutableList<Method> met
       }
 
       final ImmutableMultimap.Builder<Method, MetadataHandler<?>> providerBuilder =
-          ImmutableMultimap.builder();
+          ImmutableListMultimap.builder();
       for (final Method method : methods) {
         providerBuilder.put(method, target);
       }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
index 2b4f1d53c..3e640184f 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
@@ -69,10 +69,11 @@
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableSet;
-import java.util.Objects;
 import java.util.SortedSet;
 import java.util.TreeSet;
-import java.util.stream.Collectors;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * RelMdCollation supplies a default implementation of {@link
@@ -229,8 +230,7 @@ private RelMdCollation() {}
   }
 
   public @Nullable ImmutableList<RelCollation> collations(RelSubset rel, RelMetadataQuery mq) {
-    return copyOf(
-        Objects.requireNonNull(rel.getTraitSet().getTraits(RelCollationTraitDef.INSTANCE)));
+    return copyOf(requireNonNull(rel.getTraitSet().getTraits(RelCollationTraitDef.INSTANCE)));
   }
 
   // Helper methods
@@ -264,7 +264,7 @@ public static List<RelCollation> sort(RelCollation collation) {
   public static @Nullable List<RelCollation> calc(
       RelMetadataQuery mq, RelNode input, RexProgram program) {
     final List<RexNode> projects =
-        program.getProjectList().stream().map(program::expandLocalRef).collect(Collectors.toList());
+        program.getProjectList().stream().map(program::expandLocalRef).collect(toList());
     return project(mq, input, projects);
   }
 
@@ -552,7 +552,7 @@ public static Ordering<List<RexLiteral>> comparator(RelFieldCollation fieldColla
       case FULL:
         for (RelCollation collation : leftCollations) {
           for (RelFieldCollation field : collation.getFieldCollations()) {
-            if (!(RelFieldCollation.NullDirection.LAST == field.nullDirection)) {
+            if (RelFieldCollation.NullDirection.LAST != field.nullDirection) {
               return null;
             }
           }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java
index 6ca8331f6..a687b0ab0 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java
@@ -148,9 +148,7 @@ private RelMdColumnOrigins() {}
           }
         };
     final List<RexNode> projects = new ArrayList<>();
-    for (RexNode rex : rexShuttle.apply(rel.getProgram().getProjectList())) {
-      projects.add(rex);
-    }
+    projects.addAll(rexShuttle.apply(rel.getProgram().getProjectList()));
     final RexNode rexNode = projects.get(iOutputColumn);
     if (rexNode instanceof RexInputRef) {
       // Direct reference:  no derivation added.
@@ -202,7 +200,7 @@ private RelMdColumnOrigins() {}
     final Set<RelColumnOrigin> set = new HashSet<>();
     Set<RelColumnMapping> mappings = rel.getColumnMappings();
     if (mappings == null) {
-      if (rel.getInputs().size() > 0) {
+      if (!rel.getInputs().isEmpty()) {
         // This is a non-leaf transformation:  say we don't
         // know about origins, because there are probably
         // columns below.
@@ -239,7 +237,7 @@ private RelMdColumnOrigins() {}
     // it's up to the plugin writer to override with the
     // correct information.
 
-    if (rel.getInputs().size() > 0) {
+    if (!rel.getInputs().isEmpty()) {
       // No generic logic available for non-leaf rels.
       return null;
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
index 03bc74d79..d42338067 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
@@ -385,7 +385,7 @@ public Boolean areColumnsUnique(
         Comparable value = literal.getValueAs(Comparable.class);
         values.add(value == null ? NullSentinel.INSTANCE : value);
       }
-      if (!set.add(ImmutableList.copyOf(values))) {
+      if (!set.add(values)) {
         return false;
       }
       values.clear();
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java
index 82f5443b9..77e3ae61f 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java
@@ -203,7 +203,7 @@ public Double getDistinctRowCount(
         Comparable value = literal.getValueAs(Comparable.class);
         values.add(value == null ? NullSentinel.INSTANCE : value);
       }
-      set.add(ImmutableList.copyOf(values));
+      set.add(values);
       values.clear();
     }
     double nRows = set.size();
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java
index 1742d444f..fa23ca3a0 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdExpressionLineage.java
@@ -62,9 +62,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toSet;
 
 /**
  * Default implementation of {@link RelMetadataQuery#getExpressionLineage} for the standard logical
@@ -332,7 +332,7 @@ protected RelMdExpressionLineage() {}
         final Set<RexNode> updatedExprs =
             originalExprs.stream()
                 .map(e -> RexUtil.swapTableReferences(rexBuilder, e, currentTablesMapping))
-                .collect(Collectors.toSet());
+                .collect(toSet());
         final Set<RexNode> set = mapping.get(ref);
         if (set != null) {
           set.addAll(updatedExprs);
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java
index 13549ecaa..2399dd4b8 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java
@@ -127,7 +127,7 @@ public Double getPercentageOriginalRows(Union rel, RelMetadataQuery mq) {
       return null;
     }
 
-    if (rel.getInputs().size() == 0) {
+    if (rel.getInputs().isEmpty()) {
       // Assume no filtering happening at leaf.
       return 1.0;
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
index f6c28312f..a4f91765b 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
@@ -68,7 +68,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.BitSet;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -78,9 +77,9 @@
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toSet;
 
 /**
  * Utility to infer Predicates that are applicable above a RelNode.
@@ -469,7 +468,7 @@ public RelOptPredicateList getPredicates(Intersect intersect, RelMetadataQuery m
         finalPredicates =
             finalPredicates.stream()
                 .filter(finalPred -> !rexImplicationChecker.implies(pred, finalPred))
-                .collect(Collectors.toSet());
+                .collect(toSet());
         finalPredicates.add(pred);
       }
     }
@@ -726,7 +725,7 @@ public RelOptPredicateList inferPredicates(boolean includeEqualityInference) {
               inferredPredicates,
               EMPTY_LIST);
         default:
-          assert inferredPredicates.size() == 0;
+          assert inferredPredicates.isEmpty();
           return RelOptPredicateList.EMPTY;
       }
     }
@@ -774,7 +773,7 @@ Iterable<Mapping> mappings(final RexNode predicate) {
               exprFields.get(predicate),
               () -> "exprFields.get(predicate) is null for " + predicate);
       if (fields.cardinality() == 0) {
-        return Collections.emptyList();
+        return ImmutableList.of();
       }
       return () -> new ExprsItr(fields);
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java
index bcdb6168e..21b696f17 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java
@@ -70,7 +70,7 @@ protected RelMdSelectivity() {}
 
   public @Nullable Double getSelectivity(
       Union rel, RelMetadataQuery mq, @Nullable RexNode predicate) {
-    if ((rel.getInputs().size() == 0) || (predicate == null)) {
+    if (rel.getInputs().isEmpty() || (predicate == null)) {
       return 1.0;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
index 458d87424..ae066a910 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
@@ -38,6 +38,7 @@
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
@@ -48,9 +49,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toSet;
 
 /**
  * RelMdUniqueKeys supplies a default implementation of {@link RelMetadataQuery#getUniqueKeys} for
@@ -113,7 +114,7 @@ private static Set<ImmutableBitSet> getProjectUniqueKeys(
     // to be mapped to match the output of the project.
 
     // Single input can be mapped to multiple outputs
-    ImmutableMultimap.Builder<Integer, Integer> inToOutPosBuilder = ImmutableMultimap.builder();
+    ImmutableMultimap.Builder<Integer, Integer> inToOutPosBuilder = ImmutableListMultimap.builder();
     ImmutableBitSet.Builder mappedInColumnsBuilder = ImmutableBitSet.builder();
 
     // Build an input to output position map.
@@ -261,7 +262,7 @@ public Set<ImmutableBitSet> getUniqueKeys(
 
       // Try to find more precise unique keys.
       final Set<ImmutableBitSet> preciseUniqueKeys =
-          inputUniqueKeys.stream().filter(groupKeys::contains).collect(Collectors.toSet());
+          inputUniqueKeys.stream().filter(groupKeys::contains).collect(toSet());
       return preciseUniqueKeys.isEmpty() ? ImmutableSet.of(groupKeys) : preciseUniqueKeys;
     } else if (ignoreNulls) {
       // group by keys form a unique key
@@ -283,7 +284,7 @@ public Set<ImmutableBitSet> getUniqueKeys(Union rel, RelMetadataQuery mq, boolea
   /** Any unique key of any input of Intersect is an unique key of the Intersect. */
   public Set<ImmutableBitSet> getUniqueKeys(
       Intersect rel, RelMetadataQuery mq, boolean ignoreNulls) {
-    ImmutableSet.Builder<ImmutableBitSet> keys = new ImmutableSet.Builder<>();
+    ImmutableSet.Builder<ImmutableBitSet> keys = ImmutableSet.builder();
     for (RelNode input : rel.getInputs()) {
       Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(input, ignoreNulls);
       if (uniqueKeys != null) {
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
index bf747c196..dcdd7e79f 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
@@ -47,7 +47,6 @@
 import org.apache.calcite.util.NumberUtil;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -59,6 +58,8 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.NumberUtil.multiply;
 
 /** RelMdUtil provides utility methods used by the metadata provider methods. */
@@ -88,7 +89,7 @@ public static RexNode makeSemiJoinSelectivityRexNode(RelMetadataQuery mq, Join r
     RexBuilder rexBuilder = rel.getCluster().getRexBuilder();
     double selectivity = computeSemiJoinSelectivity(mq, rel.getLeft(), rel.getRight(), rel);
     return rexBuilder.makeCall(
-        ARTIFICIAL_SELECTIVITY_FUNC, rexBuilder.makeApproxLiteral(new BigDecimal(selectivity)));
+        ARTIFICIAL_SELECTIVITY_FUNC, rexBuilder.makeApproxLiteral(BigDecimal.valueOf(selectivity)));
   }
 
   /**
@@ -841,8 +842,8 @@ public static double estimateFilteredRows(
    * </ul>
    */
   public static double linear(int x, int minX, int maxX, double minY, double maxY) {
-    Preconditions.checkArgument(minX < maxX);
-    Preconditions.checkArgument(minY < maxY);
+    checkArgument(minX < maxX);
+    checkArgument(minY < maxY);
     if (x < minX) {
       return minY;
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
index 2c3354069..5a5f9a82a 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
@@ -368,8 +368,7 @@ public static RelMetadataQuery instance() {
     if (origins == null || origins.size() != 1) {
       return null;
     }
-    final RelColumnOrigin origin = Iterables.getOnlyElement(origins);
-    return origin;
+    return Iterables.getOnlyElement(origins);
   }
 
   /** Determines the origin of a column. */
@@ -409,7 +408,7 @@ public static RelMetadataQuery instance() {
       return null;
     }
     final Set<RelColumnOrigin> colOrigins = getColumnOrigins(rel, 0);
-    if (colOrigins == null || colOrigins.size() == 0) {
+    if (colOrigins == null || colOrigins.isEmpty()) {
       return null;
     }
     return colOrigins.iterator().next().getOriginTable();
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/janino/CacheGeneratorUtil.java b/core/src/main/java/org/apache/calcite/rel/metadata/janino/CacheGeneratorUtil.java
index 678a8900e..eb8623acb 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/janino/CacheGeneratorUtil.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/janino/CacheGeneratorUtil.java
@@ -29,11 +29,12 @@
 import com.google.common.collect.ImmutableList;
 
 import java.lang.reflect.Method;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.rel.metadata.janino.CodeGeneratorUtil.argList;
 import static org.apache.calcite.rel.metadata.janino.CodeGeneratorUtil.paramList;
 
+import static java.util.stream.Collectors.joining;
+
 /** Generates caching code for janino backed metadata. */
 class CacheGeneratorUtil {
 
@@ -193,7 +194,7 @@ private enum CacheKeyStrategy {
         String args =
             ImmutableList.copyOf(method.getParameterTypes()).stream()
                 .map(Class::getSimpleName)
-                .collect(Collectors.joining(", "));
+                .collect(joining(", "));
         buff.append("  private final Object ");
         appendKeyName(buff, methodIndex);
         buff.append(" =\n");
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/janino/DispatchGenerator.java b/core/src/main/java/org/apache/calcite/rel/metadata/janino/DispatchGenerator.java
index 37cfa633f..a62db7392 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/janino/DispatchGenerator.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/janino/DispatchGenerator.java
@@ -28,18 +28,22 @@
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.function.Function;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.rel.metadata.janino.CodeGeneratorUtil.argList;
 import static org.apache.calcite.rel.metadata.janino.CodeGeneratorUtil.paramList;
 
+import static java.util.Comparator.comparing;
+import static java.util.function.Function.identity;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toCollection;
+import static java.util.stream.Collectors.toMap;
+import static java.util.stream.Collectors.toSet;
+
 /** Generates the metadata dispatch to handlers. */
 class DispatchGenerator {
   private final Map<MetadataHandler<?>, String> metadataHandlerToName;
@@ -55,12 +59,10 @@ void dispatchMethod(
     Map<MetadataHandler<?>, Set<Class<? extends RelNode>>> handlersToClasses =
         metadataHandlers.stream()
             .distinct()
-            .collect(
-                Collectors.toMap(
-                    Function.identity(), mh -> methodAndInstanceToImplementingClass(method, mh)));
+            .collect(toMap(identity(), mh -> methodAndInstanceToImplementingClass(method, mh)));
 
     Set<Class<? extends RelNode>> delegateClassSet =
-        handlersToClasses.values().stream().flatMap(Set::stream).collect(Collectors.toSet());
+        handlersToClasses.values().stream().flatMap(Set::stream).collect(toSet());
     List<Class<? extends RelNode>> delegateClassList = topologicalSort(delegateClassSet);
     buff.append("  private ")
         .append(method.getReturnType().getName())
@@ -82,7 +84,7 @@ void dispatchMethod(
               .map(
                   clazz ->
                       ifInstanceThenDispatch(method, metadataHandlers, handlersToClasses, clazz))
-              .collect(Collectors.joining("    } else if ", "    if ", "    } else {\n")));
+              .collect(joining("    } else if ", "    if ", "    } else {\n")));
       throwUnknown(buff.append("      "), method).append("    }\n").append("  }\n");
     }
   }
@@ -177,9 +179,7 @@ private static List<Class<? extends RelNode>> topologicalSort(
       Collection<Class<? extends RelNode>> list) {
     List<Class<? extends RelNode>> l = new ArrayList<>();
     ArrayDeque<Class<? extends RelNode>> s =
-        list.stream()
-            .sorted(Comparator.comparing(Class::getName))
-            .collect(Collectors.toCollection(ArrayDeque::new));
+        list.stream().sorted(comparing(Class::getName)).collect(toCollection(ArrayDeque::new));
 
     while (!s.isEmpty()) {
       Class<? extends RelNode> n = s.remove();
diff --git a/core/src/main/java/org/apache/calcite/rel/mutable/MutableBiRel.java b/core/src/main/java/org/apache/calcite/rel/mutable/MutableBiRel.java
index b5b743945..2a53b5199 100644
--- a/core/src/main/java/org/apache/calcite/rel/mutable/MutableBiRel.java
+++ b/core/src/main/java/org/apache/calcite/rel/mutable/MutableBiRel.java
@@ -23,6 +23,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Mutable equivalent of {@link org.apache.calcite.rel.BiRel}. */
 abstract class MutableBiRel extends MutableRel {
   protected MutableRel left;
@@ -46,9 +48,7 @@ protected MutableBiRel(
   }
 
   @Override public void setInput(int ordinalInParent, MutableRel input) {
-    if (ordinalInParent > 1) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(ordinalInParent <= 1);
     if (ordinalInParent == 0) {
       this.left = input;
     } else {
diff --git a/core/src/main/java/org/apache/calcite/rel/mutable/MutableRel.java b/core/src/main/java/org/apache/calcite/rel/mutable/MutableRel.java
index d28118eec..224b1d6ef 100644
--- a/core/src/main/java/org/apache/calcite/rel/mutable/MutableRel.java
+++ b/core/src/main/java/org/apache/calcite/rel/mutable/MutableRel.java
@@ -27,7 +27,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Mutable equivalent of {@link RelNode}.
@@ -68,9 +69,9 @@ public abstract class MutableRel {
   protected int ordinalInParent;
 
   protected MutableRel(RelOptCluster cluster, RelDataType rowType, MutableRelType type) {
-    this.cluster = Objects.requireNonNull(cluster, "cluster");
-    this.rowType = Objects.requireNonNull(rowType, "rowType");
-    this.type = Objects.requireNonNull(type, "type");
+    this.cluster = requireNonNull(cluster, "cluster");
+    this.rowType = requireNonNull(rowType, "rowType");
+    this.type = requireNonNull(type, "type");
   }
 
   public @Nullable MutableRel getParent() {
diff --git a/core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java b/core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java
index 93519cbc5..0b78bb547 100644
--- a/core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java
+++ b/core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java
@@ -65,10 +65,10 @@
 
 import java.util.AbstractList;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /** Utilities for dealing with {@link MutableRel}s. */
 public abstract class MutableRels {
@@ -167,9 +167,7 @@ public static MutableRel createProject(final MutableRel child, final List<Intege
   /** Construct expression list of Project by the given fields of the input. */
   public static List<RexNode> createProjectExprs(
       final MutableRel child, final List<Integer> posList) {
-    return posList.stream()
-        .map(pos -> RexInputRef.of(pos, child.rowType))
-        .collect(Collectors.toList());
+    return posList.stream().map(pos -> RexInputRef.of(pos, child.rowType)).collect(toList());
   }
 
   /** Construct expression list of Project by the given fields of the input. */
@@ -248,7 +246,7 @@ public static RelNode fromMutable(MutableRel node, RelBuilder relBuilder) {
           final MutableUncollect uncollect = (MutableUncollect) node;
           final RelNode child = fromMutable(uncollect.getInput(), relBuilder);
           return Uncollect.create(
-              child.getTraitSet(), child, uncollect.withOrdinality, Collections.emptyList());
+              child.getTraitSet(), child, uncollect.withOrdinality, ImmutableList.of());
         }
       case WINDOW:
         {
@@ -489,6 +487,6 @@ public static MutableRel toMutable(RelNode rel) {
   }
 
   private static List<MutableRel> toMutables(List<RelNode> nodes) {
-    return nodes.stream().map(MutableRels::toMutable).collect(Collectors.toList());
+    return nodes.stream().map(MutableRels::toMutable).collect(toList());
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/rel/mutable/MutableSingleRel.java b/core/src/main/java/org/apache/calcite/rel/mutable/MutableSingleRel.java
index a5b68c91d..495bdf9d0 100644
--- a/core/src/main/java/org/apache/calcite/rel/mutable/MutableSingleRel.java
+++ b/core/src/main/java/org/apache/calcite/rel/mutable/MutableSingleRel.java
@@ -22,6 +22,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Mutable equivalent of {@link org.apache.calcite.rel.SingleRel}. */
 abstract class MutableSingleRel extends MutableRel {
   protected MutableRel input;
@@ -35,9 +37,7 @@ protected MutableSingleRel(MutableRelType type, RelDataType rowType, MutableRel
   }
 
   @Override public void setInput(int ordinalInParent, MutableRel input) {
-    if (ordinalInParent > 0) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(ordinalInParent <= 0);
     this.input = input;
     if (input != null) {
       input.parent = this;
diff --git a/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java b/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
index 652be2382..e168dc22c 100644
--- a/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
+++ b/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
@@ -108,12 +108,12 @@
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import static org.apache.calcite.rex.RexLiteral.stringValue;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /** Utility to convert relational expressions to SQL abstract syntax tree. */
 public class RelToSqlConverter extends SqlImplementor implements ReflectiveVisitor {
@@ -628,7 +628,7 @@ private List<SqlNode> generateGroupList(
     }
     switch (aggregate.getGroupType()) {
       case SIMPLE:
-        return ImmutableList.copyOf(groupKeys);
+        return groupKeys;
       case CUBE:
         if (aggregate.getGroupSet().cardinality() > 1) {
           return ImmutableList.of(
@@ -639,7 +639,7 @@ private List<SqlNode> generateGroupList(
       case ROLLUP:
         final List<Integer> rollupBits = Aggregate.Group.getRollup(aggregate.groupSets);
         final List<SqlNode> rollupKeys =
-            rollupBits.stream().map(bit -> builder.context.field(bit)).collect(Collectors.toList());
+            rollupBits.stream().map(bit -> builder.context.field(bit)).collect(toList());
         return ImmutableList.of(
             SqlStdOperatorTable.ROLLUP.createCall(SqlParserPos.ZERO, rollupKeys));
       default:
@@ -658,7 +658,7 @@ private List<SqlNode> generateGroupList(
                 SqlParserPos.ZERO,
                 groupSets.stream()
                     .map(groupSet -> groupItem(groupKeys, groupSet, aggregate.getGroupSet()))
-                    .collect(Collectors.toList())));
+                    .collect(toList())));
     }
   }
 
@@ -667,7 +667,7 @@ private static SqlNode groupItem(
     final List<SqlNode> nodes =
         groupSet.asList().stream()
             .map(key -> groupKeys.get(wholeGroupSet.indexOf(key)))
-            .collect(Collectors.toList());
+            .collect(toList());
     switch (nodes.size()) {
       case 1:
         return nodes.get(0);
@@ -689,9 +689,7 @@ public Result visit(TableScan e) {
               identifier,
               SqlNodeList.of(
                   pos,
-                  hints.stream()
-                      .map(h -> RelToSqlConverter.toSqlHint(h, pos))
-                      .collect(Collectors.toList())));
+                  hints.stream().map(h -> RelToSqlConverter.toSqlHint(h, pos)).collect(toList())));
     } else {
       node = identifier;
     }
@@ -711,7 +709,7 @@ private static SqlHint toSqlHint(RelHint hint, SqlParserPos pos) {
                           Stream.of(
                               new SqlIdentifier(e.getKey(), pos),
                               SqlLiteral.createCharString(e.getValue(), pos)))
-                  .collect(Collectors.toList())),
+                  .collect(toList())),
           SqlHint.HintOptionFormat.KV_LIST);
     } else if (hint.listOptions != null) {
       return new SqlHint(
@@ -721,7 +719,7 @@ private static SqlHint toSqlHint(RelHint hint, SqlParserPos pos) {
               pos,
               hint.listOptions.stream()
                   .map(e -> SqlLiteral.createCharString(e, pos))
-                  .collect(Collectors.toList())),
+                  .collect(toList())),
           SqlHint.HintOptionFormat.LITERAL_LIST);
     }
     return new SqlHint(
@@ -881,7 +879,7 @@ public Result visit(Values e) {
             list.stream()
                 .map(select -> (SqlNode) select)
                 .reduce((l, r) -> SqlStdOperatorTable.UNION_ALL.createCall(POS, l, r))
-                .get();
+                .orElseThrow();
       }
     } else {
       // Generate ANSI syntax
@@ -958,7 +956,7 @@ public Result visit(Sort e) {
         List<Integer> sortList =
             e.getCollation().getFieldCollations().stream()
                 .map(f -> aggregate.getGroupSet().nth(f.getFieldIndex()))
-                .collect(Collectors.toList());
+                .collect(toList());
         // "GROUP BY x, y WITH ROLLUP" implicitly sorts by x, y,
         // so skip the ORDER BY.
         final boolean isImplicitlySort = Util.startsWith(rollupList, sortList);
diff --git a/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java b/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
index ac452665c..d598f95bc 100644
--- a/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
+++ b/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
@@ -1432,7 +1432,7 @@ public static SqlNode toSql(RexLiteral literal) {
         //noinspection unchecked
         final List<RexLiteral> list = castNonNull(literal.getValueAs(List.class));
         return SqlStdOperatorTable.ROW.createCall(
-            POS, list.stream().map(e -> toSql(e)).collect(Util.toImmutableList()));
+            POS, list.stream().map(SqlImplementor::toSql).collect(Util.toImmutableList()));
 
       case SARG:
         final Sarg arg = literal.getValueAs(Sarg.class);
@@ -1498,9 +1498,9 @@ public static SqlNode toSql(RexLiteral literal) {
 
   /**
    * Simple implementation of {@link Context} that cannot handle sub-queries or correlations.
-   * Because it is so simple, you do not need to create a {@link SqlImplementor} or {@link
-   * org.apache.calcite.tools.RelBuilder} to use it. It is a good way to convert a {@link RexNode}
-   * to SQL text.
+   * Because it is so simple, you do not need to create a {@link
+   * org.apache.calcite.rel.rel2sql.SqlImplementor} or {@link org.apache.calcite.tools.RelBuilder}
+   * to use it. It is a good way to convert a {@link RexNode} to SQL text.
    */
   public static class SimpleContext extends Context {
     private final IntFunction<SqlNode> field;
@@ -1520,8 +1520,8 @@ public SimpleContext(SqlDialect dialect, IntFunction<SqlNode> field) {
   }
 
   /**
-   * Implementation of {@link Context} that has an enclosing {@link SqlImplementor} and can
-   * therefore do non-trivial expressions.
+   * Implementation of {@link Context} that has an enclosing {@link
+   * org.apache.calcite.rel.rel2sql.SqlImplementor} and can therefore do non-trivial expressions.
    */
   protected abstract class BaseContext extends Context {
     BaseContext(SqlDialect dialect, int fieldCount) {
@@ -2232,7 +2232,7 @@ public Builder(
         boolean anon,
         @Nullable Map<String, RelDataType> aliases) {
       this.rel = requireNonNull(rel, "rel");
-      this.clauses = ImmutableList.copyOf(clauses);
+      this.clauses = clauses;
       this.select = requireNonNull(select, "select");
       this.context = requireNonNull(context, "context");
       this.anon = anon;
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
index 59ae745c3..97c633d38 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
@@ -43,10 +43,8 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.immutables.value.Value;
@@ -62,10 +60,14 @@
 import java.util.NavigableSet;
 import java.util.Set;
 import java.util.TreeSet;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toCollection;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Planner rule that expands distinct aggregates (such as {@code COUNT(DISTINCT x)}) from a {@link
@@ -130,10 +132,10 @@ public AggregateExpandDistinctAggregatesRule(
     final List<AggregateCall> aggCalls = aggregate.getAggCallList();
     // Find all aggregate calls with distinct
     final List<AggregateCall> distinctAggCalls =
-        aggCalls.stream().filter(AggregateCall::isDistinct).collect(Collectors.toList());
+        aggCalls.stream().filter(AggregateCall::isDistinct).collect(toList());
     // Find all aggregate calls without distinct
     final List<AggregateCall> nonDistinctAggCalls =
-        aggCalls.stream().filter(aggCall -> !aggCall.isDistinct()).collect(Collectors.toList());
+        aggCalls.stream().filter(aggCall -> !aggCall.isDistinct()).collect(toList());
     final long filterCount = aggCalls.stream().filter(aggCall -> aggCall.filterArg >= 0).count();
     final long unsupportedNonDistinctAggCallCount =
         nonDistinctAggCalls.stream()
@@ -157,9 +159,9 @@ public AggregateExpandDistinctAggregatesRule(
     final Set<Pair<List<Integer>, Integer>> distinctCallArgLists =
         distinctAggCalls.stream()
             .map(aggCall -> Pair.of(aggCall.getArgList(), aggCall.filterArg))
-            .collect(Collectors.toCollection(LinkedHashSet::new));
+            .collect(toCollection(LinkedHashSet::new));
 
-    Preconditions.checkState(distinctCallArgLists.size() > 0, "containsDistinctCall lied");
+    checkState(!distinctCallArgLists.isEmpty(), "containsDistinctCall lied");
 
     // If all of the agg expressions are distinct and have the same
     // arguments then we can use a more efficient form.
@@ -175,14 +177,14 @@ public AggregateExpandDistinctAggregatesRule(
         nonDistinctAggCalls.stream()
             .filter(
                 aggCall -> aggCall.getAggregation().getDistinctOptionality() == Optionality.IGNORED)
-            .collect(Collectors.toList());
+            .collect(toList());
     // Different with distinctCallArgLists, this list also contains args that come from
     // agg call which can ignore the distinct constraint.
     final Set<Pair<List<Integer>, Integer>> distinctCallArgLists2 =
         Stream.of(distinctAggCalls, nonDistinctAggCallsOfIgnoredOptionality)
             .flatMap(Collection::stream)
             .map(aggCall -> Pair.of(aggCall.getArgList(), aggCall.filterArg))
-            .collect(Collectors.toCollection(LinkedHashSet::new));
+            .collect(toCollection(LinkedHashSet::new));
 
     if ((nonDistinctAggCalls.size() - nonDistinctAggCallsOfIgnoredOptionality.size()) == 0
         && distinctCallArgLists2.size() == 1
@@ -204,7 +206,7 @@ public AggregateExpandDistinctAggregatesRule(
     if (distinctAggCalls.size() == 1 // one distinct aggregate
         && filterCount == 0 // no filter
         && unsupportedNonDistinctAggCallCount == 0 // sum/min/max/count in non-distinct aggregate
-        && nonDistinctAggCalls.size() > 0) { // one or more non-distinct aggregates
+        && !nonDistinctAggCalls.isEmpty()) { // one or more non-distinct aggregates
       final RelBuilder relBuilder = call.builder();
       convertSingletonDistinct(relBuilder, aggregate, distinctCallArgLists);
       call.transformTo(relBuilder.build());
@@ -274,7 +276,7 @@ private static RelBuilder convertSingletonDistinct(
 
     // In this case, we are assuming that there is a single distinct function.
     // So make sure that argLists is of size one.
-    Preconditions.checkArgument(argLists.size() == 1);
+    checkArgument(argLists.size() == 1);
 
     // For example,
     //    SELECT deptno, COUNT(*), SUM(bonus), MIN(DISTINCT sal)
@@ -666,7 +668,7 @@ private static RelBuilder convertMonopole(
     createSelectDistinct(relBuilder, aggregate, argList, filterArg, sourceOf);
 
     // Create an aggregate on top, with the new aggregate list.
-    final List<AggregateCall> newAggCalls = Lists.newArrayList(aggregate.getAggCallList());
+    final List<AggregateCall> newAggCalls = new ArrayList<>(aggregate.getAggCallList());
     rewriteAggCalls(newAggCalls, argList, sourceOf);
     final int cardinality = aggregate.getGroupSet().cardinality();
     relBuilder.push(
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
index 60d5caf35..601fa58a9 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
@@ -44,15 +44,16 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.function.IntPredicate;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.rel.rules.AggregateExpandDistinctAggregatesRule.groupValue;
 import static org.apache.calcite.rel.rules.AggregateExpandDistinctAggregatesRule.remap;
 
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
+
 /**
  * Planner rule that rewrites an {@link Aggregate} that contains {@code WITHIN DISTINCT} aggregate
  * functions.
@@ -243,7 +244,7 @@ List<Integer> fields(List<Integer> fields, int filterArg) {
       }
 
       int field(int field, int filterArg) {
-        return Objects.requireNonNull(args.get(IntPair.of(field, filterArg)));
+        return requireNonNull(args.get(IntPair.of(field, filterArg)));
       }
 
       /**
@@ -297,7 +298,7 @@ int registerAgg(int i, RelBuilder.AggCall aggregateCall) {
       }
 
       int getAgg(int i) {
-        return Objects.requireNonNull(aggs.get(i));
+        return requireNonNull(aggs.get(i));
       }
 
       /**
@@ -324,7 +325,7 @@ int registerCount(int filterArg) {
       }
 
       int getCount(int filterArg) {
-        return Objects.requireNonNull(counts.get(filterArg));
+        return requireNonNull(counts.get(filterArg));
       }
     }
 
@@ -425,7 +426,7 @@ int getCount(int filterArg) {
               }
             }
           }
-          if (filters.size() > 0) {
+          if (!filters.isEmpty()) {
             aggCall = aggCall.filter(b.and(filters));
           }
           aggCalls.add(aggCall);
@@ -478,7 +479,7 @@ private static AggregateCall unDistinct(AggregateCall aggregateCall, IntPredicat
                       aggregateCall.getAggregation().getKind() != SqlKind.COUNT
                           || aggregateCall.hasFilter()
                           || isNullable.test(i))
-              .collect(Collectors.toList());
+              .collect(toList());
       return aggregateCall
           .withDistinct(false)
           .withDistinctKeys(ImmutableBitSet.of(aggregateCall.getArgList()))
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
index 00e0a4d35..2f68d1aa5 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
@@ -101,7 +101,7 @@ private static boolean isAggregateSupported(AggregateCall aggCall) {
 
     final List<AggregateCall> finalCalls = new ArrayList<>();
     for (AggregateCall topCall : topAgg.getAggCallList()) {
-      if (!isAggregateSupported(topCall) || topCall.getArgList().size() == 0) {
+      if (!isAggregateSupported(topCall) || topCall.getArgList().isEmpty()) {
         return;
       }
       // Make sure top aggregate argument refers to one of the aggregate
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
index 1bb46bc10..23459c556 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
@@ -53,11 +53,14 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 import java.util.function.IntPredicate;
 import java.util.function.Predicate;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Planner rule that reduces aggregate functions in {@link org.apache.calcite.rel.core.Aggregate}s
  * to simpler forms.
@@ -91,10 +94,10 @@ public class AggregateReduceFunctionsRule extends RelRule<AggregateReduceFunctio
   // ~ Static fields/initializers ---------------------------------------------
 
   private static void validateFunction(SqlKind function) {
-    if (!isValid(function)) {
-      throw new IllegalArgumentException(
-          "AggregateReduceFunctionsRule doesn't " + "support function: " + function.sql);
-    }
+    checkArgument(
+        isValid(function),
+        "AggregateReduceFunctionsRule doesn't support function: %s",
+        function.sql);
   }
 
   private static boolean isValid(SqlKind function) {
@@ -110,7 +113,7 @@ private static boolean isValid(SqlKind function) {
   /** Creates an AggregateReduceFunctionsRule. */
   protected AggregateReduceFunctionsRule(Config config) {
     super(config);
-    this.functionsToReduce = ImmutableSet.copyOf(config.actualFunctionsToReduce());
+    this.functionsToReduce = config.actualFunctionsToReduce();
   }
 
   @Deprecated // to be removed before 2.0
@@ -136,7 +139,7 @@ public AggregateReduceFunctionsRule(
             .as(Config.class)
             .withOperandFor(aggregateClass)
             // reduce specific functions provided by the client
-            .withFunctionsToReduce(Objects.requireNonNull(functionsToReduce, "functionsToReduce")));
+            .withFunctionsToReduce(requireNonNull(functionsToReduce, "functionsToReduce")));
   }
 
   // ~ Methods ----------------------------------------------------------------
@@ -260,8 +263,8 @@ private RexNode reduceAgg(
     if (canReduceAggCallByGrouping(oldAggRel, oldCall)) {
       // replace original MAX/MIN/AVG/ANY_VALUE/FIRST_VALUE/LAST_VALUE(x) with
       // target field of x, when x exists in group
-      final RexNode reducedNode = reduceAggCallByGrouping(oldAggRel, oldCall);
-      return reducedNode;
+      return reduceAggCallByGrouping(oldAggRel, oldCall);
+
     } else if (canReduce(oldCall)) {
       final Integer y;
       final Integer x;
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
index be0e4fda9..b773ceb70 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
@@ -100,7 +100,7 @@ protected void apply(
     final RelOptPlanner planner = call.getPlanner();
     final Optional<CalciteConnectionConfig> config =
         planner.getContext().maybeUnwrap(CalciteConnectionConfig.class);
-    if (!(config.isPresent() && config.get().createMaterializations())) {
+    if (!(config.isPresent() && config.orElseThrow().createMaterializations())) {
       // Disable this rule if we if materializations are disabled - in
       // particular, if we are in a recursive statement that is being used to
       // populate a materialization
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java b/core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
index 8a892e035..bb5739522 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
@@ -43,7 +43,8 @@
 import org.apache.calcite.util.graph.DirectedGraph;
 import org.apache.calcite.util.graph.TopologicalOrderIterator;
 
-import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.primitives.Ints;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -53,10 +54,11 @@
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * CalcRelSplitter operates on a {@link org.apache.calcite.rel.core.Calc} with multiple {@link
  * RexCall} sub-expressions that cannot all be implemented by a single concrete {@link RelNode}.
@@ -226,7 +228,7 @@ RelNode execute() {
       inputExprOrdinals = projectExprOrdinals;
     }
 
-    Preconditions.checkArgument(doneCondition || (conditionRef == null), "unhandled condition");
+    checkArgument(doneCondition || (conditionRef == null), "unhandled condition");
     return rel;
   }
 
@@ -397,7 +399,7 @@ private static List<Integer> computeTopologicalOrdering(
       final Set<Integer> cohort = findCohort(cohorts, i);
       final Set<Integer> targets;
       if (cohort == null) {
-        targets = Collections.singleton(i);
+        targets = ImmutableSet.of(i);
       } else {
         targets = cohort;
       }
@@ -536,11 +538,10 @@ private RexProgram createProgramForLevel(
     if (outputRowType == null) {
       outputRowType = RexUtil.createStructType(typeFactory, projectRefs, fieldNames, null);
     }
-    final RexProgram program =
-        new RexProgram(inputRowType, exprs, projectRefs, conditionRef, outputRowType);
+    return new RexProgram(inputRowType, exprs, projectRefs, conditionRef, outputRowType);
     // Program is NOT normalized here (e.g. can contain literals in
     // call operands), since literals should be inlined.
-    return program;
+
   }
 
   private String deriveFieldName(RexNode expr, int ordinal) {
@@ -659,7 +660,7 @@ protected boolean canImplement(LogicalCalc rel, String relTypeName) {
    *     attempt to place on the same level
    */
   protected List<Set<Integer>> getCohorts() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   // ~ Inner Classes ----------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java b/core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
index 7efe8a7eb..197f84b8c 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
@@ -156,8 +156,8 @@ assert requireNonNull(finder, "finder").timeUnits.isEmpty() && finder.opKinds.is
   }
 
   /** Replaces calls to EXTRACT, FLOOR and CEIL in an expression. */
-  @VisibleForTesting
   @SuppressWarnings("BetaApi")
+  @VisibleForTesting
   public static RexNode replaceTimeUnits(RexBuilder rexBuilder, RexNode e, String timeZone) {
     ImmutableSortedSet<TimeUnitRange> timeUnits = extractTimeUnits(e);
     if (!timeUnits.contains(TimeUnitRange.YEAR)) {
@@ -436,7 +436,7 @@ private boolean canRewriteExtract(RexNode operand) {
             //noinspection unchecked
             return (List<RexNode>) exprs;
           }
-          final Map<RexNode, RangeSet<Calendar>> save = ImmutableMap.copyOf(operandRanges);
+          final Map<RexNode, RangeSet<Calendar>> save = operandRanges;
           final ImmutableList.Builder<RexNode> clonedOperands = ImmutableList.builder();
           for (RexNode operand : exprs) {
             RexNode clonedOperand = operand;
@@ -514,7 +514,7 @@ RexNode compareExtract(SqlKind comparison, RexNode operand, RexLiteral literal)
       }
       // Intersect old range set with new.
       s2.removeAll(rangeSet.complement());
-      operandRanges.put(operand, ImmutableRangeSet.copyOf(s2));
+      operandRanges.put(operand, s2);
       final List<RexNode> nodes = new ArrayList<>();
       for (Range<Calendar> r : s2.asRanges()) {
         nodes.add(toRex(operand, r));
@@ -663,7 +663,7 @@ private RexNode compareFloorCeil(
       s2.add(range);
       // Intersect old range set with new.
       s2.removeAll(rangeSet.complement());
-      operandRanges.put(operand, ImmutableRangeSet.copyOf(s2));
+      operandRanges.put(operand, s2);
       if (range.isEmpty()) {
         return rexBuilder.makeLiteral(false);
       }
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ExchangeRemoveConstantKeysRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ExchangeRemoveConstantKeysRule.java
index 9c32830cc..5c6b6964e 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ExchangeRemoveConstantKeysRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ExchangeRemoveConstantKeysRule.java
@@ -39,7 +39,8 @@
 import java.util.List;
 import java.util.Set;
 import java.util.function.Predicate;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /**
  * Planner rule that removes keys from a {@link Exchange} if those keys are known to be constant.
@@ -64,7 +65,7 @@ protected static List<Integer> simplifyDistributionKeys(
       RelDistribution distribution, Set<Integer> constants) {
     return distribution.getKeys().stream()
         .filter(key -> !constants.contains(key))
-        .collect(Collectors.toList());
+        .collect(toList());
   }
 
   @Override public void onMatch(RelOptRuleCall call) {
@@ -147,7 +148,7 @@ private static void matchSortExchange(ExchangeRemoveConstantKeysRule rule, RelOp
     final List<RelFieldCollation> fieldCollations =
         sortExchange.getCollation().getFieldCollations().stream()
             .filter(fc -> !constants.contains(fc.getFieldIndex()))
-            .collect(Collectors.toList());
+            .collect(toList());
 
     boolean collationSimplified =
         fieldCollations.size() != sortExchange.getCollation().getFieldCollations().size();
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
index 01929d320..a3d7b7e35 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
@@ -73,7 +73,7 @@ protected FilterJoinRule(C config) {
 
   protected void perform(RelOptRuleCall call, @Nullable Filter filter, Join join) {
     List<RexNode> joinFilters = RelOptUtil.conjunctions(join.getCondition());
-    final List<RexNode> origJoinFilters = ImmutableList.copyOf(joinFilters);
+    final List<RexNode> origJoinFilters = joinFilters;
 
     // If there is only the joinRel,
     // make sure it does not match a cartesian product joinRel
@@ -332,7 +332,7 @@ private static List<RexNode> constructConditionFromEqualSets(
         }
       }
       // Only need one equal condition for each equal set.
-      if (leftSet.size() > 0 && rightSet.size() > 0) {
+      if (!leftSet.isEmpty() && !rightSet.isEmpty()) {
         result.add(
             rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, leftSet.get(0), rightSet.get(0)));
       }
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java b/core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
index 999abc3f0..dd4660743 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
@@ -32,9 +32,10 @@
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 
+import com.google.common.collect.ImmutableList;
+
 import org.immutables.value.Value;
 
-import java.util.Collections;
 import java.util.function.Predicate;
 
 /**
@@ -177,12 +178,11 @@ protected FilterProjectTransposeRule(
               .replaceIfs(
                   RelCollationTraitDef.INSTANCE,
                   () ->
-                      Collections.singletonList(
-                          input.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE)))
+                      ImmutableList.of(input.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE)))
               .replaceIfs(
                   RelDistributionTraitDef.INSTANCE,
                   () ->
-                      Collections.singletonList(
+                      ImmutableList.of(
                           input.getTraitSet().getTrait(RelDistributionTraitDef.INSTANCE)));
       newCondition = RexUtil.removeNullabilityCast(relBuilder.getTypeFactory(), newCondition);
       newFilterRel = filter.copy(traitSet, input, newCondition);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java b/core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
index 77c908051..132e55bf1 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
@@ -117,7 +117,7 @@ public IntersectToDistinctRule(
     relBuilder.filter(
         relBuilder.equals(
             relBuilder.field(fieldCount - 1),
-            rexBuilder.makeBigintLiteral(new BigDecimal(branchCount))));
+            rexBuilder.makeBigintLiteral(BigDecimal.valueOf(branchCount))));
 
     // Project all but the last field
     relBuilder.project(Util.skipLast(relBuilder.fields()));
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java
index c6be90be9..3868a8916 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java
@@ -74,7 +74,7 @@ public JoinAddRedundantSemiJoinRule(
 
     // determine if we have a valid join condition
     final JoinInfo joinInfo = origJoinRel.analyzeCondition();
-    if (joinInfo.leftKeys.size() == 0) {
+    if (joinInfo.leftKeys.isEmpty()) {
       return;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinDeriveIsNotNullFilterRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinDeriveIsNotNullFilterRule.java
index b27ab25fa..c29f4749f 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinDeriveIsNotNullFilterRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinDeriveIsNotNullFilterRule.java
@@ -34,7 +34,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /**
  * Planner rule that derives IS NOT NULL predicates from a inner {@link
@@ -87,25 +88,14 @@ public JoinDeriveIsNotNullFilterRule(Config config) {
     relBuilder
         .push(join.getLeft())
         .withPredicates(
-            mq,
-            r ->
-                r.filter(
-                    leftKeys.stream()
-                        .map(r::field)
-                        .map(r::isNotNull)
-                        .collect(Collectors.toList())));
+            mq, r -> r.filter(leftKeys.stream().map(r::field).map(r::isNotNull).collect(toList())));
     final RelNode newLeft = relBuilder.build();
 
     relBuilder
         .push(join.getRight())
         .withPredicates(
             mq,
-            r ->
-                r.filter(
-                    rightKeys.stream()
-                        .map(r::field)
-                        .map(r::isNotNull)
-                        .collect(Collectors.toList())));
+            r -> r.filter(rightKeys.stream().map(r::field).map(r::isNotNull).collect(toList())));
     final RelNode newRight = relBuilder.build();
 
     if (newLeft != join.getLeft() || newRight != join.getRight()) {
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
index b451efce0..59079eeac 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
@@ -41,11 +41,12 @@
 import org.apache.calcite.tools.RelBuilderFactory;
 import org.apache.calcite.util.Pair;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.immutables.value.Value;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 import static java.util.Objects.requireNonNull;
@@ -189,7 +190,7 @@ public JoinProjectTransposeRule(
             JoinRelType.INNER,
             join.getCluster().getTypeFactory(),
             null,
-            Collections.emptyList());
+            ImmutableList.of());
 
     // Create projection expressions, combining the projection expressions
     // from the projects that feed into the join.  For the RHS projection
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
index 23a4c0a16..b53e149bc 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
@@ -80,14 +80,14 @@ public JoinPushTransitivePredicatesRule(
     final RelBuilder relBuilder = call.builder();
 
     RelNode left = join.getLeft();
-    if (preds.leftInferredPredicates.size() > 0) {
+    if (!preds.leftInferredPredicates.isEmpty()) {
       RelNode curr = left;
       left = relBuilder.push(left).filter(preds.leftInferredPredicates).build();
       call.getPlanner().onCopy(curr, left);
     }
 
     RelNode right = join.getRight();
-    if (preds.rightInferredPredicates.size() > 0) {
+    if (!preds.rightInferredPredicates.isEmpty()) {
       RelNode curr = right;
       right = relBuilder.push(right).filter(preds.rightInferredPredicates).build();
       call.getPlanner().onCopy(curr, right);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
index 811517dfd..3ac1f8a69 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
@@ -403,14 +403,12 @@ private static boolean canCombine(RelNode input, boolean nullGenerating) {
     for (int i = 0; i < nFieldsOnRight; i++) {
       adjustments[i] = nFieldsOnLeft;
     }
-    rightFilter =
-        rightFilter.accept(
-            new RelOptUtil.RexInputConverter(
-                joinRel.getCluster().getRexBuilder(),
-                right.getRowType().getFieldList(),
-                joinRel.getRowType().getFieldList(),
-                adjustments));
-    return rightFilter;
+    return rightFilter.accept(
+        new RelOptUtil.RexInputConverter(
+            joinRel.getCluster().getRexBuilder(),
+            right.getRowType().getFieldList(),
+            joinRel.getRowType().getFieldList(),
+            adjustments));
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/LoptJoinTree.java b/core/src/main/java/org/apache/calcite/rel/rules/LoptJoinTree.java
index 616506eef..e53535640 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/LoptJoinTree.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/LoptJoinTree.java
@@ -24,7 +24,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Utility class used to store a {@link org.apache.calcite.rel.core.Join} tree and the factors that
@@ -187,8 +188,8 @@ protected static class Node extends BinaryTree {
 
     public Node(BinaryTree left, BinaryTree right, @UnderInitialization LoptJoinTree parent) {
       super(parent);
-      this.left = Objects.requireNonNull(left, "left");
-      this.right = Objects.requireNonNull(right, "right");
+      this.left = requireNonNull(left, "left");
+      this.right = requireNonNull(right, "right");
     }
 
     public BinaryTree getLeft() {
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java b/core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java
index fbac06544..6ab2af12f 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java
@@ -33,7 +33,6 @@
 import org.apache.calcite.util.ImmutableIntList;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.initialization.qual.UnderInitialization;
 import org.checkerframework.checker.initialization.qual.UnknownInitialization;
@@ -164,7 +163,7 @@ public LoptMultiJoin(MultiJoin multiJoin) {
     projFields = multiJoin.getProjFields();
     joinFieldRefCountsMap = multiJoin.getCopyJoinFieldRefCountsMap();
 
-    joinFilters = Lists.newArrayList(RelOptUtil.conjunctions(multiJoin.getJoinFilter()));
+    joinFilters = new ArrayList<>(RelOptUtil.conjunctions(multiJoin.getJoinFilter()));
 
     allJoinFilters = new ArrayList<>(joinFilters);
     List<@Nullable RexNode> outerJoinFilters = multiJoin.getOuterJoinConditions();
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
index 0417ab9aa..eb6352a99 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
@@ -320,7 +320,7 @@ private static void findRemovableSelfJoins(RelMetadataQuery mq, LoptMultiJoin mu
           selfJoinFilters.add(filter);
         }
       }
-      if ((selfJoinFilters.size() > 0)
+      if (!selfJoinFilters.isEmpty()
           && isSelfJoinFilterUnique(mq, multiJoin, factor1, factor2, selfJoinFilters)) {
         multiJoin.addRemovableSelfJoinPair(factor1, factor2);
       }
@@ -679,7 +679,7 @@ private static void setFactorJoinKeys(
       prevFactor = nextFactor;
     }
 
-    assert filtersToAdd.size() == 0;
+    assert filtersToAdd.isEmpty();
     return joinTree;
   }
 
@@ -1702,15 +1702,12 @@ private static RexNode swapFilter(
       adjustments[i] = -nFieldsOnLeft;
     }
 
-    condition =
-        condition.accept(
-            new RelOptUtil.RexInputConverter(
-                rexBuilder,
-                multiJoin.getJoinFields(origLeft, origRight),
-                multiJoin.getJoinFields(origRight, origLeft),
-                adjustments));
-
-    return condition;
+    return condition.accept(
+        new RelOptUtil.RexInputConverter(
+            rexBuilder,
+            multiJoin.getJoinFields(origLeft, origRight),
+            multiJoin.getJoinFields(origRight, origLeft),
+            adjustments));
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java b/core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
index 79538b464..6bf59cf93 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
@@ -39,7 +39,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -237,11 +236,11 @@ private static int isSuitableFilter(LoptMultiJoin multiJoin, RexNode joinFilter,
     RelNode factRel = multiJoin.getJoinFactor(factIdx);
     RelNode dimRel = multiJoin.getJoinFactor(dimIdx);
     final JoinInfo joinInfo = JoinInfo.of(factRel, dimRel, semiJoinCondition);
-    assert joinInfo.leftKeys.size() > 0;
+    assert !joinInfo.leftKeys.isEmpty();
 
     // mutable copies
-    final List<Integer> leftKeys = Lists.newArrayList(joinInfo.leftKeys);
-    final List<Integer> rightKeys = Lists.newArrayList(joinInfo.rightKeys);
+    final List<Integer> leftKeys = new ArrayList<>(joinInfo.leftKeys);
+    final List<Integer> rightKeys = new ArrayList<>(joinInfo.rightKeys);
 
     // make sure all the fact table keys originate from the same table
     // and are simple column references
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java b/core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java
index e26f41122..2a3ee2245 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java
@@ -32,10 +32,10 @@
 import org.apache.calcite.tools.RelBuilderFactory;
 
 import com.google.common.base.Suppliers;
+import com.google.common.collect.ImmutableList;
 
 import org.immutables.value.Value;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Supplier;
 
@@ -83,7 +83,7 @@ protected void apply(RelOptRuleCall call, Filter filter, TableScan scan) {
     final RelOptPlanner planner = call.getPlanner();
     final List<RelOptMaterialization> materializations = planner.getMaterializations();
     if (!materializations.isEmpty()) {
-      RelNode root = filter.copy(filter.getTraitSet(), Collections.singletonList(scan));
+      RelNode root = filter.copy(filter.getTraitSet(), ImmutableList.of(scan));
       List<RelOptMaterialization> applicableMaterializations =
           RelOptMaterializations.getApplicableMaterializations(root, materializations);
       for (RelOptMaterialization materialization : applicableMaterializations) {
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java b/core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java
index 333e8c163..46a2357d2 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java
@@ -33,7 +33,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -97,7 +96,7 @@ public MultiJoin(
       ImmutableMap<Integer, ImmutableIntList> joinFieldRefCountsMap,
       @Nullable RexNode postJoinFilter) {
     super(cluster, cluster.traitSetOf(Convention.NONE));
-    this.inputs = Lists.newArrayList(inputs);
+    this.inputs = new ArrayList<>(inputs);
     this.joinFilter = joinFilter;
     this.rowType = rowType;
     this.isFullOuterJoin = isFullOuterJoin;
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java b/core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
index 818c51033..591ffa025 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/MultiJoinOptimizeBushyRule.java
@@ -46,11 +46,12 @@
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.rel.rules.LoptMultiJoin.Edge;
 import static org.apache.calcite.util.mapping.Mappings.TargetMapping;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Planner rule that finds an approximately optimal ordering for join operators using a heuristic
  * algorithm.
@@ -381,7 +382,7 @@ static class JoinVertex extends Vertex {
       super(id, factors, cost);
       this.leftFactor = leftFactor;
       this.rightFactor = rightFactor;
-      this.conditions = Objects.requireNonNull(conditions, "conditions");
+      this.conditions = requireNonNull(conditions, "conditions");
     }
 
     @Override public String toString() {
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinJoinRemoveRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinJoinRemoveRule.java
index 78cb14912..4cd908a2f 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinJoinRemoveRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinJoinRemoveRule.java
@@ -36,7 +36,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /**
  * Planner rule that matches an {@link org.apache.calcite.rel.core.Project} on a {@link
@@ -153,7 +154,7 @@ public ProjectJoinJoinRemoveRule(
     final List<RexNode> newExprs =
         project.getProjects().stream()
             .map(expr -> RexUtil.shift(expr, leftBottomChildSize, -offset))
-            .collect(Collectors.toList());
+            .collect(toList());
     relBuilder.push(join).project(newExprs);
     call.transformTo(relBuilder.build());
   }
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinRemoveRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinRemoveRule.java
index 30021084b..74b0b2e7b 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinRemoveRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ProjectJoinRemoveRule.java
@@ -35,7 +35,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /**
  * Planner rule that matches an {@link Project} on a {@link Join} and removes the join provided that
@@ -130,7 +131,7 @@ public ProjectJoinRemoveRule(
       final List<RexNode> newExprs =
           project.getProjects().stream()
               .map(expr -> RexUtil.shift(expr, -offset))
-              .collect(Collectors.toList());
+              .collect(toList());
       node = project.copy(project.getTraitSet(), join.getRight(), newExprs, project.getRowType());
     }
     call.transformTo(node);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ProjectTableScanRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ProjectTableScanRule.java
index bbef93922..991895dca 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ProjectTableScanRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ProjectTableScanRule.java
@@ -39,7 +39,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /**
  * Planner rule that converts a {@link Project} on a {@link org.apache.calcite.rel.core.TableScan}
@@ -120,8 +121,7 @@ protected void apply(RelOptRuleCall call, Project project, TableScan scan) {
     if (scan instanceof Bindables.BindableTableScan) {
       final Bindables.BindableTableScan bindableScan = (Bindables.BindableTableScan) scan;
       filtersPushDown = bindableScan.filters;
-      projectsPushDown =
-          selectedColumns.stream().map(bindableScan.projects::get).collect(Collectors.toList());
+      projectsPushDown = selectedColumns.stream().map(bindableScan.projects::get).collect(toList());
     } else {
       filtersPushDown = ImmutableList.of();
       projectsPushDown = selectedColumns;
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
index b5646e175..4cf08078b 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ProjectToWindowRule.java
@@ -45,7 +45,6 @@
 import org.apache.calcite.util.graph.DirectedGraph;
 import org.apache.calcite.util.graph.TopologicalOrderIterator;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.immutables.value.Value;
@@ -57,6 +56,8 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Planner rule that slices a {@link org.apache.calcite.rel.core.Project} into sections which
  * contain windowed aggregate functions and sections which do not.
@@ -248,7 +249,7 @@ static class WindowedAggRelSplitter extends CalcRelSplitter {
             RelBuilder relBuilder,
             RelNode input,
             RexProgram program) {
-          Preconditions.checkArgument(
+          checkArgument(
               program.getCondition() == null, "WindowedAggregateRel cannot accept a condition");
           return LogicalWindow.create(cluster, traitSet, relBuilder, input, program);
         }
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java b/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
index ae97616e8..f1da0ad08 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
@@ -44,6 +44,8 @@
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 
+import com.google.common.collect.ImmutableList;
+
 import org.immutables.value.Value;
 
 import java.util.Collections;
@@ -310,8 +312,8 @@ public <R extends SingleRel> RemoveEmptySingleRule(
               .withOperandFor(clazz, predicate));
     }
 
-    @SuppressWarnings({"Guava", "UnnecessaryMethodReference"})
-    @Deprecated // to be removed before 2.0
+    @Deprecated
+    @SuppressWarnings({"Guava", "UnnecessaryMethodReference"}) // to be removed before 2.0
     public <R extends SingleRel> RemoveEmptySingleRule(
         Class<R> clazz,
         com.google.common.base.Predicate<R> predicate,
@@ -333,7 +335,7 @@ public <R extends SingleRel> RemoveEmptySingleRule(
       if (emptyValues.getConvention() != null) {
         traits = traits.replace(emptyValues.getConvention());
       }
-      emptyValues = emptyValues.copy(traits, Collections.emptyList());
+      emptyValues = emptyValues.copy(traits, ImmutableList.of());
       call.transformTo(emptyValues);
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java b/core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
index e17f1ac88..17e2c66e8 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
@@ -42,7 +42,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -51,10 +50,10 @@
 import java.util.List;
 import java.util.Set;
 import java.util.function.Predicate;
-import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * PushProjector is a utility class used to perform operations used in push projection rules.
@@ -210,7 +209,7 @@ public PushProjector(
 
     if (childRel instanceof Join) {
       Join join = (Join) childRel;
-      childFields = Lists.newArrayList(join.getLeft().getRowType().getFieldList());
+      childFields = new ArrayList<>(join.getLeft().getRowType().getFieldList());
       childFields.addAll(join.getRight().getRowType().getFieldList());
     } else {
       childFields = childRel.getRowType().getFieldList();
@@ -317,7 +316,7 @@ public PushProjector(
     // special expressions to preserve in the projection; otherwise,
     // there's no point in proceeding any further
     if (origProj == null) {
-      if (childPreserveExprs.size() == 0) {
+      if (childPreserveExprs.isEmpty()) {
         return null;
       }
 
@@ -329,14 +328,14 @@ public PushProjector(
         projRefs.set(0, nChildFields);
       }
       nProject = nChildFields;
-    } else if ((projRefs.cardinality() == nChildFields) && (childPreserveExprs.size() == 0)) {
+    } else if ((projRefs.cardinality() == nChildFields) && childPreserveExprs.isEmpty()) {
       return null;
     }
 
     // if nothing is being selected from the underlying rel, just
     // project the default expression passed in as a parameter or the
     // first column if there is no default expression
-    if ((projRefs.cardinality() == 0) && (childPreserveExprs.size() == 0)) {
+    if ((projRefs.cardinality() == 0) && childPreserveExprs.isEmpty()) {
       if (defaultExpr != null) {
         childPreserveExprs.add(defaultExpr);
       } else if (nChildFields == 1) {
@@ -419,12 +418,12 @@ public boolean locateAllRefs() {
       // if nothing is projected from the children, arbitrarily project
       // the first columns; this is necessary since Fennel doesn't
       // handle 0-column projections
-      if ((nProject == 0) && (childPreserveExprs.size() == 0)) {
+      if ((nProject == 0) && childPreserveExprs.isEmpty()) {
         projRefs.set(0);
         nProject = 1;
       }
       if (childRel instanceof Join) {
-        if ((nRightProject == 0) && (rightPreserveExprs.size() == 0)) {
+        if ((nRightProject == 0) && rightPreserveExprs.isEmpty()) {
           projRefs.set(nFields);
           nRightProject = 1;
         }
@@ -435,8 +434,8 @@ public boolean locateAllRefs() {
     // referenced and there are no special preserve expressions; note
     // that we need to do this check after we've handled the 0-column
     // project cases
-    boolean allFieldsReferenced = IntStream.range(0, nChildFields).allMatch(i -> projRefs.get(i));
-    if (allFieldsReferenced && childPreserveExprs.size() == 0 && rightPreserveExprs.size() == 0) {
+    boolean allFieldsReferenced = IntStream.range(0, nChildFields).allMatch(projRefs::get);
+    if (allFieldsReferenced && childPreserveExprs.isEmpty() && rightPreserveExprs.isEmpty()) {
       return true;
     }
 
@@ -484,7 +483,7 @@ public Project createProjectRefsAndExprs(RelNode projChild, boolean adjust, bool
     // add on the expressions that need to be preserved, converting the
     // arguments to reference the projected columns (if necessary)
     int[] adjustments = {};
-    if ((preserveExprs.size() > 0) && adjust) {
+    if (!preserveExprs.isEmpty() && adjust) {
       adjustments = new int[childFields.size()];
       for (int idx = offset; idx < childFields.size(); idx++) {
         adjustments[idx] = -offset;
@@ -503,8 +502,8 @@ public Project createProjectRefsAndExprs(RelNode projChild, boolean adjust, bool
 
       List<RelDataType> typeList =
           projChild.getRowType().getFieldList().stream()
-              .map(field -> field.getType())
-              .collect(Collectors.toList());
+              .map(RelDataTypeField::getType)
+              .collect(toList());
       RexUtil.FixNullabilityShuttle fixer =
           new RexUtil.FixNullabilityShuttle(projChild.getCluster().getRexBuilder(), typeList);
       newExpr = newExpr.accept(fixer);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
index bca502d59..b5f9b89dc 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
@@ -631,8 +631,7 @@ private CastExpander(RexBuilder builder) {
       }
 
       if (!SqlTypeUtil.isExactNumeric(fromType) || !SqlTypeUtil.isExactNumeric(toType)) {
-        throw Util.needToImplement(
-            "Cast from '" + fromType.toString() + "' to '" + toType.toString() + "'");
+        throw Util.needToImplement("Cast from '" + fromType + "' to '" + toType + "'");
       }
       int fromScale = fromType.getScale();
       int toScale = toType.getScale();
@@ -1019,8 +1018,7 @@ private CastArgAsTypeExpander(RexBuilder builder) {
       }
 
       RexNode ret = builder.makeCall(call.getType(), call.getOperator(), opBuilder.build());
-      ret = ensureType(call.getType(), ret, true);
-      return ret;
+      return ensureType(call.getType(), ret, true);
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
index 68ace4725..f9965aadd 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
@@ -81,7 +81,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Pattern;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /**
  * Collection of planner rules that apply various simplifying transformations on RexNode trees.
@@ -310,7 +311,7 @@ public ProjectReduceExpressionsRule(
       final Project project = call.rel(0);
       final RelMetadataQuery mq = call.getMetadataQuery();
       final RelOptPredicateList predicates = mq.getPulledUpPredicates(project.getInput());
-      final List<RexNode> expList = Lists.newArrayList(project.getProjects());
+      final List<RexNode> expList = new ArrayList<>(project.getProjects());
       if (reduceExpressions(
           project,
           expList,
@@ -632,7 +633,7 @@ public WindowReduceExpressionsRule(
                     fc ->
                         !predicates.constantMap.containsKey(
                             rexBuilder.makeInputRef(window.getInput(), fc.getFieldIndex())))
-                .collect(Collectors.toList());
+                .collect(toList());
 
         boolean collationReduced =
             group.orderKeys.getFieldCollations().size() != collationsList.size();
@@ -734,7 +735,7 @@ protected static boolean reduceExpressions(
       boolean treatDynamicCallsAsConstant) {
     final RelOptCluster cluster = rel.getCluster();
     final RexBuilder rexBuilder = cluster.getRexBuilder();
-    final List<RexNode> originExpList = Lists.newArrayList(expList);
+    final List<RexNode> originExpList = new ArrayList<>(expList);
     final RexExecutor executor = Util.first(cluster.getPlanner().getExecutor(), RexUtil.EXECUTOR);
     final RexSimplify simplify = new RexSimplify(rexBuilder, predicates, executor);
 
@@ -785,10 +786,10 @@ protected static boolean reduceExpressionsInternal(
       return changed;
     }
 
-    final List<RexNode> constExps2 = Lists.newArrayList(constExps);
+    final List<RexNode> constExps2 = new ArrayList<>(constExps);
     if (!predicates.constantMap.isEmpty()) {
       final List<Map.Entry<RexNode, RexNode>> pairs =
-          Lists.newArrayList(predicates.constantMap.entrySet());
+          new ArrayList<>(predicates.constantMap.entrySet());
       RexReplacer replacer =
           new RexReplacer(
               simplify,
@@ -940,7 +941,7 @@ public static RexCall pushPredicateIntoCase(RexCall call) {
 
   /** Converts op(arg0, ..., argOrdinal, ..., argN) to op(arg0,..., node, ..., argN). */
   protected static RexNode substitute(RexCall call, int ordinal, RexNode node) {
-    final List<RexNode> newOperands = Lists.newArrayList(call.getOperands());
+    final List<RexNode> newOperands = new ArrayList<>(call.getOperands());
     newOperands.set(ordinal, node);
     return call.clone(call.getType(), newOperands);
   }
@@ -982,8 +983,7 @@ protected static class RexReplacer extends RexShuttle {
       if (node != null) {
         return node;
       }
-      node = super.visitCall(call);
-      return node;
+      return super.visitCall(call);
     }
 
     private @Nullable RexNode visit(final RexNode call) {
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/SortProjectTransposeRule.java b/core/src/main/java/org/apache/calcite/rel/rules/SortProjectTransposeRule.java
index b922dfff4..264420bbc 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/SortProjectTransposeRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/SortProjectTransposeRule.java
@@ -44,7 +44,8 @@
 import org.immutables.value.Value;
 
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Planner rule that pushes a {@link org.apache.calcite.rel.core.Sort} past a {@link
@@ -130,7 +131,7 @@ protected SortProjectTransposeRule(RelOptRuleOperand operand) {
       if (node.isA(SqlKind.CAST)) {
         // Check whether it is a monotonic preserving cast, otherwise we cannot push
         final RexCall cast = (RexCall) node;
-        RelFieldCollation newFc = Objects.requireNonNull(RexUtil.apply(map, fc));
+        RelFieldCollation newFc = requireNonNull(RexUtil.apply(map, fc));
         final RexCallBinding binding =
             RexCallBinding.create(
                 cluster.getTypeFactory(), cast, ImmutableList.of(RelCollations.of(newFc)));
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/SortRemoveConstantKeysRule.java b/core/src/main/java/org/apache/calcite/rel/rules/SortRemoveConstantKeysRule.java
index 63cadab28..b64d09511 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/SortRemoveConstantKeysRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/SortRemoveConstantKeysRule.java
@@ -30,7 +30,8 @@
 import org.immutables.value.Value;
 
 import java.util.List;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /**
  * Planner rule that removes keys from a a {@link org.apache.calcite.rel.core.Sort} if those keys
@@ -63,7 +64,7 @@ protected SortRemoveConstantKeysRule(Config config) {
                 fc ->
                     !predicates.constantMap.containsKey(
                         rexBuilder.makeInputRef(input, fc.getFieldIndex())))
-            .collect(Collectors.toList());
+            .collect(toList());
 
     if (collationsList.size() == sort.collation.getFieldCollations().size()) {
       return;
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java b/core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
index c7ed6e8f0..6ac18fa2b 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/SubQueryRemoveRule.java
@@ -51,12 +51,13 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.util.Util.last;
 
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
+
 /**
  * Transform that converts IN, EXISTS and scalar sub-queries into joins.
  *
@@ -77,7 +78,7 @@ public class SubQueryRemoveRule extends RelRule<SubQueryRemoveRule.Config>
   /** Creates a SubQueryRemoveRule. */
   protected SubQueryRemoveRule(Config config) {
     super(config);
-    Objects.requireNonNull(config.matchHandler());
+    requireNonNull(config.matchHandler());
   }
 
   @Override public void onMatch(RelOptRuleCall call) {
@@ -547,7 +548,7 @@ private static RexNode rewriteUnique(RexSubQuery e, RelBuilder builder) {
     }
     builder.push(e.rel);
     List<RexNode> notNullCondition =
-        builder.fields().stream().map(builder::isNotNull).collect(Collectors.toList());
+        builder.fields().stream().map(builder::isNotNull).collect(toList());
     builder
         .filter(notNullCondition)
         .aggregate(builder.groupKey(builder.fields()), builder.countStar("c"))
@@ -668,7 +669,7 @@ private static RexNode rewriteIn(
         e.getOperands().stream()
             .filter(operand -> operand.getType().isNullable())
             .map(builder::isNull)
-            .collect(Collectors.toList());
+            .collect(toList());
 
     final RexLiteral trueLiteral = builder.literal(true);
     final RexLiteral falseLiteral = builder.literal(false);
@@ -678,7 +679,7 @@ private static RexNode rewriteIn(
       final List<RexNode> conditions =
           Pair.zip(expressionOperands, fields).stream()
               .map(pair -> builder.equals(pair.left, pair.right))
-              .collect(Collectors.toList());
+              .collect(toList());
       switch (logic) {
         case TRUE:
         case TRUE_FALSE:
@@ -687,13 +688,11 @@ private static RexNode rewriteIn(
           builder.distinct();
           break;
         default:
-          List<RexNode> isNullOperands =
-              fields.stream().map(builder::isNull).collect(Collectors.toList());
+          List<RexNode> isNullOperands = fields.stream().map(builder::isNull).collect(toList());
           // uses keyIsNulls conditions in the filter to avoid empty results
           isNullOperands.addAll(keyIsNulls);
           builder.filter(builder.or(builder.and(conditions), builder.or(isNullOperands)));
-          RexNode project =
-              builder.and(fields.stream().map(builder::isNotNull).collect(Collectors.toList()));
+          RexNode project = builder.and(fields.stream().map(builder::isNotNull).collect(toList()));
           builder.project(builder.alias(project, "cs"));
 
           if (variablesSet.isEmpty()) {
@@ -747,7 +746,7 @@ private static RexNode rewriteIn(
     final List<RexNode> conditions =
         Pair.zip(expressionOperands, builder.fields()).stream()
             .map(pair -> builder.equals(pair.left, RexUtil.shift(pair.right, refOffset)))
-            .collect(Collectors.toList());
+            .collect(toList());
     switch (logic) {
       case TRUE:
         builder.join(JoinRelType.INNER, builder.and(conditions), variablesSet);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
index 03ebfa6ce..8b5f47a86 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
@@ -58,10 +58,10 @@
 import org.apache.calcite.util.mapping.MappingType;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.BiMap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
@@ -77,6 +77,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -568,7 +570,7 @@ public abstract class MaterializedViewAggregateRule<C extends MaterializedViewAg
       }
       // Target is coarser level of aggregation. Generate an aggregate.
       final ImmutableMultimap.Builder<Integer, Integer> rewritingMappingB =
-          ImmutableMultimap.builder();
+          ImmutableListMultimap.builder();
       final ImmutableBitSet.Builder groupSetB = ImmutableBitSet.builder();
       for (int i = 0; i < queryAggregate.getGroupCount(); i++) {
         final int targetIdx = aggregateMapping.getTargetOpt(i);
@@ -783,7 +785,7 @@ private static int find(RelNode rel, int ref) {
       BiMap<RelTableRef, RelTableRef> tableMapping,
       EquivalenceClasses sourceEC,
       List<RexNode> additionalExprs) {
-    Preconditions.checkArgument(additionalExprs.isEmpty());
+    checkArgument(additionalExprs.isEmpty());
     Multimap<Integer, Integer> m = ArrayListMultimap.create();
     Map<RexTableInputRef, Set<RexTableInputRef>> equivalenceClassesMap =
         sourceEC.getEquivalenceClassesMap();
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java
index b3227dcda..ab1767247 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java
@@ -44,6 +44,8 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Materialized view rewriting for join.
  *
@@ -281,17 +283,12 @@ public abstract class MaterializedViewJoinRule<C extends MaterializedViewRule.Co
         // Bail out
         return null;
       }
-      if (lineages.size() != 1) {
-        throw new IllegalStateException(
-            "We only support project - filter - join, "
-                + "thus expression lineage should map to a single expression, got: '"
-                + lineages
-                + "' for expr '"
-                + expr
-                + "' in node '"
-                + node
-                + "'");
-      }
+      checkState(
+          lineages.size() == 1,
+          "We only support project - filter - join, thus expression lineage should map to a single expression, got: '%s' for expr '%s' in node '%s'",
+          lineages,
+          expr,
+          node);
       // Rewrite expr. Take first element from the corresponding equivalence class
       // (no need to swap the table references following the table mapping)
       exprsLineage.add(
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
index 8f4171db8..7f2212595 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
@@ -68,7 +68,6 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -77,8 +76,11 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Collections.disjoint;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -869,7 +871,7 @@ && castNonNull(sourceEC.getEquivalenceClassesMap().get(uniqueKeyColumnRef))
 
     // After removing them, we check whether all the remaining tables in the graph
     // are tables present in the query: if they are, we can try to rewrite
-    if (!Collections.disjoint(graph.vertexSet(), extraTableRefs)) {
+    if (!disjoint(graph.vertexSet(), extraTableRefs)) {
       return false;
     }
     return true;
@@ -1128,17 +1130,12 @@ protected NodeLineage generateSwapTableColumnReferencesLineage(
         // Next expression
         continue;
       }
-      if (lineages.size() != 1) {
-        throw new IllegalStateException(
-            "We only support project - filter - join, "
-                + "thus expression lineage should map to a single expression, got: '"
-                + lineages
-                + "' for expr '"
-                + expr
-                + "' in node '"
-                + node
-                + "'");
-      }
+      checkState(
+          lineages.size() == 1,
+          "We only support project - filter - join, thus expression lineage should map to a single expression, got: '%s' for expr '%s' in node '%s'",
+          lineages,
+          expr,
+          node);
       // Rewrite expr. First we swap the table references following the table
       // mapping, then we take first element from the corresponding equivalence class
       final RexNode e =
@@ -1172,17 +1169,12 @@ protected NodeLineage generateSwapColumnTableReferencesLineage(
         // Next expression
         continue;
       }
-      if (lineages.size() != 1) {
-        throw new IllegalStateException(
-            "We only support project - filter - join, "
-                + "thus expression lineage should map to a single expression, got: '"
-                + lineages
-                + "' for expr '"
-                + expr
-                + "' in node '"
-                + node
-                + "'");
-      }
+      checkState(
+          lineages.size() == 1,
+          "We only support project - filter - join, thus expression lineage should map to a single expression, got: '%s' for expr '%s' in node '%s'",
+          lineages,
+          expr,
+          node);
       // Rewrite expr. First we take first element from the corresponding
       // equivalence class, then we swap the table references following the
       // table mapping
@@ -1406,7 +1398,7 @@ protected void addEquivalenceClass(RexTableInputRef p1, RexTableInputRef p2) {
 
     protected Map<RexTableInputRef, Set<RexTableInputRef>> getEquivalenceClassesMap() {
       if (cacheEquivalenceClassesMap == null) {
-        cacheEquivalenceClassesMap = ImmutableMap.copyOf(nodeToEquivalenceClass);
+        cacheEquivalenceClassesMap = nodeToEquivalenceClass;
       }
       return cacheEquivalenceClassesMap;
     }
@@ -1416,7 +1408,7 @@ protected List<Set<RexTableInputRef>> getEquivalenceClasses() {
         Set<RexTableInputRef> visited = new HashSet<>();
         ImmutableList.Builder<Set<RexTableInputRef>> builder = ImmutableList.builder();
         for (Set<RexTableInputRef> set : nodeToEquivalenceClass.values()) {
-          if (Collections.disjoint(visited, set)) {
+          if (disjoint(visited, set)) {
             builder.add(set);
             visited.addAll(set);
           }
@@ -1445,8 +1437,8 @@ protected static class NodeLineage {
 
     private NodeLineage(
         Map<RexNode, Integer> exprsLineage, Map<RexNode, Integer> exprsLineageLosslessCasts) {
-      this.exprsLineage = ImmutableMap.copyOf(exprsLineage);
-      this.exprsLineageLosslessCasts = ImmutableMap.copyOf(exprsLineageLosslessCasts);
+      this.exprsLineage = exprsLineage;
+      this.exprsLineageLosslessCasts = exprsLineageLosslessCasts;
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java b/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java
index e2f91a12c..a6e897848 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java
@@ -40,7 +40,7 @@ public class RelCrossType extends RelDataTypeImpl {
   public RelCrossType(List<RelDataType> types, List<RelDataTypeField> fields) {
     super(fields);
     this.types = ImmutableList.copyOf(types);
-    assert types.size() >= 1;
+    assert !types.isEmpty();
     for (RelDataType type : types) {
       assert !(type instanceof RelCrossType);
     }
@@ -71,7 +71,7 @@ public List<RelDataType> getTypes() {
       if (withDetail) {
         sb.append(type.e.getFullTypeString());
       } else {
-        sb.append(type.e.toString());
+        sb.append(type.e);
       }
     }
     sb.append(")");
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
index c336ad4dc..365af6d7a 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactory.java
@@ -31,7 +31,8 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * RelDataTypeFactory is a factory for datatype descriptors. It defines methods for instantiating
@@ -408,7 +409,7 @@ class Builder {
 
     /** Creates a Builder with the given type factory. */
     public Builder(RelDataTypeFactory typeFactory) {
-      this.typeFactory = Objects.requireNonNull(typeFactory, "typeFactory");
+      this.typeFactory = requireNonNull(typeFactory, "typeFactory");
     }
 
     /**
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
index 1ee79cc60..af4e4dba4 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
@@ -152,8 +152,8 @@ private RelDataType createStructType(
     return canonize(kind, fieldNameList, typeList, nullable);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelDataType createStructType(final RelDataTypeFactory.FieldInfo fieldInfo) {
+  @Override @SuppressWarnings("deprecation")
+  public RelDataType createStructType(final RelDataTypeFactory.FieldInfo fieldInfo) {
     return canonize(
         StructKind.FULLY_QUALIFIED,
         new AbstractList<String>() {
@@ -191,7 +191,7 @@ private RelDataType createStructType(
       List<RelDataType> types, SqlTypeMappingRule mappingRule) {
     requireNonNull(types, "types");
     requireNonNull(mappingRule, "mappingRule");
-    checkArgument(types.size() >= 1, "types.size >= 1");
+    checkArgument(!types.isEmpty(), "types.size >= 1");
     RelDataType type0 = types.get(0);
     if (type0.isStruct()) {
       return leastRestrictiveStructuredType(types);
@@ -547,8 +547,8 @@ private RelDataType decimalOf2(RelDataType type) {
     return Util.getDefaultCharset();
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public FieldInfoBuilder builder() {
+  @Override @SuppressWarnings("deprecation")
+  public FieldInfoBuilder builder() {
     return new FieldInfoBuilder(this);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java
index 9df8a3de7..976d61a53 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java
@@ -38,6 +38,8 @@
 import java.util.Map;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -90,10 +92,11 @@ protected RelDataTypeImpl() {
 
   @Override public @Nullable RelDataTypeField getField(
       String fieldName, boolean caseSensitive, boolean elideRecord) {
-    if (fieldList == null) {
-      throw new IllegalStateException(
-          "Trying to access field " + fieldName + " in a type with no fields: " + this);
-    }
+    checkState(
+        fieldList != null,
+        "Trying to access field %s in a type with no fields: %s",
+        fieldName,
+        this);
     final Map<String, RelDataTypeField> fieldMap = getFieldMap();
     if (caseSensitive && fieldMap != null) {
       RelDataTypeField field = fieldMap.get(fieldName);
@@ -123,7 +126,7 @@ protected RelDataTypeImpl() {
       }
     }
     // Extra field
-    if (fieldList.size() > 0) {
+    if (!fieldList.isEmpty()) {
       final RelDataTypeField lastField = Iterables.getLast(fieldList);
       if (lastField.getName().equals("_extra")) {
         return new RelDataTypeFieldImpl(fieldName, -1, lastField.getType());
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
index 993b47594..1eedee934 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
@@ -224,9 +224,7 @@ default boolean shouldUseDoubleMultiplication(
         precision = Math.min(precision, getMaxNumericPrecision());
 
         RelDataType ret;
-        ret = typeFactory.createSqlType(SqlTypeName.DECIMAL, precision, scale);
-
-        return ret;
+        return typeFactory.createSqlType(SqlTypeName.DECIMAL, precision, scale);
       }
     }
 
@@ -288,9 +286,7 @@ default boolean shouldUseDoubleMultiplication(
         assert precision > 0;
 
         RelDataType ret;
-        ret = typeFactory.createSqlType(SqlTypeName.DECIMAL, precision, scale);
-
-        return ret;
+        return typeFactory.createSqlType(SqlTypeName.DECIMAL, precision, scale);
       }
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java b/core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
index 75daabc51..123564214 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
@@ -19,8 +19,6 @@
 import org.apache.calcite.linq4j.Ord;
 import org.apache.calcite.sql.type.SqlTypeName;
 
-import com.google.common.collect.ImmutableMap;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.io.Serializable;
@@ -66,7 +64,7 @@ public RelRecordType(StructKind kind, List<RelDataTypeField> fields, boolean nul
           map.putIfAbsent("", f);
         }
       }
-      this.fieldNameMap = ImmutableMap.copyOf(map);
+      this.fieldNameMap = map;
     } else {
       this.fieldNameMap = null;
     }
@@ -136,7 +134,7 @@ public RelRecordType(List<RelDataTypeField> fields) {
       if (withDetail) {
         sb.append(field.getType().getFullTypeString());
       } else {
-        sb.append(field.getType().toString());
+        sb.append(field.getType());
       }
       sb.append(" ");
       sb.append(field.getName());
diff --git a/core/src/main/java/org/apache/calcite/rel/type/TimeFrameSet.java b/core/src/main/java/org/apache/calcite/rel/type/TimeFrameSet.java
index b214ed245..fb1929e09 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/TimeFrameSet.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/TimeFrameSet.java
@@ -35,6 +35,8 @@
 import java.util.NavigableMap;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.avatica.util.DateTimeUtils.MILLIS_PER_DAY;
 
 import static java.lang.Math.floorDiv;
@@ -82,9 +84,7 @@ public static Builder builder() {
    */
   public TimeFrame get(String name) {
     TimeFrame timeFrame = getOpt(name);
-    if (timeFrame == null) {
-      throw new IllegalArgumentException("unknown frame: " + name);
-    }
+    checkArgument(timeFrame != null, "unknown frame: %s", name);
     return timeFrame;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/type/TimeFrames.java b/core/src/main/java/org/apache/calcite/rel/type/TimeFrames.java
index c758478f5..b08567ee9 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/TimeFrames.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/TimeFrames.java
@@ -27,6 +27,7 @@
 import org.apache.commons.math3.fraction.BigFraction;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Iterables;
@@ -43,6 +44,8 @@
 import java.util.Set;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.avatica.util.DateTimeUtils.EPOCH_JULIAN;
 
 import static java.lang.Math.floorDiv;
@@ -241,7 +244,7 @@ static class BuilderImpl implements TimeFrameSet.Builder {
     final MonotonicSupplier<TimeFrameSet> frameSetSupplier = new MonotonicSupplier<>();
     final Map<String, TimeFrameImpl> map = new LinkedHashMap<>();
     final ImmutableMultimap.Builder<TimeFrameImpl, TimeFrameImpl> rollupList =
-        ImmutableMultimap.builder();
+        ImmutableListMultimap.builder();
 
     @Override public TimeFrameSet build() {
       final TimeFrameSet frameSet = new TimeFrameSet(ImmutableMap.copyOf(map), rollupList.build());
@@ -262,9 +265,7 @@ static BigInteger toBigInteger(Number number) {
     /** Returns the time frame with the given name, or throws {@link IllegalArgumentException}. */
     TimeFrameImpl getFrame(String name) {
       final TimeFrameImpl timeFrame = map.get(name);
-      if (timeFrame == null) {
-        throw new IllegalArgumentException("unknown frame: " + name);
-      }
+      checkArgument(timeFrame != null, "unknown frame: %s", name);
       return timeFrame;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rex/LogicVisitor.java b/core/src/main/java/org/apache/calcite/rex/LogicVisitor.java
index a8d94657c..803efe2d8 100644
--- a/core/src/main/java/org/apache/calcite/rex/LogicVisitor.java
+++ b/core/src/main/java/org/apache/calcite/rex/LogicVisitor.java
@@ -23,11 +23,11 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
 
+import static java.util.Collections.replaceAll;
 import static java.util.Objects.requireNonNull;
 
 /** Visitor pattern for traversing a tree of {@link RexNode} objects. */
@@ -74,7 +74,7 @@ public static void collect(RexNode node, RexNode seek, Logic logic, List<Logic>
     node.accept(new LogicVisitor(seek, logicList), logic);
     // Convert FALSE (which can only exist within LogicVisitor) to
     // UNKNOWN_AS_TRUE.
-    Collections.replaceAll(logicList, Logic.FALSE, Logic.UNKNOWN_AS_TRUE);
+    replaceAll(logicList, Logic.FALSE, Logic.UNKNOWN_AS_TRUE);
   }
 
   @Override public @Nullable Logic visitCall(RexCall call, @Nullable Logic logic) {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java b/core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java
index f76043603..fd1ab5a45 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java
@@ -69,8 +69,8 @@ private static List<Comparable> getComparables(RexNode variable) {
         break;
       case INTEGER:
         values.add(BigDecimal.valueOf(-1L));
-        values.add(BigDecimal.valueOf(0L));
-        values.add(BigDecimal.valueOf(1L));
+        values.add(BigDecimal.ZERO);
+        values.add(BigDecimal.ONE);
         values.add(BigDecimal.valueOf(1_000_000L));
         break;
       case DECIMAL:
diff --git a/core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java b/core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java
index cd1947b13..d71b3912b 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.rex;
 
-import com.google.common.collect.ImmutableList;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -69,7 +67,7 @@ default void visitList(Iterable<? extends RexNode> exprs, P arg, List<R> out) {
   default List<R> visitList(Iterable<? extends RexNode> exprs, P arg) {
     final List<R> out = new ArrayList<>();
     visitList(exprs, arg, out);
-    return ImmutableList.copyOf(out);
+    return out;
   }
 
   /** Visits a list of expressions. */
diff --git a/core/src/main/java/org/apache/calcite/rex/RexBuilder.java b/core/src/main/java/org/apache/calcite/rex/RexBuilder.java
index d8844924d..d23f54c24 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexBuilder.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexBuilder.java
@@ -51,7 +51,6 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableRangeSet;
 import com.google.common.collect.Range;
@@ -74,12 +73,14 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.function.IntPredicate;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Util.verifyNotNull;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Factory for row expressions.
@@ -319,8 +320,7 @@ public RexNode addAggCall(
       List<AggregateCall> aggCalls,
       Map<AggregateCall, RexNode> aggCallMapping,
       final @Nullable List<RelDataType> aggArgTypes) {
-    Preconditions.checkArgument(
-        !indicator, "indicator is deprecated, use GROUPING function instead");
+    checkArgument(!indicator, "indicator is deprecated, use GROUPING function instead");
     return addAggCall(aggCall, groupCount, aggCalls, aggCallMapping, aggArgTypes);
   }
 
@@ -399,7 +399,7 @@ public RexNode makeOver(
               makeNullLiteral(type));
     }
     if (!allowPartial) {
-      Preconditions.checkArgument(rows, "DISALLOW PARTIAL over RANGE");
+      checkArgument(rows, "DISALLOW PARTIAL over RANGE");
       final RelDataType bigintType = typeFactory.createSqlType(SqlTypeName.BIGINT);
       // todo: read bound
       result =
@@ -937,10 +937,11 @@ protected RexLiteral makeLiteral(@Nullable Comparable o, RelDataType type, SqlTy
       default:
         break;
     }
-    if (typeName == SqlTypeName.DECIMAL && !SqlTypeUtil.isValidDecimalValue((BigDecimal) o, type)) {
-      throw new IllegalArgumentException(
-          "Cannot convert " + o + " to " + type + " due to overflow");
-    }
+    checkArgument(
+        typeName != SqlTypeName.DECIMAL || SqlTypeUtil.isValidDecimalValue((BigDecimal) o, type),
+        "Cannot convert %s to %s due to overflow",
+        o,
+        type);
     return new RexLiteral(o, type, typeName);
   }
 
@@ -1240,8 +1241,7 @@ public RexNode makeIn(RexNode arg, List<? extends RexNode> ranges) {
     if (areAssignable(arg, ranges)) {
       final Sarg sarg = toSarg(Comparable.class, ranges, RexUnknownAs.UNKNOWN);
       if (sarg != null) {
-        final List<RelDataType> types =
-            ranges.stream().map(RexNode::getType).collect(Collectors.toList());
+        final List<RelDataType> types = ranges.stream().map(RexNode::getType).collect(toList());
         RelDataType sargType =
             requireNonNull(
                 typeFactory.leastRestrictive(types),
@@ -1631,7 +1631,7 @@ public RexNode makeLiteral(
                 "%s is not compatible with %s, try to use makeExactLiteral",
                 o.getClass().getCanonicalName(),
                 type.getSqlTypeName());
-        return new BigDecimal(((Number) o).longValue());
+        return BigDecimal.valueOf(((Number) o).longValue());
       case FLOAT:
         if (o instanceof BigDecimal) {
           return o;
diff --git a/core/src/main/java/org/apache/calcite/rex/RexCall.java b/core/src/main/java/org/apache/calcite/rex/RexCall.java
index ed89832d5..627c1b5d1 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexCall.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexCall.java
@@ -147,7 +147,7 @@ private static String computeDigest(RexLiteral literal, RexDigestIncludeType inc
 
   protected String computeDigest(boolean withType) {
     final StringBuilder sb = new StringBuilder(op.getName());
-    if ((operands.size() == 0) && (op.getSyntax() == SqlSyntax.FUNCTION_ID)) {
+    if (operands.isEmpty() && (op.getSyntax() == SqlSyntax.FUNCTION_ID)) {
       // Don't print params for empty arg list. For example, we want
       // "SYSTEM_USER", not "SYSTEM_USER()".
     } else {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexCallBinding.java b/core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
index 44c6392a9..540dcd707 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
@@ -55,7 +55,7 @@ public RexCallBinding(
       List<RelCollation> inputCollations) {
     super(typeFactory, sqlOperator);
     this.operands = ImmutableList.copyOf(operands);
-    this.inputCollations = ImmutableList.copyOf(inputCollations);
+    this.inputCollations = inputCollations;
   }
 
   /** Creates a binding of the appropriate type. */
@@ -84,13 +84,13 @@ public static RexCallBinding create(
 
   // ~ Methods ----------------------------------------------------------------
 
-  @SuppressWarnings("deprecation")
-  @Override public @Nullable String getStringLiteralOperand(int ordinal) {
+  @Override @SuppressWarnings("deprecation")
+  public @Nullable String getStringLiteralOperand(int ordinal) {
     return RexLiteral.stringValue(operands.get(ordinal));
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public int getIntLiteralOperand(int ordinal) {
+  @Override @SuppressWarnings("deprecation")
+  public int getIntLiteralOperand(int ordinal) {
     return RexLiteral.intValue(operands.get(ordinal));
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rex/RexCorrelVariable.java b/core/src/main/java/org/apache/calcite/rex/RexCorrelVariable.java
index a1a31ccb1..b9b07a60d 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexCorrelVariable.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexCorrelVariable.java
@@ -24,6 +24,8 @@
 
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Reference to the current row of a correlating relational expression.
  *
@@ -38,7 +40,7 @@ public class RexCorrelVariable extends RexVariable {
 
   RexCorrelVariable(CorrelationId id, RelDataType type) {
     super(id.getName(), type);
-    this.id = Objects.requireNonNull(id, "id");
+    this.id = requireNonNull(id, "id");
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java b/core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java
index 22864d5d5..4da1d9f44 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java
@@ -20,10 +20,10 @@
 import org.apache.calcite.rel.type.RelDataTypeField;
 import org.apache.calcite.sql.SqlKind;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Access to a field of a row-expression.
  *
@@ -72,11 +72,13 @@ public class RexFieldAccess extends RexNode {
   private static void checkValid(RexNode expr, RelDataTypeField field) {
     RelDataType exprType = expr.getType();
     int fieldIdx = field.getIndex();
-    Preconditions.checkArgument(
+    checkArgument(
         fieldIdx >= 0
             && fieldIdx < exprType.getFieldList().size()
             && exprType.getFieldList().get(fieldIdx).equals(field),
-        "Field " + field + " does not exist for expression " + expr);
+        "Field %s does not exist for expression %s",
+        field,
+        expr);
   }
 
   public RelDataTypeField getField() {
@@ -119,7 +121,6 @@ public RexNode getReferenceExpr() {
 
   @Override public int hashCode() {
     int result = expr.hashCode();
-    result = 31 * result + field.hashCode();
-    return result;
+    return 31 * result + field.hashCode();
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/rex/RexInterpreter.java b/core/src/main/java/org/apache/calcite/rex/RexInterpreter.java
index 279f02755..ad616c9e3 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexInterpreter.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexInterpreter.java
@@ -31,19 +31,19 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.Util;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.RangeSet;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.Comparator;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.function.IntPredicate;
 
+import static java.util.Comparator.naturalOrder;
+
 /**
  * Evaluates {@link RexNode} expressions.
  *
@@ -96,7 +96,7 @@ public class RexInterpreter implements RexVisitor<Comparable> {
    * @param environment Values of certain expressions (usually {@link RexInputRef}s)
    */
   private RexInterpreter(Map<RexNode, Comparable> environment) {
-    this.environment = ImmutableMap.copyOf(environment);
+    this.environment = environment;
   }
 
   /** Evaluates an expression in an environment. */
@@ -190,9 +190,9 @@ private Comparable getOrUnbound(RexNode e) {
       case LESS_THAN_OR_EQUAL:
         return compare(values, c -> c <= 0);
       case AND:
-        return values.stream().map(Truthy::of).min(Comparator.naturalOrder()).get().toComparable();
+        return values.stream().map(Truthy::of).min(naturalOrder()).orElseThrow().toComparable();
       case OR:
-        return values.stream().map(Truthy::of).max(Comparator.naturalOrder()).get().toComparable();
+        return values.stream().map(Truthy::of).max(naturalOrder()).orElseThrow().toComparable();
       case NOT:
         return not(values.get(0));
       case CASE:
@@ -416,8 +416,8 @@ private static BigDecimal number(Comparable comparable) {
             : comparable instanceof Long
                     || comparable instanceof Integer
                     || comparable instanceof Short
-                ? new BigDecimal(((Number) comparable).longValue())
-                : new BigDecimal(((Number) comparable).doubleValue());
+                ? BigDecimal.valueOf(((Number) comparable).longValue())
+                : BigDecimal.valueOf(((Number) comparable).doubleValue());
   }
 
   private static Comparable compare(List<Comparable> values, IntPredicate p) {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexLiteral.java b/core/src/main/java/org/apache/calcite/rex/RexLiteral.java
index 08bbfa16e..ead55ecde 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexLiteral.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexLiteral.java
@@ -42,7 +42,6 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.initialization.qual.UnknownInitialization;
@@ -64,6 +63,8 @@
 import java.util.Objects;
 import java.util.TimeZone;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.rel.type.RelDataTypeImpl.NON_NULLABLE_SUFFIX;
 
@@ -216,9 +217,9 @@ public class RexLiteral extends RexNode {
     this.value = value;
     this.type = requireNonNull(type, "type");
     this.typeName = requireNonNull(typeName, "typeName");
-    Preconditions.checkArgument(valueMatchesType(value, typeName, true));
-    Preconditions.checkArgument((value == null) == type.isNullable());
-    Preconditions.checkArgument(typeName != SqlTypeName.ANY);
+    checkArgument(valueMatchesType(value, typeName, true));
+    checkArgument((value == null) == type.isNullable());
+    checkArgument(typeName != SqlTypeName.ANY);
     this.digest = computeDigest(RexDigestIncludeType.OPTIONAL);
   }
 
@@ -255,7 +256,7 @@ public class RexLiteral extends RexNode {
    * @param includeType whether the digest should include type or not
    * @return digest
    */
-  @RequiresNonNull({"typeName", "type"})
+  @RequiresNonNull({"type", "typeName"})
   public final String computeDigest(
       @UnknownInitialization RexLiteral this, RexDigestIncludeType includeType) {
     if (includeType == RexDigestIncludeType.OPTIONAL) {
@@ -630,11 +631,11 @@ private static void appendAsJava(
         break;
       case BOOLEAN:
         assert value instanceof Boolean;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case DECIMAL:
         assert value instanceof BigDecimal;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case DOUBLE:
         assert value instanceof BigDecimal;
@@ -643,7 +644,7 @@ private static void appendAsJava(
       case BIGINT:
         assert value instanceof BigDecimal;
         long narrowLong = ((BigDecimal) value).longValue();
-        sb.append(String.valueOf(narrowLong));
+        sb.append(narrowLong);
         sb.append('L');
         break;
       case BINARY:
@@ -664,22 +665,22 @@ private static void appendAsJava(
       case SYMBOL:
         assert value instanceof Enum;
         sb.append("FLAG(");
-        sb.append(value.toString());
+        sb.append(value);
         sb.append(")");
         break;
       case DATE:
         assert value instanceof DateString;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case TIME:
       case TIME_WITH_LOCAL_TIME_ZONE:
         assert value instanceof TimeString;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case TIMESTAMP:
       case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
         assert value instanceof TimestampString;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case INTERVAL_YEAR:
       case INTERVAL_YEAR_MONTH:
@@ -695,7 +696,7 @@ private static void appendAsJava(
       case INTERVAL_MINUTE_SECOND:
       case INTERVAL_SECOND:
         assert value instanceof BigDecimal;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case MULTISET:
       case ROW:
diff --git a/core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java b/core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java
index af7551b07..30bd525f0 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java
@@ -87,7 +87,7 @@ public static boolean containsMixing(RexNode node) {
    *     expression <em>is</em> a multiset.
    */
   public static boolean containsMultiset(final RexNode node, boolean deep) {
-    return null != findFirstMultiset(node, deep);
+    return findFirstMultiset(node, deep) != null;
   }
 
   /** Returns whether a list of expressions contains a multiset. */
@@ -131,7 +131,7 @@ public static boolean isMultisetCast(RexCall call) {
     RexCall firstOne = null;
     for (SqlOperator op : MULTISET_OPERATORS) {
       firstOne = RexUtil.findOperatorCall(op, call);
-      if (null != firstOne) {
+      if (firstOne != null) {
         if (firstOne.getOperator().equals(SqlStdOperatorTable.CAST) && !isMultisetCast(firstOne)) {
           firstOne = null;
           continue;
diff --git a/core/src/main/java/org/apache/calcite/rex/RexOver.java b/core/src/main/java/org/apache/calcite/rex/RexOver.java
index 9fc2809d4..4dd1480f7 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexOver.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexOver.java
@@ -22,13 +22,15 @@
 import org.apache.calcite.util.ControlFlowException;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /** Call to an aggregate function over a window. */
 public class RexOver extends RexCall {
   private static final Finder FINDER = new Finder();
@@ -67,8 +69,8 @@ public class RexOver extends RexCall {
       boolean distinct,
       boolean ignoreNulls) {
     super(type, op, operands);
-    Preconditions.checkArgument(op.isAggregator());
-    this.window = Objects.requireNonNull(window, "window");
+    checkArgument(op.isAggregator());
+    this.window = requireNonNull(window, "window");
     this.distinct = distinct;
     this.ignoreNulls = ignoreNulls;
   }
diff --git a/core/src/main/java/org/apache/calcite/rex/RexProgram.java b/core/src/main/java/org/apache/calcite/rex/RexProgram.java
index 2a57ef326..94df0a8b3 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexProgram.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexProgram.java
@@ -57,6 +57,8 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -117,7 +119,7 @@ public RexProgram(
       RelDataType outputRowType) {
     this.inputRowType = inputRowType;
     this.exprs = ImmutableList.copyOf(exprs);
-    this.projects = ImmutableList.copyOf(projects);
+    this.projects = projects;
     this.condition = condition;
     this.outputRowType = outputRowType;
     assert isValid(Litmus.THROW, null);
@@ -348,11 +350,12 @@ public static RexProgram createIdentity(RelDataType rowType) {
    * output fields.
    */
   public static RexProgram createIdentity(RelDataType rowType, RelDataType outputRowType) {
-    if (rowType != outputRowType
-        && !Pair.right(rowType.getFieldList()).equals(Pair.right(outputRowType.getFieldList()))) {
-      throw new IllegalArgumentException(
-          "field type mismatch: " + rowType + " vs. " + outputRowType);
-    }
+    checkArgument(
+        rowType == outputRowType
+            || Pair.right(rowType.getFieldList()).equals(Pair.right(outputRowType.getFieldList())),
+        "field type mismatch: %s vs. %s",
+        rowType,
+        outputRowType);
     final List<RelDataTypeField> fields = rowType.getFieldList();
     final List<RexLocalRef> projectRefs = new ArrayList<>();
     final List<RexInputRef> refs = new ArrayList<>();
diff --git a/core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java b/core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
index 9dd51748c..f25e2b8b2 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
@@ -920,8 +920,7 @@ protected RegisterInputShuttle(boolean valid) {
 
       // Return a reference to the N'th expression, which should be
       // equivalent.
-      final RexLocalRef ref = localRefList.get(index);
-      return ref;
+      return localRefList.get(index);
     }
 
     @Override public RexNode visitLocalRef(RexLocalRef local) {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexSimplify.java b/core/src/main/java/org/apache/calcite/rex/RexSimplify.java
index 75848ee6c..0a5fba4aa 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexSimplify.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexSimplify.java
@@ -56,7 +56,6 @@
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -70,6 +69,7 @@
 import static org.apache.calcite.rex.RexUnknownAs.TRUE;
 import static org.apache.calcite.rex.RexUnknownAs.UNKNOWN;
 
+import static java.util.Collections.disjoint;
 import static java.util.Objects.requireNonNull;
 
 /** Context required to simplify a row-expression. */
@@ -1413,7 +1413,7 @@ static boolean isSafeExpression(RexNode r) {
     // but not interfere with the normal simplification recursion
     List<CaseBranch> branches = new ArrayList<>();
     for (CaseBranch branch : inputBranches) {
-      if ((branches.size() > 0 && !isSafeExpression(branch.cond))
+      if ((!branches.isEmpty() && !isSafeExpression(branch.cond))
           || !isSafeExpression(branch.value)) {
         return null;
       }
@@ -1427,8 +1427,7 @@ static boolean isSafeExpression(RexNode r) {
       branches.add(new CaseBranch(cond, value));
     }
 
-    result = simplifyBooleanCaseGeneric(rexBuilder, branches);
-    return result;
+    return simplifyBooleanCaseGeneric(rexBuilder, branches);
   }
 
   /**
@@ -1796,7 +1795,7 @@ private <C extends Comparable<C>> RexNode simplifyAnd2ForUnknownAsFalse(
     // If one column should be null and is in a comparison predicate,
     // it is not satisfiable.
     // Example. IS NULL(x) AND x < 5  - not satisfiable
-    if (!Collections.disjoint(nullOperands, strongOperands)) {
+    if (!disjoint(nullOperands, strongOperands)) {
       return rexBuilder.makeLiteral(false);
     }
     // Remove not necessary IS NOT NULL expressions.
@@ -3064,7 +3063,7 @@ void addRange(Range<Comparable> range, RelDataType type) {
       nullAs = nullAs.or(UNKNOWN);
     }
 
-    @SuppressWarnings({"UnstableApiUsage", "rawtypes", "unchecked"})
+    @SuppressWarnings({"rawtypes", "unchecked", "UnstableApiUsage"})
     void addSarg(Sarg sarg, boolean negate, RelDataType type) {
       final RangeSet r;
       final RexUnknownAs nullAs;
diff --git a/core/src/main/java/org/apache/calcite/rex/RexSlot.java b/core/src/main/java/org/apache/calcite/rex/RexSlot.java
index 38e0577c3..9c1de2916 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexSlot.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexSlot.java
@@ -21,6 +21,8 @@
 import java.util.AbstractList;
 import java.util.concurrent.CopyOnWriteArrayList;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Abstract base class for {@link RexInputRef} and {@link RexLocalRef}. */
 public abstract class RexSlot extends RexVariable {
   // ~ Instance fields --------------------------------------------------------
@@ -78,9 +80,7 @@ private static AbstractList<String> fromTo(
         try {
           return super.get(index);
         } catch (IndexOutOfBoundsException e) {
-          if (index < 0) {
-            throw new IllegalArgumentException();
-          }
+          checkArgument(index >= 0);
           // Double-checked locking, but safe because CopyOnWriteArrayList.array
           // is marked volatile, and size() uses array.length.
           synchronized (this) {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexSubQuery.java b/core/src/main/java/org/apache/calcite/rex/RexSubQuery.java
index 55883f5df..635e35aa7 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexSubQuery.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexSubQuery.java
@@ -28,7 +28,6 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.sql.type.SqlTypeUtil;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -36,6 +35,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Scalar expression that represents an IN, EXISTS or scalar sub-query. */
 public class RexSubQuery extends RexCall {
   public final RelNode rel;
@@ -107,9 +108,7 @@ public static RexSubQuery unique(RelNode rel) {
   /** Creates a scalar sub-query. */
   public static RexSubQuery scalar(RelNode rel) {
     final List<RelDataTypeField> fieldList = rel.getRowType().getFieldList();
-    if (fieldList.size() != 1) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(fieldList.size() == 1);
     final RelDataTypeFactory typeFactory = rel.getCluster().getTypeFactory();
     final RelDataType type =
         typeFactory.createTypeWithNullability(fieldList.get(0).getType(), true);
@@ -140,7 +139,7 @@ public static RexSubQuery multiset(RelNode rel) {
   public static RexSubQuery map(RelNode rel) {
     final RelDataTypeFactory typeFactory = rel.getCluster().getTypeFactory();
     final RelDataType rowType = rel.getRowType();
-    Preconditions.checkArgument(
+    checkArgument(
         rowType.getFieldCount() == 2,
         "MAP requires exactly two fields, got %s; row type %s",
         rowType.getFieldCount(),
diff --git a/core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java b/core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java
index 79504fe3f..d142ba063 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java
@@ -49,7 +49,7 @@ public class RexTableInputRef extends RexInputRef {
   private RexTableInputRef(RelTableRef tableRef, int index, RelDataType type) {
     super(index, type);
     this.tableRef = tableRef;
-    this.digest = tableRef.toString() + ".$" + index;
+    this.digest = tableRef + ".$" + index;
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/rex/RexTransformer.java b/core/src/main/java/org/apache/calcite/rex/RexTransformer.java
index 1851d9089..fd3c7b8df 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexTransformer.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexTransformer.java
@@ -105,7 +105,7 @@ private RexNode transformNullSemantics(RexNode node) {
 
     // Special case when we have a Literal, Parameter or Identifier directly
     // as an operand to IS TRUE or IS FALSE.
-    if (null != directlyUnderIs) {
+    if (directlyUnderIs != null) {
       RexCall call = (RexCall) node;
       assert isParentsCount > 0 : "Stack should not be empty";
       assert 1 == call.operands.size();
@@ -117,13 +117,11 @@ private RexNode transformNullSemantics(RexNode node) {
           RexNode notNullNode = rexBuilder.makeCall(SqlStdOperatorTable.IS_NOT_NULL, operand);
           RexNode boolNode = rexBuilder.makeLiteral(directlyUnderIs.booleanValue());
           RexNode eqNode = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operand, boolNode);
-          RexNode andBoolNode = rexBuilder.makeCall(SqlStdOperatorTable.AND, notNullNode, eqNode);
+          return rexBuilder.makeCall(SqlStdOperatorTable.AND, notNullNode, eqNode);
 
-          return andBoolNode;
         } else {
           RexNode boolNode = rexBuilder.makeLiteral(directlyUnderIs.booleanValue());
-          RexNode andBoolNode = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, node, boolNode);
-          return andBoolNode;
+          return rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, node, boolNode);
         }
       }
 
@@ -139,7 +137,7 @@ private RexNode transformNullSemantics(RexNode node) {
         operands.add(transformNullSemantics(operand));
       }
 
-      if (null != directlyUnderIs) {
+      if (directlyUnderIs != null) {
         isParentsCount--;
         directlyUnderIs = null;
         return operands.get(0);
@@ -163,19 +161,17 @@ private RexNode transformNullSemantics(RexNode node) {
         }
 
         RexNode intoFinalAnd = null;
-        if ((null != isNotNullOne) && (null != isNotNullTwo)) {
+        if (isNotNullOne != null && isNotNullTwo != null) {
           intoFinalAnd = rexBuilder.makeCall(SqlStdOperatorTable.AND, isNotNullOne, isNotNullTwo);
-        } else if (null != isNotNullOne) {
+        } else if (isNotNullOne != null) {
           intoFinalAnd = isNotNullOne;
-        } else if (null != isNotNullTwo) {
+        } else if (isNotNullTwo != null) {
           intoFinalAnd = isNotNullTwo;
         }
 
-        if (null != intoFinalAnd) {
-          RexNode andNullAndCheckNode =
-              rexBuilder.makeCall(
-                  SqlStdOperatorTable.AND, intoFinalAnd, call.clone(call.getType(), operands));
-          return andNullAndCheckNode;
+        if (intoFinalAnd != null) {
+          return rexBuilder.makeCall(
+              SqlStdOperatorTable.AND, intoFinalAnd, call.clone(call.getType(), operands));
         }
 
         // if come here no need to do anything
diff --git a/core/src/main/java/org/apache/calcite/rex/RexUtil.java b/core/src/main/java/org/apache/calcite/rex/RexUtil.java
index 443062a21..d462ba346 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexUtil.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexUtil.java
@@ -157,7 +157,7 @@ public static boolean isNullLiteral(RexNode node, boolean allowCast) {
     if (node instanceof RexLiteral) {
       RexLiteral literal = (RexLiteral) node;
       if (literal.getTypeName() == SqlTypeName.NULL) {
-        assert null == literal.getValue();
+        assert literal.getValue() == null;
         return true;
       } else {
         // We don't regard UNKNOWN -- SqlLiteral(null,Boolean) -- as
@@ -2154,8 +2154,8 @@ private static boolean containsTrue(Iterable<RexNode> nodes) {
    *
    * @deprecated Use {@link #not}
    */
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   public static com.google.common.base.Function<RexNode, RexNode> notFn(
       final RexBuilder rexBuilder) {
     return e -> not(rexBuilder, e);
diff --git a/core/src/main/java/org/apache/calcite/rex/RexVariable.java b/core/src/main/java/org/apache/calcite/rex/RexVariable.java
index 7bfda3169..8ea67179b 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexVariable.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexVariable.java
@@ -18,7 +18,7 @@
 
 import org.apache.calcite.rel.type.RelDataType;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** A row-expression which references a field. */
 public abstract class RexVariable extends RexNode {
@@ -30,9 +30,9 @@ public abstract class RexVariable extends RexNode {
   // ~ Constructors -----------------------------------------------------------
 
   protected RexVariable(String name, RelDataType type) {
-    this.name = Objects.requireNonNull(name, "name");
-    this.digest = Objects.requireNonNull(name, "name");
-    this.type = Objects.requireNonNull(type, "type");
+    this.name = requireNonNull(name, "name");
+    this.digest = requireNonNull(name, "name");
+    this.type = requireNonNull(type, "type");
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/rex/RexVisitor.java b/core/src/main/java/org/apache/calcite/rex/RexVisitor.java
index c27f55758..0eaf1a33e 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexVisitor.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexVisitor.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.rex;
 
-import com.google.common.collect.ImmutableList;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -70,7 +68,7 @@ default void visitList(Iterable<? extends RexNode> exprs, List<R> out) {
   default List<R> visitList(Iterable<? extends RexNode> exprs) {
     final List<R> out = new ArrayList<>();
     visitList(exprs, out);
-    return ImmutableList.copyOf(out);
+    return out;
   }
 
   /** Visits a list of expressions. */
diff --git a/core/src/main/java/org/apache/calcite/rex/RexWindow.java b/core/src/main/java/org/apache/calcite/rex/RexWindow.java
index 8722b4cab..c8f21e1f2 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexWindow.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexWindow.java
@@ -18,13 +18,15 @@
 
 import org.apache.calcite.util.Pair;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Specification of the window of rows over which a {@link RexOver} windowed aggregate is evaluated.
@@ -72,12 +74,12 @@ public class RexWindow {
       boolean isRows) {
     this.partitionKeys = ImmutableList.copyOf(partitionKeys);
     this.orderKeys = ImmutableList.copyOf(orderKeys);
-    this.lowerBound = Objects.requireNonNull(lowerBound, "lowerBound");
-    this.upperBound = Objects.requireNonNull(upperBound, "upperBound");
+    this.lowerBound = requireNonNull(lowerBound, "lowerBound");
+    this.upperBound = requireNonNull(upperBound, "upperBound");
     this.isRows = isRows;
     this.nodeCount = computeCodeCount();
     this.digest = computeDigest();
-    Preconditions.checkArgument(
+    checkArgument(
         !(lowerBound.isUnbounded()
             && lowerBound.isPreceding()
             && upperBound.isUnbounded()
@@ -119,7 +121,7 @@ StringBuilder appendDigest(StringBuilder sb, boolean allowFraming) {
 
   private StringBuilder appendDigest_(StringBuilder sb, boolean allowFraming) {
     final int initialLength = sb.length();
-    if (partitionKeys.size() > 0) {
+    if (!partitionKeys.isEmpty()) {
       sb.append("PARTITION BY ");
       for (int i = 0; i < partitionKeys.size(); i++) {
         if (i > 0) {
@@ -128,7 +130,7 @@ private StringBuilder appendDigest_(StringBuilder sb, boolean allowFraming) {
         sb.append(partitionKeys.get(i));
       }
     }
-    if (orderKeys.size() > 0) {
+    if (!orderKeys.isEmpty()) {
       sb.append(sb.length() > initialLength ? " ORDER BY " : "ORDER BY ");
       for (int i = 0; i < orderKeys.size(); i++) {
         if (i > 0) {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexWindowBound.java b/core/src/main/java/org/apache/calcite/rex/RexWindowBound.java
index 819f4b4a9..2ab1fc6ce 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexWindowBound.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexWindowBound.java
@@ -40,8 +40,8 @@ public static RexWindowBound create(SqlNode node, RexNode rexNode) {
    *
    * @return if the bound is unbounded
    */
-  @Pure
   @EnsuresNonNullIf(expression = "getOffset()", result = false)
+  @Pure
   @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
   public boolean isUnbounded() {
     return false;
@@ -70,8 +70,8 @@ public boolean isFollowing() {
    *
    * @return if the bound is CURRENT ROW
    */
-  @Pure
   @EnsuresNonNullIf(expression = "getOffset()", result = false)
+  @Pure
   @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
   public boolean isCurrentRow() {
     return false;
diff --git a/core/src/main/java/org/apache/calcite/rex/RexWindowBounds.java b/core/src/main/java/org/apache/calcite/rex/RexWindowBounds.java
index 75e2fec46..9584324bc 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexWindowBounds.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexWindowBounds.java
@@ -26,6 +26,8 @@
 
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /** Helpers for {@link RexWindowBound}. */
 public final class RexWindowBounds {
   /** UNBOUNDED PRECEDING. */
@@ -138,8 +140,8 @@ private static class RexBoundedWindowBound extends RexWindowBound {
     private final RexNode offset;
 
     RexBoundedWindowBound(RexCall node) {
-      this.offset = Objects.requireNonNull(node.operands.get(0));
-      this.sqlKind = Objects.requireNonNull(node.getKind());
+      this.offset = requireNonNull(node.operands.get(0));
+      this.sqlKind = requireNonNull(node.getKind());
     }
 
     private RexBoundedWindowBound(SqlKind sqlKind, RexNode offset) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/AddPointOperation.java b/core/src/main/java/org/apache/calcite/runtime/AddPointOperation.java
index b69f1cb4f..896844b0b 100644
--- a/core/src/main/java/org/apache/calcite/runtime/AddPointOperation.java
+++ b/core/src/main/java/org/apache/calcite/runtime/AddPointOperation.java
@@ -20,6 +20,8 @@
 import org.locationtech.jts.geom.Geometry;
 import org.locationtech.jts.geom.util.GeometryEditor;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Geometry editor operation that adds a point to a geometry. */
 public class AddPointOperation extends GeometryEditor.CoordinateOperation {
 
@@ -33,9 +35,7 @@ public AddPointOperation(Geometry point, int index) {
   }
 
   @Override public Coordinate[] edit(Coordinate[] coordinates, Geometry geometry) {
-    if (index < 0 || index > coordinates.length) {
-      throw new IllegalArgumentException("Invalid index: " + index);
-    }
+    checkArgument(index >= 0 && index <= coordinates.length, "Invalid index: %s", index);
     Coordinate[] newCoordinates = new Coordinate[coordinates.length + 1];
     for (int i = 0; i < index; i++) {
       newCoordinates[i] = (Coordinate) coordinates[i].clone();
diff --git a/core/src/main/java/org/apache/calcite/runtime/ArrayComparator.java b/core/src/main/java/org/apache/calcite/runtime/ArrayComparator.java
index 2bc71dd7f..d7d6e124b 100644
--- a/core/src/main/java/org/apache/calcite/runtime/ArrayComparator.java
+++ b/core/src/main/java/org/apache/calcite/runtime/ArrayComparator.java
@@ -18,9 +18,10 @@
 
 import com.google.common.collect.Ordering;
 
-import java.util.Collections;
 import java.util.Comparator;
 
+import static java.util.Collections.reverseOrder;
+
 /** Compares arrays. */
 public class ArrayComparator implements Comparator<Object[]> {
   private final Comparator[] comparators;
@@ -37,7 +38,7 @@ private static Comparator[] comparators(boolean[] descendings) {
     Comparator[] comparators = new Comparator[descendings.length];
     for (int i = 0; i < descendings.length; i++) {
       boolean descending = descendings[i];
-      comparators[i] = descending ? Collections.reverseOrder() : Ordering.natural();
+      comparators[i] = descending ? reverseOrder() : Ordering.natural();
     }
     return comparators;
   }
diff --git a/core/src/main/java/org/apache/calcite/runtime/Automaton.java b/core/src/main/java/org/apache/calcite/runtime/Automaton.java
index d4f1a98f1..2f06ca897 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Automaton.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Automaton.java
@@ -25,6 +25,8 @@
 
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A nondeterministic finite-state automaton (NFA).
  *
@@ -49,11 +51,11 @@ public class Automaton {
       ImmutableList<SymbolTransition> transitions,
       ImmutableList<EpsilonTransition> epsilonTransitions,
       ImmutableList<String> symbolNames) {
-    this.startState = Objects.requireNonNull(startState, "startState");
-    this.endState = Objects.requireNonNull(endState, "endState");
-    this.transitions = Objects.requireNonNull(transitions, "transitions");
+    this.startState = requireNonNull(startState, "startState");
+    this.endState = requireNonNull(endState, "endState");
+    this.transitions = requireNonNull(transitions, "transitions");
     this.epsilonTransitions = epsilonTransitions;
-    this.symbolNames = Objects.requireNonNull(symbolNames, "symbolNames");
+    this.symbolNames = requireNonNull(symbolNames, "symbolNames");
   }
 
   /**
@@ -121,8 +123,8 @@ abstract static class Transition {
     final State toState;
 
     Transition(State fromState, State toState) {
-      this.fromState = Objects.requireNonNull(fromState, "fromState");
-      this.toState = Objects.requireNonNull(toState, "toState");
+      this.fromState = requireNonNull(fromState, "fromState");
+      this.toState = requireNonNull(toState, "toState");
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java b/core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java
index 291c6c5f4..fc4b21208 100644
--- a/core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java
+++ b/core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java
@@ -22,15 +22,17 @@
 import org.apache.calcite.runtime.Automaton.Transition;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.ArrayList;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Map.Entry.comparingByValue;
+import static java.util.Objects.requireNonNull;
 
 /** Builds a state-transition graph for deterministic finite automaton. */
 public class AutomatonBuilder {
@@ -109,7 +111,7 @@ public Automaton build() {
     // starting from zero.
     final ImmutableList<String> symbolNames =
         symbolIds.entrySet().stream()
-            .sorted(Comparator.comparingInt(Map.Entry::getValue))
+            .sorted(comparingByValue())
             .map(Map.Entry::getKey)
             .collect(Util.toImmutableList());
     return new Automaton(
@@ -122,7 +124,7 @@ public Automaton build() {
 
   /** Adds a symbol transition. */
   AutomatonBuilder symbol(State fromState, State toState, String name) {
-    Objects.requireNonNull(name, "name");
+    requireNonNull(name, "name");
     final int symbolId = symbolIds.computeIfAbsent(name, k -> symbolIds.size());
     transitionList.add(new SymbolTransition(fromState, toState, symbolId));
     return this;
@@ -210,9 +212,9 @@ AutomatonBuilder repeat(
     // fromState ---> state0 ---> state1 ---> state2 ---> state3 ---> toState
     //            e        pattern     pattern     pattern        e
     //
-    Preconditions.checkArgument(0 <= minRepeat);
-    Preconditions.checkArgument(minRepeat <= maxRepeat);
-    Preconditions.checkArgument(1 <= maxRepeat);
+    checkArgument(0 <= minRepeat);
+    checkArgument(minRepeat <= maxRepeat);
+    checkArgument(1 <= maxRepeat);
     State prevState = fromState;
     for (int i = 0; i <= maxRepeat; i++) {
       final State s = createState();
diff --git a/core/src/main/java/org/apache/calcite/runtime/BufferStyle.java b/core/src/main/java/org/apache/calcite/runtime/BufferStyle.java
index 0493d9c1f..a29adfb4e 100644
--- a/core/src/main/java/org/apache/calcite/runtime/BufferStyle.java
+++ b/core/src/main/java/org/apache/calcite/runtime/BufferStyle.java
@@ -16,10 +16,14 @@
  */
 package org.apache.calcite.runtime;
 
+import com.google.common.base.Strings;
+
 import org.locationtech.jts.operation.buffer.BufferParameters;
 
 import java.util.Locale;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** A parser for buffer styles as defined by PostGIS. */
 public class BufferStyle {
 
@@ -34,13 +38,11 @@ public class BufferStyle {
   public BufferStyle(String style) {
     String[] parameters = style.toLowerCase(Locale.ROOT).split(" ");
     for (String parameter : parameters) {
-      if (parameter == null || parameter.isEmpty()) {
+      if (Strings.isNullOrEmpty(parameter)) {
         continue;
       }
       String[] keyValue = parameter.split("=");
-      if (keyValue.length != 2) {
-        throw new IllegalArgumentException("Invalid buffer style: " + style);
-      }
+      checkArgument(keyValue.length == 2, "Invalid buffer style: %s", style);
       String key = keyValue[0];
       String value = keyValue[1];
       switch (key) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/CoordinateTransformer.java b/core/src/main/java/org/apache/calcite/runtime/CoordinateTransformer.java
index ee479cd22..605c53b18 100644
--- a/core/src/main/java/org/apache/calcite/runtime/CoordinateTransformer.java
+++ b/core/src/main/java/org/apache/calcite/runtime/CoordinateTransformer.java
@@ -22,8 +22,8 @@
 import org.locationtech.jts.geom.impl.CoordinateArraySequence;
 import org.locationtech.jts.geom.util.GeometryTransformer;
 
+import java.util.Arrays;
 import java.util.function.Function;
-import java.util.stream.Stream;
 
 /** Transforms the coordinates of a geometry. */
 public class CoordinateTransformer extends GeometryTransformer {
@@ -38,7 +38,9 @@ public CoordinateTransformer(Function<Coordinate, Coordinate> transform) {
   @Override protected CoordinateSequence transformCoordinates(
       CoordinateSequence coordinateSequence, Geometry parent) {
     Coordinate[] coordinateArray =
-        Stream.of(coordinateSequence.toCoordinateArray()).map(transform).toArray(Coordinate[]::new);
+        Arrays.stream(coordinateSequence.toCoordinateArray())
+            .map(transform)
+            .toArray(Coordinate[]::new);
     return new CoordinateArraySequence(coordinateArray);
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/runtime/DeterministicAutomaton.java b/core/src/main/java/org/apache/calcite/runtime/DeterministicAutomaton.java
index 2fb993f25..91abcbd1b 100644
--- a/core/src/main/java/org/apache/calcite/runtime/DeterministicAutomaton.java
+++ b/core/src/main/java/org/apache/calcite/runtime/DeterministicAutomaton.java
@@ -25,7 +25,9 @@
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
-import java.util.stream.Collectors;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toSet;
 
 /**
  * A deterministic finite automaton (DFA).
@@ -41,7 +43,7 @@ public class DeterministicAutomaton {
   /** Constructs the DFA from an epsilon-NFA. */
   @SuppressWarnings("method.invocation.invalid")
   DeterministicAutomaton(Automaton automaton) {
-    this.automaton = Objects.requireNonNull(automaton, "automaton");
+    this.automaton = requireNonNull(automaton, "automaton");
     // Calculate eps closure of start state
     final Set<MultiState> traversedStates = new HashSet<>();
     // Add transitions
@@ -127,7 +129,7 @@ private void finder(Automaton.State state, Set<Automaton.State> closure) {
         automaton.getEpsilonTransitions().stream()
             .filter(t -> t.fromState.equals(state))
             .map(t -> t.toState)
-            .collect(Collectors.toSet());
+            .collect(toSet());
     newStates.removeAll(closure);
     // Recursively call all "new" states
     for (Automaton.State s : newStates) {
@@ -143,10 +145,10 @@ static class Transition {
     final String symbol;
 
     Transition(MultiState fromState, MultiState toState, int symbolId, String symbol) {
-      this.fromState = Objects.requireNonNull(fromState, "fromState");
-      this.toState = Objects.requireNonNull(toState, "toState");
+      this.fromState = requireNonNull(fromState, "fromState");
+      this.toState = requireNonNull(toState, "toState");
       this.symbolId = symbolId;
-      this.symbol = Objects.requireNonNull(symbol, "symbol");
+      this.symbol = requireNonNull(symbol, "symbol");
     }
   }
 
@@ -162,7 +164,7 @@ static class MultiState {
     }
 
     MultiState(ImmutableSet<Automaton.State> states) {
-      this.states = Objects.requireNonNull(states, "states");
+      this.states = requireNonNull(states, "states");
     }
 
     public boolean contains(Automaton.State state) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/Enumerables.java b/core/src/main/java/org/apache/calcite/runtime/Enumerables.java
index 8e101515e..71e617c80 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Enumerables.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Enumerables.java
@@ -29,11 +29,12 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Utilities for processing {@link org.apache.calcite.linq4j.Enumerable} collections.
  *
@@ -66,8 +67,8 @@ public static Supplier<Enumerable<Row>> toRow(
     return () -> toRow(supplier.get());
   }
 
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   public static com.google.common.base.Supplier<Enumerable<Row>> toRow(
       final com.google.common.base.Supplier<Enumerable<@Nullable Object[]>> supplier) {
     return () -> toRow(supplier.get());
@@ -99,7 +100,7 @@ public static <E, TKey, TResult> Enumerable<TResult> match(
           final AtomicInteger matchCounter = new AtomicInteger(1);
 
           @Override public TResult current() {
-            Objects.requireNonNull(resultRow, "resultRow");
+            requireNonNull(resultRow, "resultRow");
             return resultRow;
           }
 
diff --git a/core/src/main/java/org/apache/calcite/runtime/FlatLists.java b/core/src/main/java/org/apache/calcite/runtime/FlatLists.java
index c211419b6..685a69758 100644
--- a/core/src/main/java/org/apache/calcite/runtime/FlatLists.java
+++ b/core/src/main/java/org/apache/calcite/runtime/FlatLists.java
@@ -27,7 +27,6 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -324,7 +323,7 @@ protected static class Flat1List<T> extends AbstractFlatList<T> implements Compa
     }
 
     @Override public Iterator<T> iterator() {
-      return Collections.singletonList(t0).iterator();
+      return ImmutableList.of(t0).iterator();
     }
 
     @Override public boolean equals(@Nullable Object o) {
@@ -340,8 +339,7 @@ protected static class Flat1List<T> extends AbstractFlatList<T> implements Compa
 
     @Override public int hashCode() {
       int h = 1;
-      h = h * 31 + Utilities.hash(t0);
-      return h;
+      return h * 31 + Utilities.hash(t0);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -370,8 +368,8 @@ protected static class Flat1List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
-    @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
+    @Override @SuppressWarnings("unchecked")
+    public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 1) {
         // Make a new array of a's runtime type, but my contents:
         return (T2[]) Arrays.copyOf(toArray(), 1, a.getClass());
@@ -454,8 +452,7 @@ protected static class Flat2List<T> extends AbstractFlatList<T> implements Compa
     @Override public int hashCode() {
       int h = 1;
       h = h * 31 + Utilities.hash(t0);
-      h = h * 31 + Utilities.hash(t1);
-      return h;
+      return h * 31 + Utilities.hash(t1);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -496,8 +493,8 @@ protected static class Flat2List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
-    @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
+    @Override @SuppressWarnings("unchecked")
+    public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 2) {
         // Make a new array of a's runtime type, but my contents:
         return (T2[]) Arrays.copyOf(toArray(), 2, a.getClass());
@@ -584,8 +581,7 @@ protected static class Flat3List<T> extends AbstractFlatList<T> implements Compa
       int h = 1;
       h = h * 31 + Utilities.hash(t0);
       h = h * 31 + Utilities.hash(t1);
-      h = h * 31 + Utilities.hash(t2);
-      return h;
+      return h * 31 + Utilities.hash(t2);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -638,8 +634,8 @@ protected static class Flat3List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
-    @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
+    @Override @SuppressWarnings("unchecked")
+    public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 3) {
         // Make a new array of a's runtime type, but my contents:
         return (T2[]) Arrays.copyOf(toArray(), 3, a.getClass());
@@ -733,8 +729,7 @@ protected static class Flat4List<T> extends AbstractFlatList<T> implements Compa
       h = h * 31 + Utilities.hash(t0);
       h = h * 31 + Utilities.hash(t1);
       h = h * 31 + Utilities.hash(t2);
-      h = h * 31 + Utilities.hash(t3);
-      return h;
+      return h * 31 + Utilities.hash(t3);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -799,8 +794,8 @@ protected static class Flat4List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
-    @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
+    @Override @SuppressWarnings("unchecked")
+    public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 4) {
         // Make a new array of a's runtime type, but my contents:
         return (T2[]) Arrays.copyOf(toArray(), 4, a.getClass());
@@ -903,8 +898,7 @@ protected static class Flat5List<T> extends AbstractFlatList<T> implements Compa
       h = h * 31 + Utilities.hash(t1);
       h = h * 31 + Utilities.hash(t2);
       h = h * 31 + Utilities.hash(t3);
-      h = h * 31 + Utilities.hash(t4);
-      return h;
+      return h * 31 + Utilities.hash(t4);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -981,8 +975,8 @@ protected static class Flat5List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
-    @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
+    @Override @SuppressWarnings("unchecked")
+    public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 5) {
         // Make a new array of a's runtime type, but my contents:
         return (T2[]) Arrays.copyOf(toArray(), 5, a.getClass());
@@ -1094,8 +1088,7 @@ protected static class Flat6List<T> extends AbstractFlatList<T> implements Compa
       h = h * 31 + Utilities.hash(t2);
       h = h * 31 + Utilities.hash(t3);
       h = h * 31 + Utilities.hash(t4);
-      h = h * 31 + Utilities.hash(t5);
-      return h;
+      return h * 31 + Utilities.hash(t5);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -1184,8 +1177,8 @@ protected static class Flat6List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
-    @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
+    @Override @SuppressWarnings("unchecked")
+    public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 6) {
         // Make a new array of a's runtime type, but my contents:
         return (T2[]) Arrays.copyOf(toArray(), 6, a.getClass());
diff --git a/core/src/main/java/org/apache/calcite/runtime/FlipCoordinatesTransformer.java b/core/src/main/java/org/apache/calcite/runtime/FlipCoordinatesTransformer.java
index 9409061b5..74b504892 100644
--- a/core/src/main/java/org/apache/calcite/runtime/FlipCoordinatesTransformer.java
+++ b/core/src/main/java/org/apache/calcite/runtime/FlipCoordinatesTransformer.java
@@ -22,7 +22,7 @@
 import org.locationtech.jts.geom.impl.CoordinateArraySequence;
 import org.locationtech.jts.geom.util.GeometryTransformer;
 
-import java.util.stream.Stream;
+import java.util.Arrays;
 
 /** Flips the coordinates of a geometry. */
 public class FlipCoordinatesTransformer extends GeometryTransformer {
@@ -30,7 +30,7 @@ public class FlipCoordinatesTransformer extends GeometryTransformer {
   @Override protected CoordinateSequence transformCoordinates(
       CoordinateSequence coordinateSequence, Geometry parent) {
     Coordinate[] coordinateArray =
-        Stream.of(coordinateSequence.toCoordinateArray())
+        Arrays.stream(coordinateSequence.toCoordinateArray())
             .map(c -> new Coordinate(c.y, c.x))
             .toArray(Coordinate[]::new);
     return new CoordinateArraySequence(coordinateArray);
diff --git a/core/src/main/java/org/apache/calcite/runtime/FunctionContexts.java b/core/src/main/java/org/apache/calcite/runtime/FunctionContexts.java
index c5d31e39f..0980565d2 100644
--- a/core/src/main/java/org/apache/calcite/runtime/FunctionContexts.java
+++ b/core/src/main/java/org/apache/calcite/runtime/FunctionContexts.java
@@ -23,6 +23,9 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkElementIndex;
+
 /** Runtime support for {@link org.apache.calcite.schema.FunctionContext}. */
 public class FunctionContexts {
   private FunctionContexts() {}
@@ -55,17 +58,14 @@ private static class FunctionContextImpl implements FunctionContext {
     }
 
     private @Nullable Object argumentValue(int ordinal) {
-      if (ordinal < 0 || ordinal >= argumentValues.length) {
-        throw new IndexOutOfBoundsException("argument ordinal " + ordinal + " is out of range");
-      }
+      checkElementIndex(
+          ordinal, argumentValues.length, "argument ordinal " + ordinal + " is out of range");
       return argumentValues[ordinal];
     }
 
     @Override public <V> @Nullable V getArgumentValueAs(int ordinal, Class<V> valueClass) {
       final Object v = argumentValue(ordinal);
-      if (v == null) {
-        throw new IllegalArgumentException("value of argument " + ordinal + " is not constant");
-      }
+      checkArgument(v != null, "value of argument %s is not constant", ordinal);
       if (v == NullSentinel.INSTANCE) {
         return null; // value is constant NULL
       }
diff --git a/core/src/main/java/org/apache/calcite/runtime/Hook.java b/core/src/main/java/org/apache/calcite/runtime/Hook.java
index 4a6044c27..51d5f5a30 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Hook.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Hook.java
@@ -142,8 +142,8 @@ public <T> Closeable add(final Consumer<T> handler) {
 
   // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #add(Consumer)}. */
-  @SuppressWarnings({"Guava", "ReturnValueIgnored"})
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings({"Guava", "ReturnValueIgnored"}) // to be removed before 2.0
   public <T, R> Closeable add(final Function<T, R> handler) {
     return add((Consumer<T>) handler::apply);
   }
@@ -162,8 +162,8 @@ public <T> Closeable addThread(final Consumer<T> handler) {
 
   // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #addThread(Consumer)}. */
-  @SuppressWarnings("Guava")
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // to be removed before 2.0
   public <T, R> Closeable addThread(final com.google.common.base.Function<T, R> handler) {
     return addThread((Consumer<T>) handler::apply);
   }
@@ -175,8 +175,8 @@ private boolean removeThread(Consumer handler) {
 
   // CHECKSTYLE: IGNORE 1
   /** @deprecated Use {@link #propertyJ}. */
-  @SuppressWarnings("Guava")
-  @Deprecated // return type will change in 2.0
+  @Deprecated
+  @SuppressWarnings("Guava") // return type will change in 2.0
   public static <V> com.google.common.base.Function<Holder<V>, Void> property(final V v) {
     return holder -> {
       holder.set(v);
diff --git a/core/src/main/java/org/apache/calcite/runtime/HttpUtils.java b/core/src/main/java/org/apache/calcite/runtime/HttpUtils.java
index 9323c13de..c6f2c7a64 100644
--- a/core/src/main/java/org/apache/calcite/runtime/HttpUtils.java
+++ b/core/src/main/java/org/apache/calcite/runtime/HttpUtils.java
@@ -24,9 +24,12 @@
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.net.URLEncoder;
-import java.nio.charset.StandardCharsets;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /** Utilities for connecting to REST services such as Splunk via HTTP. */
 public class HttpUtils {
   private HttpUtils() {}
@@ -52,9 +55,7 @@ public static void appendURLEncodedArgs(StringBuilder out, Map<String, String> a
   }
 
   public static void appendURLEncodedArgs(StringBuilder out, CharSequence... args) {
-    if (args.length % 2 != 0) {
-      throw new IllegalArgumentException("args should contain an even number of items");
-    }
+    checkArgument(args.length % 2 == 0, "args should contain an even number of items");
     try {
       int appended = 0;
       for (int i = 0; i < args.length; i += 2) {
@@ -107,7 +108,7 @@ public static InputStream executeMethod(
       return conn.getInputStream();
     }
     conn.setDoOutput(true);
-    try (Writer w = new OutputStreamWriter(conn.getOutputStream(), StandardCharsets.UTF_8)) {
+    try (Writer w = new OutputStreamWriter(conn.getOutputStream(), UTF_8)) {
       w.write(data.toString());
       w.flush(); // Get the response
       return conn.getInputStream();
diff --git a/core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java b/core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java
index 602a65273..c9a9f846d 100644
--- a/core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java
+++ b/core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java
@@ -27,6 +27,8 @@
 import com.fasterxml.jackson.core.PrettyPrinter;
 import com.fasterxml.jackson.core.util.DefaultIndenter;
 import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableList;
 import com.jayway.jsonpath.Configuration;
 import com.jayway.jsonpath.DocumentContext;
 import com.jayway.jsonpath.InvalidPathException;
@@ -42,7 +44,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
@@ -59,14 +60,16 @@
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.regex.Pattern.CASE_INSENSITIVE;
+import static java.util.regex.Pattern.DOTALL;
+import static java.util.regex.Pattern.MULTILINE;
 
 /** A collection of functions used in JSON processing. */
 public class JsonFunctions {
 
   private static final Pattern JSON_PATH_BASE =
       Pattern.compile(
-          "^\\s*(?<mode>strict|lax)\\s+(?<spec>.+)$",
-          Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.MULTILINE);
+          "^\\s*(?<mode>strict|lax)\\s+(?<spec>.+)$", CASE_INSENSITIVE | DOTALL | MULTILINE);
 
   private static final JacksonJsonProvider JSON_PATH_JSON_PROVIDER = new JacksonJsonProvider();
   private static final MappingProvider JSON_PATH_MAPPING_PROVIDER = new JacksonMappingProvider();
@@ -318,13 +321,13 @@ public static JsonPathContext jsonApiCommonSyntax(JsonValueContext input, String
             value = context.obj;
             break;
           case WITH_UNCONDITIONAL_ARRAY:
-            value = Collections.singletonList(context.obj);
+            value = ImmutableList.of(context.obj);
             break;
           case WITH_CONDITIONAL_ARRAY:
             if (context.obj instanceof Collection) {
               value = context.obj;
             } else {
-              value = Collections.singletonList(context.obj);
+              value = ImmutableList.of(context.obj);
             }
             break;
           default:
@@ -440,7 +443,7 @@ public static String jsonPretty(JsonValueContext input) {
           .writer(JSON_PRETTY_PRINTER)
           .writeValueAsString(input.obj);
     } catch (Exception e) {
-      throw RESOURCE.exceptionWhileSerializingToJson(Objects.toString(input.obj)).ex(e);
+      throw RESOURCE.exceptionWhileSerializingToJson(String.valueOf(input.obj)).ex(e);
     }
   }
 
@@ -516,13 +519,9 @@ private static Integer calculateDepth(Object o) {
       for (int i = 0; i < size; ++i) {
         Object obj = q.poll();
         if (obj instanceof Map) {
-          for (Object value : ((LinkedHashMap) obj).values()) {
-            q.add(value);
-          }
+          q.addAll(((LinkedHashMap) obj).values());
         } else if (obj instanceof Collection) {
-          for (Object value : (Collection) obj) {
-            q.add(value);
-          }
+          q.addAll((Collection) obj);
         }
       }
       ++depth;
@@ -645,7 +644,7 @@ public static Integer jsonStorageSize(JsonValueContext input) {
     try {
       return JSON_PATH_JSON_PROVIDER.getObjectMapper().writeValueAsBytes(input.obj).length;
     } catch (Exception e) {
-      throw RESOURCE.invalidInputForJsonStorageSize(Objects.toString(input.obj)).ex(e);
+      throw RESOURCE.invalidInputForJsonStorageSize(String.valueOf(input.obj)).ex(e);
     }
   }
 
@@ -702,7 +701,7 @@ private static String jsonModify(JsonValueContext jsonDoc, JsonModifyMode type,
       }
     }
 
-    return result == null || result.isEmpty() ? ctx.jsonString() : result;
+    return Strings.isNullOrEmpty(result) ? ctx.jsonString() : result;
   }
 
   private static void insertToJson(DocumentContext ctx, String path, Object value) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/Like.java b/core/src/main/java/org/apache/calcite/runtime/Like.java
index 5f6e13a0e..0ee71f4ea 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Like.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Like.java
@@ -21,6 +21,8 @@
 import java.util.Arrays;
 import java.util.Locale;
 
+import static java.util.regex.Pattern.CASE_INSENSITIVE;
+
 /**
  * Utilities for converting SQL {@code LIKE} and {@code SIMILAR} operators to regular expressions.
  */
@@ -289,7 +291,7 @@ static java.util.regex.Pattern posixRegexToPattern(String regex, boolean caseSen
       regex = regex.replace(v.toLowerCase(Locale.ROOT), "\\p{" + v + "}");
     }
 
-    int flags = caseSensitive ? 0 : java.util.regex.Pattern.CASE_INSENSITIVE;
+    int flags = caseSensitive ? 0 : CASE_INSENSITIVE;
     return java.util.regex.Pattern.compile(regex, flags);
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/runtime/MapEntry.java b/core/src/main/java/org/apache/calcite/runtime/MapEntry.java
index dc4f1c5cc..97f15d136 100644
--- a/core/src/main/java/org/apache/calcite/runtime/MapEntry.java
+++ b/core/src/main/java/org/apache/calcite/runtime/MapEntry.java
@@ -50,8 +50,8 @@ public MapEntry(T t, U u) {
    *
    * <p>Compares equal to any {@link Map.Entry} with the equal key and value.
    */
-  @SuppressWarnings("unchecked")
-  @Override public boolean equals(@Nullable Object o) {
+  @Override @SuppressWarnings("unchecked")
+  public boolean equals(@Nullable Object o) {
     return this == o
         || o instanceof Map.Entry
             && Objects.equals(this.t, ((Map.Entry<T, U>) o).getKey())
diff --git a/core/src/main/java/org/apache/calcite/runtime/Matcher.java b/core/src/main/java/org/apache/calcite/runtime/Matcher.java
index 142445c5e..8dafb9a13 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Matcher.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Matcher.java
@@ -21,7 +21,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -36,7 +35,11 @@
 import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Workspace that partialMatches patterns against an automaton.
@@ -57,7 +60,7 @@ public class Matcher<E> {
   /** Creates a Matcher; use {@link #builder}. */
   private Matcher(
       Automaton automaton, ImmutableMap<String, Predicate<MemoryFactory.Memory<E>>> predicates) {
-    this.predicates = Objects.requireNonNull(predicates, "predicates");
+    this.predicates = requireNonNull(predicates, "predicates");
     final ImmutableBitSet.Builder startSetBuilder = ImmutableBitSet.builder();
     startSetBuilder.set(automaton.startState.id);
     automaton.epsilonSuccessors(automaton.startState.id, startSetBuilder);
@@ -115,7 +118,7 @@ protected List<PartialMatch<E>> matchOneWithSymbols(
               dfa.getTransitions().stream()
                   .filter(t -> predicate.getKey().equals(t.symbol))
                   .filter(t -> pm.currentState.equals(t.fromState))
-                  .collect(Collectors.toList());
+                  .collect(toList());
 
           for (DeterministicAutomaton.Transition transition : transitions) {
             // System.out.println("Append new transition to ");
@@ -131,7 +134,7 @@ protected List<PartialMatch<E>> matchOneWithSymbols(
             dfa.getTransitions().stream()
                 .filter(t -> predicate.getKey().equals(t.symbol))
                 .filter(t -> dfa.startState.equals(t.fromState))
-                .collect(Collectors.toList());
+                .collect(toList());
 
         for (DeterministicAutomaton.Transition transition : transitions) {
           final PartialMatch<E> newMatch =
@@ -182,7 +185,7 @@ public void addPartialMatches(Collection<PartialMatch<E>> matches) {
     }
 
     public Set<PartialMatch<E>> getPartialMatches() {
-      return ImmutableSet.copyOf(partialMatches);
+      return partialMatches;
     }
 
     public void removePartialMatch(PartialMatch<E> pm) {
@@ -291,14 +294,11 @@ public Builder<E> add(String symbolName, Predicate<MemoryFactory.Memory<E>> pred
     public Matcher<E> build() {
       final Set<String> predicateSymbolsNotInGraph = Sets.newTreeSet(symbolPredicates.keySet());
       predicateSymbolsNotInGraph.removeAll(automaton.symbolNames);
-      if (!predicateSymbolsNotInGraph.isEmpty()) {
-        throw new IllegalArgumentException(
-            "not all predicate symbols ["
-                + predicateSymbolsNotInGraph
-                + "] are in graph ["
-                + automaton.symbolNames
-                + "]");
-      }
+      checkArgument(
+          predicateSymbolsNotInGraph.isEmpty(),
+          "not all predicate symbols [%s] are in graph [%s]",
+          predicateSymbolsNotInGraph,
+          automaton.symbolNames);
       final ImmutableMap.Builder<String, Predicate<MemoryFactory.Memory<E>>> builder =
           ImmutableMap.builder();
       for (String symbolName : automaton.symbolNames) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/PairList.java b/core/src/main/java/org/apache/calcite/runtime/PairList.java
index 25b14725d..1906bb406 100644
--- a/core/src/main/java/org/apache/calcite/runtime/PairList.java
+++ b/core/src/main/java/org/apache/calcite/runtime/PairList.java
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.linq4j.function.Functions;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
 
@@ -103,8 +102,8 @@ public static <T, U> Builder<T, U> builder() {
     return new Builder<>();
   }
 
-  @SuppressWarnings("unchecked")
-  @Override public Map.Entry<T, U> get(int index) {
+  @Override @SuppressWarnings("unchecked")
+  public Map.Entry<T, U> get(int index) {
     int x = index * 2;
     return new MapEntry<>((T) list.get(x), (U) list.get(x + 1));
   }
@@ -117,15 +116,15 @@ public static <T, U> Builder<T, U> builder() {
     list.clear();
   }
 
-  @SuppressWarnings("RedundantCast")
-  @Override public boolean add(Map.Entry<T, U> entry) {
+  @Override @SuppressWarnings("RedundantCast")
+  public boolean add(Map.Entry<T, U> entry) {
     list.add((Object) entry.getKey());
     list.add((Object) entry.getValue());
     return true;
   }
 
-  @SuppressWarnings("RedundantCast")
-  @Override public void add(int index, Map.Entry<T, U> entry) {
+  @Override @SuppressWarnings("RedundantCast")
+  public void add(int index, Map.Entry<T, U> entry) {
     int x = index * 2;
     list.add(x, (Object) entry.getKey());
     list.add(x + 1, (Object) entry.getValue());
@@ -177,8 +176,8 @@ public Map.Entry<T, U> set(int index, T t, U u) {
     return new MapEntry<>(t0, u0);
   }
 
-  @SuppressWarnings("unchecked")
-  @Override public Map.Entry<T, U> remove(int index) {
+  @Override @SuppressWarnings("unchecked")
+  public Map.Entry<T, U> remove(int index) {
     final int x = index * 2;
     T t = (T) list.remove(x);
     U u = (U) list.remove(x);
@@ -249,7 +248,7 @@ public ImmutableMap<T, U> toImmutableMap() {
 
   /** Returns an immutable PairList whose contents are the same as this PairList. */
   public PairList<T, U> immutable() {
-    final List<@Nullable Object> immutableList = ImmutableList.copyOf(list);
+    final List<@Nullable Object> immutableList = list;
     return backedBy(immutableList);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/runtime/Pattern.java b/core/src/main/java/org/apache/calcite/runtime/Pattern.java
index cd5c6521e..1ef20bf7a 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Pattern.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Pattern.java
@@ -16,12 +16,14 @@
  */
 package org.apache.calcite.runtime;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
-import java.util.Objects;
 import java.util.Stack;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.joining;
 
 /** Regular expression, to be compiled into an {@link Automaton}. */
 public interface Pattern {
@@ -157,7 +159,7 @@ abstract class AbstractPattern implements Pattern {
     final Op op;
 
     AbstractPattern(Op op) {
-      this.op = Objects.requireNonNull(op, "op");
+      this.op = requireNonNull(op, "op");
     }
 
     @Override public Automaton toAutomaton() {
@@ -171,7 +173,7 @@ class SymbolPattern extends AbstractPattern {
 
     SymbolPattern(String name) {
       super(Op.SYMBOL);
-      this.name = Objects.requireNonNull(name, "name");
+      this.name = requireNonNull(name, "name");
     }
 
     @Override public String toString() {
@@ -185,15 +187,15 @@ class OpPattern extends AbstractPattern {
 
     OpPattern(Op op, Pattern... patterns) {
       super(op);
-      Preconditions.checkArgument(patterns.length >= op.minArity);
-      Preconditions.checkArgument(op.maxArity == -1 || patterns.length <= op.maxArity);
+      checkArgument(patterns.length >= op.minArity);
+      checkArgument(op.maxArity == -1 || patterns.length <= op.maxArity);
       this.patterns = ImmutableList.copyOf(patterns);
     }
 
     @Override public String toString() {
       switch (op) {
         case SEQ:
-          return patterns.stream().map(Object::toString).collect(Collectors.joining(" "));
+          return patterns.stream().map(Object::toString).collect(joining(" "));
         case STAR:
           return "(" + patterns.get(0) + ")*";
         case PLUS:
diff --git a/core/src/main/java/org/apache/calcite/runtime/ProjectionTransformer.java b/core/src/main/java/org/apache/calcite/runtime/ProjectionTransformer.java
index dcd4644d0..c4b6a912a 100644
--- a/core/src/main/java/org/apache/calcite/runtime/ProjectionTransformer.java
+++ b/core/src/main/java/org/apache/calcite/runtime/ProjectionTransformer.java
@@ -35,8 +35,8 @@
 import org.locationtech.proj4j.CoordinateTransformFactory;
 import org.locationtech.proj4j.ProjCoordinate;
 
+import java.util.Arrays;
 import java.util.Locale;
-import java.util.stream.Stream;
 
 /** Transforms the projection of a geometry. */
 public class ProjectionTransformer extends GeometryTransformer {
@@ -62,7 +62,7 @@ public ProjectionTransformer(int sourceSrid, int targetSrid) {
   @Override protected CoordinateSequence transformCoordinates(
       CoordinateSequence coordinateSequence, Geometry parent) {
     Coordinate[] coordinateArray =
-        Stream.of(coordinateSequence.toCoordinateArray())
+        Arrays.stream(coordinateSequence.toCoordinateArray())
             .map(this::transformCoordinate)
             .toArray(Coordinate[]::new);
     return new CoordinateArraySequence(coordinateArray);
diff --git a/core/src/main/java/org/apache/calcite/runtime/RemovePointOperation.java b/core/src/main/java/org/apache/calcite/runtime/RemovePointOperation.java
index 28bb5d3e7..92f6ebbd4 100644
--- a/core/src/main/java/org/apache/calcite/runtime/RemovePointOperation.java
+++ b/core/src/main/java/org/apache/calcite/runtime/RemovePointOperation.java
@@ -20,6 +20,8 @@
 import org.locationtech.jts.geom.Geometry;
 import org.locationtech.jts.geom.util.GeometryEditor;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Geometry editor operation that removes a point to a geometry. */
 public class RemovePointOperation extends GeometryEditor.CoordinateOperation {
 
@@ -30,9 +32,7 @@ public RemovePointOperation(int index) {
   }
 
   @Override public Coordinate[] edit(Coordinate[] coordinates, Geometry geometry) {
-    if (index < 0 || index > coordinates.length - 1) {
-      throw new IllegalArgumentException("Invalid index: " + index);
-    }
+    checkArgument(index >= 0 && index <= coordinates.length - 1, "Invalid index: %s", index);
     Coordinate[] newCoordinates = new Coordinate[coordinates.length - 1];
     for (int i = 0; i < index; i++) {
       newCoordinates[i] = (Coordinate) coordinates[i].clone();
diff --git a/core/src/main/java/org/apache/calcite/runtime/Resources.java b/core/src/main/java/org/apache/calcite/runtime/Resources.java
index e6716533d..cea8e6a67 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Resources.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Resources.java
@@ -16,11 +16,13 @@
  */
 package org.apache.calcite.runtime;
 
-import org.checkerframework.checker.initialization.qual.UnderInitialization;
-import org.checkerframework.checker.nullness.qual.Nullable;
-import org.checkerframework.checker.nullness.qual.PolyNull;
-import org.checkerframework.checker.nullness.qual.RequiresNonNull;
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonMap;
+import static java.util.Objects.requireNonNull;
+import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import com.google.common.collect.ImmutableMap;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.annotation.ElementType;
@@ -54,10 +56,10 @@
 import java.util.ResourceBundle;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
-
-import static org.apache.calcite.linq4j.Nullness.castNonNull;
-
-import static java.util.Objects.requireNonNull;
+import org.checkerframework.checker.initialization.qual.UnderInitialization;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.checker.nullness.qual.PolyNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * Defining wrapper classes around resources that allow the compiler to check
@@ -461,9 +463,9 @@ public Map<String, String> getProperties() {
       // could design new annotations if any resource needed more.
       final Property property = method.getAnnotation(Property.class);
       if (property == null) {
-        return Collections.emptyMap();
+        return ImmutableMap.of();
       } else {
-        return Collections.singletonMap(property.name(), property.value());
+        return ImmutableMap.of(property.name(), property.value());
       }
     }
   }
@@ -551,10 +553,7 @@ public static Class getExceptionClass(Type type) {
         }
         if (type instanceof Class) {
           Type superclass = ((Class) type).getGenericSuperclass();
-          if (superclass == null) {
-            throw new IllegalStateException(
-                "Unable to find superclass ExInstWithCause for " + type0);
-          }
+          checkState(superclass != null, "Unable to find superclass ExInstWithCause for %s", type0);
           type = superclass;
         }
       }
diff --git a/core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java b/core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java
index b7f8543ab..b1e1fcaa8 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java
@@ -16,9 +16,10 @@
  */
 package org.apache.calcite.runtime;
 
+import com.google.common.collect.ImmutableList;
+
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -33,7 +34,7 @@
  */
 public class SortedMultiMap<K, V> extends HashMap<K, List<V>> {
   public void putMulti(K key, V value) {
-    List<V> list = put(key, Collections.singletonList(value));
+    List<V> list = put(key, ImmutableList.of(value));
     if (list == null) {
       return;
     }
diff --git a/core/src/main/java/org/apache/calcite/runtime/SpaceFillingCurve2D.java b/core/src/main/java/org/apache/calcite/runtime/SpaceFillingCurve2D.java
index 080d354df..9d1a58b80 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SpaceFillingCurve2D.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SpaceFillingCurve2D.java
@@ -117,8 +117,8 @@ class OverlappingRange extends AbstractRange {
 
   /** Lexicographic ordering for {@link IndexRange}. */
   class IndexRangeOrdering extends Ordering<IndexRange> {
-    @SuppressWarnings("override.param.invalid")
-    @Override public int compare(IndexRange x, IndexRange y) {
+    @Override @SuppressWarnings("override.param.invalid")
+    public int compare(IndexRange x, IndexRange y) {
       final int c1 = Long.compare(x.lower(), y.lower());
       if (c1 != 0) {
         return c1;
diff --git a/core/src/main/java/org/apache/calcite/runtime/SpatialTypeFunctions.java b/core/src/main/java/org/apache/calcite/runtime/SpatialTypeFunctions.java
index e643d612e..ff1401a29 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SpatialTypeFunctions.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SpatialTypeFunctions.java
@@ -74,10 +74,11 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Objects;
 import java.util.function.Function;
 import java.util.stream.Stream;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.runtime.SpatialTypeUtils.GEOMETRY_FACTORY;
 import static org.apache.calcite.runtime.SpatialTypeUtils.NO_SRID;
 import static org.apache.calcite.runtime.SpatialTypeUtils.asEwkt;
@@ -92,6 +93,9 @@
 import static org.apache.calcite.runtime.SpatialTypeUtils.fromWkt;
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Comparator.naturalOrder;
+import static java.util.Objects.requireNonNull;
+
 /**
  * Helper methods to implement spatial type (ST) functions in generated code.
  *
@@ -109,7 +113,7 @@
  *   <li>Make {@link #ST_MakeLine(Geometry, Geometry)} varargs
  * </ul>
  */
-@SuppressWarnings({"WeakerAccess", "unused"})
+@SuppressWarnings({"unused", "WeakerAccess"})
 @Deterministic
 @Strict
 @Experimental
@@ -591,7 +595,7 @@ public static Geometry ST_MakeEnvelope(
                 + yMin
                 + "))",
             srid);
-    return Objects.requireNonNull(geom, "geom");
+    return requireNonNull(geom, "geom");
   }
 
   /** Creates a rectangular Polygon. */
@@ -601,7 +605,7 @@ public static Geometry ST_MakeEnvelope(
   }
 
   /** Creates a line-string from the given POINTs (or MULTIPOINTs). */
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(Geometry geom1, Geometry geom2) {
     return GEOMETRY_FACTORY.createLineString(
         new Coordinate[] {
@@ -609,7 +613,7 @@ public static Geometry ST_MakeLine(Geometry geom1, Geometry geom2) {
         });
   }
 
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(Geometry geom1, Geometry geom2, Geometry geom3) {
     return GEOMETRY_FACTORY.createLineString(
         new Coordinate[] {
@@ -617,7 +621,7 @@ public static Geometry ST_MakeLine(Geometry geom1, Geometry geom2, Geometry geom
         });
   }
 
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(
       Geometry geom1, Geometry geom2, Geometry geom3, Geometry geom4) {
     return GEOMETRY_FACTORY.createLineString(
@@ -629,7 +633,7 @@ public static Geometry ST_MakeLine(
         });
   }
 
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(
       Geometry geom1, Geometry geom2, Geometry geom3, Geometry geom4, Geometry geom5) {
     return GEOMETRY_FACTORY.createLineString(
@@ -642,7 +646,7 @@ public static Geometry ST_MakeLine(
         });
   }
 
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(
       Geometry geom1,
       Geometry geom2,
@@ -662,31 +666,29 @@ public static Geometry ST_MakeLine(
   }
 
   /** Alias for {@link #ST_Point(BigDecimal, BigDecimal)}. */
-  @Hints({"SqlKind:ST_POINT"})
+  @Hints("SqlKind:ST_POINT")
   public static Geometry ST_MakePoint(BigDecimal x, BigDecimal y) {
     return ST_Point(x, y);
   }
 
   /** Alias for {@link #ST_Point(BigDecimal, BigDecimal, BigDecimal)}. */
-  @Hints({"SqlKind:ST_POINT3"})
+  @Hints("SqlKind:ST_POINT3")
   public static Geometry ST_MakePoint(BigDecimal x, BigDecimal y, BigDecimal z) {
     return ST_Point(x, y, z);
   }
 
   /** Constructs a 2D point from coordinates. */
-  @Hints({"SqlKind:ST_POINT"})
+  @Hints("SqlKind:ST_POINT")
   public static Geometry ST_Point(BigDecimal x, BigDecimal y) {
     // NOTE: Combine the double and BigDecimal variants of this function
     return GEOMETRY_FACTORY.createPoint(new Coordinate(x.doubleValue(), y.doubleValue()));
   }
 
   /** Constructs a 3D point from coordinates. */
-  @Hints({"SqlKind:ST_POINT3"})
+  @Hints("SqlKind:ST_POINT3")
   public static Geometry ST_Point(BigDecimal x, BigDecimal y, BigDecimal z) {
-    final Geometry g =
-        GEOMETRY_FACTORY.createPoint(
-            new Coordinate(x.doubleValue(), y.doubleValue(), z.doubleValue()));
-    return g;
+    return GEOMETRY_FACTORY.createPoint(
+        new Coordinate(x.doubleValue(), y.doubleValue(), z.doubleValue()));
   }
 
   // Geometry properties (2D)
@@ -872,8 +874,8 @@ public static Double ST_Z(Geometry geom) {
   public static Double ST_ZMax(Geometry geom) {
     return Arrays.stream(geom.getCoordinates())
         .filter(c -> !Double.isNaN(c.getZ()))
-        .map(c -> c.getZ())
-        .max(Double::compareTo)
+        .map(Coordinate::getZ)
+        .max(naturalOrder())
         .orElse(Double.NaN);
   }
 
@@ -881,8 +883,8 @@ public static Double ST_ZMax(Geometry geom) {
   public static Double ST_ZMin(Geometry geom) {
     return Arrays.stream(geom.getCoordinates())
         .filter(c -> !Double.isNaN(c.getZ()))
-        .map(c -> c.getZ())
-        .min(Double::compareTo)
+        .map(Coordinate::getZ)
+        .min(naturalOrder())
         .orElse(Double.NaN);
   }
 
@@ -942,7 +944,7 @@ private static void ST_Explode(final Geometry geom) {
   // Geometry predicates ======================================================
 
   /** Returns whether {@code geom1} contains {@code geom2}. */
-  @Hints({"SqlKind:ST_CONTAINS"})
+  @Hints("SqlKind:ST_CONTAINS")
   public static boolean ST_Contains(Geometry geom1, Geometry geom2) {
     return geom1.contains(geom2);
   }
@@ -1023,7 +1025,7 @@ public static boolean ST_Within(Geometry geom1, Geometry geom2) {
   }
 
   /** Returns whether {@code geom1} and {@code geom2} are within {@code distance} of each other. */
-  @Hints({"SqlKind:ST_DWITHIN"})
+  @Hints("SqlKind:ST_DWITHIN")
   public static boolean ST_DWithin(Geometry geom1, Geometry geom2, double distance) {
     final double distance1 = geom1.distance(geom2);
     return distance1 <= distance;
@@ -1036,8 +1038,7 @@ public static Geometry ST_Buffer(Geometry geom, double distance, String bufferSt
     BufferStyle style = new BufferStyle(bufferStyle);
     BufferParameters params = style.asBufferParameters();
     double sidedDistance = style.asSidedDistance(distance);
-    Geometry result = new BufferOp(geom, params).getResultGeometry(sidedDistance);
-    return result;
+    return new BufferOp(geom, params).getResultGeometry(sidedDistance);
   }
 
   /** Computes a buffer around {@code geom}. */
@@ -1077,9 +1078,7 @@ public static Geometry ST_Intersection(Geometry geom1, Geometry geom2) {
 
   /** Computes an offset line for {@code linestring}. */
   public static Geometry ST_OffsetCurve(Geometry linestring, double distance, String bufferStyle) {
-    if (!(linestring instanceof LineString)) {
-      throw new IllegalArgumentException("ST_OffsetCurve only accepts LineString");
-    }
+    checkArgument((linestring instanceof LineString), "ST_OffsetCurve only accepts LineString");
     BufferStyle style = new BufferStyle(bufferStyle);
     BufferParameters params = style.asBufferParameters();
     double sidedDistance = style.asSidedDistance(distance);
@@ -1229,8 +1228,7 @@ public static Geometry ST_Scale(Geometry geom, BigDecimal xFactor, BigDecimal yF
   public static Geometry ST_Translate(Geometry geom, BigDecimal x, BigDecimal y) {
     AffineTransformation transformation = new AffineTransformation();
     transformation.translate(x.doubleValue(), y.doubleValue());
-    Geometry translated = transformation.transform(geom);
-    return translated;
+    return transformation.transform(geom);
   }
 
   // Geometry editing functions (2D)
@@ -1558,7 +1556,7 @@ private static Geometry asTriangleEdges(MultiPolygon multiPolygon) {
    * Returns the position of a point on the Hilbert curve, or null if it is not a 2-dimensional
    * point.
    */
-  @Hints({"SqlKind:HILBERT"})
+  @Hints("SqlKind:HILBERT")
   public static @Nullable Long hilbert(Geometry geom) {
     if (geom instanceof Point) {
       final double x = ((Point) geom).getX();
@@ -1569,7 +1567,7 @@ private static Geometry asTriangleEdges(MultiPolygon multiPolygon) {
   }
 
   /** Returns the position of a point on the Hilbert curve. */
-  @Hints({"SqlKind:HILBERT"})
+  @Hints("SqlKind:HILBERT")
   public static long hilbert(BigDecimal x, BigDecimal y) {
     return new HilbertCurve2D(8).toIndex(x.doubleValue(), y.doubleValue());
   }
diff --git a/core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java b/core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java
index 69167761a..4483d71af 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java
@@ -40,6 +40,8 @@
 import java.util.regex.Pattern;
 import javax.xml.parsers.ParserConfigurationException;
 
+import static java.util.regex.Pattern.DOTALL;
+
 /** Utilities for spatial types. */
 @Deterministic
 @Strict
@@ -161,7 +163,7 @@ public static Geometry fromWkb(ByteString wkb) {
    * @return a geometry
    */
   public static Geometry fromEwkt(String ewkt) {
-    Pattern pattern = Pattern.compile("^(?:srid:(\\d*);)?(.*)$", Pattern.DOTALL);
+    Pattern pattern = Pattern.compile("^(?:srid:(\\d*);)?(.*)$", DOTALL);
     java.util.regex.Matcher matcher = pattern.matcher(ewkt);
     if (!matcher.matches()) {
       throw new RuntimeException("Unable to parse EWKT");
@@ -216,8 +218,7 @@ public static String asGeoJson(Geometry geometry) {
   public static String asGml(Geometry geometry) {
     GMLWriter gmlWriter = new GMLWriter();
     // remove line breaks and indentation
-    String minified = gmlWriter.write(geometry).replace("\n", "").replace("  ", "");
-    return minified;
+    return gmlWriter.write(geometry).replace("\n", "").replace("  ", "");
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java b/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
index 974fa4668..d2402ea5b 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
@@ -53,6 +53,7 @@
 
 import com.google.common.base.Splitter;
 import com.google.common.base.Strings;
+import com.google.common.base.Utf8;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -107,11 +108,22 @@
 import java.util.function.BinaryOperator;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.time.ZoneOffset.UTC;
+import static java.util.Comparator.naturalOrder;
+import static java.util.Comparator.nullsFirst;
+import static java.util.Comparator.nullsLast;
+import static java.util.Comparator.reverseOrder;
 import static java.util.Objects.requireNonNull;
+import static java.util.regex.Pattern.CASE_INSENSITIVE;
+import static java.util.regex.Pattern.DOTALL;
+import static java.util.regex.Pattern.MULTILINE;
 
 /**
  * Helper methods to implement SQL functions in generated code.
@@ -224,9 +236,7 @@ private SqlFunctions() {}
    */
   @NonDeterministic
   public static boolean throwUnless(boolean condition, String message) {
-    if (!condition) {
-      throw new IllegalStateException(message);
-    }
+    checkState(condition, message);
     return condition;
   }
 
@@ -378,16 +388,16 @@ private static int makeRegexpFlags(@Nullable String stringFlags) {
       for (int i = 0; i < stringFlags.length(); ++i) {
         switch (stringFlags.charAt(i)) {
           case 'i':
-            flags |= Pattern.CASE_INSENSITIVE;
+            flags |= CASE_INSENSITIVE;
             break;
           case 'c':
-            flags &= ~Pattern.CASE_INSENSITIVE;
+            flags &= ~CASE_INSENSITIVE;
             break;
           case 'n':
-            flags |= Pattern.DOTALL;
+            flags |= DOTALL;
             break;
           case 'm':
-            flags |= Pattern.MULTILINE;
+            flags |= MULTILINE;
             break;
           default:
             throw RESOURCE.invalidInputForRegexpReplace(stringFlags).ex();
@@ -808,7 +818,7 @@ public static int charLength(String s) {
 
   /** SQL BIT_LENGTH(string) function. */
   public static int bitLength(String s) {
-    return s.getBytes(UTF_8).length * 8;
+    return Utf8.encodedLength(s) * 8;
   }
 
   /** SQL BIT_LENGTH(binary) function. */
@@ -1027,13 +1037,13 @@ public static boolean like(String s, String pattern, String escape) {
   /** SQL {@code ILIKE} function. */
   public static boolean ilike(String s, String pattern) {
     final String regex = Like.sqlToRegexLike(pattern, null);
-    return Pattern.compile(regex, Pattern.CASE_INSENSITIVE).matcher(s).matches();
+    return Pattern.compile(regex, CASE_INSENSITIVE).matcher(s).matches();
   }
 
   /** SQL {@code ILIKE} function with escape. */
   public static boolean ilike(String s, String pattern, String escape) {
     final String regex = Like.sqlToRegexLike(pattern, escape);
-    return Pattern.compile(regex, Pattern.CASE_INSENSITIVE).matcher(s).matches();
+    return Pattern.compile(regex, CASE_INSENSITIVE).matcher(s).matches();
   }
 
   /** SQL {@code RLIKE} function. */
@@ -1930,9 +1940,7 @@ public static double acosh(BigDecimal b0) {
 
   /** SQL <code>ACOSH</code> operator applied to double values. */
   public static double acosh(double b0) {
-    if (b0 < 1) {
-      throw new IllegalArgumentException("Input parameter of acosh cannot be less than 1!");
-    }
+    checkArgument(b0 >= 1, "Input parameter of acosh cannot be less than 1!");
     return Math.log(Math.sqrt(b0 * b0 - 1.0d) + b0);
   }
 
@@ -2006,10 +2014,8 @@ public static double atanh(BigDecimal b) {
 
   /** SQL <code>ATANH</code> operator applied to double values. */
   public static double atanh(double b) {
-    if (Math.abs(b) >= 1) {
-      throw new IllegalArgumentException(
-          "Input parameter of atanh cannot be out of the " + "range (-1, 1)!");
-    }
+    checkArgument(
+        Math.abs(b) < 1, "Input parameter of atanh cannot be out of the " + "range (-1, 1)!");
     final double mult;
     // check the sign bit of the raw representation to handle -0.
     if (Double.doubleToRawLongBits(b) < 0) {
@@ -2730,8 +2736,8 @@ public static BigDecimal toBigDecimal(Number number) {
         : number instanceof BigInteger
             ? new BigDecimal((BigInteger) number)
             : number instanceof Long
-                ? new BigDecimal(number.longValue())
-                : new BigDecimal(number.doubleValue());
+                ? BigDecimal.valueOf(number.longValue())
+                : BigDecimal.valueOf(number.doubleValue());
   }
 
   public static BigDecimal toBigDecimal(Object o) {
@@ -2821,7 +2827,7 @@ public static int timeWithLocalTimeZoneToTime(int v, TimeZone timeZone) {
   public static long timeWithLocalTimeZoneToTimestamp(String date, int v, TimeZone timeZone) {
     final TimeWithTimeZoneString tTZ =
         TimeWithTimeZoneString.fromMillisOfDay(v).withTimeZone(DateTimeUtils.UTC_ZONE);
-    return new TimestampWithTimeZoneString(date + " " + tTZ.toString())
+    return new TimestampWithTimeZoneString(date + " " + tTZ)
         .withTimeZone(timeZone)
         .getLocalTimestampString()
         .getMillisSinceEpoch();
@@ -2830,7 +2836,7 @@ public static long timeWithLocalTimeZoneToTimestamp(String date, int v, TimeZone
   public static long timeWithLocalTimeZoneToTimestampWithLocalTimeZone(String date, int v) {
     final TimeWithTimeZoneString tTZ =
         TimeWithTimeZoneString.fromMillisOfDay(v).withTimeZone(DateTimeUtils.UTC_ZONE);
-    return new TimestampWithTimeZoneString(date + " " + tTZ.toString())
+    return new TimestampWithTimeZoneString(date + " " + tTZ)
         .getLocalTimestampString()
         .getMillisSinceEpoch();
   }
@@ -2951,7 +2957,7 @@ public static java.sql.Timestamp internalToTimestamp(long v) {
             Math.floorDiv(v, DateTimeUtils.MILLIS_PER_SECOND),
             (int)
                 (Math.floorMod(v, DateTimeUtils.MILLIS_PER_SECOND) * DateTimeUtils.NANOS_PER_MILLI),
-            ZoneOffset.UTC);
+            UTC);
     return java.sql.Timestamp.valueOf(dateTime);
   }
 
@@ -3067,8 +3073,7 @@ public static int date(long timestampMillis) {
   public static int date(long timestampMillis, String timeZone) {
     // Calcite represents dates as Unix integers (days since epoch).
     return (int)
-        OffsetDateTime.ofInstant(Instant.ofEpochMilli(timestampMillis), ZoneId.of(timeZone))
-            .toLocalDate()
+        LocalDate.ofInstant(Instant.ofEpochMilli(timestampMillis), ZoneId.of(timeZone))
             .toEpochDay();
   }
 
@@ -3076,7 +3081,7 @@ public static int date(long timestampMillis, String timeZone) {
   public static long datetime(int year, int month, int day, int hour, int minute, int second) {
     // BigQuery's DATETIME function returns a Calcite TIMESTAMP,
     // represented internally as milliseconds since epoch UTC.
-    return LocalDateTime.of(year, month, day, hour, minute, second).toEpochSecond(ZoneOffset.UTC)
+    return LocalDateTime.of(year, month, day, hour, minute, second).toEpochSecond(UTC)
         * DateTimeUtils.MILLIS_PER_SECOND;
   }
 
@@ -3108,7 +3113,7 @@ public static long datetime(long millisSinceEpoch, String timeZone) {
     // ZONE and TIMESTAMP, respectively) are represented internally as
     // milliseconds since epoch (or epoch UTC).
     return OffsetDateTime.ofInstant(Instant.ofEpochMilli(millisSinceEpoch), ZoneId.of(timeZone))
-        .atZoneSimilarLocal(ZoneId.of("UTC"))
+        .atZoneSimilarLocal(UTC)
         .toInstant()
         .toEpochMilli();
   }
@@ -3149,8 +3154,7 @@ private static OffsetDateTime parseBigQueryTimestampLiteral(String expression) {
       }
     }
     try {
-      return LocalDateTime.parse(expression, BIG_QUERY_TIMESTAMP_LITERAL_FORMATTER)
-          .atOffset(ZoneOffset.UTC);
+      return LocalDateTime.parse(expression, BIG_QUERY_TIMESTAMP_LITERAL_FORMATTER).atOffset(UTC);
     } catch (DateTimeParseException e2) {
       throw new IllegalArgumentException(
           String.format(Locale.ROOT, "Could not parse BigQuery timestamp literal: %s", expression),
@@ -3170,8 +3174,7 @@ public static long timestamp(int days) {
   public static long timestamp(int days, String timeZone) {
     // Calcite represents TIMESTAMP WITH LOCAL TIME ZONE as Unix integers
     // (milliseconds since epoch).
-    final LocalDateTime localDateTime =
-        LocalDateTime.of(LocalDate.ofEpochDay(days), LocalTime.MIDNIGHT);
+    final LocalDateTime localDateTime = LocalDateTime.of(LocalDate.ofEpochDay(days), LocalTime.MIN);
     final ZoneOffset zoneOffset = ZoneId.of(timeZone).getRules().getOffset(localDateTime);
     return OffsetDateTime.of(localDateTime, zoneOffset).toInstant().toEpochMilli();
   }
@@ -3193,7 +3196,7 @@ public static long timestamp(long millisSinceEpoch, String timeZone) {
     // TIME ZONE and TIMESTAMP, respectively) are represented internally as
     // milliseconds since epoch UTC and epoch.
     final Instant instant = Instant.ofEpochMilli(millisSinceEpoch);
-    final ZoneId utcZone = ZoneId.of("UTC");
+    final ZoneId utcZone = UTC;
     return OffsetDateTime.ofInstant(instant, utcZone)
         .atZoneSimilarLocal(ZoneId.of(timeZone))
         .toInstant()
@@ -3227,7 +3230,7 @@ public static int time(long timestampMillis, String timeZone) {
     final Instant instant = Instant.ofEpochMilli(timestampMillis);
     final ZoneId zoneId = ZoneId.of(timeZone);
     return (int)
-        (OffsetDateTime.ofInstant(instant, zoneId).toLocalTime().toNanoOfDay()
+        (LocalTime.ofInstant(instant, zoneId).toNanoOfDay()
             / (1000L * 1000L)); // milli > micro > nano
   }
 
@@ -3882,7 +3885,7 @@ private static AtomicLong getAtomicLong(String key) {
     final List smaller = list1;
     final List bigger = list2;
     boolean hasNull = false;
-    if (smaller.size() > 0 && bigger.size() > 0) {
+    if (!smaller.isEmpty() && !bigger.isEmpty()) {
       final Set smallestSet = new HashSet(smaller);
       hasNull = smallestSet.remove(null);
       for (Object element : bigger) {
@@ -3992,7 +3995,7 @@ public static List arrayPrepend(List list, Object element) {
   public static Long arrayPosition(List list, Object element) {
     final int index = list.indexOf(element);
     if (index != -1) {
-      return Long.valueOf(index + 1L);
+      return index + 1L;
     }
     return 0L;
   }
@@ -4044,10 +4047,7 @@ public static List arrayUnion(List list1, List list2) {
 
   /** Support the SORT_ARRAY function. */
   public static List sortArray(List list, boolean ascending) {
-    Comparator comparator =
-        ascending
-            ? Comparator.nullsFirst(Comparator.naturalOrder())
-            : Comparator.nullsLast(Comparator.reverseOrder());
+    Comparator comparator = ascending ? nullsFirst(naturalOrder()) : nullsLast(reverseOrder());
     list.sort(comparator);
     return list;
   }
@@ -4420,9 +4420,7 @@ public static <E extends Comparable> Enumerable<FlatLists.ComparableList<E>> pro
     } else {
       Class<?> beanClass = structObject.getClass();
       try {
-        if (fieldName == null) {
-          throw new IllegalStateException("Field name cannot be null for struct field access");
-        }
+        checkState(fieldName != null, "Field name cannot be null for struct field access");
         Field structField = beanClass.getDeclaredField(fieldName);
         return structField.get(structObject);
       } catch (NoSuchFieldException | IllegalAccessException ex) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java b/core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java
index 844fde77a..9d3d51c7d 100644
--- a/core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java
+++ b/core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java
@@ -56,6 +56,8 @@
 import javax.xml.xpath.XPathFactory;
 import javax.xml.xpath.XPathFactoryConfigurationException;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -229,9 +231,8 @@ private XmlFunctions() {}
   }
 
   private static SimpleNamespaceContext extractNamespaceContext(String namespace) {
-    if (!VALID_NAMESPACE_PATTERN.matcher(namespace).find()) {
-      throw new IllegalArgumentException("Invalid namespace " + namespace);
-    }
+    checkArgument(
+        VALID_NAMESPACE_PATTERN.matcher(namespace).find(), "Invalid namespace %s", namespace);
     Map<String, String> namespaceMap = new HashMap<>();
     Matcher matcher = EXTRACT_NAMESPACE_PATTERN.matcher(namespace);
     while (matcher.find()) {
diff --git a/core/src/main/java/org/apache/calcite/schema/Schemas.java b/core/src/main/java/org/apache/calcite/schema/Schemas.java
index 29ab7eb8b..67e28d082 100644
--- a/core/src/main/java/org/apache/calcite/schema/Schemas.java
+++ b/core/src/main/java/org/apache/calcite/schema/Schemas.java
@@ -42,7 +42,6 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
@@ -59,6 +58,9 @@
 import java.util.List;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.jdbc.CalciteSchema.LatticeEntry;
 
 import static java.util.Objects.requireNonNull;
@@ -229,9 +231,7 @@ public static <E> Queryable<E> queryable(
       requireNonNull(schema, "schema");
       if (iterator.hasNext()) {
         SchemaPlus next = schema.getSubSchema(name);
-        if (next == null) {
-          throw new IllegalArgumentException("schema " + name + " is not found in " + schema);
-        }
+        checkArgument(next != null, "schema %s is not found in %s", name, schema);
         schema = next;
       } else {
         return queryable(root, schema, clazz, name);
@@ -300,9 +300,7 @@ private static int[] identity(int count) {
       requireNonNull(schema, "schema");
       if (iterator.hasNext()) {
         SchemaPlus next = schema.getSubSchema(name);
-        if (next == null) {
-          throw new IllegalArgumentException("schema " + name + " is not found in " + schema);
-        }
+        checkArgument(next != null, "schema %s is not found in %s", name, schema);
         schema = next;
       } else {
         return schema.getTable(name);
@@ -582,7 +580,7 @@ public static Path path(CalciteSchema rootSchema, Iterable<String> names) {
     if (!rootSchema.name.isEmpty()) {
       // If path starts with the name of the root schema, ignore the first step
       // in the path.
-      Preconditions.checkState(rootSchema.name.equals(iterator.next()));
+      checkState(rootSchema.name.equals(iterator.next()));
     }
     for (; ; ) {
       final String name = iterator.next();
@@ -591,9 +589,7 @@ public static Path path(CalciteSchema rootSchema, Iterable<String> names) {
         return path(builder.build());
       }
       Schema next = schema.getSubSchema(name);
-      if (next == null) {
-        throw new IllegalArgumentException("schema " + name + " is not found in " + schema);
-      }
+      checkArgument(next != null, "schema %s is not found in %s", name, schema);
       schema = next;
     }
   }
@@ -638,9 +634,7 @@ private static class PathImpl extends AbstractList<Pair<String, Schema>> impleme
     }
 
     @Override public Path parent() {
-      if (pairs.isEmpty()) {
-        throw new IllegalArgumentException("at root");
-      }
+      checkArgument(!pairs.isEmpty(), "at root");
       return new PathImpl(pairs.subList(0, pairs.size() - 1));
     }
 
diff --git a/core/src/main/java/org/apache/calcite/schema/Statistics.java b/core/src/main/java/org/apache/calcite/schema/Statistics.java
index 9bedd47fb..60443a444 100644
--- a/core/src/main/java/org/apache/calcite/schema/Statistics.java
+++ b/core/src/main/java/org/apache/calcite/schema/Statistics.java
@@ -60,11 +60,10 @@ public static Statistic of(
       final @Nullable List<ImmutableBitSet> keys,
       final @Nullable List<RelReferentialConstraint> referentialConstraints,
       final @Nullable List<RelCollation> collations) {
-    List<ImmutableBitSet> keysCopy = keys == null ? ImmutableList.of() : ImmutableList.copyOf(keys);
+    List<ImmutableBitSet> keysCopy = keys == null ? ImmutableList.of() : keys;
     List<RelReferentialConstraint> referentialConstraintsCopy =
-        referentialConstraints == null ? null : ImmutableList.copyOf(referentialConstraints);
-    List<RelCollation> collationsCopy =
-        collations == null ? null : ImmutableList.copyOf(collations);
+        referentialConstraints == null ? null : referentialConstraints;
+    List<RelCollation> collationsCopy = collations == null ? null : collations;
 
     return new Statistic() {
       @Override public @Nullable Double getRowCount() {
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/AbstractSchema.java b/core/src/main/java/org/apache/calcite/schema/impl/AbstractSchema.java
index e3b1c893f..7ee700ea1 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/AbstractSchema.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/AbstractSchema.java
@@ -26,8 +26,8 @@
 import org.apache.calcite.schema.Schemas;
 import org.apache.calcite.schema.Table;
 
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -123,7 +123,7 @@ protected Map<String, RelProtoDataType> getTypeMap() {
    * @return Multi-map of functions in this schema by name
    */
   protected Multimap<String, Function> getFunctionMultimap() {
-    return ImmutableMultimap.of();
+    return ImmutableListMultimap.of();
   }
 
   @Override public final Collection<Function> getFunctions(String name) {
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/AggregateFunctionImpl.java b/core/src/main/java/org/apache/calcite/schema/impl/AggregateFunctionImpl.java
index 46c1dc884..41640934a 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/AggregateFunctionImpl.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/AggregateFunctionImpl.java
@@ -32,10 +32,11 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Implementation of {@link AggregateFunction} via user-defined class. The class should implement
  * {@code A init()}, {@code A add(A, V)}, and {@code R result(A)} methods. All the methods should be
@@ -70,8 +71,8 @@ private AggregateFunctionImpl(
     this.parameters = params;
     this.accumulatorType = accumulatorType;
     this.resultType = resultType;
-    this.initMethod = Objects.requireNonNull(initMethod, "initMethod");
-    this.addMethod = Objects.requireNonNull(addMethod, "addMethod");
+    this.initMethod = requireNonNull(initMethod, "initMethod");
+    this.addMethod = requireNonNull(addMethod, "addMethod");
     this.mergeMethod = mergeMethod;
     this.resultMethod = resultMethod;
     this.isStatic = Modifier.isStatic(initMethod.getModifiers());
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/ListTransientTable.java b/core/src/main/java/org/apache/calcite/schema/impl/ListTransientTable.java
index 05c175111..edf939c84 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/ListTransientTable.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/ListTransientTable.java
@@ -63,7 +63,7 @@ public class ListTransientTable extends AbstractQueryableTable
   @SuppressWarnings("rawtypes")
   private final List rows = new ArrayList();
 
-  @SuppressWarnings({"unused", "FieldCanBeLocal"})
+  @SuppressWarnings({"FieldCanBeLocal", "unused"})
   private final String name;
 
   private final RelDataType protoRowType;
@@ -87,8 +87,8 @@ public ListTransientTable(String name, RelDataType rowType) {
         table, catalogReader, child, operation, updateColumnList, sourceExpressionList, flattened);
   }
 
-  @SuppressWarnings("rawtypes")
-  @Override public Collection getModifiableCollection() {
+  @Override @SuppressWarnings("rawtypes")
+  public Collection getModifiableCollection() {
     return rows;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/LongSchemaVersion.java b/core/src/main/java/org/apache/calcite/schema/impl/LongSchemaVersion.java
index 079dbdeef..379137fe9 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/LongSchemaVersion.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/LongSchemaVersion.java
@@ -20,6 +20,8 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Implementation of SchemaVersion that uses a long value as representation. */
 public class LongSchemaVersion implements SchemaVersion {
   private final long value;
@@ -29,10 +31,10 @@ public LongSchemaVersion(long value) {
   }
 
   @Override public boolean isBefore(SchemaVersion other) {
-    if (!(other instanceof LongSchemaVersion)) {
-      throw new IllegalArgumentException(
-          "Cannot compare a LongSchemaVersion object with a " + other.getClass() + " object.");
-    }
+    checkArgument(
+        (other instanceof LongSchemaVersion),
+        "Cannot compare a LongSchemaVersion object with a %s object.",
+        other.getClass());
 
     return this.value < ((LongSchemaVersion) other).value;
   }
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java b/core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
index f3174cc03..91daed665 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
@@ -30,6 +30,7 @@
 import org.apache.calcite.schema.TableFunction;
 import org.apache.calcite.sql.SqlOperatorBinding;
 
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -53,7 +54,8 @@ private ScalarFunctionImpl(Method method, CallImplementor implementor) {
   /** Creates {@link org.apache.calcite.schema.ScalarFunction} for each method in a given class. */
   @Deprecated // to be removed before 2.0
   public static ImmutableMultimap<String, ScalarFunction> createAll(Class<?> clazz) {
-    final ImmutableMultimap.Builder<String, ScalarFunction> builder = ImmutableMultimap.builder();
+    final ImmutableMultimap.Builder<String, ScalarFunction> builder =
+        ImmutableListMultimap.builder();
     for (Method method : clazz.getMethods()) {
       if (method.getDeclaringClass() == Object.class) {
         continue;
@@ -73,7 +75,7 @@ public static ImmutableMultimap<String, ScalarFunction> createAll(Class<?> clazz
    * org.apache.calcite.schema.TableFunction}.
    */
   public static ImmutableMultimap<String, Function> functions(Class<?> clazz) {
-    final ImmutableMultimap.Builder<String, Function> builder = ImmutableMultimap.builder();
+    final ImmutableMultimap.Builder<String, Function> builder = ImmutableListMultimap.builder();
     for (Method method : clazz.getMethods()) {
       if (method.getDeclaringClass() == Object.class) {
         continue;
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/StarTable.java b/core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
index c57a73396..bb638808c 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/StarTable.java
@@ -41,10 +41,11 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Virtual table that is composed of two or more tables joined together.
  *
@@ -67,7 +68,7 @@ public class StarTable extends AbstractTable implements TranslatableTable {
 
   /** Creates a StarTable. */
   private StarTable(Lattice lattice, ImmutableList<Table> tables) {
-    this.lattice = Objects.requireNonNull(lattice, "lattice");
+    this.lattice = requireNonNull(lattice, "lattice");
     this.tables = tables;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/ViewTable.java b/core/src/main/java/org/apache/calcite/schema/impl/ViewTable.java
index 4a5bade01..07d2912f6 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/ViewTable.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/ViewTable.java
@@ -33,8 +33,6 @@
 import org.apache.calcite.schema.SchemaPlus;
 import org.apache.calcite.schema.TranslatableTable;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Type;
@@ -59,9 +57,9 @@ public ViewTable(
       @Nullable List<String> viewPath) {
     super(elementType);
     this.viewSql = viewSql;
-    this.schemaPath = ImmutableList.copyOf(schemaPath);
+    this.schemaPath = schemaPath;
     this.protoRowType = rowType;
-    this.viewPath = viewPath == null ? null : ImmutableList.copyOf(viewPath);
+    this.viewPath = viewPath == null ? null : viewPath;
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/ViewTableMacro.java b/core/src/main/java/org/apache/calcite/schema/impl/ViewTableMacro.java
index 71fe998ee..6298f170f 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/ViewTableMacro.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/ViewTableMacro.java
@@ -31,7 +31,6 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Type;
-import java.util.Collections;
 import java.util.List;
 
 import static java.util.Objects.requireNonNull;
@@ -66,13 +65,13 @@ public ViewTableMacro(
       @Nullable Boolean modifiable) {
     this.viewSql = viewSql;
     this.schema = schema;
-    this.viewPath = viewPath == null ? null : ImmutableList.copyOf(viewPath);
+    this.viewPath = viewPath == null ? null : viewPath;
     this.modifiable = modifiable;
-    this.schemaPath = schemaPath == null ? null : ImmutableList.copyOf(schemaPath);
+    this.schemaPath = schemaPath == null ? null : schemaPath;
   }
 
   @Override public List<FunctionParameter> getParameters() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Override public TranslatableTable apply(List<? extends @Nullable Object> arguments) {
diff --git a/core/src/main/java/org/apache/calcite/server/DdlExecutorImpl.java b/core/src/main/java/org/apache/calcite/server/DdlExecutorImpl.java
index 1d7a6e326..5e6dea1c2 100644
--- a/core/src/main/java/org/apache/calcite/server/DdlExecutorImpl.java
+++ b/core/src/main/java/org/apache/calcite/server/DdlExecutorImpl.java
@@ -30,7 +30,7 @@ public class DdlExecutorImpl implements DdlExecutor, ReflectiveVisitor {
   protected DdlExecutorImpl() {}
 
   /** Dispatches calls to the appropriate method based on the type of the first argument. */
-  @SuppressWarnings({"method.invocation.invalid", "argument.type.incompatible"})
+  @SuppressWarnings({"argument.type.incompatible", "method.invocation.invalid"})
   private final ReflectUtil.MethodDispatcher<Void> dispatcher =
       ReflectUtil.createMethodDispatcher(
           void.class, this, "execute", SqlNode.class, CalcitePrepare.Context.class);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlAggFunction.java b/core/src/main/java/org/apache/calcite/sql/SqlAggFunction.java
index 9e1a3a20f..a9e7d4492 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlAggFunction.java
@@ -31,7 +31,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Abstract base class for the definition of an aggregate function: an operator which aggregates
@@ -143,7 +144,7 @@ protected SqlAggFunction(
         funcType);
     this.requiresOrder = requiresOrder;
     this.requiresOver = requiresOver;
-    this.requiresGroupOrder = Objects.requireNonNull(requiresGroupOrder, "requiresGroupOrder");
+    this.requiresGroupOrder = requireNonNull(requiresGroupOrder, "requiresGroupOrder");
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlBasicCall.java b/core/src/main/java/org/apache/calcite/sql/SqlBasicCall.java
index 3e4cb8834..b4c165255 100755
--- a/core/src/main/java/org/apache/calcite/sql/SqlBasicCall.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlBasicCall.java
@@ -22,10 +22,11 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /** Implementation of {@link SqlCall} that keeps its operands in an array. */
 public class SqlBasicCall extends SqlCall {
   private SqlOperator operator;
@@ -67,7 +68,7 @@ public SqlBasicCall(
       SqlParserPos pos,
       @Nullable SqlLiteral functionQualifier) {
     super(pos);
-    this.operator = Objects.requireNonNull(operator, "operator");
+    this.operator = requireNonNull(operator, "operator");
     this.operandList = ImmutableNullableList.copyOf(operandList);
     this.functionQuantifier = functionQualifier;
   }
@@ -96,20 +97,20 @@ public SqlCall withExpanded(boolean expanded) {
    * instance, a version where overloading has been resolved); use with care.
    */
   public void setOperator(SqlOperator operator) {
-    this.operator = Objects.requireNonNull(operator, "operator");
+    this.operator = requireNonNull(operator, "operator");
   }
 
   @Override public SqlOperator getOperator() {
     return operator;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return operandList;
   }
 
-  @SuppressWarnings("unchecked")
-  @Override public <S extends SqlNode> S operand(int i) {
+  @Override @SuppressWarnings("unchecked")
+  public <S extends SqlNode> S operand(int i) {
     return (S) castNonNull(operandList.get(i));
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
index 4d271d142..a3732f62a 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
@@ -29,6 +29,8 @@
 import java.nio.charset.Charset;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A sql type name specification of basic sql type.
  *
@@ -216,11 +218,11 @@ public int getPrecision() {
       SqlCollation collation = SqlCollation.COERCIBLE;
 
       Charset charset;
-      if (null == this.charSetName) {
+      if (this.charSetName == null) {
         charset = typeFactory.getDefaultCharset();
       } else {
         String javaCharSetName =
-            Objects.requireNonNull(SqlUtil.translateCharacterSetName(charSetName), charSetName);
+            requireNonNull(SqlUtil.translateCharacterSetName(charSetName), charSetName);
         charset = Charset.forName(javaCharSetName);
       }
       type = typeFactory.createTypeWithCharsetAndCollation(type, charset, collation);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
index caded025f..ca181cd00 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
@@ -134,8 +134,7 @@ private RelDataType convertType(SqlValidator validator, SqlCall call, RelDataTyp
     if (SqlTypeUtil.inCharFamily(operandType0) && SqlTypeUtil.inCharFamily(operandType1)) {
       Charset cs0 = operandType0.getCharset();
       Charset cs1 = operandType1.getCharset();
-      assert (null != cs0) && (null != cs1)
-          : "An implicit or explicit charset should have been set";
+      assert cs0 != null && cs1 != null : "An implicit or explicit charset should have been set";
       if (!cs0.equals(cs1)) {
         throw validator.newValidationError(
             call, RESOURCE.incompatibleCharset(getName(), cs0.name(), cs1.name()));
@@ -143,7 +142,7 @@ private RelDataType convertType(SqlValidator validator, SqlCall call, RelDataTyp
 
       SqlCollation collation0 = operandType0.getCollation();
       SqlCollation collation1 = operandType1.getCollation();
-      assert (null != collation0) && (null != collation1)
+      assert collation0 != null && collation1 != null
           : "An implicit or explicit collation should have been set";
 
       // Validation will occur inside getCoercibilityDyadicOperator...
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlBinaryStringLiteral.java b/core/src/main/java/org/apache/calcite/sql/SqlBinaryStringLiteral.java
index 015963545..4cd0dfbb3 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlBinaryStringLiteral.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlBinaryStringLiteral.java
@@ -22,7 +22,8 @@
 import org.apache.calcite.util.Util;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * A binary (or hexadecimal) string literal.
@@ -51,7 +52,7 @@ public BitString getBitString() {
   }
 
   private BitString getValueNonNull() {
-    return (BitString) Objects.requireNonNull(value, "value");
+    return (BitString) requireNonNull(value, "value");
   }
 
   @Override public SqlBinaryStringLiteral clone(SqlParserPos pos) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCall.java b/core/src/main/java/org/apache/calcite/sql/SqlCall.java
index c5ec59a19..9a86d4397 100755
--- a/core/src/main/java/org/apache/calcite/sql/SqlCall.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCall.java
@@ -32,10 +32,11 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A <code>SqlCall</code> is a call to an {@link SqlOperator operator}. (Operators can be used to
  * describe any syntactic construct, so in practice, every non-leaf node in a SQL parse tree is a
@@ -185,9 +186,8 @@ public int operandCount() {
   protected String getCallSignature(SqlValidator validator, @Nullable SqlValidatorScope scope) {
     List<String> signatureList = new ArrayList<>();
     for (final SqlNode operand : getOperandList()) {
-      final RelDataType argType =
-          validator.deriveType(Objects.requireNonNull(scope, "scope"), operand);
-      if (null == argType) {
+      final RelDataType argType = validator.deriveType(requireNonNull(scope, "scope"), operand);
+      if (argType == null) {
         continue;
       }
       signatureList.add(argType.toString());
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java b/core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
index 309eae28c..83998939e 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
@@ -42,7 +42,6 @@
 import org.apache.calcite.util.Pair;
 
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -106,7 +105,7 @@ public SqlCallBinding(SqlValidator validator, SqlValidatorScope scope, SqlCall c
     if (group != null) {
       int n = 0;
       for (SqlNode groupItem : group) {
-        if (!(groupItem instanceof SqlNodeList) || ((SqlNodeList) groupItem).size() != 0) {
+        if (!(groupItem instanceof SqlNodeList) || !((SqlNodeList) groupItem).isEmpty()) {
           ++n;
         }
       }
@@ -144,7 +143,7 @@ public List<SqlNode> operands() {
         return operandList;
       }
       final SqlOperandCountRange range = checker.getOperandCountRange();
-      final List<SqlNode> list = Lists.newArrayList(operandList);
+      final List<SqlNode> list = new ArrayList<>(operandList);
       while (list.size() < range.getMax()
           && checker.isOptional(list.size())
           && checker.isFixedParameters()) {
@@ -234,15 +233,15 @@ public SqlCall permutedCall() {
     return call.getOperandList().get(ordinal).getMonotonicity(scope);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public @Nullable String getStringLiteralOperand(int ordinal) {
+  @Override @SuppressWarnings("deprecation")
+  public @Nullable String getStringLiteralOperand(int ordinal) {
     SqlNode node = call.operand(ordinal);
     final Object o = SqlLiteral.value(node);
     return o instanceof NlsString ? ((NlsString) o).getValue() : null;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public int getIntLiteralOperand(int ordinal) {
+  @Override @SuppressWarnings("deprecation")
+  public int getIntLiteralOperand(int ordinal) {
     SqlNode node = call.operand(ordinal);
     final Object o = SqlLiteral.value(node);
     if (o instanceof BigDecimal) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCharStringLiteral.java b/core/src/main/java/org/apache/calcite/sql/SqlCharStringLiteral.java
index c37e599c1..3bcaac5af 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlCharStringLiteral.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCharStringLiteral.java
@@ -25,7 +25,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * A character string literal.
@@ -54,7 +55,7 @@ public NlsString getNlsString() {
   }
 
   private NlsString getValueNonNull() {
-    return (NlsString) Objects.requireNonNull(value, "value");
+    return (NlsString) requireNonNull(value, "value");
   }
   /** Returns the collation. */
   public @Nullable SqlCollation getCollation() {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java
index 068b1b7fd..cd6396b00 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java
@@ -133,7 +133,7 @@ public SqlCollation(Coercibility coercibility, Locale locale, Charset charset, S
   }
 
   protected String generateCollationName(@UnderInitialization SqlCollation this, Charset charset) {
-    return charset.name().toUpperCase(Locale.ROOT) + "$" + String.valueOf(locale) + "$" + strength;
+    return charset.name().toUpperCase(Locale.ROOT) + "$" + locale + "$" + strength;
   }
 
   /**
@@ -167,7 +167,7 @@ protected String generateCollationName(@UnderInitialization SqlCollation this, C
   public static SqlCollation getCoercibilityDyadicOperatorThrows(
       SqlCollation col1, SqlCollation col2) {
     SqlCollation ret = getCoercibilityDyadic(col1, col2);
-    if (null == ret) {
+    if (ret == null) {
       throw RESOURCE
           .invalidCompare(
               col1.collationName,
@@ -199,8 +199,8 @@ public static String getCoercibilityDyadicComparison(SqlCollation col1, SqlColla
    */
   protected static @Nullable SqlCollation getCoercibilityDyadic(
       SqlCollation col1, SqlCollation col2) {
-    assert null != col1;
-    assert null != col2;
+    assert col1 != null;
+    assert col2 != null;
     final Coercibility coercibility1 = col1.getCoercibility();
     final Coercibility coercibility2 = col2.getCoercibility();
     switch (coercibility1) {
@@ -293,8 +293,8 @@ public final Locale getLocale() {
    * Returns the {@link Collator} to compare values having the current collation, or {@code null} if
    * no specific {@link Collator} is needed, in which case {@link String#compareTo} will be used.
    */
-  @Pure
   @JsonIgnore
+  @Pure
   public @Nullable Collator getCollator() {
     return null;
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java
index 865e8d472..7cccbb208 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java
@@ -24,7 +24,7 @@
 import org.apache.calcite.util.Litmus;
 import org.apache.calcite.util.Util;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * A sql type name specification of collection type.
@@ -73,8 +73,8 @@ public class SqlCollectionTypeNameSpec extends SqlTypeNameSpec {
   public SqlCollectionTypeNameSpec(
       SqlTypeNameSpec elementTypeName, SqlTypeName collectionTypeName, SqlParserPos pos) {
     super(new SqlIdentifier(collectionTypeName.name(), pos), pos);
-    this.elementTypeName = Objects.requireNonNull(elementTypeName, "elementTypeName");
-    this.collectionTypeName = Objects.requireNonNull(collectionTypeName, "collectionTypeName");
+    this.elementTypeName = requireNonNull(elementTypeName, "elementTypeName");
+    this.collectionTypeName = requireNonNull(collectionTypeName, "collectionTypeName");
   }
 
   public SqlTypeNameSpec getElementTypeName() {
@@ -99,7 +99,7 @@ public SqlTypeNameSpec getElementTypeName() {
     if (!this.elementTypeName.equalsDeep(that.elementTypeName, litmus)) {
       return litmus.fail("{} != {}", this, spec);
     }
-    if (!Objects.equals(this.collectionTypeName, that.collectionTypeName)) {
+    if (this.collectionTypeName != that.collectionTypeName) {
       return litmus.fail("{} != {}", this, spec);
     }
     return litmus.succeed();
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
index a878d111e..55715bc6e 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
@@ -229,8 +229,7 @@ public RelDataType deriveType(SqlValidator validator, boolean nullable) {
 
     // Fix-up the nullability, default is false.
     final RelDataTypeFactory typeFactory = validator.getTypeFactory();
-    type = fixUpNullability(typeFactory, type, nullable);
-    return type;
+    return fixUpNullability(typeFactory, type, nullable);
   }
 
   // ~ Tools ------------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDateLiteral.java b/core/src/main/java/org/apache/calcite/sql/SqlDateLiteral.java
index f769211cd..92624f1e8 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDateLiteral.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDateLiteral.java
@@ -22,7 +22,7 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.DateString;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * A SQL literal representing a DATE value, such as <code>DATE
@@ -41,7 +41,7 @@ public class SqlDateLiteral extends SqlAbstractDateTimeLiteral {
 
   /** Converts this literal to a {@link DateString}. */
   protected DateString getDate() {
-    return (DateString) Objects.requireNonNull(value, "value");
+    return (DateString) requireNonNull(value, "value");
   }
 
   @Override public SqlDateLiteral clone(SqlParserPos pos) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDdl.java b/core/src/main/java/org/apache/calcite/sql/SqlDdl.java
index 5480fb757..923118e93 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDdl.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDdl.java
@@ -18,7 +18,7 @@
 
 import org.apache.calcite.sql.parser.SqlParserPos;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** Base class for CREATE, DROP and other DDL statements. */
 public abstract class SqlDdl extends SqlCall {
@@ -31,7 +31,7 @@ public abstract class SqlDdl extends SqlCall {
   /** Creates a SqlDdl. */
   protected SqlDdl(SqlOperator operator, SqlParserPos pos) {
     super(pos);
-    this.operator = Objects.requireNonNull(operator, "operator");
+    this.operator = requireNonNull(operator, "operator");
   }
 
   @Override public SqlOperator getOperator() {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDelete.java b/core/src/main/java/org/apache/calcite/sql/SqlDelete.java
index 3b71dec0b..0af01d15a 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDelete.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDelete.java
@@ -61,13 +61,13 @@ public SqlDelete(
     return OPERATOR;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(targetTable, condition, alias);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         targetTable = operand;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDescribeSchema.java b/core/src/main/java/org/apache/calcite/sql/SqlDescribeSchema.java
index 1fbed4110..6174e2943 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDescribeSchema.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDescribeSchema.java
@@ -31,8 +31,8 @@ public class SqlDescribeSchema extends SqlCall {
 
   public static final SqlSpecialOperator OPERATOR =
       new SqlSpecialOperator("DESCRIBE_SCHEMA", SqlKind.DESCRIBE_SCHEMA) {
-        @SuppressWarnings("argument.type.incompatible")
-        @Override public SqlCall createCall(
+        @Override @SuppressWarnings("argument.type.incompatible")
+        public SqlCall createCall(
             @Nullable SqlLiteral functionQualifier,
             SqlParserPos pos,
             @Nullable SqlNode... operands) {
@@ -54,8 +54,8 @@ public SqlDescribeSchema(SqlParserPos pos, SqlIdentifier schema) {
     schema.unparse(writer, leftPrec, rightPrec);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         schema = (SqlIdentifier) operand;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDescribeTable.java b/core/src/main/java/org/apache/calcite/sql/SqlDescribeTable.java
index e70bc6018..fe58b02d1 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDescribeTable.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDescribeTable.java
@@ -22,7 +22,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * A <code>SqlDescribeTable</code> is a node of a parse tree that represents a {@code DESCRIBE
@@ -32,8 +33,8 @@ public class SqlDescribeTable extends SqlCall {
 
   public static final SqlSpecialOperator OPERATOR =
       new SqlSpecialOperator("DESCRIBE_TABLE", SqlKind.DESCRIBE_TABLE) {
-        @SuppressWarnings("argument.type.incompatible")
-        @Override public SqlCall createCall(
+        @Override @SuppressWarnings("argument.type.incompatible")
+        public SqlCall createCall(
             @Nullable SqlLiteral functionQualifier,
             SqlParserPos pos,
             @Nullable SqlNode... operands) {
@@ -48,7 +49,7 @@ public class SqlDescribeTable extends SqlCall {
   /** Creates a SqlDescribeTable. */
   public SqlDescribeTable(SqlParserPos pos, SqlIdentifier table, @Nullable SqlIdentifier column) {
     super(pos);
-    this.table = Objects.requireNonNull(table, "table");
+    this.table = requireNonNull(table, "table");
     this.column = column;
   }
 
@@ -61,8 +62,8 @@ public SqlDescribeTable(SqlParserPos pos, SqlIdentifier table, @Nullable SqlIden
     }
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         table = (SqlIdentifier) operand;
@@ -79,8 +80,8 @@ public SqlDescribeTable(SqlParserPos pos, SqlIdentifier table, @Nullable SqlIden
     return OPERATOR;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(table, column);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDialect.java b/core/src/main/java/org/apache/calcite/sql/SqlDialect.java
index b4f53db3a..d32841253 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDialect.java
@@ -41,7 +41,6 @@
 import org.apache.calcite.util.format.FormatModel;
 import org.apache.calcite.util.format.FormatModels;
 
-import com.google.common.base.Preconditions;
 import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableSet;
 
@@ -59,6 +58,8 @@
 import java.util.Set;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.DateTimeStringUtils.getDateFormatter;
 
 import static java.util.Objects.requireNonNull;
@@ -522,7 +523,7 @@ public void unparseSqlIntervalQualifier(
         writer.keyword(start);
       }
 
-      if (null != qualifier.timeUnitRange.endUnit) {
+      if (qualifier.timeUnitRange.endUnit != null) {
         writer.keyword("TO");
         final String end = qualifier.timeUnitRange.endUnit.name();
         if ((TimeUnit.SECOND == qualifier.timeUnitRange.endUnit)
@@ -977,7 +978,7 @@ public void unparseTopN(SqlWriter writer, @Nullable SqlNode offset, @Nullable Sq
    */
   protected static void unparseFetchUsingAnsi(
       SqlWriter writer, @Nullable SqlNode offset, @Nullable SqlNode fetch) {
-    Preconditions.checkArgument(fetch != null || offset != null);
+    checkArgument(fetch != null || offset != null);
     if (offset != null) {
       writer.newlineAndIndent();
       final SqlWriter.Frame offsetFrame = writer.startList(SqlWriter.FrameTypeEnum.OFFSET);
@@ -1001,7 +1002,7 @@ protected static void unparseFetchUsingAnsi(
   /** Unparses offset/fetch using "LIMIT fetch OFFSET offset" syntax. */
   protected static void unparseFetchUsingLimit(
       SqlWriter writer, @Nullable SqlNode offset, @Nullable SqlNode fetch) {
-    Preconditions.checkArgument(fetch != null || offset != null);
+    checkArgument(fetch != null || offset != null);
     unparseLimit(writer, fetch);
     unparseOffset(writer, offset);
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDialects.java b/core/src/main/java/org/apache/calcite/sql/SqlDialects.java
index 88866cd3a..27338e110 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDialects.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDialects.java
@@ -52,19 +52,16 @@ public static SqlDialect.Context createContext(DatabaseMetaData databaseMetaData
     final Casing unquotedCasing = getCasing(databaseMetaData, false);
     final Casing quotedCasing = getCasing(databaseMetaData, true);
     final boolean caseSensitive = isCaseSensitive(databaseMetaData);
-    final SqlDialect.Context c =
-        SqlDialect.EMPTY_CONTEXT
-            .withDatabaseProductName(databaseProductName)
-            .withDatabaseMajorVersion(databaseMajorVersion)
-            .withDatabaseMinorVersion(databaseMinorVersion)
-            .withDatabaseVersion(databaseVersion)
-            .withIdentifierQuoteString(quoteString)
-            .withUnquotedCasing(unquotedCasing)
-            .withQuotedCasing(quotedCasing)
-            .withCaseSensitive(caseSensitive)
-            .withNullCollation(nullCollation);
-
-    return c;
+    return SqlDialect.EMPTY_CONTEXT
+        .withDatabaseProductName(databaseProductName)
+        .withDatabaseMajorVersion(databaseMajorVersion)
+        .withDatabaseMinorVersion(databaseMinorVersion)
+        .withDatabaseVersion(databaseVersion)
+        .withIdentifierQuoteString(quoteString)
+        .withUnquotedCasing(unquotedCasing)
+        .withQuotedCasing(quotedCasing)
+        .withCaseSensitive(caseSensitive)
+        .withNullCollation(nullCollation);
   }
 
   private static String getIdentifierQuoteString(DatabaseMetaData databaseMetaData) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlExplain.java b/core/src/main/java/org/apache/calcite/sql/SqlExplain.java
index fa1e1ad2e..984393428 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlExplain.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlExplain.java
@@ -30,8 +30,8 @@
 public class SqlExplain extends SqlCall {
   public static final SqlSpecialOperator OPERATOR =
       new SqlSpecialOperator("EXPLAIN", SqlKind.EXPLAIN) {
-        @SuppressWarnings("argument.type.incompatible")
-        @Override public SqlCall createCall(
+        @Override @SuppressWarnings("argument.type.incompatible")
+        public SqlCall createCall(
             @Nullable SqlLiteral functionQualifier,
             SqlParserPos pos,
             @Nullable SqlNode... operands) {
@@ -93,8 +93,8 @@ public SqlExplain(
     return ImmutableNullableList.of(explicandum, detailLevel, depth, format);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         explicandum = operand;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlFilterOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlFilterOperator.java
index 53902d694..9ed875948 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlFilterOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlFilterOperator.java
@@ -25,10 +25,10 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 
-import java.util.Objects;
-
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * An operator that applies a filter before rows are included in an aggregate function.
  *
@@ -82,7 +82,7 @@ public SqlFilterOperator() {
     validator.validateAggregateParams(
         aggCall, flat.filter, flat.distinctList, flat.orderList, scope);
 
-    final SqlNode filter = Objects.requireNonNull(flat.filter);
+    final SqlNode filter = requireNonNull(flat.filter);
     final RelDataType type = validator.deriveType(scope, filter);
     if (!SqlTypeUtil.inBooleanFamily(type)) {
       throw validator.newValidationError(filter, RESOURCE.condMustBeBoolean("FILTER"));
@@ -114,10 +114,10 @@ public SqlFilterOperator() {
     validator1.setValidatedNodeType(call, ret);
     validator1.setValidatedNodeType(aggCall, ret);
     if (flat.distinctList != null) {
-      validator1.setValidatedNodeType(Objects.requireNonNull(flat.distinctCall), ret);
+      validator1.setValidatedNodeType(requireNonNull(flat.distinctCall), ret);
     }
     if (flat.orderList != null) {
-      validator1.setValidatedNodeType(Objects.requireNonNull(flat.orderCall), ret);
+      validator1.setValidatedNodeType(requireNonNull(flat.orderCall), ret);
     }
     return ret;
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlFunction.java b/core/src/main/java/org/apache/calcite/sql/SqlFunction.java
index fce0b906e..c67e11b12 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlFunction.java
@@ -34,11 +34,12 @@
 import org.checkerframework.dataflow.qual.Pure;
 
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /** A <code>SqlFunction</code> is a type of operator which has conventional function-call syntax. */
 public class SqlFunction extends SqlOperator {
 
@@ -136,7 +137,7 @@ protected SqlFunction(
     super(name, kind, 100, 100, returnTypeInference, operandTypeInference, operandTypeChecker);
 
     this.sqlIdentifier = sqlIdentifier;
-    this.category = Objects.requireNonNull(category, "category");
+    this.category = requireNonNull(category, "category");
   }
 
   // ~ Methods ----------------------------------------------------------------
@@ -213,7 +214,7 @@ public boolean isQuantifierAllowed() {
   /** Throws a validation error if a DISTINCT or ALL quantifier is present but not allowed. */
   protected void validateQuantifier(SqlValidator validator, SqlCall call) {
     SqlLiteral functionQuantifier = call.getFunctionQuantifier();
-    if ((null != functionQuantifier) && !isQuantifierAllowed()) {
+    if (functionQuantifier != null && !isQuantifierAllowed()) {
       throw validator.newValidationError(
           functionQuantifier, RESOURCE.functionQuantifierNotAllowed(call.getOperator().getName()));
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlGroupedWindowFunction.java b/core/src/main/java/org/apache/calcite/sql/SqlGroupedWindowFunction.java
index e7d50377f..a6062a603 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlGroupedWindowFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlGroupedWindowFunction.java
@@ -22,13 +22,14 @@
 import org.apache.calcite.sql.type.SqlReturnTypeInference;
 import org.apache.calcite.sql.validate.SqlMonotonicity;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * SQL function that computes keys by which rows can be partitioned and aggregated.
  *
@@ -74,7 +75,7 @@ public SqlGroupedWindowFunction(
       SqlFunctionCategory category) {
     super(name, kind, returnTypeInference, operandTypeInference, operandTypeChecker, category);
     this.groupFunction = groupFunction;
-    Preconditions.checkArgument(groupFunction == null || groupFunction.groupFunction == null);
+    checkArgument(groupFunction == null || groupFunction.groupFunction == null);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlHint.java b/core/src/main/java/org/apache/calcite/sql/SqlHint.java
index 1c737c78d..ae79ccde4 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlHint.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlHint.java
@@ -117,7 +117,7 @@ public HintOptionFormat getOptionFormat() {
    */
   public List<String> getOptionList() {
     if (optionFormat == HintOptionFormat.ID_LIST) {
-      return ImmutableList.copyOf(SqlIdentifier.simpleNames(options));
+      return SqlIdentifier.simpleNames(options);
     } else if (optionFormat == HintOptionFormat.LITERAL_LIST) {
       return options.stream()
           .map(
@@ -143,7 +143,7 @@ public Map<String, String> getOptionKVPairs() {
         final SqlNode v = options.get(i + 1);
         attrs.put(getOptionKeyAsString(k), ((SqlLiteral) v).getValueAs(String.class));
       }
-      return ImmutableMap.copyOf(attrs);
+      return attrs;
     } else {
       return ImmutableMap.of();
     }
@@ -151,7 +151,7 @@ public Map<String, String> getOptionKVPairs() {
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
     name.unparse(writer, leftPrec, rightPrec);
-    if (this.options.size() > 0) {
+    if (!this.options.isEmpty()) {
       SqlWriter.Frame frame = writer.startList(SqlWriter.FrameTypeEnum.FUN_CALL, "(", ")");
       for (int i = 0; i < options.size(); i++) {
         SqlNode option = options.get(i);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlInsert.java b/core/src/main/java/org/apache/calcite/sql/SqlInsert.java
index ab2cdafd0..d3b798ee3 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlInsert.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlInsert.java
@@ -30,8 +30,8 @@
 public class SqlInsert extends SqlCall {
   public static final SqlSpecialOperator OPERATOR =
       new SqlSpecialOperator("INSERT", SqlKind.INSERT) {
-        @SuppressWarnings("argument.type.incompatible")
-        @Override public SqlCall createCall(
+        @Override @SuppressWarnings("argument.type.incompatible")
+        public SqlCall createCall(
             @Nullable SqlLiteral functionQualifier,
             SqlParserPos pos,
             @Nullable SqlNode... operands) {
@@ -71,8 +71,8 @@ public SqlInsert(
     return OPERATOR;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(keywords, targetTable, source, columnList);
   }
 
@@ -87,8 +87,8 @@ public final boolean isUpsert() {
     return getModifierNode(SqlInsertKeyword.UPSERT) != null;
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         keywords = (SqlNodeList) operand;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlIntervalLiteral.java b/core/src/main/java/org/apache/calcite/sql/SqlIntervalLiteral.java
index e1c9db9d1..6bac11c20 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlIntervalLiteral.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlIntervalLiteral.java
@@ -68,8 +68,8 @@ private SqlIntervalLiteral(
     writer.getDialect().unparseSqlIntervalLiteral(writer, this, leftPrec, rightPrec);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public int signum() {
+  @Override @SuppressWarnings("deprecation")
+  public int signum() {
     return ((IntervalValue) castNonNull(value)).signum();
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java b/core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
index 72617a912..d6453835f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
@@ -471,7 +471,7 @@ private void checkLeadFieldInRange(
 
   private static final BigDecimal[] POWERS10 = {
     ZERO,
-    BigDecimal.valueOf(10),
+    BigDecimal.TEN,
     BigDecimal.valueOf(100),
     BigDecimal.valueOf(1000),
     BigDecimal.valueOf(10000),
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java b/core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
index 70b35e4e7..613214a13 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
@@ -496,14 +496,14 @@ private static String constructFuncList(String... functionNames) {
   }
 
   @Override public SqlNode rewriteCall(SqlValidator validator, SqlCall call) {
-    if (null == lookupMakeCallObj) {
+    if (lookupMakeCallObj == null) {
       throw validator.newValidationError(call, RESOURCE.functionUndefined(getName()));
     }
     return lookupMakeCallObj.getOperator().rewriteCall(validator, call);
   }
 
   public SqlCall getLookupCall() {
-    if (null == lookupCall) {
+    if (lookupCall == null) {
       lookupCall =
           requireNonNull(lookupMakeCallObj, "lookupMakeCallObj")
               .createCall(SqlParserPos.ZERO, requireNonNull(thisOperands, "thisOperands"));
@@ -534,7 +534,7 @@ public SqlCall getLookupCall() {
     // only expected to come here if validator called this method
     SqlCallBinding callBinding = (SqlCallBinding) opBinding;
 
-    if (null == lookupMakeCallObj) {
+    if (lookupMakeCallObj == null) {
       throw callBinding.newValidationError(RESOURCE.functionUndefined(getName()));
     }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlJoin.java b/core/src/main/java/org/apache/calcite/sql/SqlJoin.java
index 60f479198..5289d8ea6 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlJoin.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlJoin.java
@@ -22,13 +22,13 @@
 import org.apache.calcite.util.ImmutableNullableList;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
 import java.util.function.UnaryOperator;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Parse tree node representing a {@code JOIN} clause. */
@@ -69,7 +69,7 @@ public SqlJoin(
     this.conditionType = requireNonNull(conditionType, "conditionType");
     this.condition = condition;
 
-    Preconditions.checkArgument(natural.getTypeName() == SqlTypeName.BOOLEAN);
+    checkArgument(natural.getTypeName() == SqlTypeName.BOOLEAN);
     conditionType.getValueAs(JoinConditionType.class);
     joinType.getValueAs(JoinType.class);
   }
@@ -90,13 +90,13 @@ public SqlJoin(
     return SqlKind.JOIN;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(left, natural, joinType, right, conditionType, condition);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         left = operand;
@@ -187,8 +187,8 @@ private SqlJoinOperator(String name, int prec) {
       return SqlSyntax.SPECIAL;
     }
 
-    @SuppressWarnings("argument.type.incompatible")
-    @Override public SqlCall createCall(
+    @Override @SuppressWarnings("argument.type.incompatible")
+    public SqlCall createCall(
         @Nullable SqlLiteral functionQualifier, SqlParserPos pos, @Nullable SqlNode... operands) {
       assert functionQualifier == null;
       return new SqlJoin(
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlLiteral.java b/core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
index f1f174868..c6effd9b3 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
@@ -721,7 +721,7 @@ public RelDataType createSqlType(RelDataTypeFactory typeFactory) {
       case NULL:
       case BOOLEAN:
         RelDataType ret = typeFactory.createSqlType(typeName);
-        ret = typeFactory.createTypeWithNullability(ret, null == value);
+        ret = typeFactory.createTypeWithNullability(ret, value == null);
         return ret;
       case BINARY:
         bitString = (BitString) requireNonNull(value, "value");
@@ -730,11 +730,11 @@ public RelDataType createSqlType(RelDataTypeFactory typeFactory) {
       case CHAR:
         NlsString string = (NlsString) requireNonNull(value, "value");
         Charset charset = string.getCharset();
-        if (null == charset) {
+        if (charset == null) {
           charset = typeFactory.getDefaultCharset();
         }
         SqlCollation collation = string.getCollation();
-        if (null == collation) {
+        if (collation == null) {
           collation = SqlCollation.COERCIBLE;
         }
         RelDataType type = typeFactory.createSqlType(SqlTypeName.CHAR, string.getValue().length());
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java b/core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java
index b64cd2b89..9e47972c6 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java
@@ -23,12 +23,13 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.ImmutableNullableList;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
 
 /** SqlNode for MATCH_RECOGNIZE clause. */
 public class SqlMatchRecognize extends SqlCall {
@@ -82,20 +83,19 @@ public SqlMatchRecognize(
       SqlNodeList orderList,
       @Nullable SqlLiteral interval) {
     super(pos);
-    this.tableRef = Objects.requireNonNull(tableRef, "tableRef");
-    this.pattern = Objects.requireNonNull(pattern, "pattern");
+    this.tableRef = requireNonNull(tableRef, "tableRef");
+    this.pattern = requireNonNull(pattern, "pattern");
     this.strictStart = strictStart;
     this.strictEnd = strictEnd;
-    this.patternDefList = Objects.requireNonNull(patternDefList, "patternDefList");
-    Preconditions.checkArgument(patternDefList.size() > 0);
-    this.measureList = Objects.requireNonNull(measureList, "measureList");
+    this.patternDefList = requireNonNull(patternDefList, "patternDefList");
+    checkArgument(!patternDefList.isEmpty());
+    this.measureList = requireNonNull(measureList, "measureList");
     this.after = after;
     this.subsetList = subsetList;
-    Preconditions.checkArgument(
-        rowsPerMatch == null || rowsPerMatch.value instanceof RowsPerMatchOption);
+    checkArgument(rowsPerMatch == null || rowsPerMatch.value instanceof RowsPerMatchOption);
     this.rowsPerMatch = rowsPerMatch;
-    this.partitionList = Objects.requireNonNull(partitionList, "partitionList");
-    this.orderList = Objects.requireNonNull(orderList, "orderList");
+    this.partitionList = requireNonNull(partitionList, "partitionList");
+    this.orderList = requireNonNull(orderList, "orderList");
     this.interval = interval;
   }
 
@@ -109,8 +109,8 @@ public SqlMatchRecognize(
     return SqlKind.MATCH_RECOGNIZE;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(
         tableRef,
         pattern,
@@ -134,11 +134,11 @@ public SqlMatchRecognize(
     validator.validateMatchRecognize(this);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case OPERAND_TABLE_REF:
-        tableRef = Objects.requireNonNull(operand, "operand");
+        tableRef = requireNonNull(operand, "operand");
         break;
       case OPERAND_PATTERN:
         pattern = operand;
@@ -150,11 +150,11 @@ public SqlMatchRecognize(
         strictEnd = (SqlLiteral) operand;
         break;
       case OPERAND_PATTERN_DEFINES:
-        patternDefList = Objects.requireNonNull((SqlNodeList) operand);
-        Preconditions.checkArgument(patternDefList.size() > 0);
+        patternDefList = requireNonNull((SqlNodeList) operand);
+        checkArgument(!patternDefList.isEmpty());
         break;
       case OPERAND_MEASURES:
-        measureList = Objects.requireNonNull((SqlNodeList) operand);
+        measureList = requireNonNull((SqlNodeList) operand);
         break;
       case OPERAND_AFTER:
         after = operand;
@@ -164,8 +164,7 @@ public SqlMatchRecognize(
         break;
       case OPERAND_ROWS_PER_MATCH:
         rowsPerMatch = (SqlLiteral) operand;
-        Preconditions.checkArgument(
-            rowsPerMatch == null || rowsPerMatch.value instanceof RowsPerMatchOption);
+        checkArgument(rowsPerMatch == null || rowsPerMatch.value instanceof RowsPerMatchOption);
         break;
       case OPERAND_PARTITION_BY:
         partitionList = (SqlNodeList) operand;
@@ -277,8 +276,8 @@ private SqlMatchRecognizeOperator() {
       return SqlSyntax.SPECIAL;
     }
 
-    @SuppressWarnings("argument.type.incompatible")
-    @Override public SqlCall createCall(
+    @Override @SuppressWarnings("argument.type.incompatible")
+    public SqlCall createCall(
         @Nullable SqlLiteral functionQualifier, SqlParserPos pos, @Nullable SqlNode... operands) {
       assert functionQualifier == null;
       assert operands.length == 12;
@@ -332,7 +331,7 @@ private SqlMatchRecognizeOperator() {
       pattern.tableRef.unparse(writer, 0, 0);
       final SqlWriter.Frame mrFrame = writer.startFunCall("MATCH_RECOGNIZE");
 
-      if (pattern.partitionList != null && pattern.partitionList.size() > 0) {
+      if (pattern.partitionList != null && !pattern.partitionList.isEmpty()) {
         writer.newlineAndIndent();
         writer.sep("PARTITION BY");
         final SqlWriter.Frame partitionFrame = writer.startList("", "");
@@ -340,13 +339,13 @@ private SqlMatchRecognizeOperator() {
         writer.endList(partitionFrame);
       }
 
-      if (pattern.orderList != null && pattern.orderList.size() > 0) {
+      if (pattern.orderList != null && !pattern.orderList.isEmpty()) {
         writer.newlineAndIndent();
         writer.sep("ORDER BY");
         writer.list(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, SqlWriter.COMMA, pattern.orderList);
       }
 
-      if (pattern.measureList != null && pattern.measureList.size() > 0) {
+      if (pattern.measureList != null && !pattern.measureList.isEmpty()) {
         writer.newlineAndIndent();
         writer.sep("MEASURES");
         final SqlWriter.Frame measureFrame = writer.startList("", "");
@@ -385,7 +384,7 @@ private SqlMatchRecognizeOperator() {
         interval.unparse(writer, 0, 0);
       }
 
-      if (pattern.subsetList != null && pattern.subsetList.size() > 0) {
+      if (pattern.subsetList != null && !pattern.subsetList.isEmpty()) {
         writer.newlineAndIndent();
         writer.sep("SUBSET");
         SqlWriter.Frame subsetFrame = writer.startList("", "");
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlMerge.java b/core/src/main/java/org/apache/calcite/sql/SqlMerge.java
index 3e082fdc3..b7001913b 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlMerge.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlMerge.java
@@ -71,14 +71,14 @@ public SqlMerge(
     return SqlKind.MERGE;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<@Nullable SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<@Nullable SqlNode> getOperandList() {
     return ImmutableNullableList.of(
         targetTable, condition, source, updateCall, insertCall, sourceSelect, alias);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         assert operand instanceof SqlIdentifier;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlNode.java b/core/src/main/java/org/apache/calcite/sql/SqlNode.java
index 4b3609c47..10d26895b 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlNode.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlNode.java
@@ -33,11 +33,12 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 import java.util.function.UnaryOperator;
 import java.util.stream.Collector;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A <code>SqlNode</code> is a SQL parse tree.
  *
@@ -61,7 +62,7 @@ public abstract class SqlNode implements Cloneable {
    * @param pos Parser position, must not be null.
    */
   SqlNode(SqlParserPos pos) {
-    this.pos = Objects.requireNonNull(pos, "pos");
+    this.pos = requireNonNull(pos, "pos");
   }
 
   // ~ Methods ----------------------------------------------------------------
@@ -72,8 +73,8 @@ public abstract class SqlNode implements Cloneable {
    *     early versions of Java
    */
   @Deprecated
-  @SuppressWarnings({"MethodDoesntCallSuperMethod", "AmbiguousMethodReference"})
-  @Override public Object clone() {
+  @Override @SuppressWarnings({"AmbiguousMethodReference", "MethodDoesntCallSuperMethod"})
+  public Object clone() {
     return clone(getParserPosition());
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlNodeList.java b/core/src/main/java/org/apache/calcite/sql/SqlNodeList.java
index 3b4c97c51..f15f55f9d 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlNodeList.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlNodeList.java
@@ -32,12 +32,13 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
-import java.util.Objects;
 import java.util.RandomAccess;
 import java.util.function.Consumer;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A <code>SqlNodeList</code> is a list of {@link SqlNode}s. It is also a {@link SqlNode}, so may
  * appear in a parse tree.
@@ -74,7 +75,7 @@ public class SqlNodeList extends SqlNode implements List<SqlNode>, RandomAccess
    */
   private SqlNodeList(SqlParserPos pos, List<@Nullable SqlNode> list) {
     super(pos);
-    this.list = Objects.requireNonNull(list, "list");
+    this.list = requireNonNull(list, "list");
   }
 
   /** Creates a SqlNodeList that is initially empty. */
@@ -122,28 +123,28 @@ public static SqlNodeList of(SqlParserPos pos, List<@Nullable SqlNode> list) {
     ((List<SqlNode>) list).forEach(action);
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public Iterator</*Nullable*/ SqlNode> iterator() {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public Iterator</*Nullable*/ SqlNode> iterator() {
     return list.iterator();
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public ListIterator</*Nullable*/ SqlNode> listIterator() {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public ListIterator</*Nullable*/ SqlNode> listIterator() {
     return list.listIterator();
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public ListIterator</*Nullable*/ SqlNode> listIterator(int index) {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public ListIterator</*Nullable*/ SqlNode> listIterator(int index) {
     return list.listIterator(index);
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public List</*Nullable*/ SqlNode> subList(int fromIndex, int toIndex) {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public List</*Nullable*/ SqlNode> subList(int fromIndex, int toIndex) {
     return list.subList(fromIndex, toIndex);
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public /*Nullable*/ SqlNode get(int n) {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public /*Nullable*/ SqlNode get(int n) {
     return list.get(n);
   }
 
@@ -167,15 +168,15 @@ public static SqlNodeList of(SqlParserPos pos, List<@Nullable SqlNode> list) {
     return list.lastIndexOf(o);
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public Object[] toArray() {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public Object[] toArray() {
     // Per JDK specification, must return an Object[] not SqlNode[]; see e.g.
     // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652
     return list.toArray();
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public <T> @Nullable T[] toArray(T @Nullable [] a) {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public <T> @Nullable T[] toArray(T @Nullable [] a) {
     return list.toArray(a);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlNullTreatmentOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlNullTreatmentOperator.java
index cb68dbfdc..8b77ce856 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlNullTreatmentOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlNullTreatmentOperator.java
@@ -23,10 +23,10 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.ImmutableNullableList;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
@@ -41,7 +41,7 @@
 public class SqlNullTreatmentOperator extends SqlSpecialOperator {
   public SqlNullTreatmentOperator(SqlKind kind) {
     super(kind.sql, kind, 20, true, ReturnTypes.ARG0, null, OperandTypes.ANY);
-    Preconditions.checkArgument(kind == SqlKind.RESPECT_NULLS || kind == SqlKind.IGNORE_NULLS);
+    checkArgument(kind == SqlKind.RESPECT_NULLS || kind == SqlKind.IGNORE_NULLS);
   }
 
   @Override public SqlCall createCall(
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlOperator.java
index 3c70aa85e..95dad2d50 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlOperator.java
@@ -47,6 +47,8 @@
 import java.util.Objects;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -462,13 +464,11 @@ protected void preValidateCall(SqlValidator validator, SqlValidatorScope scope,
   public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
     if (returnTypeInference != null) {
       RelDataType returnType = returnTypeInference.inferReturnType(opBinding);
-      if (returnType == null) {
-        throw new IllegalArgumentException(
-            "Cannot infer return type for "
-                + opBinding.getOperator()
-                + "; operand types: "
-                + opBinding.collectOperandTypes());
-      }
+      checkArgument(
+          returnType != null,
+          "Cannot infer return type for %s; operand types: %s",
+          opBinding.getOperator(),
+          opBinding.collectOperandTypes());
 
       if (operandTypeInference != null
           && opBinding instanceof SqlCallBinding
@@ -656,7 +656,7 @@ public final RelDataType inferReturnType(
    */
   public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
     // Check that all of the operands are of the right type.
-    if (null == operandTypeChecker) {
+    if (operandTypeChecker == null) {
       // If you see this you must either give operandTypeChecker a value
       // or override this method.
       throw Util.needToImplement(this);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlOrderBy.java b/core/src/main/java/org/apache/calcite/sql/SqlOrderBy.java
index e0a830ab2..575d1e8cc 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlOrderBy.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlOrderBy.java
@@ -34,8 +34,8 @@
 public class SqlOrderBy extends SqlCall {
   public static final SqlSpecialOperator OPERATOR =
       new Operator() {
-        @SuppressWarnings("argument.type.incompatible")
-        @Override public SqlCall createCall(
+        @Override @SuppressWarnings("argument.type.incompatible")
+        public SqlCall createCall(
             @Nullable SqlLiteral functionQualifier,
             SqlParserPos pos,
             @Nullable SqlNode... operands) {
@@ -74,8 +74,8 @@ public SqlOrderBy(
     return OPERATOR;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(query, orderList, offset, fetch);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
index 6afbbd813..05fc110a6 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
@@ -25,6 +25,8 @@
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
@@ -89,10 +91,11 @@ public SqlOverOperator() {
     // can be empty
     SqlNode agg = call.operand(0);
 
-    if (!(agg instanceof SqlCall)) {
-      throw new IllegalStateException(
-          "Argument to SqlOverOperator" + " should be SqlCall, got " + agg.getClass() + ": " + agg);
-    }
+    checkState(
+        (agg instanceof SqlCall),
+        "Argument to SqlOverOperator should be SqlCall, got %s: %s",
+        agg.getClass(),
+        agg);
 
     SqlNode window = call.operand(1);
     SqlWindow w = validator.resolveWindow(window, scope);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlPivot.java b/core/src/main/java/org/apache/calcite/sql/SqlPivot.java
index c1f841bf8..26452ebeb 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlPivot.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlPivot.java
@@ -30,12 +30,11 @@
 
 import java.util.HashSet;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 import java.util.function.BiConsumer;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.joining;
 
 /**
  * Parse tree node that represents a PIVOT applied to a table reference (or sub-query).
@@ -66,10 +65,10 @@ public SqlPivot(
       SqlNodeList axisList,
       SqlNodeList inList) {
     super(pos);
-    this.query = Objects.requireNonNull(query, "query");
-    this.aggList = Objects.requireNonNull(aggList, "aggList");
-    this.axisList = Objects.requireNonNull(axisList, "axisList");
-    this.inList = Objects.requireNonNull(inList, "inList");
+    this.query = requireNonNull(query, "query");
+    this.aggList = requireNonNull(aggList, "aggList");
+    this.axisList = requireNonNull(axisList, "axisList");
+    this.inList = requireNonNull(inList, "inList");
   }
 
   // ~ Methods ----------------------------------------------------------------
@@ -82,8 +81,8 @@ public SqlPivot(
     return ImmutableNullableList.of(query, aggList, axisList, inList);
   }
 
-  @SuppressWarnings("nullness")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("nullness")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     // Only 'query' is mutable. (It is required for validation.)
     switch (i) {
       case 0:
@@ -156,8 +155,7 @@ public void forEachNameValues(BiConsumer<String, SqlNodeList> consumer) {
 
   static String pivotAlias(SqlNode node) {
     if (node instanceof SqlNodeList) {
-      return ((SqlNodeList) node)
-          .stream().map(SqlPivot::pivotAlias).collect(Collectors.joining("_"));
+      return ((SqlNodeList) node).stream().map(SqlPivot::pivotAlias).collect(joining("_"));
     }
     return node.toString();
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
index 6585be6af..55b2b182c 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
@@ -66,12 +66,12 @@ public SqlPostfixOperator(
       // Determine coercibility and resulting collation name of
       // unary operator if needed.
       RelDataType operandType = validator.getValidatedNodeType(call.operand(0));
-      if (null == operandType) {
+      if (operandType == null) {
         throw new AssertionError("operand's type should have been derived");
       }
       if (SqlTypeUtil.inCharFamily(operandType)) {
         SqlCollation collation = operandType.getCollation();
-        assert null != collation : "An implicit or explicit collation should have been set";
+        assert collation != null : "An implicit or explicit collation should have been set";
         type =
             validator
                 .getTypeFactory()
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
index a691557cf..cfc7e5f87 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
@@ -68,7 +68,7 @@ public SqlPrefixOperator(
       // Determine coercibility and resulting collation name of
       // unary operator if needed.
       RelDataType operandType = validator.getValidatedNodeType(call.operand(0));
-      if (null == operandType) {
+      if (operandType == null) {
         throw new AssertionError("operand's type should have been derived");
       }
       if (SqlTypeUtil.inCharFamily(operandType)) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java
index 8b9ccf547..b5695687c 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java
@@ -20,7 +20,7 @@
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.validate.SqlValidator;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
 
 /**
  * SqlProcedureCallOperator represents the CALL statement. It takes a single operand which is the
@@ -43,7 +43,7 @@ public SqlProcedureCallOperator() {
     return new SqlSelect(
         SqlParserPos.ZERO,
         null,
-        new SqlNodeList(Collections.singletonList(call.operand(0)), SqlParserPos.ZERO),
+        new SqlNodeList(ImmutableList.of(call.operand(0)), SqlParserPos.ZERO),
         SqlStdOperatorTable.VALUES.createCall(
             SqlParserPos.ZERO,
             SqlStdOperatorTable.ROW.createCall(
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java
index 9e4f04229..0869ef618 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java
@@ -25,8 +25,9 @@
 import org.apache.calcite.util.Pair;
 
 import java.util.List;
-import java.util.Objects;
-import java.util.stream.Collectors;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * A sql type name specification of row type.
@@ -68,9 +69,9 @@ public class SqlRowTypeNameSpec extends SqlTypeNameSpec {
   public SqlRowTypeNameSpec(
       SqlParserPos pos, List<SqlIdentifier> fieldNames, List<SqlDataTypeSpec> fieldTypes) {
     super(new SqlIdentifier(SqlTypeName.ROW.getName(), pos), pos);
-    Objects.requireNonNull(fieldNames, "fieldNames");
-    Objects.requireNonNull(fieldTypes, "fieldTypes");
-    assert fieldNames.size() > 0; // there must be at least one field.
+    requireNonNull(fieldNames, "fieldNames");
+    requireNonNull(fieldTypes, "fieldTypes");
+    assert !fieldNames.isEmpty(); // there must be at least one field.
     this.fieldNames = fieldNames;
     this.fieldTypes = fieldTypes;
   }
@@ -121,7 +122,7 @@ public int getArity() {
   @Override public RelDataType deriveType(SqlValidator sqlValidator) {
     final RelDataTypeFactory typeFactory = sqlValidator.getTypeFactory();
     return typeFactory.createStructType(
-        fieldTypes.stream().map(dt -> dt.deriveType(sqlValidator)).collect(Collectors.toList()),
-        fieldNames.stream().map(SqlIdentifier::toString).collect(Collectors.toList()));
+        fieldTypes.stream().map(dt -> dt.deriveType(sqlValidator)).collect(toList()),
+        fieldNames.stream().map(SqlIdentifier::toString).collect(toList()));
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSelect.java b/core/src/main/java/org/apache/calcite/sql/SqlSelect.java
index 81d2a87db..cb62f3fcd 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSelect.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSelect.java
@@ -128,8 +128,8 @@ public SqlSelect(
     return SqlKind.SELECT;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(
         keywordList,
         selectList,
@@ -296,7 +296,7 @@ public void setHints(@Nullable SqlNodeList hints) {
   @EnsuresNonNullIf(expression = "hints", result = true)
   public boolean hasHints() {
     // The hints may be passed as null explicitly.
-    return this.hints != null && this.hints.size() > 0;
+    return this.hints != null && !this.hints.isEmpty();
   }
 
   @Override public void validate(SqlValidator validator, SqlValidatorScope scope) {
@@ -327,7 +327,7 @@ public boolean hasHints() {
   }
 
   public boolean hasOrderBy() {
-    return orderBy != null && orderBy.size() != 0;
+    return orderBy != null && !orderBy.isEmpty();
   }
 
   public boolean hasWhere() {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java
index 3b2c095ca..78b7fa798 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java
@@ -128,8 +128,8 @@ public SqlSelect createCall(
     }
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
+  @Override @SuppressWarnings("deprecation")
+  public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
     SqlSelect select = (SqlSelect) call;
     final SqlWriter.Frame selectFrame = writer.startList(SqlWriter.FrameTypeEnum.SELECT);
     writer.sep("SELECT");
@@ -197,8 +197,7 @@ public SqlSelect createCall(
       }
     }
     if (select.groupBy != null) {
-      SqlNodeList groupBy =
-          select.groupBy.size() == 0 ? SqlNodeList.SINGLETON_EMPTY : select.groupBy;
+      SqlNodeList groupBy = select.groupBy.isEmpty() ? SqlNodeList.SINGLETON_EMPTY : select.groupBy;
       // if the DISTINCT keyword of GROUP BY is present it can be the only item
       if (groupBy.size() == 1
           && groupBy.get(0) != null
@@ -215,7 +214,7 @@ public SqlSelect createCall(
       writer.sep("HAVING");
       select.having.unparse(writer, 0, 0);
     }
-    if (select.windowDecls.size() > 0) {
+    if (!select.windowDecls.isEmpty()) {
       writer.sep("WINDOW");
       writer.list(SqlWriter.FrameTypeEnum.WINDOW_DECL_LIST, SqlWriter.COMMA, select.windowDecls);
     }
@@ -223,7 +222,7 @@ public SqlSelect createCall(
       writer.sep("QUALIFY");
       select.qualify.unparse(writer, 0, 0);
     }
-    if (select.orderBy != null && select.orderBy.size() > 0) {
+    if (select.orderBy != null && !select.orderBy.isEmpty()) {
       writer.sep("ORDER BY");
       writer.list(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, SqlWriter.COMMA, select.orderBy);
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSetOption.java b/core/src/main/java/org/apache/calcite/sql/SqlSetOption.java
index 2a23d5e9b..00126f847 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSetOption.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSetOption.java
@@ -67,8 +67,8 @@
 public class SqlSetOption extends SqlAlter {
   public static final SqlSpecialOperator OPERATOR =
       new SqlSpecialOperator("SET_OPTION", SqlKind.SET_OPTION) {
-        @SuppressWarnings("argument.type.incompatible")
-        @Override public SqlCall createCall(
+        @Override @SuppressWarnings("argument.type.incompatible")
+        public SqlCall createCall(
             @Nullable SqlLiteral functionQualifier,
             SqlParserPos pos,
             @Nullable SqlNode... operands) {
@@ -119,8 +119,8 @@ public SqlSetOption(
     return OPERATOR;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     final List<@Nullable SqlNode> operandList = new ArrayList<>();
     if (scope == null) {
       operandList.add(null);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSetSemanticsTableOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlSetSemanticsTableOperator.java
index 98594a27f..220c00d7f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSetSemanticsTableOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSetSemanticsTableOperator.java
@@ -53,14 +53,14 @@ public SqlSetSemanticsTableOperator() {
     call.operand(0).unparse(writer, 0, 0);
 
     SqlNodeList partitionList = call.operand(1);
-    if (partitionList.size() > 0) {
+    if (!partitionList.isEmpty()) {
       writer.sep("PARTITION BY");
       final SqlWriter.Frame partitionFrame = writer.startList("", "");
       partitionList.unparse(writer, 0, 0);
       writer.endList(partitionFrame);
     }
     SqlNodeList orderList = call.operand(2);
-    if (orderList.size() > 0) {
+    if (!orderList.isEmpty()) {
       writer.sep("ORDER BY");
       writer.list(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, SqlWriter.COMMA, orderList);
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSnapshot.java b/core/src/main/java/org/apache/calcite/sql/SqlSnapshot.java
index 5b7d3804c..3e8447523 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSnapshot.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSnapshot.java
@@ -24,7 +24,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Parse tree node for "{@code FOR SYSTEM_TIME AS OF}" temporal clause. */
 public class SqlSnapshot extends SqlCall {
@@ -39,8 +40,8 @@ public class SqlSnapshot extends SqlCall {
   /** Creates a SqlSnapshot. */
   public SqlSnapshot(SqlParserPos pos, SqlNode tableRef, SqlNode period) {
     super(pos);
-    this.tableRef = Objects.requireNonNull(tableRef, "tableRef");
-    this.period = Objects.requireNonNull(period, "period");
+    this.tableRef = requireNonNull(tableRef, "tableRef");
+    this.period = requireNonNull(period, "period");
   }
 
   // ~ Methods
@@ -64,10 +65,10 @@ public SqlNode getPeriod() {
   @Override public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case OPERAND_TABLE_REF:
-        tableRef = Objects.requireNonNull(operand, "operand");
+        tableRef = requireNonNull(operand, "operand");
         break;
       case OPERAND_PERIOD:
-        period = Objects.requireNonNull(operand, "operand");
+        period = requireNonNull(operand, "operand");
         break;
       default:
         throw new AssertionError(i);
@@ -91,8 +92,8 @@ private SqlSnapshotOperator() {
       return SqlSyntax.SPECIAL;
     }
 
-    @SuppressWarnings("argument.type.incompatible")
-    @Override public SqlCall createCall(
+    @Override @SuppressWarnings("argument.type.incompatible")
+    public SqlCall createCall(
         @Nullable SqlLiteral functionQualifier, SqlParserPos pos, @Nullable SqlNode... operands) {
       assert functionQualifier == null;
       assert operands.length == 2;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSpatialTypeOperatorTable.java b/core/src/main/java/org/apache/calcite/sql/SqlSpatialTypeOperatorTable.java
index ee314ee66..555809f17 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSpatialTypeOperatorTable.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSpatialTypeOperatorTable.java
@@ -36,7 +36,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Implementation of {@link org.apache.calcite.sql.SqlSpatialTypeOperatorTable} containing the
@@ -60,12 +61,9 @@ public SqlSpatialTypeOperatorTable() {
         schema, null, ImmutableList.of(), SqlSpatialTypeFunctions.class.getName(), "*", true);
 
     // Register the spatial aggregate functions.
-    schema.add(
-        "ST_UNION", Objects.requireNonNull(AggregateFunctionImpl.create(UnionOperation.class)));
-    schema.add(
-        "ST_ACCUM", Objects.requireNonNull(AggregateFunctionImpl.create(AccumOperation.class)));
-    schema.add(
-        "ST_COLLECT", Objects.requireNonNull(AggregateFunctionImpl.create(CollectOperation.class)));
+    schema.add("ST_UNION", requireNonNull(AggregateFunctionImpl.create(UnionOperation.class)));
+    schema.add("ST_ACCUM", requireNonNull(AggregateFunctionImpl.create(AccumOperation.class)));
+    schema.add("ST_COLLECT", requireNonNull(AggregateFunctionImpl.create(CollectOperation.class)));
 
     // Create a catalog reader to retrieve the operators.
     CalciteCatalogReader catalogReader =
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlTableRef.java b/core/src/main/java/org/apache/calcite/sql/SqlTableRef.java
index b4b4cb87a..f2c01c55f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlTableRef.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlTableRef.java
@@ -73,7 +73,7 @@ public SqlTableRef(SqlParserPos pos, SqlIdentifier tableName, SqlNodeList hints)
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
     tableName.unparse(writer, leftPrec, rightPrec);
-    if (this.hints != null && this.hints.size() > 0) {
+    if (this.hints != null && !this.hints.isEmpty()) {
       writer.getDialect().unparseTableScanHints(writer, this.hints, leftPrec, rightPrec);
     }
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlTimeLiteral.java b/core/src/main/java/org/apache/calcite/sql/SqlTimeLiteral.java
index d7dffd78c..9cfa03732 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlTimeLiteral.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlTimeLiteral.java
@@ -20,9 +20,9 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TimeString;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkArgument;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * A SQL literal representing a TIME value, for example <code>TIME
@@ -35,14 +35,14 @@ public class SqlTimeLiteral extends SqlAbstractDateTimeLiteral {
 
   SqlTimeLiteral(TimeString t, int precision, boolean hasTimeZone, SqlParserPos pos) {
     super(t, hasTimeZone, SqlTypeName.TIME, precision, pos);
-    Preconditions.checkArgument(this.precision >= 0);
+    checkArgument(this.precision >= 0);
   }
 
   // ~ Methods ----------------------------------------------------------------
 
   /** Converts this literal to a {@link TimeString}. */
   protected TimeString getTime() {
-    return (TimeString) Objects.requireNonNull(value, "value");
+    return (TimeString) requireNonNull(value, "value");
   }
 
   @Override public SqlTimeLiteral clone(SqlParserPos pos) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlTimestampLiteral.java b/core/src/main/java/org/apache/calcite/sql/SqlTimestampLiteral.java
index 56d749612..02ed808c0 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlTimestampLiteral.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlTimestampLiteral.java
@@ -20,9 +20,9 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.TimestampString;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkArgument;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * A SQL literal representing a TIMESTAMP value, for example <code>TIMESTAMP
@@ -35,8 +35,8 @@ public class SqlTimestampLiteral extends SqlAbstractDateTimeLiteral {
 
   SqlTimestampLiteral(TimestampString ts, int precision, SqlTypeName typeName, SqlParserPos pos) {
     super(ts, false, typeName, precision, pos);
-    Preconditions.checkArgument(this.precision >= 0);
-    Preconditions.checkArgument(
+    checkArgument(this.precision >= 0);
+    checkArgument(
         typeName == SqlTypeName.TIMESTAMP
             || typeName == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE);
   }
@@ -45,7 +45,7 @@ public class SqlTimestampLiteral extends SqlAbstractDateTimeLiteral {
 
   @Override public SqlTimestampLiteral clone(SqlParserPos pos) {
     return new SqlTimestampLiteral(
-        (TimestampString) Objects.requireNonNull(value, "value"), precision, getTypeName(), pos);
+        (TimestampString) requireNonNull(value, "value"), precision, getTypeName(), pos);
   }
 
   @Override public String toString() {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlUnpivot.java b/core/src/main/java/org/apache/calcite/sql/SqlUnpivot.java
index e8c821cd2..e2618b733 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlUnpivot.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlUnpivot.java
@@ -26,11 +26,12 @@
 
 import java.util.HashSet;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Parse tree node that represents UNPIVOT applied to a table reference (or sub-query).
  *
@@ -74,11 +75,11 @@ public SqlUnpivot(
       SqlNodeList axisList,
       SqlNodeList inList) {
     super(pos);
-    this.query = Objects.requireNonNull(query, "query");
+    this.query = requireNonNull(query, "query");
     this.includeNulls = includeNulls;
-    this.measureList = Objects.requireNonNull(measureList, "measureList");
-    this.axisList = Objects.requireNonNull(axisList, "axisList");
-    this.inList = Objects.requireNonNull(inList, "inList");
+    this.measureList = requireNonNull(measureList, "measureList");
+    this.axisList = requireNonNull(axisList, "axisList");
+    this.inList = requireNonNull(inList, "inList");
   }
 
   // ~ Methods ----------------------------------------------------------------
@@ -91,8 +92,8 @@ public SqlUnpivot(
     return ImmutableNullableList.of(query, measureList, axisList, inList);
   }
 
-  @SuppressWarnings("nullness")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("nullness")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     // Only 'query' is mutable. (It is required for validation.)
     switch (i) {
       case 0:
@@ -121,7 +122,7 @@ public SqlUnpivot(
   }
 
   /** Returns the measure list as SqlIdentifiers. */
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   public void forEachMeasure(Consumer<SqlIdentifier> consumer) {
     ((List<SqlIdentifier>) (List) measureList).forEach(consumer);
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlUpdate.java b/core/src/main/java/org/apache/calcite/sql/SqlUpdate.java
index ec630d39f..964a0c1f4 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlUpdate.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlUpdate.java
@@ -70,14 +70,14 @@ public SqlUpdate(
     return OPERATOR;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<@Nullable SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<@Nullable SqlNode> getOperandList() {
     return ImmutableNullableList.of(
         targetTable, targetColumnList, sourceExpressionList, condition, alias);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         assert operand instanceof SqlIdentifier;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlUtil.java b/core/src/main/java/org/apache/calcite/sql/SqlUtil.java
index 936e71516..6b65b4528 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlUtil.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlUtil.java
@@ -49,7 +49,6 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Predicates;
 import com.google.common.base.Utf8;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
@@ -59,7 +58,6 @@
 import org.checkerframework.checker.nullness.qual.PolyNull;
 
 import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
 import java.nio.charset.UnsupportedCharsetException;
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
@@ -70,12 +68,16 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.function.Predicate;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Predicates.instanceOf;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
+
 /** Contains utility functions related to SQL parsing, all static. */
 public abstract class SqlUtil {
   // ~ Constants --------------------------------------------------------------
@@ -180,7 +182,7 @@ public static boolean isNullLiteral(@Nullable SqlNode node, boolean allowCast) {
     if (node instanceof SqlLiteral) {
       SqlLiteral literal = (SqlLiteral) node;
       if (literal.getTypeName() == SqlTypeName.NULL) {
-        assert null == literal.getValue();
+        assert literal.getValue() == null;
         return true;
       } else {
         // We don't regard UNKNOWN -- SqlLiteral(null,Boolean) -- as
@@ -401,7 +403,7 @@ public static void unparseSqlIdentifierSyntax(
         }
       }
     }
-    if (null != identifier.getCollation()) {
+    if (identifier.getCollation() != null) {
       identifier.getCollation().unparse(writer);
     }
     writer.endList(frame);
@@ -491,7 +493,7 @@ public static SqlLiteral concatenateLiterals(List<SqlLiteral> lits) {
   private static Iterator<SqlOperator> filterOperatorRoutinesByKind(
       Iterator<SqlOperator> routines, final SqlKind sqlKind) {
     return Iterators.filter(
-        routines, operator -> Objects.requireNonNull(operator, "operator").getKind() == sqlKind);
+        routines, operator -> requireNonNull(operator, "operator").getKind() == sqlKind);
   }
 
   /**
@@ -597,11 +599,11 @@ private static Iterator<SqlOperator> lookupSubjectRoutinesByName(
     opTab.lookupOperatorOverloads(funcName, category, syntax, sqlOperators, nameMatcher);
     switch (syntax) {
       case FUNCTION:
-        return Iterators.filter(sqlOperators.iterator(), Predicates.instanceOf(SqlFunction.class));
+        return Iterators.filter(sqlOperators.iterator(), instanceOf(SqlFunction.class));
       default:
         return Iterators.filter(
             sqlOperators.iterator(),
-            operator -> Objects.requireNonNull(operator, "operator").getSyntax() == syntax);
+            operator -> requireNonNull(operator, "operator").getSyntax() == syntax);
     }
   }
 
@@ -610,7 +612,7 @@ private static Iterator<SqlOperator> filterRoutinesByParameterCount(
     return Iterators.filter(
         routines,
         operator ->
-            Objects.requireNonNull(operator, "operator")
+            requireNonNull(operator, "operator")
                 .getOperandCountRange()
                 .isValidCount(argTypes.size()));
   }
@@ -638,7 +640,7 @@ private static Iterator<SqlOperator> filterRoutinesByParameterTypeAndName(
             Iterators.filter(routines, SqlFunction.class),
             function -> {
               SqlOperandTypeChecker operandTypeChecker =
-                  Objects.requireNonNull(function, "function").getOperandTypeChecker();
+                  requireNonNull(function, "function").getOperandTypeChecker();
               if (operandTypeChecker == null || !operandTypeChecker.isFixedParameters()) {
                 // no parameter information for builtins; keep for now,
                 // the type coerce will not work here.
@@ -656,7 +658,7 @@ private static Iterator<SqlOperator> filterRoutinesByParameterTypeAndName(
                   return false;
                 }
               } else {
-                permutedArgTypes = Lists.newArrayList(argTypes);
+                permutedArgTypes = new ArrayList<>(argTypes);
                 while (permutedArgTypes.size() < argTypes.size()) {
                   paramTypes.add(null);
                 }
@@ -739,7 +741,7 @@ private static Iterator<SqlOperator> filterRoutinesByTypePrecedence(
                       final RelDataType paramType = paramTypes.get(index);
                       return precList.compareTypePrecedence(paramType, bestMatch) >= 0;
                     })
-                .collect(Collectors.toList());
+                .collect(toList());
       }
     }
     //noinspection unchecked
@@ -850,7 +852,7 @@ public static String getOperatorSignature(SqlOperator op, List<?> typeList) {
   public static String getAliasedSignature(SqlOperator op, String opName, List<?> typeList) {
     StringBuilder ret = new StringBuilder();
     String template = op.getSignatureTemplate(typeList.size());
-    if (null == template) {
+    if (template == null) {
       ret.append("'");
       ret.append(opName);
       ret.append("(");
@@ -928,16 +930,15 @@ public static boolean isCallTo(SqlNode node, SqlOperator operator) {
    */
   public static RelDataType createNlsStringType(RelDataTypeFactory typeFactory, NlsString str) {
     Charset charset = str.getCharset();
-    if (null == charset) {
+    if (charset == null) {
       charset = typeFactory.getDefaultCharset();
     }
     SqlCollation collation = str.getCollation();
-    if (null == collation) {
+    if (collation == null) {
       collation = SqlCollation.COERCIBLE;
     }
     RelDataType type = typeFactory.createSqlType(SqlTypeName.CHAR, str.getValue().length());
-    type = typeFactory.createTypeWithCharsetAndCollation(type, charset, collation);
-    return type;
+    return typeFactory.createTypeWithCharsetAndCollation(type, charset, collation);
   }
 
   /**
@@ -996,7 +997,7 @@ public static Charset getCharset(String charsetName) {
    */
   @SuppressWarnings("BetaApi")
   public static void validateCharset(ByteString value, Charset charset) {
-    if (charset == StandardCharsets.UTF_8) {
+    if (charset == UTF_8) {
       final byte[] bytes = value.getBytes();
       if (!Utf8.isWellFormed(bytes)) {
         // CHECKSTYLE: IGNORE 1
@@ -1046,7 +1047,7 @@ public static ImmutableList<SqlNode> getAncestry(
       throw new AssertionError("not found: " + predicate + " in " + root);
     } catch (Util.FoundOne e) {
       //noinspection unchecked
-      return (ImmutableList<SqlNode>) Objects.requireNonNull(e.getNode(), "Genealogist result");
+      return (ImmutableList<SqlNode>) requireNonNull(e.getNode(), "Genealogist result");
     }
   }
 
@@ -1062,7 +1063,7 @@ public static ImmutableList<SqlNode> getAncestry(
    */
   public static List<RelHint> getRelHint(
       HintStrategyTable hintStrategies, @Nullable SqlNodeList sqlHints) {
-    if (sqlHints == null || sqlHints.size() == 0) {
+    if (sqlHints == null || sqlHints.isEmpty()) {
       return ImmutableList.of();
     }
     final ImmutableList.Builder<RelHint> relHints = ImmutableList.builder();
@@ -1106,7 +1107,7 @@ public static List<RelHint> getRelHint(
   public static RelNode attachRelHint(
       HintStrategyTable hintStrategies, List<RelHint> hints, Hintable rel) {
     final List<RelHint> relHints = hintStrategies.apply(hints, (RelNode) rel);
-    if (relHints.size() > 0) {
+    if (!relHints.isEmpty()) {
       return rel.attachHints(relHints);
     }
     return (RelNode) rel;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlWindow.java b/core/src/main/java/org/apache/calcite/sql/SqlWindow.java
index 235a68763..0bcbaeef0 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlWindow.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlWindow.java
@@ -163,14 +163,14 @@ public static SqlWindow create(
     return SqlKind.WINDOW;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(
         declName, refName, partitionList, orderList, isRows, lowerBound, upperBound, allowPartial);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         this.declName = (SqlIdentifier) operand;
@@ -202,7 +202,7 @@ public static SqlWindow create(
   }
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
-    if (null != declName) {
+    if (declName != null) {
       declName.unparse(writer, 0, 0);
       writer.keyword("AS");
     }
@@ -322,7 +322,7 @@ static void checkSpecialLiterals(SqlWindow window, SqlValidator validator) {
     Object upperLitType = null;
     SqlOperator lowerOp = null;
     SqlOperator upperOp = null;
-    if (null != lowerBound) {
+    if (lowerBound != null) {
       if (lowerBound.getKind() == SqlKind.LITERAL) {
         lowerLitType = ((SqlLiteral) lowerBound).getValue();
         if (Bound.UNBOUNDED_FOLLOWING == lowerLitType) {
@@ -332,7 +332,7 @@ static void checkSpecialLiterals(SqlWindow window, SqlValidator validator) {
         lowerOp = ((SqlCall) lowerBound).getOperator();
       }
     }
-    if (null != upperBound) {
+    if (upperBound != null) {
       if (upperBound.getKind() == SqlKind.LITERAL) {
         upperLitType = ((SqlLiteral) upperBound).getValue();
         if (Bound.UNBOUNDED_PRECEDING == upperLitType) {
@@ -344,20 +344,20 @@ static void checkSpecialLiterals(SqlWindow window, SqlValidator validator) {
     }
 
     if (Bound.CURRENT_ROW == lowerLitType) {
-      if (null != upperOp) {
+      if (upperOp != null) {
         if (upperOp == PRECEDING_OPERATOR) {
           throw validator.newValidationError(
               castNonNull(upperBound), RESOURCE.currentRowPrecedingError());
         }
       }
-    } else if (null != lowerOp) {
+    } else if (lowerOp != null) {
       if (lowerOp == FOLLOWING_OPERATOR) {
-        if (null != upperOp) {
+        if (upperOp != null) {
           if (upperOp == PRECEDING_OPERATOR) {
             throw validator.newValidationError(
                 castNonNull(upperBound), RESOURCE.followingBeforePrecedingError());
           }
-        } else if (null != upperLitType) {
+        } else if (upperLitType != null) {
           if (Bound.CURRENT_ROW == upperLitType) {
             throw validator.newValidationError(
                 castNonNull(upperBound), RESOURCE.currentRowFollowingError());
@@ -451,7 +451,7 @@ public SqlWindow overlay(SqlWindow that, SqlValidator validator) {
     // 711 rule 10e
     final SqlNode lowerBound = that.getLowerBound();
     final SqlNode upperBound = that.getUpperBound();
-    if ((null != lowerBound) || (null != upperBound)) {
+    if (lowerBound != null || upperBound != null) {
       throw validator.newValidationError(that.isRows, RESOURCE.refWindowWithFrame());
     }
 
@@ -586,7 +586,7 @@ public boolean isAllowPartial() {
     }
 
     // 6.10 rule 6a Function RANK & DENSE_RANK require ORDER BY clause
-    if (orderList.size() == 0
+    if (orderList.isEmpty()
         && !SqlValidatorUtil.containsMonotonic(scope)
         && windowCall != null
         && windowCall.getOperator().requiresOrder()) {
@@ -602,7 +602,7 @@ public boolean isAllowPartial() {
       SqlTypeFamily orderTypeFam = null;
 
       // SQL03 7.10 Rule 11a
-      if (orderList.size() > 0) {
+      if (!orderList.isEmpty()) {
         // if order by is a compound list then range not allowed
         if (orderList.size() > 1 && !isRows()) {
           throw validator.newValidationError(isRows, RESOURCE.compoundOrderByProhibitsRange());
@@ -626,7 +626,7 @@ public boolean isAllowPartial() {
 
       // Validate across boundaries. 7.10 Rule 8 a-d
       checkSpecialLiterals(this, validator);
-    } else if (orderList.size() == 0
+    } else if (orderList.isEmpty()
         && !SqlValidatorUtil.containsMonotonic(scope)
         && windowCall != null
         && windowCall.getOperator().requiresOrder()) {
@@ -645,7 +645,7 @@ private static void validateFrameBoundary(
       @Nullable SqlTypeFamily orderTypeFam,
       SqlValidator validator,
       SqlValidatorScope scope) {
-    if (null == bound) {
+    if (bound == null) {
       return;
     }
     bound.validate(validator, scope);
@@ -784,8 +784,8 @@ private SqlWindowOperator() {
       return SqlSyntax.SPECIAL;
     }
 
-    @SuppressWarnings("argument.type.incompatible")
-    @Override public SqlCall createCall(
+    @Override @SuppressWarnings("argument.type.incompatible")
+    public SqlCall createCall(
         @Nullable SqlLiteral functionQualifier, SqlParserPos pos, @Nullable SqlNode... operands) {
       assert functionQualifier == null;
       assert operands.length == 8;
@@ -831,13 +831,13 @@ private SqlWindowOperator() {
       if (window.refName != null) {
         window.refName.unparse(writer, 0, 0);
       }
-      if (window.partitionList.size() > 0) {
+      if (!window.partitionList.isEmpty()) {
         writer.sep("PARTITION BY");
         final SqlWriter.Frame partitionFrame = writer.startList("", "");
         window.partitionList.unparse(writer, 0, 0);
         writer.endList(partitionFrame);
       }
-      if (window.orderList.size() > 0) {
+      if (!window.orderList.isEmpty()) {
         writer.sep("ORDER BY");
         final SqlWriter.Frame orderFrame = writer.startList("", "");
         window.orderList.unparse(writer, 0, 0);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java b/core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java
index 53b38293f..5e349cbdb 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java
@@ -29,14 +29,13 @@
 import org.apache.calcite.sql.validate.SqlNameMatcher;
 import org.apache.calcite.sql.validate.SqlValidator;
 
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Collections;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
@@ -124,10 +123,9 @@ protected abstract static class AbstractOperandMetadata implements SqlOperandMet
     final int mandatoryParamCount;
 
     AbstractOperandMetadata(List<String> paramNames, int mandatoryParamCount) {
-      this.paramNames = ImmutableList.copyOf(paramNames);
+      this.paramNames = paramNames;
       this.mandatoryParamCount = mandatoryParamCount;
-      Preconditions.checkArgument(
-          mandatoryParamCount >= 0 && mandatoryParamCount <= paramNames.size());
+      checkArgument(mandatoryParamCount >= 0 && mandatoryParamCount <= paramNames.size());
     }
 
     @Override public SqlOperandCountRange getOperandCountRange() {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlWith.java b/core/src/main/java/org/apache/calcite/sql/SqlWith.java
index 9a149cf86..e285ab88f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlWith.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlWith.java
@@ -53,8 +53,8 @@ public SqlWith(SqlParserPos pos, SqlNodeList withList, SqlNode body) {
     return ImmutableList.of(withList, body);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         withList = (SqlNodeList) operand;
@@ -101,8 +101,8 @@ private SqlWithOperator() {
       writer.endList(frame);
     }
 
-    @SuppressWarnings("argument.type.incompatible")
-    @Override public SqlCall createCall(
+    @Override @SuppressWarnings("argument.type.incompatible")
+    public SqlCall createCall(
         @Nullable SqlLiteral functionQualifier, SqlParserPos pos, @Nullable SqlNode... operands) {
       return new SqlWith(pos, (SqlNodeList) operands[0], operands[1]);
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlWithItem.java b/core/src/main/java/org/apache/calcite/sql/SqlWithItem.java
index 6b40b8279..59197f546 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlWithItem.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlWithItem.java
@@ -43,13 +43,13 @@ public SqlWithItem(
     return SqlKind.WITH_ITEM;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(name, columnList, query);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         name = (SqlIdentifier) operand;
@@ -92,8 +92,8 @@ private static class SqlWithItemOperator extends SqlSpecialOperator {
       withItem.query.unparse(writer, MDX_PRECEDENCE, MDX_PRECEDENCE);
     }
 
-    @SuppressWarnings("argument.type.incompatible")
-    @Override public SqlCall createCall(
+    @Override @SuppressWarnings("argument.type.incompatible")
+    public SqlCall createCall(
         @Nullable SqlLiteral functionQualifier, SqlParserPos pos, @Nullable SqlNode... operands) {
       assert functionQualifier == null;
       assert operands.length == 3;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlWithinDistinctOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlWithinDistinctOperator.java
index 760a6e999..9f51f0e32 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlWithinDistinctOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlWithinDistinctOperator.java
@@ -23,10 +23,10 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 
-import java.util.Objects;
-
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * An operator that applies a distinct operation before rows are included in an aggregate function.
  *
@@ -71,8 +71,8 @@ public SqlWithinDistinctOperator() {
       throw validator.newValidationError(
           call, RESOURCE.withinDistinctNotAllowed(flat.aggregateCall.getOperator().getName()));
     }
-    for (SqlNode order : Objects.requireNonNull(flat.distinctList)) {
-      Objects.requireNonNull(validator.deriveType(scope, order));
+    for (SqlNode order : requireNonNull(flat.distinctList)) {
+      requireNonNull(validator.deriveType(scope, order));
     }
     validator.validateAggregateParams(
         flat.aggregateCall, flat.filter, flat.distinctList, flat.orderList, scope);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlWithinGroupOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlWithinGroupOperator.java
index 22499bf26..d0d88d4e7 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlWithinGroupOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlWithinGroupOperator.java
@@ -25,10 +25,10 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 
-import java.util.Objects;
-
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * An operator that applies a sort operation before rows are included in an aggregate function.
  *
@@ -77,8 +77,8 @@ public SqlWithinGroupOperator() {
       throw validator.newValidationError(call, RESOURCE.withinGroupNotAllowed(operator.getName()));
     }
 
-    for (SqlNode order : Objects.requireNonNull(flat.orderList)) {
-      Objects.requireNonNull(validator.deriveType(scope, order));
+    for (SqlNode order : requireNonNull(flat.orderList)) {
+      requireNonNull(validator.deriveType(scope, order));
     }
     validator.validateAggregateParams(
         flat.aggregateCall, flat.filter, flat.distinctList, flat.orderList, scope);
diff --git a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
index 101f680af..162806d33 100644
--- a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
+++ b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
@@ -45,7 +45,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
@@ -144,7 +143,7 @@ public List<SqlMoniker> getCompletionHints(String sql, int cursor, String[] repl
     }
 
     if (wordStart < 0) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     // Search forwards to the end of the word we should remove. Eat up
@@ -171,12 +170,12 @@ public List<SqlMoniker> getCompletionHints(String sql, int cursor, String[] repl
     }
 
     if (word.isEmpty()) {
-      return ImmutableList.copyOf(completionHints);
+      return completionHints;
     }
 
     // If cursor was part of the way through a word, only include hints
     // which start with that word in the result.
-    final ImmutableList.Builder<SqlMoniker> result = new ImmutableList.Builder<>();
+    final ImmutableList.Builder<SqlMoniker> result = ImmutableList.builder();
     Casing preferredCasing = getPreferredCasing(word);
 
     boolean ignoreCase = preferredCasing != Casing.UNCHANGED;
@@ -197,7 +196,7 @@ public List<SqlMoniker> getCompletionHints0(String sql, int cursor) {
     String simpleSql = simplifySql(sql, cursor);
     int idx = simpleSql.indexOf(HINT_TOKEN);
     if (idx < 0) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     SqlParserPos pos = new SqlParserPos(1, idx + 1);
     return getCompletionHints(simpleSql, pos);
@@ -494,19 +493,19 @@ public String simplifySql(String sql, int cursor) {
    *
    * @return an of SQL reserved and keywords
    */
-  @EnsuresNonNull({"reservedWordsSet", "reservedWordsList"})
+  @EnsuresNonNull({"reservedWordsList", "reservedWordsSet"})
   public List<String> getReservedAndKeyWords() {
     ensureReservedAndKeyWords();
     return reservedWordsList;
   }
 
-  @EnsuresNonNull({"reservedWordsSet", "reservedWordsList"})
+  @EnsuresNonNull({"reservedWordsList", "reservedWordsSet"})
   private Set<String> getReservedAndKeyWordsSet() {
     ensureReservedAndKeyWords();
     return reservedWordsSet;
   }
 
-  @EnsuresNonNull({"reservedWordsSet", "reservedWordsList"})
+  @EnsuresNonNull({"reservedWordsList", "reservedWordsSet"})
   private void ensureReservedAndKeyWords() {
     if (reservedWordsSet != null && reservedWordsList != null) {
       return;
diff --git a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction.java b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction.java
index 7943aa1c6..29b69d6ec 100644
--- a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction.java
@@ -34,6 +34,7 @@
 import org.apache.calcite.sql.validate.SqlMoniker;
 import org.apache.calcite.util.BuiltInMethod;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -41,7 +42,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /** Table function that returns completion hints for a given SQL statement. */
@@ -66,7 +66,7 @@ public class SqlAdvisorGetHintsFunction implements TableFunction, ImplementableF
       RexImpTable.createImplementor(
           (translator, call, operands) ->
               Expressions.call(
-                  GET_COMPLETION_HINTS, Iterables.concat(Collections.singleton(ADVISOR), operands)),
+                  GET_COMPLETION_HINTS, Iterables.concat(ImmutableSet.of(ADVISOR), operands)),
           NullPolicy.ANY,
           false);
 
diff --git a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction2.java b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction2.java
index 57d6a9be5..131ef6ed3 100644
--- a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction2.java
+++ b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction2.java
@@ -34,6 +34,7 @@
 import org.apache.calcite.sql.validate.SqlMoniker;
 import org.apache.calcite.util.BuiltInMethod;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -41,7 +42,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -69,7 +69,7 @@ public class SqlAdvisorGetHintsFunction2 implements TableFunction, Implementable
       RexImpTable.createImplementor(
           (translator, call, operands) ->
               Expressions.call(
-                  GET_COMPLETION_HINTS, Iterables.concat(Collections.singleton(ADVISOR), operands)),
+                  GET_COMPLETION_HINTS, Iterables.concat(ImmutableSet.of(ADVISOR), operands)),
           NullPolicy.ANY,
           false);
 
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCheckConstraint.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCheckConstraint.java
index 9e8c9ffaa..927de6c06 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCheckConstraint.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCheckConstraint.java
@@ -52,8 +52,8 @@ public class SqlCheckConstraint extends SqlCall {
     return OPERATOR;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(name, expression);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateForeignSchema.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateForeignSchema.java
index f50f118cf..fce8a782b 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateForeignSchema.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateForeignSchema.java
@@ -28,17 +28,19 @@
 import org.apache.calcite.util.ImmutableNullableList;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.AbstractList;
 import java.util.List;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /** Parse tree for {@code CREATE FOREIGN SCHEMA} statement. */
 public class SqlCreateForeignSchema extends SqlCreate {
   public final SqlIdentifier name;
@@ -59,16 +61,16 @@ public class SqlCreateForeignSchema extends SqlCreate {
       @Nullable SqlNode library,
       @Nullable SqlNodeList optionList) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.type = type;
     this.library = library;
-    Preconditions.checkArgument(
+    checkArgument(
         (type == null) != (library == null), "of type and library, exactly one must be specified");
     this.optionList = optionList; // may be null
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(name, type, library, optionList);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java
index d6f7b1f87..fcde04d7c 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java
@@ -29,11 +29,12 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import java.util.Arrays;
 import java.util.List;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
 
 /** Parse tree for {@code CREATE FUNCTION} statement. */
 public class SqlCreateFunction extends SqlCreate {
@@ -53,10 +54,10 @@ public SqlCreateFunction(
       SqlNode className,
       SqlNodeList usingList) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.className = className;
-    this.usingList = Objects.requireNonNull(usingList, "usingList");
-    Preconditions.checkArgument(usingList.size() % 2 == 0);
+    this.usingList = requireNonNull(usingList, "usingList");
+    checkArgument(usingList.size() % 2 == 0);
   }
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
@@ -68,7 +69,7 @@ public SqlCreateFunction(
     name.unparse(writer, 0, 0);
     writer.keyword("AS");
     className.unparse(writer, 0, 0);
-    if (usingList.size() > 0) {
+    if (!usingList.isEmpty()) {
       writer.keyword("USING");
       final SqlWriter.Frame frame = writer.startList(SqlWriter.FrameTypeEnum.SIMPLE);
       for (Pair<SqlLiteral, SqlLiteral> using : pairs()) {
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateMaterializedView.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateMaterializedView.java
index de3b4804e..df1061bc6 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateMaterializedView.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateMaterializedView.java
@@ -30,7 +30,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Parse tree for {@code CREATE MATERIALIZED VIEW} statement. */
 public class SqlCreateMaterializedView extends SqlCreate {
@@ -50,13 +51,13 @@ public class SqlCreateMaterializedView extends SqlCreate {
       @Nullable SqlNodeList columnList,
       SqlNode query) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.columnList = columnList; // may be null
-    this.query = Objects.requireNonNull(query, "query");
+    this.query = requireNonNull(query, "query");
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(name, columnList, query);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateSchema.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateSchema.java
index 1ea927586..6e2dfb708 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateSchema.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateSchema.java
@@ -27,7 +27,8 @@
 import org.apache.calcite.util.ImmutableNullableList;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Parse tree for {@code CREATE SCHEMA} statement. */
 public class SqlCreateSchema extends SqlCreate {
@@ -39,7 +40,7 @@ public class SqlCreateSchema extends SqlCreate {
   /** Creates a SqlCreateSchema. */
   SqlCreateSchema(SqlParserPos pos, boolean replace, boolean ifNotExists, SqlIdentifier name) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
   }
 
   @Override public List<SqlNode> getOperandList() {
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateTable.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateTable.java
index e2d0ee586..d655e8fe1 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateTable.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateTable.java
@@ -30,7 +30,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Parse tree for {@code CREATE TABLE} statement. */
 public class SqlCreateTable extends SqlCreate {
@@ -50,13 +51,13 @@ protected SqlCreateTable(
       @Nullable SqlNodeList columnList,
       @Nullable SqlNode query) {
     super(OPERATOR, pos, replace, ifNotExists);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.columnList = columnList; // may be null
     this.query = query; // for "CREATE TABLE ... AS query"; may be null
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(name, columnList, query);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateType.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateType.java
index d56210f47..b1c989c15 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateType.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateType.java
@@ -31,7 +31,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Parse tree for {@code CREATE TYPE} statement. */
 public class SqlCreateType extends SqlCreate {
@@ -50,13 +51,13 @@ public class SqlCreateType extends SqlCreate {
       @Nullable SqlNodeList attributeDefs,
       @Nullable SqlDataTypeSpec dataType) {
     super(OPERATOR, pos, replace, false);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.attributeDefs = attributeDefs; // may be null
     this.dataType = dataType; // may be null
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(name, attributeDefs);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateView.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateView.java
index 37c0ece8e..94df6b216 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateView.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateView.java
@@ -30,7 +30,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Parse tree for {@code CREATE VIEW} statement. */
 public class SqlCreateView extends SqlCreate {
@@ -49,13 +50,13 @@ public class SqlCreateView extends SqlCreate {
       @Nullable SqlNodeList columnList,
       SqlNode query) {
     super(OPERATOR, pos, replace, false);
-    this.name = Objects.requireNonNull(name, "name");
+    this.name = requireNonNull(name, "name");
     this.columnList = columnList; // may be null
-    this.query = Objects.requireNonNull(query, "query");
+    this.query = requireNonNull(query, "query");
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(name, columnList, query);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlKeyConstraint.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlKeyConstraint.java
index 134be71e7..eb1d82af8 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlKeyConstraint.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlKeyConstraint.java
@@ -72,8 +72,8 @@ public static SqlKeyConstraint primary(
     return UNIQUE;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return ImmutableNullableList.of(name, columnList);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java
index 63b2560a4..00b55e2f5 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java
@@ -46,8 +46,6 @@
 import org.apache.calcite.util.format.FormatModel;
 import org.apache.calcite.util.format.FormatModels;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Arrays;
@@ -74,103 +72,102 @@ public class BigQuerySqlDialect extends SqlDialect {
   public static final SqlDialect DEFAULT = new BigQuerySqlDialect(DEFAULT_CONTEXT);
 
   private static final List<String> RESERVED_KEYWORDS =
-      ImmutableList.copyOf(
-          Arrays.asList(
-              "ALL",
-              "AND",
-              "ANY",
-              "ARRAY",
-              "AS",
-              "ASC",
-              "ASSERT_ROWS_MODIFIED",
-              "AT",
-              "BETWEEN",
-              "BY",
-              "CASE",
-              "CAST",
-              "COLLATE",
-              "CONTAINS",
-              "CREATE",
-              "CROSS",
-              "CUBE",
-              "CURRENT",
-              "DEFAULT",
-              "DEFINE",
-              "DESC",
-              "DISTINCT",
-              "ELSE",
-              "END",
-              "ENUM",
-              "ESCAPE",
-              "EXCEPT",
-              "EXCLUDE",
-              "EXISTS",
-              "EXTRACT",
-              "FALSE",
-              "FETCH",
-              "FOLLOWING",
-              "FOR",
-              "FROM",
-              "FULL",
-              "GROUP",
-              "GROUPING",
-              "GROUPS",
-              "HASH",
-              "HAVING",
-              "IF",
-              "IGNORE",
-              "IN",
-              "INNER",
-              "INTERSECT",
-              "INTERVAL",
-              "INTO",
-              "IS",
-              "JOIN",
-              "LATERAL",
-              "LEFT",
-              "LIKE",
-              "LIMIT",
-              "LOOKUP",
-              "MERGE",
-              "NATURAL",
-              "NEW",
-              "NO",
-              "NOT",
-              "NULL",
-              "NULLS",
-              "OF",
-              "ON",
-              "OR",
-              "ORDER",
-              "OUTER",
-              "OVER",
-              "PARTITION",
-              "PRECEDING",
-              "PROTO",
-              "RANGE",
-              "RECURSIVE",
-              "RESPECT",
-              "RIGHT",
-              "ROLLUP",
-              "ROWS",
-              "SELECT",
-              "SET",
-              "SOME",
-              "STRUCT",
-              "TABLESAMPLE",
-              "THEN",
-              "TO",
-              "TREAT",
-              "TRUE",
-              "UNBOUNDED",
-              "UNION",
-              "UNNEST",
-              "USING",
-              "WHEN",
-              "WHERE",
-              "WINDOW",
-              "WITH",
-              "WITHIN"));
+      Arrays.asList(
+          "ALL",
+          "AND",
+          "ANY",
+          "ARRAY",
+          "AS",
+          "ASC",
+          "ASSERT_ROWS_MODIFIED",
+          "AT",
+          "BETWEEN",
+          "BY",
+          "CASE",
+          "CAST",
+          "COLLATE",
+          "CONTAINS",
+          "CREATE",
+          "CROSS",
+          "CUBE",
+          "CURRENT",
+          "DEFAULT",
+          "DEFINE",
+          "DESC",
+          "DISTINCT",
+          "ELSE",
+          "END",
+          "ENUM",
+          "ESCAPE",
+          "EXCEPT",
+          "EXCLUDE",
+          "EXISTS",
+          "EXTRACT",
+          "FALSE",
+          "FETCH",
+          "FOLLOWING",
+          "FOR",
+          "FROM",
+          "FULL",
+          "GROUP",
+          "GROUPING",
+          "GROUPS",
+          "HASH",
+          "HAVING",
+          "IF",
+          "IGNORE",
+          "IN",
+          "INNER",
+          "INTERSECT",
+          "INTERVAL",
+          "INTO",
+          "IS",
+          "JOIN",
+          "LATERAL",
+          "LEFT",
+          "LIKE",
+          "LIMIT",
+          "LOOKUP",
+          "MERGE",
+          "NATURAL",
+          "NEW",
+          "NO",
+          "NOT",
+          "NULL",
+          "NULLS",
+          "OF",
+          "ON",
+          "OR",
+          "ORDER",
+          "OUTER",
+          "OVER",
+          "PARTITION",
+          "PRECEDING",
+          "PROTO",
+          "RANGE",
+          "RECURSIVE",
+          "RESPECT",
+          "RIGHT",
+          "ROLLUP",
+          "ROWS",
+          "SELECT",
+          "SET",
+          "SOME",
+          "STRUCT",
+          "TABLESAMPLE",
+          "THEN",
+          "TO",
+          "TREAT",
+          "TRUE",
+          "UNBOUNDED",
+          "UNION",
+          "UNNEST",
+          "USING",
+          "WHEN",
+          "WHERE",
+          "WINDOW",
+          "WITH",
+          "WITHIN");
 
   /**
    * An unquoted BigQuery identifier must start with a letter and be followed by zero or more
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/Db2SqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/Db2SqlDialect.java
index db6de9ae2..901e36a24 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/Db2SqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/Db2SqlDialect.java
@@ -68,7 +68,7 @@ public Db2SqlDialect(Context context) {
         throw new AssertionError("Unsupported type: " + qualifier.timeUnitRange);
     }
 
-    if (null != qualifier.timeUnitRange.endUnit) {
+    if (qualifier.timeUnitRange.endUnit != null) {
       throw new AssertionError("Unsupported end unit: " + qualifier.timeUnitRange.endUnit);
     }
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java
index d3b4f45b8..e2edbfaab 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java
@@ -37,8 +37,6 @@
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.util.RelToSqlConverterUtil;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Arrays;
@@ -63,117 +61,116 @@ public FireboltSqlDialect(Context context) {
 
   /** Reserved Keywords for Firebolt. */
   private static final List<String> RESERVED_KEYWORDS =
-      ImmutableList.copyOf(
-          Arrays.asList(
-              "ALL",
-              "ALTER",
-              "AND",
-              "ARRAY",
-              "BETWEEN",
-              "BIGINT",
-              "BOOL",
-              "BOOLEAN",
-              "BOTH",
-              "CASE",
-              "CAST",
-              "CHAR",
-              "CONCAT",
-              "COPY",
-              "CREATE",
-              "CROSS",
-              "CURRENT_DATE",
-              "CURRENT_TIMESTAMP",
-              "DATABASE",
-              "DATE",
-              "DATETIME",
-              "DECIMAL",
-              "DELETE",
-              "DESCRIBE",
-              "DISTINCT",
-              "DOUBLE",
-              "DOUBLECOLON",
-              "DOW",
-              "DOY",
-              "DROP",
-              "EMPTY_IDENTIFIER",
-              "EPOCH",
-              "EXCEPT",
-              "EXECUTE",
-              "EXISTS",
-              "EXPLAIN",
-              "EXTRACT",
-              "FALSE",
-              "FETCH",
-              "FIRST",
-              "FLOAT",
-              "FROM",
-              "FULL",
-              "GENERATE",
-              "GROUP",
-              "HAVING",
-              "IF",
-              "ILIKE",
-              "IN",
-              "INNER",
-              "INSERT",
-              "INT",
-              "INTEGER",
-              "INTERSECT",
-              "INTERVAL",
-              "IS",
-              "ISNULL",
-              "JOIN",
-              "JOIN_TYPE",
-              "LEADING",
-              "LEFT",
-              "LIKE",
-              "LIMIT",
-              "LIMIT_DISTINCT",
-              "LOCALTIMESTAMP",
-              "LONG",
-              "NATURAL",
-              "NEXT",
-              "NOT",
-              "NULL",
-              "NUMERIC",
-              "OFFSET",
-              "ON",
-              "ONLY",
-              "OR",
-              "ORDER",
-              "OUTER",
-              "OVER",
-              "PARTITION",
-              "PRECISION",
-              "PREPARE",
-              "PRIMARY",
-              "QUARTER",
-              "RIGHT",
-              "ROW",
-              "ROWS",
-              "SAMPLE",
-              "SELECT",
-              "SET",
-              "SHOW",
-              "TEXT",
-              "TIME",
-              "TIMESTAMP",
-              "TOP",
-              "TRAILING",
-              "TRIM",
-              "TRUE",
-              "TRUNCATE",
-              "UNION",
-              "UNKNOWN_CHAR",
-              "UNNEST",
-              "UNTERMINATED_STRING",
-              "UPDATE",
-              "USING",
-              "VARCHAR",
-              "WEEK",
-              "WHEN",
-              "WHERE",
-              "WITH"));
+      Arrays.asList(
+          "ALL",
+          "ALTER",
+          "AND",
+          "ARRAY",
+          "BETWEEN",
+          "BIGINT",
+          "BOOL",
+          "BOOLEAN",
+          "BOTH",
+          "CASE",
+          "CAST",
+          "CHAR",
+          "CONCAT",
+          "COPY",
+          "CREATE",
+          "CROSS",
+          "CURRENT_DATE",
+          "CURRENT_TIMESTAMP",
+          "DATABASE",
+          "DATE",
+          "DATETIME",
+          "DECIMAL",
+          "DELETE",
+          "DESCRIBE",
+          "DISTINCT",
+          "DOUBLE",
+          "DOUBLECOLON",
+          "DOW",
+          "DOY",
+          "DROP",
+          "EMPTY_IDENTIFIER",
+          "EPOCH",
+          "EXCEPT",
+          "EXECUTE",
+          "EXISTS",
+          "EXPLAIN",
+          "EXTRACT",
+          "FALSE",
+          "FETCH",
+          "FIRST",
+          "FLOAT",
+          "FROM",
+          "FULL",
+          "GENERATE",
+          "GROUP",
+          "HAVING",
+          "IF",
+          "ILIKE",
+          "IN",
+          "INNER",
+          "INSERT",
+          "INT",
+          "INTEGER",
+          "INTERSECT",
+          "INTERVAL",
+          "IS",
+          "ISNULL",
+          "JOIN",
+          "JOIN_TYPE",
+          "LEADING",
+          "LEFT",
+          "LIKE",
+          "LIMIT",
+          "LIMIT_DISTINCT",
+          "LOCALTIMESTAMP",
+          "LONG",
+          "NATURAL",
+          "NEXT",
+          "NOT",
+          "NULL",
+          "NUMERIC",
+          "OFFSET",
+          "ON",
+          "ONLY",
+          "OR",
+          "ORDER",
+          "OUTER",
+          "OVER",
+          "PARTITION",
+          "PRECISION",
+          "PREPARE",
+          "PRIMARY",
+          "QUARTER",
+          "RIGHT",
+          "ROW",
+          "ROWS",
+          "SAMPLE",
+          "SELECT",
+          "SET",
+          "SHOW",
+          "TEXT",
+          "TIME",
+          "TIMESTAMP",
+          "TOP",
+          "TRAILING",
+          "TRIM",
+          "TRUE",
+          "TRUNCATE",
+          "UNION",
+          "UNKNOWN_CHAR",
+          "UNNEST",
+          "UNTERMINATED_STRING",
+          "UPDATE",
+          "USING",
+          "VARCHAR",
+          "WEEK",
+          "WHEN",
+          "WHERE",
+          "WITH");
 
   /**
    * An unquoted Firebolt identifier must start with a letter and be followed by zero or more
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
index 9882359b5..6b315090a 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
@@ -102,12 +102,12 @@ public JethroDataSqlDialect(Context context) {
         }
       }
     }
-    LOGGER.debug("Unsupported function in jethro: " + operator + " with params " + paramTypes);
+    LOGGER.debug("Unsupported function in jethro: {} with params {}", operator, paramTypes);
     return false;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public boolean supportsOffsetFetch() {
+  @Override @SuppressWarnings("deprecation")
+  public boolean supportsOffsetFetch() {
     return false;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
index 48e292fee..5f1451ad1 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
@@ -40,6 +40,8 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** A <code>SqlDialect</code> implementation for the Microsoft SQL Server database. */
@@ -147,9 +149,7 @@ public MssqlSqlDialect(Context context) {
 
   @Override public void unparseCall(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
     if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {
-      if (call.operandCount() != 3) {
-        throw new IllegalArgumentException("MSSQL SUBSTRING requires FROM and FOR arguments");
-      }
+      checkArgument(call.operandCount() == 3, "MSSQL SUBSTRING requires FROM and FOR arguments");
       SqlUtil.unparseFunctionSyntax(MSSQL_SUBSTRING, writer, call, false);
     } else {
       switch (call.getKind()) {
@@ -260,7 +260,7 @@ private static void unparseFloor(SqlWriter writer, SqlCall call) {
         throw new AssertionError("Unsupported type: " + qualifier.timeUnitRange);
     }
 
-    if (null != qualifier.timeUnitRange.endUnit) {
+    if (qualifier.timeUnitRange.endUnit != null) {
       throw new AssertionError("End unit is not supported now: " + qualifier.timeUnitRange.endUnit);
     }
   }
@@ -290,7 +290,7 @@ private static void unparseFloorWithUnit(
     call.operand(0).unparse(writer, 0, 0);
     writer.print(", 126)");
 
-    if (offset.length() > 0) {
+    if (!offset.isEmpty()) {
       writer.print("+'" + offset + "'");
     }
     writer.endList(frame);
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
index a828ca3e6..dd1a50fae 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
@@ -239,7 +239,7 @@ public MysqlSqlDialect(Context context) {
 
       case WITHIN_GROUP:
         final List<SqlNode> operands = call.getOperandList();
-        if (operands.size() <= 0 || operands.get(0).getKind() != SqlKind.LISTAGG) {
+        if (operands.isEmpty() || operands.get(0).getKind() != SqlKind.LISTAGG) {
           super.unparseCall(writer, call, leftPrec, rightPrec);
           return;
         }
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/PrestoSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/PrestoSqlDialect.java
index 17d8a5d22..29212e13b 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/PrestoSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/PrestoSqlDialect.java
@@ -29,10 +29,10 @@
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.util.RelToSqlConverterUtil;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** A <code>SqlDialect</code> implementation for the Presto database. */
 public class PrestoSqlDialect extends SqlDialect {
   public static final Context DEFAULT_CONTEXT =
@@ -69,7 +69,7 @@ public PrestoSqlDialect(Context context) {
   /** Unparses offset/fetch using "OFFSET offset LIMIT fetch " syntax. */
   private static void unparseUsingLimit(
       SqlWriter writer, @Nullable SqlNode offset, @Nullable SqlNode fetch) {
-    Preconditions.checkArgument(fetch != null || offset != null);
+    checkArgument(fetch != null || offset != null);
     unparseOffset(writer, offset);
     unparseLimit(writer, fetch);
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlAnyValueAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlAnyValueAggFunction.java
index c2b35643c..e2f58bec7 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlAnyValueAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlAnyValueAggFunction.java
@@ -24,10 +24,10 @@
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.util.Optionality;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Definition of the <code>ANY_VALUE</code> aggregate functions, returning any one of the values
  * which go into it.
@@ -51,7 +51,7 @@ public SqlAnyValueAggFunction(SqlKind kind) {
         false,
         false,
         Optionality.FORBIDDEN);
-    Preconditions.checkArgument(kind == SqlKind.ANY_VALUE);
+    checkArgument(kind == SqlKind.ANY_VALUE);
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlAvgAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlAvgAggFunction.java
index 95c2647bc..9d8e06a3e 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlAvgAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlAvgAggFunction.java
@@ -24,7 +24,7 @@
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.util.Optionality;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * <code>Avg</code> is an aggregator which returns the average of the values which go into it. It
@@ -53,7 +53,7 @@ public SqlAvgAggFunction(SqlKind kind) {
         false,
         false,
         Optionality.FORBIDDEN);
-    Preconditions.checkArgument(SqlKind.AVG_AGG_FUNCTIONS.contains(kind), "unsupported sql kind");
+    checkArgument(SqlKind.AVG_AGG_FUNCTIONS.contains(kind), "unsupported sql kind");
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlBitOpAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlBitOpAggFunction.java
index 80dfc8366..3b775a916 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlBitOpAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlBitOpAggFunction.java
@@ -24,10 +24,10 @@
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.util.Optionality;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Definition of the <code>BIT_AND</code> and <code>BIT_OR</code> aggregate functions, returning the
  * bitwise AND/OR of all non-null input values, or null if none.
@@ -51,8 +51,7 @@ public SqlBitOpAggFunction(SqlKind kind) {
         false,
         false,
         Optionality.FORBIDDEN);
-    Preconditions.checkArgument(
-        kind == SqlKind.BIT_AND || kind == SqlKind.BIT_OR || kind == SqlKind.BIT_XOR);
+    checkArgument(kind == SqlKind.BIT_AND || kind == SqlKind.BIT_OR || kind == SqlKind.BIT_XOR);
   }
 
   @Override public <T extends Object> @Nullable T unwrap(Class<T> clazz) {
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java
index c97b7aaeb..e6e8552c9 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java
@@ -83,7 +83,7 @@ public static SqlCase createSwitched(
       SqlNodeList whenList,
       SqlNodeList thenList,
       @Nullable SqlNode elseClause) {
-    if (null != value) {
+    if (value != null) {
       for (int i = 0; i < whenList.size(); i++) {
         SqlNode e = whenList.get(i);
         final SqlCall call;
@@ -96,7 +96,7 @@ public static SqlCase createSwitched(
       }
     }
 
-    if (null == elseClause) {
+    if (elseClause == null) {
       elseClause = SqlLiteral.createNull(pos);
     }
 
@@ -113,13 +113,13 @@ public static SqlCase createSwitched(
     return SqlStdOperatorTable.CASE;
   }
 
-  @SuppressWarnings("nullness")
-  @Override public List<SqlNode> getOperandList() {
+  @Override @SuppressWarnings("nullness")
+  public List<SqlNode> getOperandList() {
     return UnmodifiableArrayList.of(value, whenList, thenList, elseExpr);
   }
 
-  @SuppressWarnings("assignment.type.incompatible")
-  @Override public void setOperand(int i, @Nullable SqlNode operand) {
+  @Override @SuppressWarnings("assignment.type.incompatible")
+  public void setOperand(int i, @Nullable SqlNode operand) {
     switch (i) {
       case 0:
         value = operand;
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
index a0d951d9c..28492841b 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
@@ -262,7 +262,7 @@ private static RelDataType inferTypeFromValidator(SqlCallBinding callBinding) {
     }
 
     RelDataType ret = typeFactory.leastRestrictive(argTypes);
-    if (null == ret) {
+    if (ret == null) {
       boolean coerced = false;
       if (callBinding.isTypeCoercionEnabled()) {
         TypeCoercion typeCoercion = callBinding.getValidator().getTypeCoercion();
@@ -271,7 +271,7 @@ private static RelDataType inferTypeFromValidator(SqlCallBinding callBinding) {
         // nullability when deducing the common type. Use the deduced type
         // (with the correct nullability) in SqlValidator
         // instead of the commonType as the return type.
-        if (null != commonType) {
+        if (commonType != null) {
           coerced = typeCoercion.caseWhenCoercion(callBinding);
           if (coerced) {
             ret = SqlTypeUtil.deriveType(callBinding);
@@ -328,8 +328,8 @@ private static RelDataType inferTypeFromOperands(SqlOperatorBinding opBinding) {
     return SqlSyntax.SPECIAL;
   }
 
-  @SuppressWarnings("argument.type.incompatible")
-  @Override public SqlCall createCall(
+  @Override @SuppressWarnings("argument.type.incompatible")
+  public SqlCall createCall(
       @Nullable SqlLiteral functionQualifier, SqlParserPos pos, @Nullable SqlNode... operands) {
     assert functionQualifier == null;
     assert operands.length == 4;
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlCountAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlCountAggFunction.java
index e9801decf..286b7779d 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlCountAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlCountAggFunction.java
@@ -73,14 +73,14 @@ public SqlCountAggFunction(String name, SqlOperandTypeChecker sqlOperandTypeChec
     return SqlSyntax.FUNCTION_STAR;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     return ImmutableList.of(
         typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.ANY), true));
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     return typeFactory.createSqlType(SqlTypeName.BIGINT);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java
index fcc9b6621..8b7f0f19b 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java
@@ -24,7 +24,7 @@
 import org.apache.calcite.sql.type.ReturnTypes;
 import org.apache.calcite.util.Optionality;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * <code>Covar</code> is an aggregator which returns the Covariance of the values which go into it.
@@ -50,8 +50,7 @@ public SqlCovarAggFunction(SqlKind kind) {
         false,
         false,
         Optionality.FORBIDDEN);
-    Preconditions.checkArgument(
-        SqlKind.COVAR_AVG_AGG_FUNCTIONS.contains(kind), "unsupported sql kind: " + kind);
+    checkArgument(SqlKind.COVAR_AVG_AGG_FUNCTIONS.contains(kind), "unsupported sql kind: %s", kind);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlFirstLastValueAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlFirstLastValueAggFunction.java
index 9f4058f43..b719dcf27 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlFirstLastValueAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlFirstLastValueAggFunction.java
@@ -26,11 +26,12 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.util.Optionality;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * <code>FIRST_VALUE</code> and <code>LAST_VALUE</code> aggregate functions return the first or the
  * last value in a list of values that are input to the function.
@@ -50,7 +51,7 @@ public SqlFirstLastValueAggFunction(SqlKind kind) {
         false,
         true,
         Optionality.FORBIDDEN);
-    Preconditions.checkArgument(kind == SqlKind.FIRST_VALUE || kind == SqlKind.LAST_VALUE);
+    checkArgument(kind == SqlKind.FIRST_VALUE || kind == SqlKind.LAST_VALUE);
   }
 
   @Deprecated // to be removed before 2.0
@@ -60,14 +61,14 @@ public SqlFirstLastValueAggFunction(boolean firstFlag) {
 
   // ~ Methods ----------------------------------------------------------------
 
-  @SuppressWarnings("deprecation")
-  @Override public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     return ImmutableList.of(
         typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.ANY), true));
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     return typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.ANY), true);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlFloorFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlFloorFunction.java
index becbb0e44..c4b470b8b 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlFloorFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlFloorFunction.java
@@ -37,10 +37,10 @@
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Definition of the "FLOOR" and "CEIL" built-in SQL functions. */
 public class SqlFloorFunction extends SqlMonotonicUnaryFunction {
   // ~ Constructors -----------------------------------------------------------
@@ -74,7 +74,7 @@ public SqlFloorFunction(SqlKind kind) {
                 OperandTypes.DATETIME,
                 OperandTypes.ANY)),
         SqlFunctionCategory.NUMERIC);
-    Preconditions.checkArgument(kind == SqlKind.FLOOR || kind == SqlKind.CEIL);
+    checkArgument(kind == SqlKind.FLOOR || kind == SqlKind.CEIL);
   }
 
   public SqlFloorFunction withName(String name) {
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlHistogramAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlHistogramAggFunction.java
index b6c09d8f9..5e0bfb633 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlHistogramAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlHistogramAggFunction.java
@@ -60,8 +60,8 @@ public SqlHistogramAggFunction(RelDataType type) {
 
   // ~ Methods ----------------------------------------------------------------
 
-  @SuppressWarnings("deprecation")
-  @Override public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     return ImmutableList.of(type);
   }
 
@@ -70,8 +70,8 @@ public RelDataType getType() {
     return type;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     return type;
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
index 67e7d9c5a..05c6a2573 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
@@ -128,11 +128,11 @@ private static SqlBinaryOperator of(SqlKind kind) {
       // First check that the expressions in the IN list are compatible
       // with each other. Same rules as the VALUES operator (per
       // SQL:2003 Part 2 Section 8.4, <in predicate>).
-      if (null == rightType && validator.config().typeCoercionEnabled()) {
+      if (rightType == null && validator.config().typeCoercionEnabled()) {
         // Do implicit type cast if it is allowed to.
         rightType = validator.getTypeCoercion().getWiderTypeFor(rightTypeList, true);
       }
-      if (null == rightType) {
+      if (rightType == null) {
         throw validator.newValidationError(right, RESOURCE.incompatibleTypesInList());
       }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayAggAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayAggAggFunction.java
index 01e76d731..dbaf814ba 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayAggAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonArrayAggAggFunction.java
@@ -36,7 +36,7 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** The <code>JSON_OBJECTAGG</code> aggregate function. */
 public class SqlJsonArrayAggAggFunction extends SqlAggFunction {
@@ -54,7 +54,7 @@ public SqlJsonArrayAggAggFunction(SqlKind kind, SqlJsonConstructorNullClause nul
         false,
         false,
         Optionality.OPTIONAL);
-    this.nullClause = Objects.requireNonNull(nullClause, "nullClause");
+    this.nullClause = requireNonNull(nullClause, "nullClause");
   }
 
   @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectAggAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectAggAggFunction.java
index e1104cdf6..3eec5dd70 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectAggAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonObjectAggAggFunction.java
@@ -33,7 +33,7 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.Optionality;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** The <code>JSON_OBJECTAGG</code> aggregate function. */
 public class SqlJsonObjectAggAggFunction extends SqlAggFunction {
@@ -58,7 +58,7 @@ public SqlJsonObjectAggAggFunction(SqlKind kind, SqlJsonConstructorNullClause nu
         false,
         false,
         Optionality.FORBIDDEN);
-    this.nullClause = Objects.requireNonNull(nullClause, "nullClause");
+    this.nullClause = requireNonNull(nullClause, "nullClause");
   }
 
   @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java
index 266d80a4d..2391429b8 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java
@@ -45,7 +45,8 @@
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /** The <code>JSON_VALUE</code> function. */
 public class SqlJsonValueFunction extends SqlFunction {
@@ -55,7 +56,7 @@ public SqlJsonValueFunction(String name) {
         name,
         SqlKind.OTHER_FUNCTION,
         ReturnTypes.cascade(
-            opBinding -> explicitTypeSpec(opBinding).orElse(getDefaultType(opBinding)),
+            opBinding -> explicitTypeSpec(opBinding).orElseGet(() -> getDefaultType(opBinding)),
             SqlTypeTransforms.FORCE_NULLABLE),
         null,
         OperandTypes.family(
@@ -76,7 +77,7 @@ public static List<SqlNode> removeTypeSpecOperands(SqlCall call) {
       operands.set(2, null);
       operands.set(3, null);
     }
-    return operands.stream().filter(Objects::nonNull).collect(Collectors.toList());
+    return operands.stream().filter(Objects::nonNull).collect(toList());
   }
 
   @Override public SqlOperandCountRange getOperandCountRange() {
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLeadLagAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLeadLagAggFunction.java
index 71661271d..6cace2ae9 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLeadLagAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLeadLagAggFunction.java
@@ -29,7 +29,7 @@
 import org.apache.calcite.sql.type.SqlTypeTransforms;
 import org.apache.calcite.util.Optionality;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * <code>LEAD</code> and <code>LAG</code> aggregate functions return the value of given expression
@@ -56,7 +56,7 @@ public SqlLeadLagAggFunction(SqlKind kind) {
         false,
         true,
         Optionality.FORBIDDEN);
-    Preconditions.checkArgument(kind == SqlKind.LEAD || kind == SqlKind.LAG);
+    checkArgument(kind == SqlKind.LEAD || kind == SqlKind.LAG);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java
index fa15d2b0a..8158aff4b 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.config.CalciteConnectionProperty;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
@@ -30,6 +29,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -87,7 +88,7 @@ public enum SqlLibrary {
   SqlLibrary(String abbrev, String fun) {
     this.abbrev = requireNonNull(abbrev, "abbrev");
     this.fun = requireNonNull(fun, "fun");
-    Preconditions.checkArgument(fun.equals(name().toLowerCase(Locale.ROOT).replace("_", "")));
+    checkArgument(fun.equals(name().toLowerCase(Locale.ROOT).replace("_", "")));
   }
 
   @SuppressWarnings("SwitchStatementWithTooFewBranches")
@@ -111,9 +112,7 @@ public static List<SqlLibrary> parse(String libraryNameList) {
     if (!libraryNameList.isEmpty()) {
       for (String libraryName : libraryNameList.split(",")) {
         @Nullable SqlLibrary library = SqlLibrary.of(libraryName);
-        if (library == null) {
-          throw new IllegalArgumentException("unknown library '" + libraryName + "'");
-        }
+        checkArgument(library != null, "unknown library '%s'", libraryName);
         list.add(library);
       }
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
index 3ffd8d72b..e8e696073 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
@@ -53,7 +53,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
 import static org.apache.calcite.sql.fun.SqlLibrary.ALL;
@@ -68,6 +67,7 @@
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Defines functions and operators that are not part of standard SQL but belong to one or more other
@@ -86,7 +86,7 @@ private SqlLibraryOperators() {}
    * <p>This operator is for SQL (and AST); for internal use (RexNode and Aggregate) use {@code
    * AGG_M2M}.
    */
-  @LibraryOperator(libraries = {CALCITE})
+  @LibraryOperator(libraries = CALCITE)
   public static final SqlFunction AGGREGATE =
       SqlBasicAggFunction.create(
           "AGGREGATE", SqlKind.AGGREGATE_FN, ReturnTypes.ARG0, OperandTypes.MEASURE);
@@ -96,7 +96,7 @@ private SqlLibraryOperators() {}
    * from {@code tz1} to {@code tz2}. This function is only on Redshift, but we list it in
    * PostgreSQL because Redshift does not have its own library.
    */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlFunction CONVERT_TIMEZONE =
       SqlBasicFunction.create(
           "CONVERT_TIMEZONE",
@@ -105,7 +105,7 @@ private SqlLibraryOperators() {}
           SqlFunctionCategory.TIMEDATE);
 
   /** THE "DATE_ADD(date, interval)" function (BigQuery) adds the interval to the date. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_ADD =
       SqlBasicFunction.create(
               SqlKind.DATE_ADD, ReturnTypes.ARG0_NULLABLE, OperandTypes.DATE_INTERVAL)
@@ -115,7 +115,7 @@ private SqlLibraryOperators() {}
    * THE "DATE_DIFF(date, date2, timeUnit)" function (BigQuery) returns the number of timeUnit in
    * (date - date2).
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_DIFF =
       new SqlTimestampDiffFunction(
           "DATE_DIFF",
@@ -161,7 +161,7 @@ private SqlLibraryOperators() {}
    * <p>Not to be confused with standard {@link SqlStdOperatorTable#CONVERT}, which converts a
    * string from one character set to another.
    */
-  @LibraryOperator(libraries = {MSSQL})
+  @LibraryOperator(libraries = MSSQL)
   public static final SqlFunction MSSQL_CONVERT =
       SqlBasicFunction.create(
               SqlKind.CAST,
@@ -191,7 +191,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
   }
 
   /** The "DATE_PART(timeUnit, datetime)" function (Databricks, Postgres, Redshift, Snowflake). */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlFunction DATE_PART =
       new SqlExtractFunction("DATE_PART") {
         @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
@@ -203,14 +203,14 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
    * The "DATE_SUB(date, interval)" function (BigQuery); subtracts interval from the date,
    * independent of any time zone.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_SUB =
       SqlBasicFunction.create(
               SqlKind.DATE_SUB, ReturnTypes.ARG0_NULLABLE, OperandTypes.DATE_INTERVAL)
           .withFunctionType(SqlFunctionCategory.TIMEDATE);
 
   /** The "DATEPART(timeUnit, datetime)" function (Microsoft SQL Server). */
-  @LibraryOperator(libraries = {MSSQL})
+  @LibraryOperator(libraries = MSSQL)
   public static final SqlFunction DATEPART =
       new SqlExtractFunction("DATEPART") {
         @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
@@ -237,7 +237,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
       };
 
   /** The "DECODE(v, v1, result1, [v2, result2, ...], resultN)" function. */
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction DECODE =
       SqlBasicFunction.create(SqlKind.DECODE, DECODE_RETURN_TYPE, OperandTypes.VARIADIC);
 
@@ -271,7 +271,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
   }
 
   /** The "NVL(value, value)" function. */
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlBasicFunction NVL =
       SqlBasicFunction.create(
           SqlKind.NVL,
@@ -279,11 +279,11 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
           OperandTypes.SAME_SAME);
 
   /** The "IFNULL(value, value)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction IFNULL = NVL.withName("IFNULL");
 
   /** The "LENGTH(string)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction LENGTH = SqlStdOperatorTable.CHAR_LENGTH.withName("LENGTH");
 
   /** The "LPAD(original_value, return_length[, pattern])" function. */
@@ -327,7 +327,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
           .withFunctionType(SqlFunctionCategory.STRING);
 
   /** The "SPLIT(string [, delimiter])" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction SPLIT =
       SqlBasicFunction.create(
               "SPLIT",
@@ -368,7 +368,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.STRING);
 
   /** The "ENDS_WITH(value1, value2)" function (BigQuery). */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ENDS_WITH =
       SqlBasicFunction.create(
           "ENDS_WITH",
@@ -377,7 +377,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.STRING);
 
   /** The "STARTS_WITH(value1, value2)" function (BigQuery). */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction STARTS_WITH =
       SqlBasicFunction.create(
           "STARTS_WITH",
@@ -386,11 +386,11 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.STRING);
 
   /** BigQuery's "SUBSTR(string, position [, substringLength ])" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction SUBSTR_BIG_QUERY = SUBSTR.withKind(SqlKind.SUBSTR_BIG_QUERY);
 
   /** MySQL's "SUBSTR(string, position [, substringLength ])" function. */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction SUBSTR_MYSQL = SUBSTR.withKind(SqlKind.SUBSTR_MYSQL);
 
   /**
@@ -405,11 +405,11 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>If {@code position} &lt; 0, treat {@code position} as "length(string) + position + 1".
    * </ul>
    */
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction SUBSTR_ORACLE = SUBSTR.withKind(SqlKind.SUBSTR_ORACLE);
 
   /** PostgreSQL's "SUBSTR(string, position [, substringLength ])" function. */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlFunction SUBSTR_POSTGRESQL = SUBSTR.withKind(SqlKind.SUBSTR_POSTGRESQL);
 
   /** The "GREATEST(value, value)" function. */
@@ -432,7 +432,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "CEIL(value)" function. Identical to the standard <code>CEIL</code> function except the
    * return type should be a double if the operand is an integer.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction CEIL_BIG_QUERY =
       new SqlFloorFunction(SqlKind.CEIL)
           .withName("CEIL_BIG_QUERY")
@@ -442,7 +442,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "FLOOR(value)" function. Identical to the stadnard <code>FLOOR</code> function except the
    * return type should be a double if the operand is an integer.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FLOOR_BIG_QUERY =
       new SqlFloorFunction(SqlKind.FLOOR)
           .withName("FLOOR_BIG_QUERY")
@@ -459,40 +459,40 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
   @LibraryOperator(libraries = {BIG_QUERY, ORACLE, POSTGRESQL})
   public static final SqlFunction TRANSLATE3 = new SqlTranslate3Function();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_TYPE = new SqlJsonTypeFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_DEPTH = new SqlJsonDepthFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_LENGTH = new SqlJsonLengthFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_KEYS = new SqlJsonKeysFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_PRETTY = new SqlJsonPrettyFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_REMOVE = new SqlJsonRemoveFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_STORAGE_SIZE = new SqlJsonStorageSizeFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_INSERT = new SqlJsonModifyFunction("JSON_INSERT");
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_REPLACE = new SqlJsonModifyFunction("JSON_REPLACE");
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_SET = new SqlJsonModifyFunction("JSON_SET");
 
   @LibraryOperator(libraries = {MYSQL, ORACLE})
   public static final SqlFunction REGEXP_REPLACE = new SqlRegexpReplaceFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction COMPRESS =
       SqlBasicFunction.create(
           "COMPRESS",
@@ -500,28 +500,28 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.STRING,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction EXTRACT_VALUE =
       SqlBasicFunction.create(
           "EXTRACTVALUE",
           ReturnTypes.VARCHAR_2000.andThen(SqlTypeTransforms.FORCE_NULLABLE),
           OperandTypes.STRING_STRING);
 
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction XML_TRANSFORM =
       SqlBasicFunction.create(
           "XMLTRANSFORM",
           ReturnTypes.VARCHAR_2000.andThen(SqlTypeTransforms.FORCE_NULLABLE),
           OperandTypes.STRING_STRING);
 
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction EXTRACT_XML =
       SqlBasicFunction.create(
           "EXTRACT",
           ReturnTypes.VARCHAR_2000.andThen(SqlTypeTransforms.FORCE_NULLABLE),
           OperandTypes.STRING_STRING_OPTIONAL_STRING);
 
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction EXISTS_NODE =
       SqlBasicFunction.create(
           "EXISTSNODE",
@@ -532,7 +532,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "BOOL_AND(condition)" aggregate function, PostgreSQL and Redshift's equivalent to {@link
    * SqlStdOperatorTable#EVERY}.
    */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlAggFunction BOOL_AND =
       new SqlMinMaxAggFunction("BOOL_AND", SqlKind.MIN, OperandTypes.BOOLEAN);
 
@@ -540,7 +540,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "BOOL_OR(condition)" aggregate function, PostgreSQL and Redshift's equivalent to {@link
    * SqlStdOperatorTable#SOME}.
    */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlAggFunction BOOL_OR =
       new SqlMinMaxAggFunction("BOOL_OR", SqlKind.MAX, OperandTypes.BOOLEAN);
 
@@ -548,7 +548,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "LOGICAL_AND(condition)" aggregate function, BigQuery's equivalent to {@link
    * SqlStdOperatorTable#EVERY}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction LOGICAL_AND =
       new SqlMinMaxAggFunction("LOGICAL_AND", SqlKind.MIN, OperandTypes.BOOLEAN);
 
@@ -556,7 +556,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "LOGICAL_OR(condition)" aggregate function, BigQuery's equivalent to {@link
    * SqlStdOperatorTable#SOME}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction LOGICAL_OR =
       new SqlMinMaxAggFunction("LOGICAL_OR", SqlKind.MAX, OperandTypes.BOOLEAN);
 
@@ -566,7 +566,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *
    * <p>{@code COUNTIF(b)} is equivalent to {@code COUNT(*) FILTER (WHERE b)}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction COUNTIF =
       SqlBasicAggFunction.create(SqlKind.COUNTIF, ReturnTypes.BIGINT, OperandTypes.BOOLEAN)
           .withDistinct(Optionality.FORBIDDEN);
@@ -575,7 +575,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "ARRAY_AGG(value [ ORDER BY ...])" aggregate function, in BigQuery and PostgreSQL, gathers
    * values into arrays.
    */
-  @LibraryOperator(libraries = {POSTGRESQL, BIG_QUERY})
+  @LibraryOperator(libraries = {BIG_QUERY, POSTGRESQL})
   public static final SqlAggFunction ARRAY_AGG =
       SqlBasicAggFunction.create(
               SqlKind.ARRAY_AGG,
@@ -589,7 +589,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "ARRAY_CONCAT_AGG(value [ ORDER BY ...])" aggregate function, in BigQuery and PostgreSQL,
    * concatenates array values into arrays.
    */
-  @LibraryOperator(libraries = {POSTGRESQL, BIG_QUERY})
+  @LibraryOperator(libraries = {BIG_QUERY, POSTGRESQL})
   public static final SqlAggFunction ARRAY_CONCAT_AGG =
       SqlBasicAggFunction.create(SqlKind.ARRAY_CONCAT_AGG, ReturnTypes.ARG0, OperandTypes.ARRAY)
           .withFunctionType(SqlFunctionCategory.SYSTEM)
@@ -602,7 +602,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * <p>{@code STRING_AGG(v, sep ORDER BY x, y)} is implemented by rewriting to {@code LISTAGG(v,
    * sep) WITHIN GROUP (ORDER BY x, y)}.
    */
-  @LibraryOperator(libraries = {POSTGRESQL, BIG_QUERY})
+  @LibraryOperator(libraries = {BIG_QUERY, POSTGRESQL})
   public static final SqlAggFunction STRING_AGG =
       SqlBasicAggFunction.create(
               SqlKind.STRING_AGG,
@@ -618,7 +618,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * <p>{@code GROUP_CONCAT(v ORDER BY x, y SEPARATOR s)} is implemented by rewriting to {@code
    * LISTAGG(v, s) WITHIN GROUP (ORDER BY x, y)}.
    */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlAggFunction GROUP_CONCAT =
       SqlBasicAggFunction.create(
               SqlKind.GROUP_CONCAT,
@@ -633,14 +633,14 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "MAX_BY(value, comp)" aggregate function, Spark's equivalent to {@link
    * SqlStdOperatorTable#ARG_MAX}.
    */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlAggFunction MAX_BY = SqlStdOperatorTable.ARG_MAX.withName("MAX_BY");
 
   /**
    * The "MIN_BY(condition)" aggregate function, Spark's equivalent to {@link
    * SqlStdOperatorTable#ARG_MIN}.
    */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlAggFunction MIN_BY = SqlStdOperatorTable.ARG_MIN.withName("MIN_BY");
 
   /**
@@ -648,7 +648,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * SqlStdOperatorTable#PERCENTILE_CONT}, but uses an {@code OVER} clause rather than {@code WITHIN
    * GROUP}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction PERCENTILE_CONT2 =
       SqlBasicAggFunction.create(
               "PERCENTILE_CONT",
@@ -665,7 +665,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * SqlStdOperatorTable#PERCENTILE_DISC}, but uses an {@code OVER} clause rather than {@code WITHIN
    * GROUP}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction PERCENTILE_DISC2 =
       SqlBasicAggFunction.create(
               "PERCENTILE_DISC",
@@ -687,7 +687,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code DATE(timestamp)}
    * </ul>
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE =
       SqlBasicFunction.create(
           "DATE",
@@ -721,7 +721,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code DATETIME(timestampLtz[, timeZone])}
    * </ul>
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME =
       SqlBasicFunction.create(
           "DATETIME",
@@ -757,7 +757,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code TIME(timestamp)}
    * </ul>
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME =
       SqlBasicFunction.create(
           "TIME",
@@ -787,7 +787,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code TIMESTAMP(timestamp[, timeZone])}
    * </ul>
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP =
       SqlBasicFunction.create(
           "TIMESTAMP",
@@ -811,7 +811,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.TIMEDATE);
 
   /** The "CURRENT_DATETIME([timezone])" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction CURRENT_DATETIME =
       SqlBasicFunction.create(
           "CURRENT_DATETIME",
@@ -823,7 +823,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "DATE_FROM_UNIX_DATE(integer)" function; returns a DATE value a given number of seconds
    * after 1970-01-01.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_FROM_UNIX_DATE =
       SqlBasicFunction.create(
           "DATE_FROM_UNIX_DATE",
@@ -832,7 +832,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.TIMEDATE);
 
   /** The "UNIX_DATE(date)" function; returns the number of days since 1970-01-01. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction UNIX_DATE =
       SqlBasicFunction.create(
           "UNIX_DATE",
@@ -844,7 +844,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "MONTHNAME(datetime)" function; returns the name of the month, in the current locale, of a
    * TIMESTAMP or DATE argument.
    */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction MONTHNAME =
       SqlBasicFunction.create(
           "MONTHNAME",
@@ -856,7 +856,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "DAYNAME(datetime)" function; returns the name of the day of the week, in the current
    * locale, of a TIMESTAMP or DATE argument.
    */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction DAYNAME =
       SqlBasicFunction.create(
           "DAYNAME", ReturnTypes.VARCHAR_2000, OperandTypes.DATETIME, SqlFunctionCategory.TIMEDATE);
@@ -885,7 +885,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.CBSTRING_INTEGER,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction SPACE =
       SqlBasicFunction.create(
           "SPACE",
@@ -893,7 +893,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.INTEGER,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction STRCMP =
       SqlBasicFunction.create(
           "STRCMP",
@@ -901,7 +901,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.STRING_STRING,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {BIG_QUERY, MYSQL, POSTGRESQL, ORACLE})
+  @LibraryOperator(libraries = {BIG_QUERY, MYSQL, ORACLE, POSTGRESQL})
   public static final SqlFunction SOUNDEX =
       SqlBasicFunction.create(
           "SOUNDEX",
@@ -909,7 +909,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.CHARACTER,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlFunction DIFFERENCE =
       SqlBasicFunction.create(
           "DIFFERENCE",
@@ -918,22 +918,22 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.STRING);
 
   /** The case-insensitive variant of the LIKE operator. */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlSpecialOperator ILIKE =
       new SqlLikeOperator("ILIKE", SqlKind.LIKE, false, false);
 
   /** The case-insensitive variant of the NOT LIKE operator. */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlSpecialOperator NOT_ILIKE =
       new SqlLikeOperator("NOT ILIKE", SqlKind.LIKE, true, false);
 
   /** The regex variant of the LIKE operator. */
-  @LibraryOperator(libraries = {SPARK, HIVE})
+  @LibraryOperator(libraries = {HIVE, SPARK})
   public static final SqlSpecialOperator RLIKE =
       new SqlLikeOperator("RLIKE", SqlKind.RLIKE, false, true);
 
   /** The regex variant of the NOT LIKE operator. */
-  @LibraryOperator(libraries = {SPARK, HIVE})
+  @LibraryOperator(libraries = {HIVE, SPARK})
   public static final SqlSpecialOperator NOT_RLIKE =
       new SqlLikeOperator("NOT RLIKE", SqlKind.RLIKE, true, true);
 
@@ -943,7 +943,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *
    * <p>It accepts at least 1 argument and returns null if any of the arguments is null.
    */
-  @LibraryOperator(libraries = {MYSQL, BIG_QUERY})
+  @LibraryOperator(libraries = {BIG_QUERY, MYSQL})
   public static final SqlFunction CONCAT_FUNCTION =
       SqlBasicFunction.create(
               "CONCAT",
@@ -985,7 +985,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *
    * <p>It is assigned {@link SqlKind#CONCAT2} to make it not equal to {@link #CONCAT_FUNCTION}.
    */
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction CONCAT2 =
       SqlBasicFunction.create(
               "CONCAT",
@@ -1032,7 +1032,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code CONCAT_WS(null, null, null)} returns "".
    * </ul>
    */
-  @LibraryOperator(libraries = {MSSQL})
+  @LibraryOperator(libraries = MSSQL)
   public static final SqlFunction CONCAT_WS_MSSQL =
       SqlBasicFunction.create(
               "CONCAT_WS",
@@ -1055,7 +1055,7 @@ private static RelDataType arrayReturnType(SqlOperatorBinding opBinding) {
    * The "ARRAY(exp, ...)" function (Spark); compare with the standard array value constructor,
    * "ARRAY [exp, ...]".
    */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY =
       SqlBasicFunction.create(
           "ARRAY", SqlLibraryOperators::arrayReturnType, OperandTypes.SAME_VARIADIC);
@@ -1075,7 +1075,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
   }
 
   /** The "ARRAY_APPEND(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_APPEND =
       SqlBasicFunction.create(
           SqlKind.ARRAY_APPEND,
@@ -1083,12 +1083,12 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_COMPACT(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_COMPACT =
       SqlBasicFunction.create(SqlKind.ARRAY_COMPACT, ReturnTypes.ARG0_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_CONCAT(array [, array]*)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ARRAY_CONCAT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_CONCAT,
@@ -1096,19 +1096,19 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.AT_LEAST_ONE_SAME_VARIADIC);
 
   /** The "ARRAY_CONTAINS(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_CONTAINS =
       SqlBasicFunction.create(
           SqlKind.ARRAY_CONTAINS, ReturnTypes.BOOLEAN_NULLABLE, OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_DISTINCT(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_DISTINCT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_DISTINCT, ReturnTypes.ARG0_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_EXCEPT(array1, array2)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_EXCEPT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_EXCEPT,
@@ -1118,7 +1118,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
               OperandTypes.family(SqlTypeFamily.ARRAY, SqlTypeFamily.ARRAY)));
 
   /** The "ARRAY_INTERSECT(array1, array2)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_INTERSECT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_INTERSECT,
@@ -1128,7 +1128,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
               OperandTypes.family(SqlTypeFamily.ARRAY, SqlTypeFamily.ARRAY)));
 
   /** The "ARRAY_JOIN(array, delimiter [, nullText ])" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_JOIN =
       SqlBasicFunction.create(
           SqlKind.ARRAY_JOIN,
@@ -1136,31 +1136,31 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.STRING_ARRAY_CHARACTER_OPTIONAL_CHARACTER);
 
   /** The "ARRAY_LENGTH(array)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ARRAY_LENGTH =
       SqlBasicFunction.create(
           SqlKind.ARRAY_LENGTH, ReturnTypes.INTEGER_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_MAX(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_MAX =
       SqlBasicFunction.create(
           SqlKind.ARRAY_MAX, ReturnTypes.TO_COLLECTION_ELEMENT_FORCE_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_MAX(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_MIN =
       SqlBasicFunction.create(
           SqlKind.ARRAY_MIN, ReturnTypes.TO_COLLECTION_ELEMENT_FORCE_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_POSITION(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_POSITION =
       SqlBasicFunction.create(
           SqlKind.ARRAY_POSITION, ReturnTypes.BIGINT_NULLABLE, OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_PREPEND(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_PREPEND =
       SqlBasicFunction.create(
           SqlKind.ARRAY_PREPEND,
@@ -1168,13 +1168,13 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_REMOVE(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_REMOVE =
       SqlBasicFunction.create(
           SqlKind.ARRAY_REMOVE, ReturnTypes.ARG0_NULLABLE, OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_REPEAT(element, count)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_REPEAT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_REPEAT,
@@ -1185,17 +1185,17 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
               OperandTypes.typeName(SqlTypeName.INTEGER)));
 
   /** The "ARRAY_REVERSE(array)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ARRAY_REVERSE =
       SqlBasicFunction.create(SqlKind.ARRAY_REVERSE, ReturnTypes.ARG0_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_SIZE(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_SIZE =
       SqlBasicFunction.create(SqlKind.ARRAY_SIZE, ReturnTypes.INTEGER_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_UNION(array1, array2)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_UNION =
       SqlBasicFunction.create(
           SqlKind.ARRAY_UNION,
@@ -1205,7 +1205,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
               OperandTypes.family(SqlTypeFamily.ARRAY, SqlTypeFamily.ARRAY)));
 
   /** The "ARRAY_TO_STRING(array, delimiter [, nullText ])" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ARRAY_TO_STRING =
       SqlBasicFunction.create(
           SqlKind.ARRAY_TO_STRING,
@@ -1213,7 +1213,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.STRING_ARRAY_CHARACTER_OPTIONAL_CHARACTER);
 
   /** The "ARRAYS_OVERLAP(array1, array2)" function (Spark). */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAYS_OVERLAP =
       SqlBasicFunction.create(
           SqlKind.ARRAYS_OVERLAP,
@@ -1230,9 +1230,7 @@ private static RelDataType deriveTypeArraysZip(SqlOperatorBinding opBinding) {
     }
 
     final List<String> indexes =
-        IntStream.range(0, argComponentTypes.size())
-            .mapToObj(i -> String.valueOf(i))
-            .collect(Collectors.toList());
+        IntStream.range(0, argComponentTypes.size()).mapToObj(String::valueOf).collect(toList());
     final RelDataType structType =
         opBinding.getTypeFactory().createStructType(argComponentTypes, indexes);
     return SqlTypeUtil.createArrayType(
@@ -1240,7 +1238,7 @@ private static RelDataType deriveTypeArraysZip(SqlOperatorBinding opBinding) {
   }
 
   /** The "ARRAYS_ZIP(array, ...)" function (Spark). */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAYS_ZIP =
       SqlBasicFunction.create(
           SqlKind.ARRAYS_ZIP,
@@ -1249,7 +1247,7 @@ private static RelDataType deriveTypeArraysZip(SqlOperatorBinding opBinding) {
           OperandTypes.SAME_VARIADIC);
 
   /** The "SORT_ARRAY(array)" function (Spark). */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction SORT_ARRAY =
       SqlBasicFunction.create(
           SqlKind.SORT_ARRAY,
@@ -1276,24 +1274,24 @@ private static RelDataType deriveTypeMapConcat(SqlOperatorBinding opBinding) {
   }
 
   /** The "MAP_CONCAT(map [, map]*)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_CONCAT =
       SqlBasicFunction.create(
           SqlKind.MAP_CONCAT, SqlLibraryOperators::deriveTypeMapConcat, OperandTypes.SAME_VARIADIC);
 
   /** The "MAP_ENTRIES(map)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_ENTRIES =
       SqlBasicFunction.create(
           SqlKind.MAP_ENTRIES, ReturnTypes.TO_MAP_ENTRIES_NULLABLE, OperandTypes.MAP);
 
   /** The "MAP_KEYS(map)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_KEYS =
       SqlBasicFunction.create(SqlKind.MAP_KEYS, ReturnTypes.TO_MAP_KEYS_NULLABLE, OperandTypes.MAP);
 
   /** The "MAP_VALUES(map)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_VALUES =
       SqlBasicFunction.create(
           SqlKind.MAP_VALUES, ReturnTypes.TO_MAP_VALUES_NULLABLE, OperandTypes.MAP);
@@ -1310,7 +1308,7 @@ private static RelDataType deriveTypeMapFromArrays(SqlOperatorBinding opBinding)
   }
 
   /** The "MAP_FROM_ARRAYS(keysArray, valuesArray)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_FROM_ARRAYS =
       SqlBasicFunction.create(
           SqlKind.MAP_FROM_ARRAYS,
@@ -1329,7 +1327,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   }
 
   /** The "MAP_FROM_ENTRIES(arrayOfEntries)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_FROM_ENTRIES =
       SqlBasicFunction.create(
           SqlKind.MAP_FROM_ENTRIES,
@@ -1337,7 +1335,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.MAP_FROM_ENTRIES);
 
   /** The "STR_TO_MAP(string[, stringDelimiter[, keyValueDelimiter]])" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction STR_TO_MAP =
       SqlBasicFunction.create(
           SqlKind.STR_TO_MAP,
@@ -1358,7 +1356,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.STRING,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction TO_BASE64 =
       SqlBasicFunction.create(
           "TO_BASE64",
@@ -1366,7 +1364,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.STRING.or(OperandTypes.BINARY),
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FROM_BASE32 =
       SqlBasicFunction.create(
           "FROM_BASE32",
@@ -1374,7 +1372,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.CHARACTER,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TO_BASE32 =
       SqlBasicFunction.create(
           "TO_BASE32",
@@ -1385,7 +1383,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   /**
    * The "FROM_HEX(varchar)" function; converts a hexadecimal-encoded {@code varchar} into bytes.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FROM_HEX =
       SqlBasicFunction.create(
           "FROM_HEX",
@@ -1394,7 +1392,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           SqlFunctionCategory.STRING);
 
   /** The "TO_HEX(binary)" function; converts {@code binary} into a hexadecimal varchar. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TO_HEX =
       SqlBasicFunction.create(
           "TO_HEX", ReturnTypes.VARCHAR_NULLABLE, OperandTypes.BINARY, SqlFunctionCategory.STRING);
@@ -1415,7 +1413,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TO_DATE(string1, string2)" function; casts string1 to a DATE using the format specified in
    * string2.
    */
-  @LibraryOperator(libraries = {POSTGRESQL, ORACLE})
+  @LibraryOperator(libraries = {ORACLE, POSTGRESQL})
   public static final SqlFunction TO_DATE =
       SqlBasicFunction.create(
           "TO_DATE",
@@ -1427,7 +1425,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TO_TIMESTAMP(string1, string2)" function; casts string1 to a TIMESTAMP using the format
    * specified in string2.
    */
-  @LibraryOperator(libraries = {POSTGRESQL, ORACLE})
+  @LibraryOperator(libraries = {ORACLE, POSTGRESQL})
   public static final SqlFunction TO_TIMESTAMP =
       SqlBasicFunction.create(
           "TO_TIMESTAMP",
@@ -1439,7 +1437,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "PARSE_TIME(string, string)" function (BigQuery); converts a string representation of time
    * to a TIME value.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction PARSE_TIME =
       SqlBasicFunction.create(
           "PARSE_TIME",
@@ -1451,7 +1449,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "PARSE_DATE(string, string)" function (BigQuery); Converts a string representation of date
    * to a DATE object.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction PARSE_DATE =
       SqlBasicFunction.create(
           "PARSE_DATE",
@@ -1465,7 +1463,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    *
    * <p>In BigQuery, the "TIMESTAMP" datatype maps to Calcite's TIMESTAMP_WITH_LOCAL_TIME_ZONE
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction PARSE_TIMESTAMP =
       SqlBasicFunction.create(
           "PARSE_TIMESTAMP",
@@ -1480,7 +1478,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP} type of Calcite and Standard SQL is called {@code DATETIME}
    * in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction PARSE_DATETIME =
       SqlBasicFunction.create(
           "PARSE_DATETIME",
@@ -1492,7 +1490,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "FORMAT_TIME(string, time)" function (BigQuery); Formats a time object according to the
    * specified string.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FORMAT_TIME =
       SqlBasicFunction.create(
           "FORMAT_TIME",
@@ -1504,7 +1502,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "FORMAT_DATE(string, date)" function (BigQuery); Formats a date object according to the
    * specified string.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FORMAT_DATE =
       SqlBasicFunction.create(
           "FORMAT_DATE",
@@ -1518,7 +1516,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    *
    * <p>In BigQuery, the "TIMESTAMP" datatype maps to Calcite's TIMESTAMP_WITH_LOCAL_TIME_ZONE
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FORMAT_TIMESTAMP =
       SqlBasicFunction.create(
           "FORMAT_TIMESTAMP",
@@ -1543,7 +1541,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP} type of Calcite and Standard SQL is called {@code DATETIME}
    * in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FORMAT_DATETIME =
       SqlBasicFunction.create(
           "FORMAT_DATETIME",
@@ -1569,7 +1567,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * but in Calcite the second argument can be any interval expression, not just an interval
    * literal.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlBasicFunction TIMESTAMP_ADD2 =
       SqlBasicFunction.create(
               SqlKind.TIMESTAMP_ADD, ReturnTypes.ARG0_NULLABLE, OperandTypes.TIMESTAMP_INTERVAL)
@@ -1582,7 +1580,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>{@code TIMESTAMP_DIFF(t1, t2, unit)} is equivalent to {@code TIMESTAMPDIFF(unit, t2, t1)}
    * and {@code (t1 - t2) unit}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_DIFF3 =
       new SqlTimestampDiffFunction(
           "TIMESTAMP_DIFF",
@@ -1592,7 +1590,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIME_ADD(time, interval)" function (BigQuery); adds interval expression to the specified
    * time expression.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME_ADD =
       SqlBasicFunction.create(
               SqlKind.TIME_ADD, ReturnTypes.ARG0_NULLABLE, OperandTypes.TIME_INTERVAL)
@@ -1602,7 +1600,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIME_DIFF(time, time, timeUnit)" function (BigQuery); returns the number of timeUnit
    * between the two time expressions.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME_DIFF =
       new SqlTimestampDiffFunction(
           "TIME_DIFF",
@@ -1612,7 +1610,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "DATE_TRUNC(date, timeUnit)" function (BigQuery); truncates a DATE value to the beginning
    * of a timeUnit.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_TRUNC =
       SqlBasicFunction.create(
               "DATE_TRUNC",
@@ -1632,7 +1630,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>In BigQuery, the syntax is "TIME_SUB(time, INTERVAL int64 date_part)" but in Calcite the
    * second argument can be any interval expression, not just an interval literal.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME_SUB =
       SqlBasicFunction.create(
               SqlKind.TIME_SUB, ReturnTypes.ARG0_NULLABLE, OperandTypes.TIME_INTERVAL)
@@ -1642,7 +1640,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIME_TRUNC(time, timeUnit)" function (BigQuery); truncates a TIME value to the beginning
    * of a timeUnit.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME_TRUNC =
       SqlBasicFunction.create(
           "TIME_TRUNC",
@@ -1660,7 +1658,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>In BigQuery, the syntax is "TIMESTAMP_SUB(timestamp, INTERVAL int64 date_part)" but in
    * Calcite the second argument can be any interval expression, not just an interval literal.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlBasicFunction TIMESTAMP_SUB =
       SqlBasicFunction.create(
               SqlKind.TIMESTAMP_SUB, ReturnTypes.ARG0_NULLABLE, OperandTypes.TIMESTAMP_INTERVAL)
@@ -1675,7 +1673,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>A synonym for {@link #TIMESTAMP_SUB}, which supports both {@code TIMESTAMP} and {@code
    * TIMESTAMP WITH LOCAL TIME ZONE} operands.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME_SUB = TIMESTAMP_SUB.withName("DATETIME_SUB");
 
   /**
@@ -1685,7 +1683,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP WITH LOCAL TIME ZONE} type of Calcite is called {@code
    * TIMESTAMP} in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_TRUNC =
       SqlBasicFunction.create(
           "TIMESTAMP_TRUNC",
@@ -1703,7 +1701,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP} type of Calcite and Standard SQL is called {@code DATETIME}
    * in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME_TRUNC =
       SqlBasicFunction.create(
           "DATETIME_TRUNC",
@@ -1718,7 +1716,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIMESTAMP_SECONDS(bigint)" function; returns a TIMESTAMP value a given number of seconds
    * after 1970-01-01 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_SECONDS =
       SqlBasicFunction.create(
           "TIMESTAMP_SECONDS",
@@ -1730,7 +1728,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIMESTAMP_MILLIS(bigint)" function; returns a TIMESTAMP value a given number of
    * milliseconds after 1970-01-01 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_MILLIS =
       SqlBasicFunction.create(
           "TIMESTAMP_MILLIS",
@@ -1742,7 +1740,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIMESTAMP_MICROS(bigint)" function; returns a TIMESTAMP value a given number of
    * micro-seconds after 1970-01-01 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_MICROS =
       SqlBasicFunction.create(
           "TIMESTAMP_MICROS",
@@ -1753,7 +1751,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   /**
    * The "UNIX_SECONDS(bigint)" function; returns the number of seconds since 1970-01-01 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction UNIX_SECONDS =
       SqlBasicFunction.create(
           "UNIX_SECONDS",
@@ -1765,7 +1763,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "UNIX_MILLIS(bigint)" function; returns the number of milliseconds since 1970-01-01
    * 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction UNIX_MILLIS =
       SqlBasicFunction.create(
           "UNIX_MILLIS",
@@ -1777,7 +1775,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "UNIX_MICROS(bigint)" function; returns the number of microseconds since 1970-01-01
    * 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction UNIX_MICROS =
       SqlBasicFunction.create(
           "UNIX_MICROS",
@@ -1789,7 +1787,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "DATETIME_ADD(timestamp, interval)" function (BigQuery). As {@code TIMESTAMP_ADD}, returns
    * a Calcite {@code TIMESTAMP} (which BigQuery calls a {@code DATETIME}).
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME_ADD = TIMESTAMP_ADD2.withName("DATETIME_ADD");
 
   /**
@@ -1798,7 +1796,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP} type of Calcite and Standard SQL is called {@code DATETIME}
    * in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME_DIFF =
       new SqlTimestampDiffFunction(
           "DATETIME_DIFF",
@@ -1822,18 +1820,18 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
       SqlBasicFunction.create(
           "CHR", ReturnTypes.CHAR, OperandTypes.INTEGER, SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction TANH =
       SqlBasicFunction.create(
           "TANH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
   /** The "COTH(value)" function; returns the hyperbolic cotangent of {@code value}. */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction COTH =
       SqlBasicFunction.create(
           "COTH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction COSH =
       SqlBasicFunction.create(
           "COSH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
@@ -1841,13 +1839,13 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   /**
    * The {@code ACOSH(numeric)} function; returns the inverse hyperbolic cosine of {@code value}.
    */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction ACOSH =
       SqlBasicFunction.create(
           "ACOSH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
   /** The {@code ASINH(numeric)} function; returns the inverse hyperbolic sine of {@code value}. */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction ASINH =
       SqlBasicFunction.create(
           "ASINH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
@@ -1855,34 +1853,34 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   /**
    * The {@code ATANH(numeric)} function; returns the inverse hyperbolic tangent of {@code value}.
    */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction ATANH =
       SqlBasicFunction.create(
           "ATANH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
   /** The "COTH(value)" function; returns the hyperbolic secant of {@code value}. */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction SECH =
       SqlBasicFunction.create(
           "SECH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
   /** The "COTH(value)" function; returns the hyperbolic cosecant of {@code value}. */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction CSCH =
       SqlBasicFunction.create(
           "CSCH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction SINH =
       SqlBasicFunction.create(
           "SINH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction CSC =
       SqlBasicFunction.create(
           "CSC", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction SEC =
       SqlBasicFunction.create(
           "SEC", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
@@ -1925,7 +1923,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * @see SqlStdOperatorTable#LN
    * @see SqlStdOperatorTable#LOG10
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction LOG =
       SqlBasicFunction.create(
           "LOG",
@@ -1933,32 +1931,32 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.NUMERIC_OPTIONAL_NUMERIC,
           SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction POW = SqlStdOperatorTable.POWER.withName("POW");
 
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TRUNC = SqlStdOperatorTable.TRUNCATE.withName("TRUNC");
 
   /** Infix "::" cast operator used by PostgreSQL, for example {@code '100'::INTEGER}. */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlOperator INFIX_CAST = new SqlCastOperator();
 
   /**
    * The "SAFE_CAST(expr AS type)" function; identical to CAST(), except that if conversion fails,
    * it returns NULL instead of raising an error.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction SAFE_CAST = new SqlCastFunction("SAFE_CAST", SqlKind.SAFE_CAST);
 
   /** The "TRY_CAST(expr AS type)" function, equivalent to SAFE_CAST. */
-  @LibraryOperator(libraries = {MSSQL})
+  @LibraryOperator(libraries = MSSQL)
   public static final SqlFunction TRY_CAST = new SqlCastFunction("TRY_CAST", SqlKind.SAFE_CAST);
 
   /**
    * The "OFFSET(index)" array subscript operator used by BigQuery. The index starts at 0 and
    * produces an error if the index is out of range.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlOperator OFFSET =
       new SqlItemOperator("OFFSET", OperandTypes.ARRAY, 0, false);
 
@@ -1966,7 +1964,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "ORDINAL(index)" array subscript operator used by BigQuery. The index starts at 1 and
    * produces an error if the index is out of range.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlOperator ORDINAL =
       new SqlItemOperator("ORDINAL", OperandTypes.ARRAY, 1, false);
 
@@ -1974,7 +1972,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "SAFE_OFFSET(index)" array subscript operator used by BigQuery. The index starts at 0 and
    * returns null if the index is out of range.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlOperator SAFE_OFFSET =
       new SqlItemOperator("SAFE_OFFSET", OperandTypes.ARRAY, 0, true);
 
@@ -1982,12 +1980,12 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "SAFE_ORDINAL(index)" array subscript operator used by BigQuery. The index starts at 1 and
    * returns null if the index is out of range.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlOperator SAFE_ORDINAL =
       new SqlItemOperator("SAFE_ORDINAL", OperandTypes.ARRAY, 1, true);
 
   /** NULL-safe "&lt;=&gt;" equal operator used by MySQL, for example {@code 1<=>NULL}. */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlOperator NULL_SAFE_EQUAL =
       new SqlBinaryOperator(
           "<=>",
@@ -1999,7 +1997,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.COMPARABLE_UNORDERED_COMPARABLE_UNORDERED);
 
   /** The "BIT_LENGTH(string or binary)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction BIT_LENGTH =
       SqlBasicFunction.create(
           "BIT_LENGTH",
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
index 35e16351b..08d3acd9b 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
@@ -35,6 +35,8 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.Litmus;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * An operator describing the <code>LIKE</code> and <code>SIMILAR</code> operators.
  *
@@ -79,10 +81,11 @@ public class SqlLikeOperator extends SqlSpecialOperator {
         ReturnTypes.BOOLEAN_NULLABLE,
         InferTypes.FIRST_KNOWN,
         OperandTypes.STRING_SAME_SAME_SAME);
-    if (!caseSensitive && kind != SqlKind.LIKE) {
-      throw new IllegalArgumentException(
-          "Only (possibly negated) " + SqlKind.LIKE + " can be made case-insensitive, not " + kind);
-    }
+    checkArgument(
+        caseSensitive || kind == SqlKind.LIKE,
+        "Only (possibly negated) %s can be made case-insensitive, not %s",
+        SqlKind.LIKE,
+        kind);
 
     this.negated = negated;
     this.caseSensitive = caseSensitive;
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
index 7f77800e2..23521f29e 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
@@ -183,7 +183,7 @@ private static boolean argTypesValid(SqlCallBinding callBinding) {
   /** Concatenates the operands of a call to this operator. */
   public static SqlLiteral concatenateOperands(SqlCall call) {
     final List<SqlNode> operandList = call.getOperandList();
-    assert operandList.size() > 0;
+    assert !operandList.isEmpty();
     assert operandList.get(0) instanceof SqlLiteral : operandList.get(0).getClass();
     return SqlUtil.concatenateLiterals(Util.cast(operandList, SqlLiteral.class));
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
index 22b15bbcb..4b686da7c 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
@@ -55,7 +55,7 @@ public SqlMapValueConstructor() {
 
   @Override public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
     final List<RelDataType> argTypes = SqlTypeUtil.deriveType(callBinding, callBinding.operands());
-    if (argTypes.size() == 0) {
+    if (argTypes.isEmpty()) {
       throw callBinding.newValidationError(RESOURCE.mapRequiresTwoOrMoreArgs());
     }
     if (argTypes.size() % 2 > 0) {
@@ -63,7 +63,7 @@ public SqlMapValueConstructor() {
     }
     final Pair<@Nullable RelDataType, @Nullable RelDataType> componentType =
         getComponentTypes(callBinding.getTypeFactory(), argTypes);
-    if (null == componentType.left || null == componentType.right) {
+    if (componentType.left == null || componentType.right == null) {
       if (throwOnFailure) {
         throw callBinding.newValidationError(RESOURCE.needSameTypeParameter());
       }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlMinMaxAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlMinMaxAggFunction.java
index 759560b05..a7961576d 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlMinMaxAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlMinMaxAggFunction.java
@@ -27,13 +27,14 @@
 import org.apache.calcite.sql.type.SqlOperandTypeChecker;
 import org.apache.calcite.util.Optionality;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Definition of the <code>MIN</code> and <code>MAX</code> aggregate functions, returning the
  * returns the smallest/largest of the values which go into it.
@@ -88,7 +89,7 @@ public SqlMinMaxAggFunction(
         Optionality.FORBIDDEN);
     this.argTypes = ImmutableList.of();
     this.minMaxKind = MINMAX_COMPARABLE;
-    Preconditions.checkArgument(kind == SqlKind.MIN || kind == SqlKind.MAX);
+    checkArgument(kind == SqlKind.MIN || kind == SqlKind.MAX);
   }
 
   @Deprecated // to be removed before 2.0
@@ -114,8 +115,8 @@ public int getMinMaxKind() {
     return Optionality.IGNORED;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     switch (minMaxKind) {
       case MINMAX_PRIMITIVE:
       case MINMAX_COMPARABLE:
@@ -127,8 +128,8 @@ public int getMinMaxKind() {
     }
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     switch (minMaxKind) {
       case MINMAX_PRIMITIVE:
       case MINMAX_COMPARABLE:
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
index 76da570fb..6ebe25e0e 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
@@ -71,7 +71,7 @@ protected SqlMultisetQueryConstructor(String name, SqlKind kind, SqlTypeTransfor
   @Override public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
     final List<RelDataType> argTypes = SqlTypeUtil.deriveType(callBinding, callBinding.operands());
     final RelDataType componentType = callBinding.getTypeFactory().leastRestrictive(argTypes);
-    if (null == componentType) {
+    if (componentType == null) {
       if (throwOnFailure) {
         throw callBinding.newValidationError(RESOURCE.needSameTypeParameter());
       }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
index 23c2b8009..3545dc1e9 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
@@ -80,11 +80,11 @@ protected SqlMultisetValueConstructor(String name, SqlKind kind) {
 
   @Override public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
     final List<RelDataType> argTypes = SqlTypeUtil.deriveType(callBinding, callBinding.operands());
-    if (argTypes.size() == 0) {
+    if (argTypes.isEmpty()) {
       throw callBinding.newValidationError(RESOURCE.requireAtLeastOneArg());
     }
     final RelDataType componentType = getComponentType(callBinding.getTypeFactory(), argTypes);
-    if (null == componentType) {
+    if (componentType == null) {
       if (throwOnFailure) {
         throw callBinding.newValidationError(RESOURCE.needSameTypeParameter());
       }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlQuantifyOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlQuantifyOperator.java
index 9031d4e44..c7bbad7cb 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlQuantifyOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlQuantifyOperator.java
@@ -26,12 +26,13 @@
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Definition of the SQL <code>ALL</code> and <code>SOME</code>operators.
@@ -57,15 +58,15 @@ public class SqlQuantifyOperator extends SqlInOperator {
    */
   SqlQuantifyOperator(SqlKind kind, SqlKind comparisonKind) {
     super(comparisonKind.sql + " " + kind, kind);
-    this.comparisonKind = Objects.requireNonNull(comparisonKind, "comparisonKind");
-    Preconditions.checkArgument(
+    this.comparisonKind = requireNonNull(comparisonKind, "comparisonKind");
+    checkArgument(
         comparisonKind == SqlKind.EQUALS
             || comparisonKind == SqlKind.NOT_EQUALS
             || comparisonKind == SqlKind.LESS_THAN_OR_EQUAL
             || comparisonKind == SqlKind.LESS_THAN
             || comparisonKind == SqlKind.GREATER_THAN_OR_EQUAL
             || comparisonKind == SqlKind.GREATER_THAN);
-    Preconditions.checkArgument(kind == SqlKind.SOME || kind == SqlKind.ALL);
+    checkArgument(kind == SqlKind.SOME || kind == SqlKind.ALL);
   }
 
   @Override public RelDataType deriveType(SqlValidator validator, SqlValidatorScope scope, SqlCall call) {
@@ -95,7 +96,7 @@ public class SqlQuantifyOperator extends SqlInOperator {
     if (right instanceof SqlNodeList && ((SqlNodeList) right).size() == 1) {
       final RelDataType rightType = validator.deriveType(scope, ((SqlNodeList) right).get(0));
       if (SqlTypeUtil.isCollection(rightType)) {
-        final RelDataType componentRightType = Objects.requireNonNull(rightType.getComponentType());
+        final RelDataType componentRightType = requireNonNull(rightType.getComponentType());
         final RelDataType leftType = validator.deriveType(scope, left);
         if (SqlTypeUtil.sameNamedType(componentRightType, leftType)
             || SqlTypeUtil.isNull(leftType)
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlRegrCountAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlRegrCountAggFunction.java
index 99daf2791..c195e35f1 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlRegrCountAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlRegrCountAggFunction.java
@@ -19,7 +19,7 @@
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.type.OperandTypes;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * Definition of the SQL <code>REGR_COUNT</code> aggregation function.
@@ -30,6 +30,6 @@
 public class SqlRegrCountAggFunction extends SqlCountAggFunction {
   public SqlRegrCountAggFunction(SqlKind kind) {
     super("REGR_COUNT", OperandTypes.NUMERIC_NUMERIC);
-    Preconditions.checkArgument(SqlKind.REGR_COUNT == kind, "unsupported sql kind: " + kind);
+    checkArgument(SqlKind.REGR_COUNT == kind, "unsupported sql kind: %s", kind);
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
index 0fdd04bad..d7ad3968a 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
@@ -85,7 +85,7 @@ private static void unparseCube(SqlWriter writer, SqlCall call) {
           operand2.unparse(writer, 0, 0);
         }
         writer.endList(frame2);
-      } else if (operand instanceof SqlNodeList && ((SqlNodeList) operand).size() == 0) {
+      } else if (operand instanceof SqlNodeList && ((SqlNodeList) operand).isEmpty()) {
         writer.keyword("()");
       } else {
         operand.unparse(writer, 0, 0);
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlSingleValueAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlSingleValueAggFunction.java
index 3aa8e99d3..722adf77a 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlSingleValueAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlSingleValueAggFunction.java
@@ -65,13 +65,13 @@ public SqlSingleValueAggFunction(RelDataType type) {
     return false;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     return ImmutableList.of(type);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     return type;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlSpatialTypeFunctions.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlSpatialTypeFunctions.java
index 720939a87..1976717f4 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlSpatialTypeFunctions.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlSpatialTypeFunctions.java
@@ -56,7 +56,7 @@ private SqlSpatialTypeFunctions() {}
    *
    * @see SpatialTypeFunctions ST_Explode
    */
-  @SuppressWarnings({"WeakerAccess", "unused"})
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public static ScannableTable ST_Explode(Geometry geom) {
     return new ExplodeTable(geom);
   }
@@ -66,7 +66,7 @@ public static ScannableTable ST_Explode(Geometry geom) {
    *
    * @see SpatialTypeFunctions ST_MakeGrid
    */
-  @SuppressWarnings({"WeakerAccess", "unused"})
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public static ScannableTable ST_MakeGrid(
       final Geometry geom, final BigDecimal deltaX, final BigDecimal deltaY) {
     return new GridTable(geom, deltaX, deltaY, false);
@@ -77,7 +77,7 @@ public static ScannableTable ST_MakeGrid(
    *
    * @see SpatialTypeFunctions ST_MakeGridPoints
    */
-  @SuppressWarnings({"WeakerAccess", "unused"})
+  @SuppressWarnings({"unused", "WeakerAccess"})
   public static ScannableTable ST_MakeGridPoints(
       final Geometry geom, final BigDecimal deltaX, final BigDecimal deltaY) {
     return new GridTable(geom, deltaX, deltaY, true);
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlSumAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlSumAggFunction.java
index 6b67811cb..4b80a26db 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlSumAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlSumAggFunction.java
@@ -63,8 +63,8 @@ public SqlSumAggFunction(RelDataType type) {
 
   // ~ Methods ----------------------------------------------------------------
 
-  @SuppressWarnings("deprecation")
-  @Override public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     return ImmutableList.of(type);
   }
 
@@ -73,8 +73,8 @@ public RelDataType getType() {
     return type;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     return type;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlSumEmptyIsZeroAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlSumEmptyIsZeroAggFunction.java
index d2f785432..8cf4cb4d9 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlSumEmptyIsZeroAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlSumEmptyIsZeroAggFunction.java
@@ -58,14 +58,14 @@ public SqlSumEmptyIsZeroAggFunction() {
 
   // ~ Methods ----------------------------------------------------------------
 
-  @SuppressWarnings("deprecation")
-  @Override public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public List<RelDataType> getParameterTypes(RelDataTypeFactory typeFactory) {
     return ImmutableList.of(
         typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.ANY), true));
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
+  @Override @SuppressWarnings("deprecation")
+  public RelDataType getReturnType(RelDataTypeFactory typeFactory) {
     return typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.ANY), true);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java b/core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java
index fbec5c9c4..21802a3d5 100644
--- a/core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java
+++ b/core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java
@@ -18,8 +18,9 @@
 
 import org.apache.calcite.util.CalciteParserException;
 
+import com.google.common.collect.ImmutableList;
+
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Set;
 import java.util.TreeSet;
 
@@ -115,7 +116,7 @@ public SqlParserPos getPos() {
    */
   public Collection<String> getExpectedTokenNames() {
     if (expectedTokenSequences == null) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     int maxLength = 0;
     for (int[] expectedTokenSequence : expectedTokenSequences) {
diff --git a/core/src/main/java/org/apache/calcite/sql/parser/SqlParser.java b/core/src/main/java/org/apache/calcite/sql/parser/SqlParser.java
index 2168d88cf..e9ecf7e06 100644
--- a/core/src/main/java/org/apache/calcite/sql/parser/SqlParser.java
+++ b/core/src/main/java/org/apache/calcite/sql/parser/SqlParser.java
@@ -393,8 +393,8 @@ public ConfigBuilder setIdentifierTimeUnitMap(
       return setConfig(config.withTimeUnitCodes(identifierTimeUnitMap));
     }
 
-    @SuppressWarnings("unused")
-    @Deprecated // to be removed before 2.0
+    @Deprecated
+    @SuppressWarnings("unused") // to be removed before 2.0
     public ConfigBuilder setAllowBangEqual(final boolean allowBangEqual) {
       if (allowBangEqual != config.conformance().isBangEqualAllowed()) {
         return setConformance(
diff --git a/core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java b/core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java
index 6818bde6e..f22514429 100644
--- a/core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java
+++ b/core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java
@@ -188,7 +188,7 @@ public static SqlParserPos sum(final SqlNode[] nodes) {
    * beginning of the first to the end of the last.
    */
   public static SqlParserPos sum(final List<? extends SqlNode> nodes) {
-    if (nodes.size() == 0) {
+    if (nodes.isEmpty()) {
       throw new AssertionError();
     }
     SqlParserPos pos0 = nodes.get(0).getParserPosition();
@@ -209,7 +209,7 @@ public static SqlParserPos sum(final List<? extends SqlNode> nodes) {
   public static SqlParserPos sum(Iterable<SqlParserPos> poses) {
     final List<SqlParserPos> list =
         poses instanceof List ? (List<SqlParserPos>) poses : Lists.newArrayList(poses);
-    if (list.size() == 0) {
+    if (list.isEmpty()) {
       throw new AssertionError();
     }
     final SqlParserPos pos0 = list.get(0);
diff --git a/core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java b/core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
index d1ae7544d..91bcd6f28 100644
--- a/core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
+++ b/core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
@@ -48,7 +48,6 @@
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.trace.CalciteTrace;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -69,6 +68,8 @@
 import java.util.function.Predicate;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.lang.Integer.parseInt;
@@ -363,8 +364,7 @@ public static SqlIntervalLiteral parseIntervalLiteral(
       SqlParserPos pos, int sign, String s, SqlIntervalQualifier intervalQualifier) {
     if (s.equals("")) {
       throw SqlUtil.newContextException(
-          pos,
-          RESOURCE.illegalIntervalLiteral(s + " " + intervalQualifier.toString(), pos.toString()));
+          pos, RESOURCE.illegalIntervalLiteral(s + " " + intervalQualifier, pos.toString()));
     }
     return SqlLiteral.createInterval(sign, s, intervalQualifier, pos);
   }
@@ -404,7 +404,7 @@ public static long intervalToMillis(SqlIntervalLiteral.IntervalValue interval) {
   }
 
   public static long intervalToMillis(String literal, SqlIntervalQualifier intervalQualifier) {
-    Preconditions.checkArgument(!intervalQualifier.isYearMonth(), "interval must be day time");
+    checkArgument(!intervalQualifier.isYearMonth(), "interval must be day time");
     int[] ret;
     try {
       ret =
@@ -437,7 +437,7 @@ public static long intervalToMonths(SqlIntervalLiteral.IntervalValue interval) {
   }
 
   public static long intervalToMonths(String literal, SqlIntervalQualifier intervalQualifier) {
-    Preconditions.checkArgument(intervalQualifier.isYearMonth(), "interval must be year month");
+    checkArgument(intervalQualifier.isYearMonth(), "interval must be year month");
     int[] ret;
     try {
       ret =
@@ -484,7 +484,7 @@ public static byte[] parseBinaryString(String s) {
     s = s.replace("\f", "");
     s = s.replace("'", "");
 
-    if (s.length() == 0) {
+    if (s.isEmpty()) {
       return new byte[0];
     }
     assert (s.length() & 1) == 0; // must be even nbr of hex digits
@@ -551,7 +551,7 @@ public static String toCase(String s, Casing casing) {
    * trim("aBaac123AabC","abBcC")} returns {@code "123A"}.
    */
   public static String trim(String s, String chars) {
-    if (s.length() == 0) {
+    if (s.isEmpty()) {
       return "";
     }
 
@@ -751,7 +751,7 @@ public static String rightTrim(String s, char c) {
    */
   public static <T> void replaceSublist(List<T> list, int start, int end, T o) {
     requireNonNull(list, "list");
-    Preconditions.checkArgument(start < end);
+    checkArgument(start < end);
     for (int i = end - 1; i > start; --i) {
       list.remove(i);
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java b/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
index 4b8662444..f538c84a7 100644
--- a/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
+++ b/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
@@ -29,7 +29,6 @@
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.trace.CalciteLogger;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -49,6 +48,8 @@
 import java.util.Set;
 import java.util.function.Consumer;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -525,9 +526,7 @@ public void newlineAndIndent(int indent) {
   }
 
   void indent(int indent) {
-    if (indent < 0) {
-      throw new IllegalArgumentException("negative indent " + indent);
-    }
+    checkArgument(indent >= 0, "negative indent %s", indent);
     Spaces.append(buf, indent);
   }
 
@@ -935,7 +934,7 @@ protected Frame startList(
 
   @Override public void endList(@Nullable Frame frame) {
     FrameImpl endedFrame = (FrameImpl) frame;
-    Preconditions.checkArgument(frame == this.frame, "Frame does not match current frame");
+    checkArgument(frame == this.frame, "Frame does not match current frame");
     if (endedFrame == null) {
       throw new RuntimeException("No list started");
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/type/AbstractSqlType.java b/core/src/main/java/org/apache/calcite/sql/type/AbstractSqlType.java
index c0541890d..7af1403b7 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/AbstractSqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/AbstractSqlType.java
@@ -26,7 +26,8 @@
 
 import java.io.Serializable;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Abstract base class for SQL implementations of {@link RelDataType}. */
 public abstract class AbstractSqlType extends RelDataTypeImpl implements Cloneable, Serializable {
@@ -47,7 +48,7 @@ public abstract class AbstractSqlType extends RelDataTypeImpl implements Cloneab
   protected AbstractSqlType(
       SqlTypeName typeName, boolean isNullable, @Nullable List<? extends RelDataTypeField> fields) {
     super(fields);
-    this.typeName = Objects.requireNonNull(typeName, "typeName");
+    this.typeName = requireNonNull(typeName, "typeName");
     this.isNullable = isNullable || (typeName == SqlTypeName.NULL);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/type/ApplySqlType.java b/core/src/main/java/org/apache/calcite/sql/type/ApplySqlType.java
index 2111caad2..6d1597f70 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/ApplySqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/ApplySqlType.java
@@ -48,7 +48,7 @@ abstract class ApplySqlType extends AbstractSqlType {
           if (withDetail) {
             sb.append(type.getFullTypeString());
           } else {
-            sb.append(type.toString());
+            sb.append(type);
           }
         });
     sb.append('>');
diff --git a/core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java b/core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
index 295432567..44dd1a174 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
@@ -20,6 +20,8 @@
 import org.apache.calcite.rel.type.RelDataTypeFamily;
 import org.apache.calcite.rel.type.RelDataTypePrecedenceList;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.sql.type.NonNullableAccessors.getComponentTypeOrThrow;
 
 import static java.util.Objects.requireNonNull;
@@ -46,7 +48,7 @@ public ArraySqlType(RelDataType elementType, boolean isNullable) {
     if (withDetail) {
       sb.append(elementType.getFullTypeString());
     } else {
-      sb.append(elementType.toString());
+      sb.append(elementType);
     }
     sb.append(" ARRAY");
   }
@@ -73,12 +75,8 @@ public ArraySqlType(RelDataType elementType, boolean isNullable) {
       }
 
       @Override public int compareTypePrecedence(RelDataType type1, RelDataType type2) {
-        if (!containsType(type1)) {
-          throw new IllegalArgumentException("must contain type: " + type1);
-        }
-        if (!containsType(type2)) {
-          throw new IllegalArgumentException("must contain type: " + type2);
-        }
+        checkArgument(containsType(type1), "must contain type: %s", type1);
+        checkArgument(containsType(type2), "must contain type: %s", type2);
         return getComponentType()
             .getPrecedenceList()
             .compareTypePrecedence(getComponentTypeOrThrow(type1), getComponentTypeOrThrow(type2));
diff --git a/core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java
index 2faec6cfd..3e196d79b 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java
@@ -52,7 +52,7 @@ public class AssignableOperandTypeChecker implements SqlOperandTypeChecker {
    */
   public AssignableOperandTypeChecker(
       List<RelDataType> paramTypes, @Nullable List<String> paramNames) {
-    this.paramTypes = ImmutableList.copyOf(paramTypes);
+    this.paramTypes = paramTypes;
     this.paramNames = paramNames == null ? null : ImmutableList.copyOf(paramNames);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/type/BasicSqlType.java b/core/src/main/java/org/apache/calcite/sql/type/BasicSqlType.java
index f774a9395..b681bee38 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/BasicSqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/BasicSqlType.java
@@ -20,12 +20,13 @@
 import org.apache.calcite.sql.SqlCollation;
 import org.apache.calcite.util.SerializableCharset;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.nio.charset.Charset;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * BasicSqlType represents a standard atomic SQL type (excluding interval types).
@@ -96,7 +97,7 @@ private BasicSqlType(
       @Nullable SqlCollation collation,
       @Nullable SerializableCharset wrappedCharset) {
     super(typeName, nullable, null);
-    this.typeSystem = Objects.requireNonNull(typeSystem, "typeSystem");
+    this.typeSystem = requireNonNull(typeSystem, "typeSystem");
     this.precision = precision;
     this.scale = scale;
     this.collation = collation;
@@ -141,7 +142,7 @@ BasicSqlType createWithNullability(boolean nullable) {
    * <p>This must be a character type.
    */
   BasicSqlType createWithCharsetAndCollation(Charset charset, SqlCollation collation) {
-    Preconditions.checkArgument(SqlTypeUtil.inCharFamily(this));
+    checkArgument(SqlTypeUtil.inCharFamily(this));
     return new BasicSqlType(
         this.typeSystem,
         this.typeName,
diff --git a/core/src/main/java/org/apache/calcite/sql/type/ComparableOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/ComparableOperandTypeChecker.java
index 4a7374296..cecab135e 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/ComparableOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/ComparableOperandTypeChecker.java
@@ -22,7 +22,7 @@
 import org.apache.calcite.sql.SqlOperatorBinding;
 import org.apache.calcite.sql.validate.implicit.TypeCoercion;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Type checking strategy which verifies that types have the required attributes to be used as
@@ -46,7 +46,7 @@ public ComparableOperandTypeChecker(
       int nOperands, RelDataTypeComparability requiredComparability, Consistency consistency) {
     super(nOperands);
     this.requiredComparability = requiredComparability;
-    this.consistency = Objects.requireNonNull(consistency, "consistency");
+    this.consistency = requireNonNull(consistency, "consistency");
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
index 8dda0bedd..b181a4cef 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
@@ -35,9 +35,9 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.function.BiFunction;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * This class allows multiple existing {@link SqlOperandTypeChecker} rules to be combined into one
@@ -357,10 +357,10 @@ private boolean coerceOperands(SqlCallBinding callBinding, boolean repeat) {
     // collect SqlTypeFamily and data type of all the operands.
     List<SqlTypeFamily> families =
         allowedRules.stream()
-            .filter(r -> r instanceof ImplicitCastOperandTypeChecker)
+            .filter(ImplicitCastOperandTypeChecker.class::isInstance)
             // All the rules are SqlSingleOperandTypeChecker.
             .map(r -> ((ImplicitCastOperandTypeChecker) r).getOperandSqlTypeFamily(0))
-            .collect(Collectors.toList());
+            .collect(toList());
     if (families.size() < allowedRules.size()) {
       // Not all the checkers are ImplicitCastOperandTypeChecker, returns early.
       return false;
diff --git a/core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java
index 936f6472b..595ab5aa9 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java
@@ -47,14 +47,14 @@ public class CompositeSingleOperandTypeChecker extends CompositeOperandTypeCheck
 
   // ~ Methods ----------------------------------------------------------------
 
-  @SuppressWarnings("unchecked")
-  @Override public ImmutableList<? extends SqlSingleOperandTypeChecker> getRules() {
+  @Override @SuppressWarnings("unchecked")
+  public ImmutableList<? extends SqlSingleOperandTypeChecker> getRules() {
     return (ImmutableList<? extends SqlSingleOperandTypeChecker>) allowedRules;
   }
 
   @Override public boolean checkSingleOperandType(
       SqlCallBinding callBinding, SqlNode node, int iFormalOperand, boolean throwOnFailure) {
-    assert allowedRules.size() >= 1;
+    assert !allowedRules.isEmpty();
 
     final ImmutableList<? extends SqlSingleOperandTypeChecker> rules = getRules();
     if (composition == Composition.SEQUENCE) {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/ExplicitOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/ExplicitOperandTypeChecker.java
index ecab82d0b..eaf7cdeb7 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/ExplicitOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/ExplicitOperandTypeChecker.java
@@ -24,7 +24,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 
 import static java.util.Objects.requireNonNull;
 
@@ -35,7 +34,7 @@ public class ExplicitOperandTypeChecker implements SqlOperandTypeChecker {
   private final RelDataType type;
 
   public ExplicitOperandTypeChecker(RelDataType type) {
-    this.type = Objects.requireNonNull(type, "type");
+    this.type = requireNonNull(type, "type");
   }
 
   @Override public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java
index e56acda72..5deee7a68 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java
@@ -31,6 +31,8 @@
 import java.util.List;
 import java.util.function.Predicate;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
@@ -68,10 +70,9 @@ public class FamilyOperandTypeChecker
   @Override public boolean checkSingleOperandType(
       SqlCallBinding callBinding, SqlNode node, int iFormalOperand, boolean throwOnFailure) {
     Util.discard(iFormalOperand);
-    if (families.size() != 1) {
-      throw new IllegalStateException(
-          "Cannot use as SqlSingleOperandTypeChecker without exactly one family");
-    }
+    checkState(
+        families.size() == 1,
+        "Cannot use as SqlSingleOperandTypeChecker without exactly one family");
     return checkSingleOperandType(
         callBinding, node, iFormalOperand, families.get(0), throwOnFailure);
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java b/core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java
index 74eb54798..630c7ba8a 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java
@@ -28,7 +28,7 @@
 import org.apache.calcite.sql.pretty.SqlPrettyWriter;
 import org.apache.calcite.sql.util.SqlString;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** IntervalSqlType represents a standard SQL datetime interval type. */
 public class IntervalSqlType extends AbstractSqlType {
@@ -43,8 +43,8 @@ public class IntervalSqlType extends AbstractSqlType {
   public IntervalSqlType(
       RelDataTypeSystem typeSystem, SqlIntervalQualifier intervalQualifier, boolean isNullable) {
     super(intervalQualifier.typeName(), isNullable, null);
-    this.typeSystem = Objects.requireNonNull(typeSystem, "typeSystem");
-    this.intervalQualifier = Objects.requireNonNull(intervalQualifier, "intervalQualifier");
+    this.typeSystem = requireNonNull(typeSystem, "typeSystem");
+    this.intervalQualifier = requireNonNull(intervalQualifier, "intervalQualifier");
     computeDigest();
   }
 
@@ -79,9 +79,9 @@ public IntervalSqlType(
   public IntervalSqlType combine(RelDataTypeFactoryImpl typeFactory, IntervalSqlType that) {
     assert this.typeName.isYearMonth() == that.typeName.isYearMonth();
     boolean nullable = isNullable || that.isNullable;
-    TimeUnit thisStart = Objects.requireNonNull(typeName.getStartUnit());
+    TimeUnit thisStart = requireNonNull(typeName.getStartUnit());
     TimeUnit thisEnd = typeName.getEndUnit();
-    final TimeUnit thatStart = Objects.requireNonNull(that.typeName.getStartUnit());
+    final TimeUnit thatStart = requireNonNull(that.typeName.getStartUnit());
     final TimeUnit thatEnd = that.typeName.getEndUnit();
 
     int secondPrec = this.intervalQualifier.getStartPrecisionPreservingDefault();
@@ -97,12 +97,12 @@ public IntervalSqlType combine(RelDataTypeFactoryImpl typeFactory, IntervalSqlTy
       secondPrec =
           SqlIntervalQualifier.combineStartPrecisionPreservingDefault(
               typeFactory.getTypeSystem(), this.intervalQualifier, that.intervalQualifier);
-    } else if (null == thisEnd || thisEnd.ordinal() < thatStart.ordinal()) {
+    } else if (thisEnd == null || thisEnd.ordinal() < thatStart.ordinal()) {
       thisEnd = thatStart;
     }
 
-    if (null != thatEnd) {
-      if (null == thisEnd || thisEnd.ordinal() < thatEnd.ordinal()) {
+    if (thatEnd != null) {
+      if (thisEnd == null || thisEnd.ordinal() < thatEnd.ordinal()) {
         thisEnd = thatEnd;
       }
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/type/MatchReturnTypeInference.java b/core/src/main/java/org/apache/calcite/sql/type/MatchReturnTypeInference.java
index c54c4aa41..806af00b3 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/MatchReturnTypeInference.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/MatchReturnTypeInference.java
@@ -19,13 +19,14 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.sql.SqlOperatorBinding;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Returns the first type that matches a set of given {@link SqlTypeName}s. If no match could be
  * found, null is returned.
@@ -51,10 +52,10 @@ public MatchReturnTypeInference(int start, SqlTypeName... typeNames) {
    * Returns the first type matching any type in typeNames at or after position start (zero based).
    */
   public MatchReturnTypeInference(int start, Iterable<SqlTypeName> typeNames) {
-    Preconditions.checkArgument(start >= 0);
+    checkArgument(start >= 0);
     this.start = start;
     this.typeNames = ImmutableList.copyOf(typeNames);
-    Preconditions.checkArgument(!this.typeNames.isEmpty());
+    checkArgument(!this.typeNames.isEmpty());
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java
index 2f84df4f7..3558f8541 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java
@@ -56,7 +56,7 @@ public class MultisetOperandTypeChecker implements SqlOperandTypeChecker {
                 ImmutableList.of(
                     getComponentTypeOrThrow(SqlTypeUtil.deriveType(callBinding, op0)),
                     getComponentTypeOrThrow(SqlTypeUtil.deriveType(callBinding, op1))));
-    if (null == biggest) {
+    if (biggest == null) {
       if (throwOnFailure) {
         throw callBinding.newError(
             RESOURCE.typeNotComparable(
diff --git a/core/src/main/java/org/apache/calcite/sql/type/MultisetSqlType.java b/core/src/main/java/org/apache/calcite/sql/type/MultisetSqlType.java
index 6c377a245..cdfc10c90 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/MultisetSqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/MultisetSqlType.java
@@ -20,6 +20,8 @@
 import org.apache.calcite.rel.type.RelDataTypeFamily;
 import org.apache.calcite.rel.type.RelDataTypePrecedenceList;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.sql.type.NonNullableAccessors.getComponentTypeOrThrow;
 
 /** MultisetSqlType represents a standard SQL2003 multiset type. */
@@ -47,7 +49,7 @@ public MultisetSqlType(RelDataType elementType, boolean isNullable) {
     if (withDetail) {
       sb.append(elementType.getFullTypeString());
     } else {
-      sb.append(elementType.toString());
+      sb.append(elementType);
     }
     sb.append(" MULTISET");
   }
@@ -81,12 +83,8 @@ public MultisetSqlType(RelDataType elementType, boolean isNullable) {
       }
 
       @Override public int compareTypePrecedence(RelDataType type1, RelDataType type2) {
-        if (!containsType(type1)) {
-          throw new IllegalArgumentException("must contain type: " + type1);
-        }
-        if (!containsType(type2)) {
-          throw new IllegalArgumentException("must contain type: " + type2);
-        }
+        checkArgument(containsType(type1), "must contain type: %s", type1);
+        checkArgument(containsType(type2), "must contain type: %s", type2);
         return getComponentType()
             .getPrecedenceList()
             .compareTypePrecedence(getComponentTypeOrThrow(type1), getComponentTypeOrThrow(type2));
diff --git a/core/src/main/java/org/apache/calcite/sql/type/OperandMetadataImpl.java b/core/src/main/java/org/apache/calcite/sql/type/OperandMetadataImpl.java
index 061d25853..6f4bb884c 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/OperandMetadataImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/OperandMetadataImpl.java
@@ -21,11 +21,12 @@
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 
 import java.util.List;
-import java.util.Objects;
 import java.util.function.Function;
 import java.util.function.IntFunction;
 import java.util.function.Predicate;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Operand type-checking strategy user-defined functions (including user-defined aggregate
  * functions, table functions, and table macros).
@@ -48,7 +49,7 @@ public class OperandMetadataImpl extends FamilyOperandTypeChecker implements Sql
       IntFunction<String> paramNameFn,
       Predicate<Integer> optional) {
     super(families, optional);
-    this.paramTypesFactory = Objects.requireNonNull(paramTypesFactory, "paramTypesFactory");
+    this.paramTypesFactory = requireNonNull(paramTypesFactory, "paramTypesFactory");
     this.paramNameFn = paramNameFn;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java b/core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
index 12502c29e..a7095eae7 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/OperandTypes.java
@@ -451,8 +451,8 @@ public static SqlOperandTypeChecker variadic(final SqlOperandCountRange range) {
       new FamilyOperandTypeChecker(
           ImmutableList.of(SqlTypeFamily.ARRAY, SqlTypeFamily.CHARACTER, SqlTypeFamily.CHARACTER),
           i -> i == 2) {
-        @SuppressWarnings("argument.type.incompatible")
-        @Override public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
+        @Override @SuppressWarnings("argument.type.incompatible")
+        public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
           if (!super.checkOperandTypes(callBinding, throwOnFailure)) {
             return false;
           }
diff --git a/core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java b/core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
index 0ee4b0e4d..f7b77b1c5 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
@@ -34,12 +34,12 @@
 import org.apache.calcite.util.Glossary;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import java.util.AbstractList;
 import java.util.List;
 import java.util.function.UnaryOperator;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.sql.type.NonNullableAccessors.getCharset;
 import static org.apache.calcite.sql.type.NonNullableAccessors.getCollation;
 import static org.apache.calcite.sql.validate.SqlNonNullableAccessors.getNamespace;
@@ -780,7 +780,7 @@ public static SqlCall stripSeparator(SqlCall call) {
             && !containsNullType
             && !(SqlTypeUtil.inCharOrBinaryFamilies(argType0)
                 && SqlTypeUtil.inCharOrBinaryFamilies(argType1))) {
-          Preconditions.checkArgument(SqlTypeUtil.sameNamedType(argType0, argType1));
+          checkArgument(SqlTypeUtil.sameNamedType(argType0, argType1));
         }
         SqlCollation pickedCollation = null;
         if (!containsAnyType && !containsNullType && SqlTypeUtil.inCharFamily(argType0)) {
@@ -818,7 +818,7 @@ public static SqlCall stripSeparator(SqlCall call) {
         }
 
         ret = typeFactory.createSqlType(typeName, typePrecision);
-        if (null != pickedCollation) {
+        if (pickedCollation != null) {
           RelDataType pickedType;
           if (getCollation(argType0).equals(pickedCollation)) {
             pickedType = argType0;
@@ -1016,7 +1016,7 @@ private static RelDataType multivalentStringWithSepSumPrecision(SqlOperatorBindi
         RelDataType multisetType = recordMultisetType.getComponentType();
         assert multisetType != null : "expected a multiset type: " + recordMultisetType;
         final List<RelDataTypeField> fields = multisetType.getFieldList();
-        assert fields.size() > 0;
+        assert !fields.isEmpty();
         final RelDataType firstColType = fields.get(0).getType();
         return opBinding.getTypeFactory().createMultisetType(firstColType, -1);
       };
@@ -1138,5 +1138,5 @@ private static RelDataType multivalentStringWithSepSumPrecision(SqlOperatorBindi
       };
 
   public static final SqlReturnTypeInference PERCENTILE_DISC_CONT =
-      opBinding -> opBinding.getCollationType();
+      SqlOperatorBinding::getCollationType;
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
index f616e878f..945fe2d92 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
@@ -32,6 +32,8 @@
 import java.util.Collections;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
@@ -62,10 +64,9 @@ protected boolean checkOperandTypesImpl(
       SqlOperatorBinding operatorBinding,
       boolean throwOnFailure,
       @Nullable SqlCallBinding callBinding) {
-    if (throwOnFailure && callBinding == null) {
-      throw new IllegalArgumentException(
-          "callBinding must be non-null in case throwOnFailure=true");
-    }
+    checkArgument(
+        !throwOnFailure || callBinding != null,
+        "callBinding must be non-null in case throwOnFailure=true");
     int nOperandsActual = nOperands;
     if (nOperandsActual == -1) {
       nOperandsActual = operatorBinding.getOperandCount();
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeExceptLastOperandChecker.java b/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeExceptLastOperandChecker.java
index de3844946..4b3d6e908 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeExceptLastOperandChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeExceptLastOperandChecker.java
@@ -29,6 +29,8 @@
 import java.util.Collections;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
@@ -52,10 +54,9 @@ public SameOperandTypeExceptLastOperandChecker(int nOperands, String lastOperand
       SqlOperatorBinding operatorBinding,
       boolean throwOnFailure,
       @Nullable SqlCallBinding callBinding) {
-    if (throwOnFailure && callBinding == null) {
-      throw new IllegalArgumentException(
-          "callBinding must be non-null in case throwOnFailure=true");
-    }
+    checkArgument(
+        !throwOnFailure || callBinding != null,
+        "callBinding must be non-null in case throwOnFailure=true");
     int nOperandsActual = nOperands;
     if (nOperandsActual == -1) {
       nOperandsActual = operatorBinding.getOperandCount();
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SetopOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/SetopOperandTypeChecker.java
index f86928912..786b10f43 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SetopOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SetopOperandTypeChecker.java
@@ -109,7 +109,7 @@ public class SetopOperandTypeChecker implements SqlOperandTypeChecker {
           for (int j = 0; j < callBinding.getOperandCount(); j++) {
             TypeCoercion typeCoercion = validator.getTypeCoercion();
             RelDataType widenType = typeCoercion.getWiderTypeFor(columnIthTypes, true);
-            if (null != widenType) {
+            if (widenType != null) {
               coerced =
                   typeCoercion.rowTypeCoercion(
                           callBinding.getScope(), callBinding.operand(j), i, widenType)
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlOperandCountRanges.java b/core/src/main/java/org/apache/calcite/sql/type/SqlOperandCountRanges.java
index 8d2928ede..24de1e7d0 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlOperandCountRanges.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlOperandCountRanges.java
@@ -18,7 +18,7 @@
 
 import org.apache.calcite.sql.SqlOperandCountRange;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /** Helpers for {@link SqlOperandCountRange}. */
 public abstract class SqlOperandCountRanges {
@@ -46,8 +46,8 @@ private static class RangeImpl implements SqlOperandCountRange {
     RangeImpl(int min, int max) {
       this.min = min;
       this.max = max;
-      Preconditions.checkArgument(min <= max || max == -1);
-      Preconditions.checkArgument(min >= 0);
+      checkArgument(min <= max || max == -1);
+      checkArgument(min >= 0);
     }
 
     @Override public boolean isValidCount(int count) {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlReturnTypeInferenceChain.java b/core/src/main/java/org/apache/calcite/sql/type/SqlReturnTypeInferenceChain.java
index 637b34665..2c696ff43 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlReturnTypeInferenceChain.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlReturnTypeInferenceChain.java
@@ -19,11 +19,12 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.sql.SqlOperatorBinding;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Strategy to infer the type of an operator call from the type of the operands by using a series of
  * {@link SqlReturnTypeInference} rules in a given order. If a rule fails to find a return type (by
@@ -43,7 +44,7 @@ public class SqlReturnTypeInferenceChain implements SqlReturnTypeInference {
    * <p>Package-protected. Use {@link org.apache.calcite.sql.type.ReturnTypes#chain}.
    */
   SqlReturnTypeInferenceChain(SqlReturnTypeInference... rules) {
-    Preconditions.checkArgument(rules.length > 1);
+    checkArgument(rules.length > 1);
     this.rules = ImmutableList.copyOf(rules);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
index 91e6030d3..8e01f0eb8 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.sql.type;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 
 import java.util.EnumSet;
@@ -45,7 +44,7 @@ public class SqlTypeAssignmentRule implements SqlTypeMappingRule {
    *     type
    */
   private SqlTypeAssignmentRule(Map<SqlTypeName, ImmutableSet<SqlTypeName>> map) {
-    this.map = ImmutableMap.copyOf(map);
+    this.map = map;
   }
 
   static {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java
index 6470f05b4..ce29f65fa 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java
@@ -16,16 +16,16 @@
  */
 package org.apache.calcite.sql.type;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.HashSet;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Rules that determine whether a type is castable from another type.
  *
@@ -97,7 +97,7 @@ public class SqlTypeCoercionRule implements SqlTypeMappingRule {
    *     type
    */
   private SqlTypeCoercionRule(Map<SqlTypeName, ImmutableSet<SqlTypeName>> map) {
-    this.map = ImmutableMap.copyOf(map);
+    this.map = map;
   }
 
   static {
@@ -335,7 +335,7 @@ private SqlTypeCoercionRule(Map<SqlTypeName, ImmutableSet<SqlTypeName>> map) {
 
   /** Returns an instance. */
   public static SqlTypeCoercionRule instance() {
-    return Objects.requireNonNull(THREAD_PROVIDERS.get(), "threadProviders");
+    return requireNonNull(THREAD_PROVIDERS.get(), "threadProviders");
   }
 
   /** Returns an instance that allows more lenient type coercion. */
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
index 9caf3e202..63055bab6 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
@@ -140,7 +140,7 @@ public SqlTypeFactoryImpl(RelDataTypeSystem typeSystem) {
       List<RelDataType> types, SqlTypeMappingRule mappingRule) {
     requireNonNull(types, "types");
     requireNonNull(mappingRule, "mappingRule");
-    checkArgument(types.size() >= 1, "types.size >= 1");
+    checkArgument(!types.isEmpty(), "types.size >= 1");
 
     RelDataType type0 = types.get(0);
     if (type0.getSqlTypeName() != null) {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRule.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRule.java
index 7b80b18ac..b93fa613d 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRule.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRule.java
@@ -19,9 +19,10 @@
 import com.google.common.collect.ImmutableSet;
 
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Interface that defines rules within type mappings.
  *
@@ -44,8 +45,8 @@ public interface SqlTypeMappingRule {
    * to}.
    */
   default boolean canApplyFrom(SqlTypeName to, SqlTypeName from) {
-    Objects.requireNonNull(to, "to");
-    Objects.requireNonNull(from, "from");
+    requireNonNull(to, "to");
+    requireNonNull(from, "from");
 
     if (to == SqlTypeName.NULL || to == SqlTypeName.UNKNOWN) {
       return false;
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java
index 9f890d5ea..403884866 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java
@@ -25,7 +25,7 @@
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 
-import java.util.HashMap;
+import java.util.EnumMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
@@ -66,9 +66,8 @@ public static class Builder {
 
     /** Creates an empty {@link Builder}. */
     Builder() {
-      this.map = new HashMap<>();
-      this.sets =
-          CacheBuilder.newBuilder().build(CacheLoader.from(set -> Sets.immutableEnumSet(set)));
+      this.map = new EnumMap<>(SqlTypeName.class);
+      this.sets = CacheBuilder.newBuilder().build(CacheLoader.from(Sets::immutableEnumSet));
     }
 
     /** Add a map entry to the existing {@link Builder} mapping. */
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransformCascade.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransformCascade.java
index 6497ae27d..6e7f85dbb 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransformCascade.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeTransformCascade.java
@@ -19,12 +19,13 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.sql.SqlOperatorBinding;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Strategy to infer the type of an operator call from the type of the operands by using one {@link
@@ -40,8 +41,8 @@ public class SqlTypeTransformCascade implements SqlReturnTypeInference {
 
   /** Creates a SqlTypeTransformCascade from a rule and an array of one or more transforms. */
   public SqlTypeTransformCascade(SqlReturnTypeInference rule, SqlTypeTransform... transforms) {
-    Preconditions.checkArgument(transforms.length > 0);
-    this.rule = Objects.requireNonNull(rule, "rule");
+    checkArgument(transforms.length > 0);
+    this.rule = requireNonNull(rule, "rule");
     this.transforms = ImmutableList.copyOf(transforms);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
index 9d874872d..1c3f241c4 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeUtil.java
@@ -42,7 +42,6 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 
@@ -58,8 +57,8 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
-import java.util.function.Function;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.rel.type.RelDataTypeImpl.NON_NULLABLE_SUFFIX;
 import static org.apache.calcite.sql.type.NonNullableAccessors.getCharset;
@@ -68,6 +67,10 @@
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.function.Function.identity;
+import static java.util.stream.Collectors.counting;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.toList;
 
 /** Contains utility methods used during SQL validation or type derivation. */
 public abstract class SqlTypeUtil {
@@ -366,16 +369,16 @@ public static boolean isTimestamp(RelDataType type) {
   }
 
   /** Returns whether a type is some kind of INTERVAL. */
-  @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
   @EnsuresNonNullIf(expression = "#1.getIntervalQualifier()", result = true)
+  @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
   public static boolean isInterval(RelDataType type) {
     return SqlTypeFamily.DATETIME_INTERVAL.contains(type);
   }
 
   /** Returns whether a type is in SqlTypeFamily.Character. */
-  @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
   @EnsuresNonNullIf(expression = "#1.getCharset()", result = true)
   @EnsuresNonNullIf(expression = "#1.getCollation()", result = true)
+  @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
   public static boolean inCharFamily(RelDataType type) {
     return type.getFamily() == SqlTypeFamily.CHARACTER;
   }
@@ -946,7 +949,7 @@ public static RelDataType flattenRecordType(
     Map<String, Long> fieldCnt =
         fieldList.stream()
             .map(RelDataTypeField::getName)
-            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+            .collect(groupingBy(identity(), counting()));
     int i = -1;
     for (RelDataTypeField field : fieldList) {
       ++i;
@@ -1054,9 +1057,9 @@ public static SqlDataTypeSpec convertTypeToSpec(
       List<SqlIdentifier> fieldNames =
           fields.stream()
               .map(f -> new SqlIdentifier(f.getName(), SqlParserPos.ZERO))
-              .collect(Collectors.toList());
+              .collect(toList());
       List<SqlDataTypeSpec> fieldTypes =
-          fields.stream().map(f -> convertTypeToSpec(f.getType())).collect(Collectors.toList());
+          fields.stream().map(f -> convertTypeToSpec(f.getType())).collect(toList());
       typeNameSpec = new SqlRowTypeNameSpec(SqlParserPos.ZERO, fieldNames, fieldTypes);
     } else {
       throw new UnsupportedOperationException(
@@ -1108,7 +1111,7 @@ public static RelDataType createMapType(
   /** Creates a MAP type from a record type. The record type must have exactly two fields. */
   public static RelDataType createMapTypeFromRecord(
       RelDataTypeFactory typeFactory, RelDataType type) {
-    Preconditions.checkArgument(
+    checkArgument(
         type.getFieldCount() == 2,
         "MAP requires exactly two fields, got %s; row type %s",
         type.getFieldCount(),
@@ -1219,8 +1222,8 @@ public static boolean equalSansNullability(RelDataType type1, RelDataType type2)
    */
   public static boolean equalAsCollectionSansNullability(
       RelDataTypeFactory factory, RelDataType type1, RelDataType type2) {
-    Preconditions.checkArgument(isCollection(type1), "Input type1 must be collection type");
-    Preconditions.checkArgument(isCollection(type2), "Input type2 must be collection type");
+    checkArgument(isCollection(type1), "Input type1 must be collection type");
+    checkArgument(isCollection(type2), "Input type2 must be collection type");
 
     return (type1 == type2)
         || (type1.getSqlTypeName() == type2.getSqlTypeName()
@@ -1240,8 +1243,8 @@ && equalSansNullability(
    */
   public static boolean equalAsMapSansNullability(
       RelDataTypeFactory factory, RelDataType type1, RelDataType type2) {
-    Preconditions.checkArgument(isMap(type1), "Input type1 must be map type");
-    Preconditions.checkArgument(isMap(type2), "Input type2 must be map type");
+    checkArgument(isMap(type1), "Input type1 must be map type");
+    checkArgument(isMap(type2), "Input type2 must be map type");
 
     MapSqlType mType1 = (MapSqlType) type1;
     MapSqlType mType2 = (MapSqlType) type2;
@@ -1267,8 +1270,8 @@ public static boolean equalAsStructSansNullability(
       RelDataType type1,
       RelDataType type2,
       @Nullable SqlNameMatcher nameMatcher) {
-    Preconditions.checkArgument(type1.isStruct(), "Input type1 must be struct type");
-    Preconditions.checkArgument(type2.isStruct(), "Input type2 must be struct type");
+    checkArgument(type1.isStruct(), "Input type1 must be struct type");
+    checkArgument(type2.isStruct(), "Input type2 must be struct type");
 
     if (type1 == type2) {
       return true;
diff --git a/core/src/main/java/org/apache/calcite/sql/util/ChainedSqlOperatorTable.java b/core/src/main/java/org/apache/calcite/sql/util/ChainedSqlOperatorTable.java
index 6423a859d..3b942f785 100644
--- a/core/src/main/java/org/apache/calcite/sql/util/ChainedSqlOperatorTable.java
+++ b/core/src/main/java/org/apache/calcite/sql/util/ChainedSqlOperatorTable.java
@@ -50,7 +50,7 @@ public ChainedSqlOperatorTable(List<SqlOperatorTable> tableList) {
 
   /** Internal constructor; call {@link SqlOperatorTables#chain}. */
   protected ChainedSqlOperatorTable(ImmutableList<SqlOperatorTable> tableList) {
-    this.tableList = ImmutableList.copyOf(tableList);
+    this.tableList = tableList.asList();
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/util/IdPair.java b/core/src/main/java/org/apache/calcite/sql/util/IdPair.java
index 8cbd5d345..ab44a50f7 100644
--- a/core/src/main/java/org/apache/calcite/sql/util/IdPair.java
+++ b/core/src/main/java/org/apache/calcite/sql/util/IdPair.java
@@ -20,7 +20,8 @@
 
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Similar to {@link org.apache.calcite.util.Pair} but identity is based on identity of values.
@@ -40,8 +41,8 @@ public static <L, R> IdPair<L, R> of(L left, R right) {
   }
 
   protected IdPair(L left, R right) {
-    this.left = Objects.requireNonNull(left, "left");
-    this.right = Objects.requireNonNull(right, "right");
+    this.left = requireNonNull(left, "left");
+    this.right = requireNonNull(right, "right");
   }
 
   @Override public String toString() {
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/AbstractNamespace.java b/core/src/main/java/org/apache/calcite/sql/validate/AbstractNamespace.java
index 55542b669..efd381aa0 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/AbstractNamespace.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/AbstractNamespace.java
@@ -23,13 +23,15 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
 
 /** Abstract implementation of {@link SqlValidatorNamespace}. */
 abstract class AbstractNamespace implements SqlValidatorNamespace {
@@ -75,10 +77,10 @@ abstract class AbstractNamespace implements SqlValidatorNamespace {
       case UNVALIDATED:
         try {
           status = SqlValidatorImpl.Status.IN_PROGRESS;
-          Preconditions.checkArgument(
+          checkArgument(
               rowType == null, "Namespace.rowType must be null before validate has been called");
           RelDataType type = validateImpl(targetRowType);
-          Preconditions.checkArgument(type != null, "validateImpl() returned null");
+          checkArgument(type != null, "validateImpl() returned null");
           setType(type);
         } finally {
           status = SqlValidatorImpl.Status.VALID;
@@ -105,7 +107,7 @@ abstract class AbstractNamespace implements SqlValidatorNamespace {
   @Override public RelDataType getRowType() {
     if (rowType == null) {
       validator.validateNamespace(this, validator.unknownType);
-      Objects.requireNonNull(rowType, "validate must set rowType");
+      requireNonNull(rowType, "validate must set rowType");
     }
     return rowType;
   }
@@ -116,7 +118,7 @@ abstract class AbstractNamespace implements SqlValidatorNamespace {
 
   @Override public RelDataType getType() {
     Util.discard(getRowType());
-    return Objects.requireNonNull(type, "type");
+    return requireNonNull(type, "type");
   }
 
   @Override public void setType(RelDataType type) {
@@ -149,8 +151,8 @@ abstract class AbstractNamespace implements SqlValidatorNamespace {
     return SqlMonotonicity.NOT_MONOTONIC;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public void makeNullable() {}
+  @Override @SuppressWarnings("deprecation")
+  public void makeNullable() {}
 
   public String translate(String name) {
     return name;
@@ -205,7 +207,7 @@ protected RelDataType toStruct(RelDataType type, @Nullable SqlNode unnest) {
     return validator
         .getTypeFactory()
         .builder()
-        .add(SqlValidatorUtil.alias(Objects.requireNonNull(unnest, "unnest"), 0), type)
+        .add(SqlValidatorUtil.alias(requireNonNull(unnest, "unnest"), 0), type)
         .build();
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/AggVisitor.java b/core/src/main/java/org/apache/calcite/sql/validate/AggVisitor.java
index ec9004550..f077444c4 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/AggVisitor.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/AggVisitor.java
@@ -30,7 +30,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Visitor that can find aggregate and windowed aggregate functions.
@@ -74,8 +75,8 @@ abstract class AggVisitor extends SqlBasicVisitor<Void> {
     this.over = over;
     this.aggregate = aggregate;
     this.delegate = delegate;
-    this.opTab = Objects.requireNonNull(opTab, "opTab");
-    this.nameMatcher = Objects.requireNonNull(nameMatcher, "nameMatcher");
+    this.opTab = requireNonNull(opTab, "opTab");
+    this.nameMatcher = requireNonNull(nameMatcher, "nameMatcher");
   }
 
   @Override public Void visit(SqlCall call) {
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java b/core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java
index df7107f2b..1521f2a83 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java
@@ -30,7 +30,6 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSortedMultiset;
 
 import java.util.Collection;
@@ -258,7 +257,7 @@ public static class Resolved {
       this.groupExprList = ImmutableList.copyOf(groupExprList);
       this.groupSet = ImmutableBitSet.range(groupExprList.size());
       this.groupSets = ImmutableSortedMultiset.copyOf(groupSets);
-      this.groupExprProjection = ImmutableMap.copyOf(groupExprProjection);
+      this.groupExprProjection = groupExprProjection;
     }
 
     /** Returns whether a field should be nullable due to grouping sets. */
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/CyclicDefinitionException.java b/core/src/main/java/org/apache/calcite/sql/validate/CyclicDefinitionException.java
index 6233a8e29..d682d9a6d 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/CyclicDefinitionException.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/CyclicDefinitionException.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.sql.validate;
 
-import com.google.common.collect.ImmutableList;
-
 import java.util.List;
 
 /** Thrown when an object, such as a view, is found to have a cylic definition. */
@@ -29,6 +27,6 @@ public class CyclicDefinitionException extends RuntimeException {
   public CyclicDefinitionException(int depth, List<String> path) {
     super("Cyclic object definition: " + path);
     this.depth = depth;
-    this.path = ImmutableList.copyOf(path);
+    this.path = path;
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/DelegatingNamespace.java b/core/src/main/java/org/apache/calcite/sql/validate/DelegatingNamespace.java
index d6006bb44..f7ec2cb25 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/DelegatingNamespace.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/DelegatingNamespace.java
@@ -99,8 +99,8 @@ protected DelegatingNamespace(SqlValidatorNamespace namespace) {
     return namespace.getMonotonicity(columnName);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public void makeNullable() {}
+  @Override @SuppressWarnings("deprecation")
+  public void makeNullable() {}
 
   @Override public <T extends Object> T unwrap(Class<T> clazz) {
     if (clazz.isInstance(this)) {
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java b/core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java
index 279c3b7f5..c81c63c27 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/DelegatingScope.java
@@ -34,7 +34,6 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableList;
 
@@ -49,6 +48,8 @@
 import java.util.Map;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
@@ -74,7 +75,7 @@ public abstract class DelegatingScope implements SqlValidatorScope {
    * Computes and stores information that cannot be computed on construction, but only after
    * sub-queries have been validated.
    */
-  @SuppressWarnings({"methodref.receiver.bound.invalid", "FunctionalExpressionCanBeFolded"})
+  @SuppressWarnings({"FunctionalExpressionCanBeFolded", "methodref.receiver.bound.invalid"})
   public final Supplier<AggregatingSelectScope.Resolved> resolved =
       Suppliers.memoize(this::resolve)::get;
 
@@ -199,8 +200,8 @@ protected void addColumnNames(SqlValidatorNamespace ns, List<SqlMoniker> colName
     parent.findAliases(result);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public Pair<String, SqlValidatorNamespace> findQualifyingTableName(
+  @Override @SuppressWarnings("deprecation")
+  public Pair<String, SqlValidatorNamespace> findQualifyingTableName(
       String columnName, SqlNode ctx) {
     //noinspection deprecation
     return parent.findQualifyingTableName(columnName, ctx);
@@ -219,8 +220,8 @@ protected void addColumnNames(SqlValidatorNamespace ns, List<SqlMoniker> colName
     return parent.nullifyType(node, type);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public @Nullable SqlValidatorNamespace getTableNamespace(List<String> names) {
+  @Override @SuppressWarnings("deprecation")
+  public @Nullable SqlValidatorNamespace getTableNamespace(List<String> names) {
     return parent.getTableNamespace(names);
   }
 
@@ -591,7 +592,7 @@ private static boolean hasAmbiguousField(
   }
 
   private AggregatingSelectScope.Resolved resolve() {
-    Preconditions.checkArgument(groupAnalyzer == null, "resolve already in progress");
+    checkArgument(groupAnalyzer == null, "resolve already in progress");
     SqlValidatorUtil.GroupAnalyzer groupAnalyzer = new SqlValidatorUtil.GroupAnalyzer();
     this.groupAnalyzer = groupAnalyzer;
     try {
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/EmptyScope.java b/core/src/main/java/org/apache/calcite/sql/validate/EmptyScope.java
index 9120ffe6d..907c79716 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/EmptyScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/EmptyScope.java
@@ -81,8 +81,8 @@ class EmptyScope implements SqlValidatorScope {
   @Override public void resolve(
       List<String> names, SqlNameMatcher nameMatcher, boolean deep, Resolved resolved) {}
 
-  @SuppressWarnings("deprecation")
-  @Override public @Nullable SqlValidatorNamespace getTableNamespace(List<String> names) {
+  @Override @SuppressWarnings("deprecation")
+  public @Nullable SqlValidatorNamespace getTableNamespace(List<String> names) {
     SqlValidatorTable table = validator.catalogReader.getTable(names);
     return table != null ? new TableNamespace(validator, table) : null;
   }
@@ -190,8 +190,8 @@ public void findAllTableNames(List<SqlMoniker> result) {}
     // valid
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public Pair<String, SqlValidatorNamespace> findQualifyingTableName(
+  @Override @SuppressWarnings("deprecation")
+  public Pair<String, SqlValidatorNamespace> findQualifyingTableName(
       String columnName, SqlNode ctx) {
     throw validator.newValidationError(ctx, RESOURCE.columnNotFound(columnName));
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java b/core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
index 902ecdfe5..bd13ededf 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/IdentifierNamespace.java
@@ -34,10 +34,11 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Objects;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Namespace whose contents are defined by the type of an {@link
  * org.apache.calcite.sql.SqlIdentifier identifier}.
@@ -75,7 +76,7 @@ public class IdentifierNamespace extends AbstractNamespace {
     super(validator, enclosingNode);
     this.id = id;
     this.extendList = extendList;
-    this.parentScope = Objects.requireNonNull(parentScope, "parentScope");
+    this.parentScope = requireNonNull(parentScope, "parentScope");
   }
 
   IdentifierNamespace(
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/ListScope.java b/core/src/main/java/org/apache/calcite/sql/validate/ListScope.java
index b85011a0a..62d8adbab 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/ListScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/ListScope.java
@@ -36,6 +36,8 @@
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Abstract base for a scope which is defined by a list of child namespaces and which inherits from
  * a parent scope.
@@ -55,7 +57,7 @@ protected ListScope(SqlValidatorScope parent) {
   // ~ Methods ----------------------------------------------------------------
 
   @Override public void addChild(SqlValidatorNamespace ns, String alias, boolean nullable) {
-    Objects.requireNonNull(alias, "alias");
+    requireNonNull(alias, "alias");
     children.add(new ScopeChild(children.size(), alias, ns, nullable));
   }
 
@@ -154,8 +156,8 @@ public boolean isChildNullable(int i) {
     parent.findAliases(result);
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public Pair<String, SqlValidatorNamespace> findQualifyingTableName(
+  @Override @SuppressWarnings("deprecation")
+  public Pair<String, SqlValidatorNamespace> findQualifyingTableName(
       final String columnName, SqlNode ctx) {
     final SqlNameMatcher nameMatcher = validator.catalogReader.nameMatcher();
     final Map<String, ScopeChild> map = findQualifyingTableNames(columnName, ctx, nameMatcher);
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java b/core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java
index b2d581494..0a43d855c 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java
@@ -27,6 +27,8 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Namespace whose contents are defined by the result of a call to a user-defined procedure. */
@@ -53,15 +55,15 @@ public class ProcedureNamespace extends AbstractNamespace {
     final RelDataType type = validator.deriveTypeImpl(scope, call);
     final SqlOperator operator = call.getOperator();
     final SqlCallBinding callBinding = new SqlCallBinding(validator, scope, call);
-    if (!(operator instanceof SqlTableFunction)) {
-      throw new IllegalArgumentException(
-          "Argument must be a table function: " + operator.getNameAsId());
-    }
+    checkArgument(
+        (operator instanceof SqlTableFunction),
+        "Argument must be a table function: %s",
+        operator.getNameAsId());
     final SqlTableFunction tableFunction = (SqlTableFunction) operator;
-    if (type.getSqlTypeName() != SqlTypeName.CURSOR) {
-      throw new IllegalArgumentException(
-          "Table function should have CURSOR " + "type, not " + type);
-    }
+    checkArgument(
+        type.getSqlTypeName() == SqlTypeName.CURSOR,
+        "Table function should have CURSOR type, not %s",
+        type);
     final SqlReturnTypeInference rowTypeInference = tableFunction.getRowTypeInference();
     return requireNonNull(
         rowTypeInference.inferReturnType(callBinding),
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java b/core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
index 40263e4ce..7059a36bd 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
@@ -136,7 +136,7 @@ public class SelectScope extends ListScope {
   }
 
   @Override public @Nullable SqlWindow lookupWindow(String name) {
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     final List<SqlWindow> windowList = (List<SqlWindow>) (List) select.getWindowList();
     for (SqlWindow window : windowList) {
       final SqlIdentifier declId =
@@ -159,7 +159,7 @@ public class SelectScope extends ListScope {
 
     // TODO: compare fully qualified names
     final SqlNodeList orderList = getOrderList();
-    if (orderList.size() > 0) {
+    if (!orderList.isEmpty()) {
       SqlNode order0 = orderList.get(0);
       monotonicity = SqlMonotonicity.INCREASING;
       if ((order0 instanceof SqlCall)
@@ -182,7 +182,7 @@ public class SelectScope extends ListScope {
       if (children.size() == 1) {
         final SqlValidatorNamespace child = children.get(0).namespace;
         final List<Pair<SqlNode, SqlMonotonicity>> monotonicExprs = child.getMonotonicExprs();
-        if (monotonicExprs.size() > 0) {
+        if (!monotonicExprs.isEmpty()) {
           orderList.add(monotonicExprs.get(0).left);
         }
       }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlIdentifierMoniker.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlIdentifierMoniker.java
index 1149d48de..babf0f405 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlIdentifierMoniker.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlIdentifierMoniker.java
@@ -19,7 +19,8 @@
 import org.apache.calcite.sql.SqlIdentifier;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * An implementation of {@link SqlMoniker} that encapsulates the normalized name information of a
@@ -34,7 +35,7 @@ public class SqlIdentifierMoniker implements SqlMoniker {
 
   /** Creates an SqlIdentifierMoniker. */
   public SqlIdentifierMoniker(SqlIdentifier id) {
-    this.id = Objects.requireNonNull(id, "id");
+    this.id = requireNonNull(id, "id");
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlMonikerImpl.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlMonikerImpl.java
index 0bef83b4a..b3d0df658 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlMonikerImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlMonikerImpl.java
@@ -27,6 +27,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /** A generic implementation of {@link SqlMoniker}. */
 public class SqlMonikerImpl implements SqlMoniker {
   // ~ Instance fields --------------------------------------------------------
@@ -39,7 +41,7 @@ public class SqlMonikerImpl implements SqlMoniker {
   /** Creates a moniker with an array of names. */
   public SqlMonikerImpl(List<String> names, SqlMonikerType type) {
     this.names = ImmutableList.copyOf(names);
-    this.type = Objects.requireNonNull(type, "type");
+    this.type = requireNonNull(type, "type");
   }
 
   /** Creates a moniker with a single name. */
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java
index 1d3ee5b22..8dd122bd2 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java
@@ -150,7 +150,7 @@ private static class LiberalNameMatcher extends BaseMatcher {
     @Override protected boolean listMatches(List<String> list0, List<String> list1) {
       final boolean b = super.listMatches(list0, list1);
       if (b) {
-        matchedNames = ImmutableList.copyOf(list1);
+        matchedNames = list1;
       }
       return b;
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlNonNullableAccessors.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlNonNullableAccessors.java
index 304000f0c..966b755dc 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlNonNullableAccessors.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlNonNullableAccessors.java
@@ -28,8 +28,6 @@
 
 import org.apiguardian.api.API;
 
-import java.util.Objects;
-
 import static java.util.Objects.requireNonNull;
 
 /** This class provides non-nullable accessors for common getters. */
@@ -38,7 +36,7 @@ private SqlNonNullableAccessors() {}
 
   private static String safeToString(Object obj) {
     try {
-      return Objects.toString(obj);
+      return String.valueOf(obj);
     } catch (Throwable e) {
       return "Error in toString: " + e;
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlQualified.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlQualified.java
index da856fc96..08594db67 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlQualified.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlQualified.java
@@ -50,7 +50,7 @@ private SqlQualified(
   }
 
   @Override public String toString() {
-    return "{id: " + identifier.toString() + ", prefix: " + prefixLength + "}";
+    return "{id: " + identifier + ", prefix: " + prefixLength + "}";
   }
 
   public static SqlQualified create(
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedFunction.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedFunction.java
index 5660dbac7..5b2996dcc 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedFunction.java
@@ -113,8 +113,8 @@ public Function getFunction() {
     return function;
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public List<String> getParamNames() {
+  @Override @SuppressWarnings("deprecation")
+  public List<String> getParamNames() {
     return Util.transform(function.getParameters(), FunctionParameter::getName);
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
index 2998fe190..611834859 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
@@ -40,6 +40,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * User-defined table macro.
  *
@@ -92,8 +94,8 @@ public SqlUserDefinedTableMacro(
     return (@Nullable SqlOperandMetadata) super.getOperandTypeChecker();
   }
 
-  @SuppressWarnings("deprecation")
-  @Override public List<String> getParamNames() {
+  @Override @SuppressWarnings("deprecation")
+  public List<String> getParamNames() {
     return Util.transform(tableMacro.getParameters(), FunctionParameter::getName);
   }
 
@@ -128,16 +130,12 @@ public TranslatableTable getTable(SqlOperatorBinding callBinding) {
           if (callBinding.isOperandLiteral(i, true)) {
             value = callBinding.getOperandLiteralValue(i, type);
           } else {
-            if (failOnNonLiteral) {
-              throw new IllegalArgumentException(
-                  "All arguments of call to macro "
-                      + opName
-                      + " should be literal. Actual argument #"
-                      + parameter.getOrdinal()
-                      + " ("
-                      + parameter.getName()
-                      + ") is not literal");
-            }
+            checkArgument(
+                !failOnNonLiteral,
+                "All arguments of call to macro %s should be literal. Actual argument #%s (%s) is not literal",
+                opName,
+                parameter.getOrdinal(),
+                parameter.getName());
             if (type.isNullable()) {
               value = null;
             } else {
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
index 9844e3dfe..39650a34d 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
@@ -116,7 +116,6 @@
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.trace.CalciteTrace;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
@@ -150,7 +149,9 @@
 import java.util.function.BiFunction;
 import java.util.function.Supplier;
 import java.util.function.UnaryOperator;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.sql.SqlUtil.stripAs;
@@ -162,6 +163,7 @@
 import static org.apache.calcite.util.Util.first;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /** Default implementation of {@link SqlValidator}. */
 public class SqlValidatorImpl implements SqlValidatorWithHints {
@@ -332,18 +334,18 @@ public SqlConformance getConformance() {
     return config.conformance();
   }
 
-  @Pure
-  @Override public SqlValidatorCatalogReader getCatalogReader() {
+  @Override @Pure
+  public SqlValidatorCatalogReader getCatalogReader() {
     return catalogReader;
   }
 
-  @Pure
-  @Override public SqlOperatorTable getOperatorTable() {
+  @Override @Pure
+  public SqlOperatorTable getOperatorTable() {
     return opTab;
   }
 
-  @Pure
-  @Override public RelDataTypeFactory getTypeFactory() {
+  @Override @Pure
+  public RelDataTypeFactory getTypeFactory() {
     return typeFactory;
   }
 
@@ -850,11 +852,11 @@ private void lookupJoinHints(
     SqlNode right = join.getRight();
     SqlNode condition = join.getCondition();
     lookupFromHints(left, scope, pos, hintList);
-    if (hintList.size() > 0) {
+    if (!hintList.isEmpty()) {
       return;
     }
     lookupFromHints(right, scope, pos, hintList);
-    if (hintList.size() > 0) {
+    if (!hintList.isEmpty()) {
       return;
     }
     final JoinConditionType conditionType = join.getConditionType();
@@ -886,7 +888,7 @@ public final void lookupNameCompletionHints(
     // Remove the last part of name - it is a dummy
     List<String> subNames = Util.skipLast(names);
 
-    if (subNames.size() > 0) {
+    if (!subNames.isEmpty()) {
       // If there's a prefix, resolve it to a namespace.
       SqlValidatorNamespace ns = null;
       for (String name : subNames) {
@@ -1708,7 +1710,7 @@ protected SqlSelect createSourceSelectForDelete(SqlDelete call) {
   @Nullable
   RelDataType getTableConstructorRowType(SqlCall values, SqlValidatorScope scope) {
     final List<SqlNode> rows = values.getOperandList();
-    assert rows.size() >= 1;
+    assert !rows.isEmpty();
     final List<RelDataType> rowTypes = new ArrayList<>();
     for (final SqlNode row : rows) {
       assert row.getKind() == SqlKind.ROW;
@@ -1826,7 +1828,7 @@ RelDataType getTableConstructorRowType(SqlCall values, SqlValidatorScope scope)
       return ns.getType();
     }
     type = deriveTypeImpl(scope, expr);
-    Preconditions.checkArgument(type != null, "SqlValidator.deriveTypeInternal returned null");
+    checkArgument(type != null, "SqlValidator.deriveTypeInternal returned null");
     setValidatedNodeType(expr, type);
     return type;
   }
@@ -2385,7 +2387,7 @@ private SqlNode registerFrom(
           tableScope = new TableScope(parentScope, node);
         }
         tableScope.addChild(newNs, requireNonNull(alias, "alias"), forceNullable);
-        if (extendList != null && extendList.size() != 0) {
+        if (extendList != null && !extendList.isEmpty()) {
           return enclosingNode;
         }
         return newNode;
@@ -2506,7 +2508,7 @@ private SqlNode registerFrom(
             extendList,
             forceNullable,
             lateral);
-        if (extendList != null && extendList.size() != 0) {
+        if (extendList != null && !extendList.isEmpty()) {
           return enclosingNode;
         }
         return newNode;
@@ -2595,7 +2597,7 @@ private void registerQuery(
       SqlNode enclosingNode,
       @Nullable String alias,
       boolean forceNullable) {
-    Preconditions.checkArgument(usingScope == null || alias != null);
+    checkArgument(usingScope == null || alias != null);
     registerQuery(parentScope, usingScope, node, enclosingNode, alias, forceNullable, true);
   }
 
@@ -2619,7 +2621,7 @@ private void registerQuery(
       boolean checkUpdate) {
     requireNonNull(node, "node");
     requireNonNull(enclosingNode, "enclosingNode");
-    Preconditions.checkArgument(usingScope == null || alias != null);
+    checkArgument(usingScope == null || alias != null);
 
     SqlCall call;
     List<SqlNode> operands;
@@ -3290,7 +3292,7 @@ protected void validateJoin(SqlJoin join, SqlValidatorScope scope) {
     // Validate condition.
     switch (conditionType) {
       case NONE:
-        Preconditions.checkArgument(join.getCondition() == null);
+        checkArgument(join.getCondition() == null);
         break;
       case ON:
         final SqlNode condition = expand(getCondition(join), joinScope);
@@ -3303,7 +3305,7 @@ protected void validateJoin(SqlJoin join, SqlValidatorScope scope) {
         List<SqlIdentifier> list = (List) getCondition(join);
 
         // Parser ensures that using clause is not empty.
-        Preconditions.checkArgument(!list.isEmpty(), "Empty USING clause");
+        checkArgument(!list.isEmpty(), "Empty USING clause");
         for (SqlIdentifier id : list) {
           validateCommonJoinColumn(id, left, right, scope, natural);
         }
@@ -3402,7 +3404,7 @@ private void validateCommonJoinColumn(
   }
 
   private RelDataType checkAndDeriveDataType(SqlIdentifier id, SqlNode node) {
-    Preconditions.checkArgument(id.names.size() == 1);
+    checkArgument(id.names.size() == 1);
     String name = id.names.get(0);
     SqlNameMatcher nameMatcher = getCatalogReader().nameMatcher();
     RelDataType rowType = getNamespaceOrThrow(node).getRowType();
@@ -3419,7 +3421,7 @@ private RelDataType checkAndDeriveDataType(SqlIdentifier id, SqlNode node) {
    */
   private RelDataType validateCommonInputJoinColumn(
       SqlIdentifier id, SqlNode leftOrRight, SqlValidatorScope scope, boolean natural) {
-    Preconditions.checkArgument(id.names.size() == 1);
+    checkArgument(id.names.size() == 1);
     final String name = id.names.get(0);
     final SqlValidatorNamespace namespace = getNamespaceOrThrow(leftOrRight);
     final RelDataType rowType = namespace.getRowType();
@@ -3433,7 +3435,7 @@ private RelDataType validateCommonInputJoinColumn(
       final RelCrossType crossType = (RelCrossType) rowType;
       rowTypes = new ArrayList<>(crossType.getTypes());
     } else {
-      rowTypes = Collections.singleton(rowType);
+      rowTypes = ImmutableSet.of(rowType);
     }
     for (RelDataType rowType0 : rowTypes) {
       if (nameMatcher.frequency(rowType0.getFieldNames(), name) > 1) {
@@ -3490,7 +3492,7 @@ protected void validateSelect(SqlSelect select, RelDataType targetRowType) {
       names =
           names.stream()
               .<@Nullable String>map(s -> s == null ? null : s.toUpperCase(Locale.ROOT))
-              .collect(Collectors.toList());
+              .collect(toList());
     }
     final int duplicateAliasOrdinal = Util.firstDuplicate(names);
     if (duplicateAliasOrdinal >= 0) {
@@ -3853,7 +3855,7 @@ private static SqlModality deduceModality(SqlNode query) {
 
     // Make sure that ORDER BY is possible.
     final SqlNodeList orderList = select.getOrderList();
-    if (orderList != null && orderList.size() > 0) {
+    if (orderList != null && !orderList.isEmpty()) {
       switch (modality) {
         case STREAM:
           if (!hasSortedPrefix(scope, orderList)) {
@@ -3897,7 +3899,7 @@ private static boolean isSortCompatible(SelectScope scope, SqlNode node, boolean
     }
   }
 
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   protected void validateWindowClause(SqlSelect select) {
     final SqlNodeList windowList = select.getWindowList();
     if (windowList.isEmpty()) {
@@ -4189,7 +4191,7 @@ protected void validateGroupClause(SqlSelect select) {
       aggregatingScope = (AggregatingSelectScope) selectScope;
     }
     for (SqlNode groupItem : groupList) {
-      if (groupItem instanceof SqlNodeList && ((SqlNodeList) groupItem).size() == 0) {
+      if (groupItem instanceof SqlNodeList && ((SqlNodeList) groupItem).isEmpty()) {
         continue;
       }
       validateGroupItem(groupScope, aggregatingScope, groupItem);
@@ -4260,7 +4262,7 @@ protected void validateWhereOrOn(SqlValidatorScope scope, SqlNode condition, Str
   private static boolean isReturnBooleanType(RelDataType relDataType) {
     if (relDataType instanceof RelRecordType) {
       RelRecordType recordType = (RelRecordType) relDataType;
-      Preconditions.checkState(
+      checkState(
           recordType.getFieldList().size() == 1,
           "sub-query as condition must return only one column");
       RelDataTypeField recordField = recordType.getFieldList().get(0);
@@ -4505,7 +4507,7 @@ protected RelDataType createTargetRowType(
         typeFactory.createStructType(
             logicalTargetRowType.getFieldList().stream()
                 .filter(f -> strategies.get(f.getIndex()).canInsertInto())
-                .collect(Collectors.toList()));
+                .collect(toList()));
 
     final RelDataType targetRowTypeToValidate =
         logicalSourceRowType.getFieldCount() == logicalTargetRowType.getFieldCount()
@@ -4565,7 +4567,7 @@ private void checkConstraint(
       final ImmutableBitSet constrainedColumns =
           ImmutableBitSet.of((Iterable<Integer>) projectMap.keySet());
       @SuppressWarnings("assignment.type.incompatible")
-      List<@KeyFor({"tableIndexToTargetField", "projectMap"}) Integer> constrainedTargetColumns =
+      List<@KeyFor({"projectMap", "tableIndexToTargetField"}) Integer> constrainedTargetColumns =
           targetColumns.intersect(constrainedColumns).asList();
 
       // Validate insert values against the view constraint.
@@ -4993,7 +4995,7 @@ protected void validateValues(
 
     final List<SqlNode> operands = node.getOperandList();
     for (SqlNode operand : operands) {
-      if (!(operand.getKind() == SqlKind.ROW)) {
+      if (operand.getKind() != SqlKind.ROW) {
         throw Util.needToImplement("Values function where operands are scalars");
       }
 
@@ -5059,7 +5061,7 @@ protected void validateValues(
                   }
                 });
 
-        if (null == type) {
+        if (type == null) {
           throw newValidationError(
               node, RESOURCE.incompatibleValueType(SqlStdOperatorTable.VALUES.getName()));
         }
@@ -5278,7 +5280,7 @@ SqlValidatorNamespace lookupFieldNamespace(RelDataType rowType, String name) {
             RESOURCE.intervalMustBeNonNegative(
                 intervalValue != null ? intervalValue : interval.toString()));
       }
-      if (orderBy == null || orderBy.size() == 0) {
+      if (orderBy == null || orderBy.isEmpty()) {
         throw newValidationError(interval, RESOURCE.cannotUseWithinWithoutOrderBy());
       }
 
@@ -5302,7 +5304,7 @@ SqlValidatorNamespace lookupFieldNamespace(RelDataType rowType, String name) {
     validateDefinitions(matchRecognize, scope);
 
     SqlNodeList subsets = matchRecognize.getSubsetList();
-    if (subsets != null && subsets.size() > 0) {
+    if (subsets != null && !subsets.isEmpty()) {
       for (SqlNode node : subsets) {
         List<SqlNode> operands = ((SqlCall) node).getOperandList();
         String leftString = ((SqlIdentifier) operands.get(0)).getSimple();
@@ -5339,7 +5341,7 @@ SqlValidatorNamespace lookupFieldNamespace(RelDataType rowType, String name) {
         });
 
     final RelDataType rowType = typeBuilder.build();
-    if (matchRecognize.getMeasureList().size() == 0) {
+    if (matchRecognize.getMeasureList().isEmpty()) {
       ns.setType(getNamespaceOrThrow(matchRecognize.getTableRef()).getRowType());
     } else {
       ns.setType(rowType);
@@ -5396,8 +5398,7 @@ private SqlNode navigationInMeasure(SqlNode node, boolean allRows) {
       node = SqlStdOperatorTable.AS.createCall(SqlParserPos.ZERO, newNode, ops.get(1));
     }
 
-    node = new NavigationExpander().go(node);
-    return node;
+    return new NavigationExpander().go(node);
   }
 
   private void validateDefinitions(SqlMatchRecognize mr, MatchRecognizeScope scope) {
@@ -5677,8 +5678,7 @@ private SqlNode navigationInDefine(SqlNode node, String alpha) {
     Set<String> prefix = node.accept(new PatternValidator(false));
     Util.discard(prefix);
     node = new NavigationExpander().go(node);
-    node = new NavigationReplacer(alpha).go(node);
-    return node;
+    return new NavigationReplacer(alpha).go(node);
   }
 
   @Override public void validateAggregateParams(
@@ -5738,7 +5738,7 @@ private SqlNode navigationInDefine(SqlNode node, String alpha) {
     final SqlAggFunction op = (SqlAggFunction) aggCall.getOperator();
     switch (op.requiresGroupOrder()) {
       case MANDATORY:
-        if (orderList == null || orderList.size() == 0) {
+        if (orderList == null || orderList.isEmpty()) {
           throw newValidationError(
               aggCall, RESOURCE.aggregateMissingWithinGroupClause(op.getName()));
         }
@@ -5752,7 +5752,7 @@ private SqlNode navigationInDefine(SqlNode node, String alpha) {
         }
         break;
       case FORBIDDEN:
-        if (orderList != null && orderList.size() != 0) {
+        if (orderList != null && !orderList.isEmpty()) {
           throw newValidationError(
               aggCall, RESOURCE.withinGroupClauseIllegalInAggregate(op.getName()));
         }
@@ -5890,7 +5890,7 @@ public SqlNode extendedExpandGroupBy(SqlNode expr, SqlValidatorScope scope, SqlS
 
   @Override public List<@Nullable List<String>> getFieldOrigins(SqlNode sqlQuery) {
     if (sqlQuery instanceof SqlExplain) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     final RelDataType rowType = getValidatedNodeType(sqlQuery);
     final int fieldCount = rowType.getFieldCount();
@@ -6123,7 +6123,7 @@ private static class PatternVarVisitor implements SqlVisitor<Void> {
     }
 
     @Override public Void visit(SqlIdentifier id) {
-      Preconditions.checkArgument(id.isSimple());
+      checkArgument(id.isSimple());
       scope.addPatternVar(id.getSimple());
       return null;
     }
@@ -6244,8 +6244,7 @@ private class DeriveTypeVisitor implements SqlVisitor<RelDataType> {
         }
         type = field.getType();
       }
-      type = SqlTypeUtil.addCharsetAndCollation(type, getTypeFactory());
-      return type;
+      return SqlTypeUtil.addCharsetAndCollation(type, getTypeFactory());
     }
 
     @Override public RelDataType visit(SqlDataTypeSpec dataType) {
@@ -6683,7 +6682,7 @@ private static class NavigationExpander extends NavigationModifier {
         return newInnerNode;
       }
 
-      if (operands.size() > 0) {
+      if (!operands.isEmpty()) {
         for (SqlNode node : operands) {
           if (node != null) {
             SqlNode newNode = node.accept(new NavigationExpander());
@@ -6844,7 +6843,7 @@ private class PatternValidator extends SqlBasicVisitor<@Nullable Set<String>> {
             }
             break;
           default:
-            if (operands.size() == 0
+            if (operands.isEmpty()
                 || !(operands.get(0) instanceof SqlCall)
                 || ((SqlCall) operands.get(0)).getOperator() != SqlStdOperatorTable.CLASSIFIER) {
               if (vars.isEmpty()) {
@@ -6937,7 +6936,7 @@ private class Permute {
             }
           }
           rowType = b.build();
-          this.sources = ImmutableList.copyOf(sources);
+          this.sources = sources;
           this.trivial = left.trivial && right.trivial && (names == null || names.isEmpty());
           break;
 
@@ -6961,7 +6960,7 @@ void permute(List<SqlNode> selectItems, PairList<String, RelDataType> fields) {
         return;
       }
 
-      final List<SqlNode> oldSelectItems = ImmutableList.copyOf(selectItems);
+      final List<SqlNode> oldSelectItems = selectItems;
       selectItems.clear();
       selectItems.addAll(oldSelectItems.subList(0, offset));
       final PairList<String, RelDataType> oldFields = fields.immutable();
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java
index 25943ab13..465e4a09d 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java
@@ -244,7 +244,7 @@ public int stepCount() {
 
     /** Returns the steps in this path. */
     public List<Step> steps() {
-      ImmutableList.Builder<Step> paths = new ImmutableList.Builder<>();
+      ImmutableList.Builder<Step> paths = ImmutableList.builder();
       build(paths);
       return paths.build();
     }
@@ -346,7 +346,7 @@ class Resolve {
       this.scope = scope;
       assert !(scope instanceof TableScope);
       this.path = requireNonNull(path, "path");
-      this.remainingNames = ImmutableList.copyOf(remainingNames);
+      this.remainingNames = remainingNames;
     }
 
     /** The row type of the found namespace, nullable if the lookup has looked into outer joins. */
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
index 26b7cb035..e1eda5f36 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
@@ -61,7 +61,6 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
@@ -71,17 +70,17 @@
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Properties;
 import java.util.Set;
 import java.util.TreeSet;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNullList;
 import static org.apache.calcite.sql.type.NonNullableAccessors.getCharset;
 import static org.apache.calcite.sql.type.NonNullableAccessors.getCollation;
@@ -184,7 +183,7 @@ public static List<RelDataTypeField> getExtendedColumns(
    * Converts a list of extended columns (of the form [name0, type0, name1, type1, ...]) into a list
    * of (name, type) pairs.
    */
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   private static PairList<SqlIdentifier, SqlDataTypeSpec> pairs(SqlNodeList extendedColumns) {
     return PairList.backedBy((List) extendedColumns.getList());
   }
@@ -263,7 +262,7 @@ public static void checkCharsetAndCollateConsistentIfCharType(RelDataType type)
           // todo: enable this checking when we have a charset to
           //   collation mapping
           throw new Error(
-              type.toString()
+              type
                   + " was found to have charset '"
                   + strCharset.name()
                   + "' and a mismatched collation charset '"
@@ -311,7 +310,7 @@ public static SqlNode addAlias(SqlNode expr, String alias) {
    * @return An alias, if one can be derived; or a synthetic alias "expr$<i>ordinal</i>"; never null
    */
   public static String alias(SqlNode node, int ordinal) {
-    Preconditions.checkArgument(ordinal >= 0);
+    checkArgument(ordinal >= 0);
     return requireNonNull(alias_(node, ordinal), "alias");
   }
 
@@ -636,7 +635,7 @@ private static void addFields(
    * namespace, never null, may represent a schema, table, column, etc.
    */
   public static SqlValidatorNamespace lookup(SqlValidatorScope scope, List<String> names) {
-    assert names.size() > 0;
+    assert !names.isEmpty();
     final SqlNameMatcher nameMatcher = scope.getValidator().getCatalogReader().nameMatcher();
     final SqlValidatorScope.ResolvedImpl resolved = new SqlValidatorScope.ResolvedImpl();
     scope.resolve(ImmutableList.of(names.get(0)), nameMatcher, false, resolved);
@@ -849,7 +848,7 @@ private static ImmutableBitSet analyzeGroupExpr(
                 scope, groupAnalyzer, ((SqlCall) expandedGroupExpr).getOperandList()));
       case OTHER:
         if (expandedGroupExpr instanceof SqlNodeList
-            && ((SqlNodeList) expandedGroupExpr).size() == 0) {
+            && ((SqlNodeList) expandedGroupExpr).isEmpty()) {
           return ImmutableBitSet.of();
         }
         break;
@@ -1164,7 +1163,7 @@ public static Pair<SqlNode, RelDataType> validateExprWithRowType(
         new SqlSelect(
             SqlParserPos.ZERO,
             null,
-            new SqlNodeList(Collections.singletonList(expr), SqlParserPos.ZERO),
+            new SqlNodeList(ImmutableList.of(expr), SqlParserPos.ZERO),
             new SqlIdentifier(tableName, SqlParserPos.ZERO),
             null,
             null,
@@ -1213,7 +1212,7 @@ public static CalciteCatalogReader createSingleTableCatalogReader(
 
     // prepare root schema
     final ExplicitRowTypeTable table = new ExplicitRowTypeTable(rowType);
-    final Map<String, Table> tableMap = Collections.singletonMap(tableName, table);
+    final Map<String, Table> tableMap = ImmutableMap.of(tableName, table);
     CalciteSchema schema =
         CalciteSchema.createRootSchema(false, false, "", new ExplicitTableSchema(tableMap));
 
@@ -1403,11 +1402,10 @@ public static class FlatAggregate {
         @Nullable SqlCall filterCall,
         @Nullable SqlCall distinctCall,
         @Nullable SqlCall orderCall) {
-      this.aggregateCall = Objects.requireNonNull(aggregateCall, "aggregateCall");
-      Preconditions.checkArgument(filterCall == null || filterCall.getKind() == SqlKind.FILTER);
-      Preconditions.checkArgument(
-          distinctCall == null || distinctCall.getKind() == SqlKind.WITHIN_DISTINCT);
-      Preconditions.checkArgument(orderCall == null || orderCall.getKind() == SqlKind.WITHIN_GROUP);
+      this.aggregateCall = requireNonNull(aggregateCall, "aggregateCall");
+      checkArgument(filterCall == null || filterCall.getKind() == SqlKind.FILTER);
+      checkArgument(distinctCall == null || distinctCall.getKind() == SqlKind.WITHIN_DISTINCT);
+      checkArgument(orderCall == null || orderCall.getKind() == SqlKind.WITHIN_GROUP);
       this.filterCall = filterCall;
       this.filter = filterCall == null ? null : filterCall.operand(1);
       this.distinctCall = distinctCall;
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/TableScope.java b/core/src/main/java/org/apache/calcite/sql/validate/TableScope.java
index 3120c1f61..865341eb0 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/TableScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/TableScope.java
@@ -19,7 +19,7 @@
 import org.apache.calcite.sql.SqlNode;
 import org.apache.calcite.sql.SqlSelect;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * The name-resolution scope of a LATERAL TABLE clause.
@@ -40,8 +40,8 @@ class TableScope extends ListScope {
    * @param parent Parent scope
    */
   TableScope(SqlValidatorScope parent, SqlNode node) {
-    super(Objects.requireNonNull(parent, "parent"));
-    this.node = Objects.requireNonNull(node, "node");
+    super(requireNonNull(parent, "parent"));
+    this.node = requireNonNull(node, "node");
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java b/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
index bc284fdd0..b3d53ee40 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
@@ -551,17 +551,17 @@ private RelDataType getTightestCommonTypeOrThrow(
       return null;
     }
     RelDataType resultType = getTightestCommonType(type1, type2);
-    if (null == resultType) {
+    if (resultType == null) {
       resultType = getWiderTypeForDecimal(type1, type2);
     }
-    if (null == resultType && stringPromotion) {
+    if (resultType == null && stringPromotion) {
       resultType = promoteToVarChar(type1, type2);
     }
-    if (null == resultType) {
+    if (resultType == null) {
       if (SqlTypeUtil.isArray(type1) && SqlTypeUtil.isArray(type2)) {
         RelDataType valType =
             getWiderTypeForTwo(type1.getComponentType(), type2.getComponentType(), stringPromotion);
-        if (null != valType) {
+        if (valType != null) {
           resultType = factory.createArrayType(valType, -1);
         }
       }
@@ -612,7 +612,7 @@ private RelDataType getTightestCommonTypeOrThrow(
     List<RelDataType> target = stringPromotion ? partitionByCharacter(typeList) : typeList;
     for (RelDataType tp : target) {
       resultType = getWiderTypeForTwo(tp, resultType, stringPromotion);
-      if (null == resultType) {
+      if (resultType == null) {
         return null;
       }
     }
@@ -651,7 +651,7 @@ boolean canImplicitTypeCast(List<RelDataType> types, List<SqlTypeFamily> familie
     }
     for (Pair<RelDataType, SqlTypeFamily> pair : Pair.zip(types, families)) {
       RelDataType implicitType = implicitCast(pair.left, pair.right);
-      if (null == implicitType) {
+      if (implicitType == null) {
         return false;
       }
       needed = pair.left != implicitType || needed;
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java b/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
index 4523a3386..15e9b2768 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
@@ -50,13 +50,13 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.sql.validate.SqlNonNullableAccessors.getScope;
 import static org.apache.calcite.sql.validate.SqlNonNullableAccessors.getSelectList;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /** Default implementation of Calcite implicit type cast. */
 public class TypeCoercionImpl extends AbstractTypeCoercion {
@@ -237,7 +237,7 @@ protected boolean binaryArithmeticWithStrings(
       // Binary comparison operator like: = > >= < <=
       if (kind.belongsTo(SqlKind.BINARY_COMPARISON)) {
         final RelDataType commonType = commonTypeForBinaryComparison(type1, type2);
-        if (null != commonType) {
+        if (commonType != null) {
           coerced = coerceOperandsType(binding.getScope(), binding.getCall(), commonType);
         }
       }
@@ -245,9 +245,9 @@ protected boolean binaryArithmeticWithStrings(
     // Infix operator like: BETWEEN
     if (kind == SqlKind.BETWEEN) {
       final List<RelDataType> operandTypes =
-          Util.range(operandCnt).stream().map(binding::getOperandType).collect(Collectors.toList());
+          Util.range(operandCnt).stream().map(binding::getOperandType).collect(toList());
       final RelDataType commonType = commonTypeForComparison(operandTypes);
-      if (null != commonType) {
+      if (commonType != null) {
         coerced = coerceOperandsType(binding.getScope(), binding.getCall(), commonType);
       }
     }
@@ -404,7 +404,7 @@ protected boolean booleanEquality(SqlCallBinding binding, RelDataType left, RelD
     // Entering this method means we have already got a wider type, recompute it here
     // just to make the interface more clear.
     RelDataType widerType = getWiderTypeFor(argTypes, true);
-    if (null != widerType) {
+    if (widerType != null) {
       boolean coerced = false;
       for (int i = 0; i < thenList.size(); i++) {
         coerced = coerceColumnType(scope, thenList, i, widerType) || coerced;
@@ -554,7 +554,7 @@ protected boolean booleanEquality(SqlCallBinding binding, RelDataType left, RelD
     for (int i = 0; i < operandTypes.size(); i++) {
       RelDataType implicitType = implicitCast(operandTypes.get(i), expectedFamilies.get(i));
       coerced =
-          null != implicitType
+          implicitType != null
                   && operandTypes.get(i) != implicitType
                   && coerceOperandType(binding.getScope(), binding.getCall(), i, implicitType)
               || coerced;
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java
index 7378add79..f70cfff38 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java
@@ -56,10 +56,11 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.stream.Collectors.toList;
+
 /**
  * Converts expressions to aggregates.
  *
@@ -460,7 +461,7 @@ private void translateAgg(
     final RelDataType type = bb.getValidator().deriveType(bb.scope, call);
     boolean distinct = false;
     SqlLiteral quantifier = call.getFunctionQuantifier();
-    if ((null != quantifier) && (quantifier.getValue() == SqlSelectKeyword.DISTINCT)) {
+    if (quantifier != null && (quantifier.getValue() == SqlSelectKeyword.DISTINCT)) {
       distinct = true;
     }
     boolean approximate = false;
@@ -470,7 +471,7 @@ private void translateAgg(
       approximate = true;
     }
     final RelCollation collation;
-    if (orderList == null || orderList.size() == 0) {
+    if (orderList == null || orderList.isEmpty()) {
       collation = RelCollations.EMPTY;
     } else {
       try {
@@ -486,7 +487,7 @@ private void translateAgg(
                                 RelFieldCollation.Direction.ASCENDING,
                                 RelFieldCollation.NullDirection.UNSPECIFIED,
                                 this::sortToFieldCollation))
-                    .collect(Collectors.toList()));
+                    .collect(toList()));
       } finally {
         // switch back into agg mode
         bb.agg = this;
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/CorrelateProjectExtractor.java b/core/src/main/java/org/apache/calcite/sql2rel/CorrelateProjectExtractor.java
index a852bdb3a..e77d8e929 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/CorrelateProjectExtractor.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/CorrelateProjectExtractor.java
@@ -95,7 +95,7 @@ public CorrelateProjectExtractor(RelBuilderFactory factory) {
     Set<RexNode> callsWithCorrelationInRight =
         findCorrelationDependentCalls(correlate.getCorrelationId(), right);
     boolean isTrivialCorrelation =
-        callsWithCorrelationInRight.stream().allMatch(exp -> exp instanceof RexFieldAccess);
+        callsWithCorrelationInRight.stream().allMatch(RexFieldAccess.class::isInstance);
     // Early exit condition
     if (isTrivialCorrelation) {
       if (correlate.getLeft().equals(left) && correlate.getRight().equals(right)) {
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/NullInitializerExpressionFactory.java b/core/src/main/java/org/apache/calcite/sql2rel/NullInitializerExpressionFactory.java
index 76a1c4bb4..62d1cae2a 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/NullInitializerExpressionFactory.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/NullInitializerExpressionFactory.java
@@ -36,8 +36,8 @@ public class NullInitializerExpressionFactory implements InitializerExpressionFa
 
   public NullInitializerExpressionFactory() {}
 
-  @SuppressWarnings("deprecation")
-  @Override public boolean isGeneratedAlways(RelOptTable table, int iColumn) {
+  @Override @SuppressWarnings("deprecation")
+  public boolean isGeneratedAlways(RelOptTable table, int iColumn) {
     switch (generationStrategy(table, iColumn)) {
       case VIRTUAL:
       case STORED:
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/ReflectiveConvertletTable.java b/core/src/main/java/org/apache/calcite/sql2rel/ReflectiveConvertletTable.java
index 26e0d9817..74d783845 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/ReflectiveConvertletTable.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/ReflectiveConvertletTable.java
@@ -22,8 +22,6 @@
 import org.apache.calcite.sql.SqlOperator;
 import org.apache.calcite.sql.parser.SqlParserPos;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.initialization.qual.UnderInitialization;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.checker.nullness.qual.RequiresNonNull;
@@ -34,6 +32,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -212,7 +212,7 @@ protected void addAlias(
         alias,
         (SqlRexConvertlet)
             (cx, call) -> {
-              Preconditions.checkArgument(call.getOperator() == alias, "call to wrong operator");
+              checkArgument(call.getOperator() == alias, "call to wrong operator");
               final SqlCall newCall = target.createCall(SqlParserPos.ZERO, call.getOperandList());
               cx.getValidator()
                   .setValidatedNodeType(newCall, cx.getValidator().getValidatedNodeType(call));
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java b/core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
index 0781a4c09..65de364a6 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
@@ -93,6 +93,7 @@
 import org.apache.calcite.util.mapping.Mappings;
 import org.apache.calcite.util.trace.CalciteTrace;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedMap;
@@ -110,7 +111,6 @@
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -119,11 +119,11 @@
 import java.util.Objects;
 import java.util.Set;
 import java.util.TreeMap;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * RelDecorrelator replaces all correlated expressions (corExp) in a relational expression (RelNode)
@@ -225,9 +225,7 @@ public static RelNode decorrelateQuery(RelNode rootRel, RelBuilder relBuilder) {
     }
 
     // Re-propagate the hints.
-    newRootRel = RelOptUtil.propagateRelHints(newRootRel, true);
-
-    return newRootRel;
+    return RelOptUtil.propagateRelHints(newRootRel, true);
   }
 
   private void setCurrent(@Nullable RelNode root, @Nullable Correlate corRel) {
@@ -287,16 +285,14 @@ protected RelNode decorrelate(RelNode root) {
     root = planner.findBestExp();
     if (SQL2REL_LOGGER.isDebugEnabled()) {
       SQL2REL_LOGGER.debug(
-          "Plan before extracting correlated computations:\n"
-  + RelOptUtil.toString(root));
+          "Plan before extracting correlated computations:\n{}", RelOptUtil.toString(root));
     }
     root = root.accept(new CorrelateProjectExtractor(f));
     // Necessary to update cm (CorrelMap) since CorrelateProjectExtractor above may modify the plan
     this.cm = new CorelMapBuilder().build(root);
     if (SQL2REL_LOGGER.isDebugEnabled()) {
       SQL2REL_LOGGER.debug(
-          "Plan after extracting correlated computations:\n"
-  + RelOptUtil.toString(root));
+          "Plan after extracting correlated computations:\n{}", RelOptUtil.toString(root));
     }
     // Perform decorrelation.
     map.clear();
@@ -400,7 +396,7 @@ protected RexNode removeCorrelationExpr(
   public @Nullable Frame decorrelateRel(RelNode rel, boolean isCorVarDefined) {
     RelNode newRel = rel.copy(rel.getTraitSet(), rel.getInputs());
 
-    if (rel.getInputs().size() > 0) {
+    if (!rel.getInputs().isEmpty()) {
       List<RelNode> oldInputs = rel.getInputs();
       List<RelNode> newInputs = new ArrayList<>();
       for (int i = 0; i < oldInputs.size(); ++i) {
@@ -1184,7 +1180,7 @@ private static boolean isWidening(RelDataType type, RelDataType type1) {
       return null;
     }
 
-    assert rel.getRequiredColumns().cardinality() <= rightFrame.corDefOutputs.keySet().size();
+    assert rel.getRequiredColumns().cardinality() <= rightFrame.corDefOutputs.size();
 
     // Change correlator rel into a join.
     // Join all the correlated variables produced by this correlator rel
@@ -1980,7 +1976,7 @@ static RemoveCorrelationForScalarProjectRuleConfig config(
         right = right.stripped();
 
         // check filter input contains no correlation
-        if (RelOptUtil.getVariablesUsed(right).size() > 0) {
+        if (!RelOptUtil.getVariablesUsed(right).isEmpty()) {
           return;
         }
 
@@ -2040,7 +2036,7 @@ static RemoveCorrelationForScalarProjectRuleConfig config(
         nullIndicatorPos = left.getRowType().getFieldCount() + rightJoinKeys.get(0).getIndex();
       } else if (d.cm.mapRefRelToCorRef.containsKey(project)) {
         // check filter input contains no correlation
-        if (RelOptUtil.getVariablesUsed(right).size() > 0) {
+        if (!RelOptUtil.getVariablesUsed(right).isEmpty()) {
           return;
         }
 
@@ -2189,7 +2185,7 @@ static RemoveCorrelationForScalarAggregateRuleConfig config(
       for (AggregateCall aggCall : aggCalls) {
         ++k;
         if ((aggCall.getAggregation() instanceof SqlCountAggFunction)
-            && (aggCall.getArgList().size() == 0)) {
+            && aggCall.getArgList().isEmpty()) {
           isCountStar.add(k);
         }
       }
@@ -2206,7 +2202,7 @@ static RemoveCorrelationForScalarAggregateRuleConfig config(
         right = right.stripped();
 
         // check filter input contains no correlation
-        if (RelOptUtil.getVariablesUsed(right).size() > 0) {
+        if (!RelOptUtil.getVariablesUsed(right).isEmpty()) {
           return;
         }
 
@@ -2302,7 +2298,7 @@ static RemoveCorrelationForScalarAggregateRuleConfig config(
         joinCond = d.removeCorrelationExpr(filter.getCondition(), false);
       } else if (d.cm.mapRefRelToCorRef.containsKey(aggInputProject)) {
         // check rightInput contains no correlation
-        if (RelOptUtil.getVariablesUsed(right).size() > 0) {
+        if (!RelOptUtil.getVariablesUsed(right).isEmpty()) {
           return;
         }
 
@@ -2422,7 +2418,7 @@ static RemoveCorrelationForScalarAggregateRuleConfig config(
         if (isCountStar.contains(k)) {
           // this is a count(*), transform it to count(nullIndicator)
           // the null indicator is located at the end
-          argList = Collections.singletonList(nullIndicatorPos);
+          argList = ImmutableList.of(nullIndicatorPos);
         } else {
           argList = new ArrayList<>();
 
@@ -2599,7 +2595,7 @@ private void onMatch2(
       List<RexNode> requiredNodes =
           correlate.getRequiredColumns().asList().stream()
               .map(ord -> rexBuilder.makeInputRef(correlate, ord))
-              .collect(Collectors.toList());
+              .collect(toList());
       Correlate newCorrelate =
           (Correlate)
               d.relBuilder
@@ -2753,7 +2749,7 @@ private CorelMap(
         Map<RexFieldAccess, CorRef> mapFieldAccessToCorRef) {
       this.mapRefRelToCorRef = mapRefRelToCorRef;
       this.mapCorToCorRel = mapCorToCorRel;
-      this.mapFieldAccessToCorRef = ImmutableMap.copyOf(mapFieldAccessToCorRef);
+      this.mapFieldAccessToCorRef = mapFieldAccessToCorRef;
     }
 
     @Override public String toString() {
@@ -2766,8 +2762,8 @@ private CorelMap(
           + "\n";
     }
 
-    @SuppressWarnings("UndefinedEquals")
-    @Override public boolean equals(@Nullable Object obj) {
+    @Override @SuppressWarnings("UndefinedEquals")
+    public boolean equals(@Nullable Object obj) {
       return obj == this
           || obj instanceof CorelMap
               // TODO: Multimap does not have well-defined equals behavior
@@ -2950,6 +2946,6 @@ protected RelDecorrelator getVisitor() {
 
   /** Returns the rules applied on the rel after decorrelation, never null. */
   protected Collection<RelOptRule> getPostDecorrelateRules() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java b/core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
index 671a210eb..cbe565540 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
@@ -72,17 +72,19 @@
 import org.apache.calcite.util.mapping.Mappings;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.math.BigDecimal;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Transformer that walks over a tree of relational expressions, replacing each {@link RelNode} with
  * a 'slimmed down' relational expression that projects only the columns required by its consumer.
@@ -162,11 +164,9 @@ public RelFieldTrimmer(
   public RelNode trim(RelNode root) {
     final int fieldCount = root.getRowType().getFieldCount();
     final ImmutableBitSet fieldsUsed = ImmutableBitSet.range(fieldCount);
-    final Set<RelDataTypeField> extraFields = Collections.emptySet();
+    final Set<RelDataTypeField> extraFields = ImmutableSet.of();
     final TrimResult trimResult = dispatchTrimFields(root, fieldsUsed, extraFields);
-    if (!trimResult.right.isIdentity()) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(trimResult.right.isIdentity());
     if (SqlToRelConverter.SQL2REL_LOGGER.isDebugEnabled()) {
       SqlToRelConverter.SQL2REL_LOGGER.debug(
           RelOptUtil.dumpPlan(
@@ -352,13 +352,11 @@ public TrimResult trimFields(
     for (RelNode input : rel.getInputs()) {
       ImmutableBitSet inputFieldsUsed = ImmutableBitSet.range(input.getRowType().getFieldCount());
       TrimResult trimResult = dispatchTrimFields(input, inputFieldsUsed, extraFields);
-      if (!trimResult.right.isIdentity()) {
-        throw new IllegalArgumentException(
-            "Expected identity mapping after processing RelNode "
-                + input
-                + "; but got "
-                + trimResult.right);
-      }
+      checkArgument(
+          trimResult.right.isIdentity(),
+          "Expected identity mapping after processing RelNode %s; but got %s",
+          input,
+          trimResult.right);
       newInputs.add(trimResult.left);
     }
     RelNode newRel = rel.copy(rel.getTraitSet(), newInputs);
@@ -605,7 +603,7 @@ public TrimResult trimFields(
     }
 
     // Create input with trimmed columns.
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     TrimResult trimResult = trimChild(sort, input, inputFieldsUsed.build(), inputExtraFields);
     RelNode newInput = trimResult.left;
     final Mapping inputMapping = trimResult.right;
@@ -641,7 +639,7 @@ public TrimResult trimFields(
     }
 
     // Create input with trimmed columns.
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     final TrimResult trimResult =
         trimChild(exchange, input, inputFieldsUsed.build(), inputExtraFields);
     final RelNode newInput = trimResult.left;
@@ -679,7 +677,7 @@ public TrimResult trimFields(
     }
 
     // Create input with trimmed columns.
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     TrimResult trimResult =
         trimChild(sortExchange, input, inputFieldsUsed.build(), inputExtraFields);
     RelNode newInput = trimResult.left;
@@ -760,7 +758,7 @@ public TrimResult trimFields(
       // on-demand fields.
       Set<RelDataTypeField> inputExtraFields =
           RelDataTypeImpl.extra(inputRowType) == null
-              ? Collections.emptySet()
+              ? ImmutableSet.of()
               : combinedInputExtraFields;
       inputExtraFieldCounts.add(inputExtraFields.size());
       TrimResult trimResult = trimChild(join, input, inputFieldsUsed.build(), inputExtraFields);
@@ -956,7 +954,7 @@ public TrimResult trimFields(
 
     // Create input with trimmed columns.
     final RelNode input = aggregate.getInput();
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     final TrimResult trimResult =
         trimChild(aggregate, input, inputFieldsUsed.build(), inputExtraFields);
     final RelNode newInput = trimResult.left;
@@ -1042,7 +1040,7 @@ public TrimResult trimFields(
     final ImmutableBitSet inputFieldsUsed = ImmutableBitSet.range(inputFieldCount);
 
     // Create input with trimmed columns.
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     TrimResult trimResult = trimChild(modifier, input, inputFieldsUsed, inputExtraFields);
     RelNode newInput = trimResult.left;
     final Mapping inputMapping = trimResult.right;
@@ -1054,7 +1052,7 @@ public TrimResult trimFields(
 
     LogicalTableModify newModifier = modifier;
     if (newInput != input) {
-      newModifier = modifier.copy(modifier.getTraitSet(), Collections.singletonList(newInput));
+      newModifier = modifier.copy(modifier.getTraitSet(), ImmutableList.of(newInput));
     }
     assert newModifier.getClass() == modifier.getClass();
 
@@ -1080,7 +1078,7 @@ public TrimResult trimFields(
       ImmutableBitSet inputFieldsUsed = ImmutableBitSet.range(inputFieldCount);
 
       // Create input with trimmed columns.
-      final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+      final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
       TrimResult trimResult = trimChildRestore(tabFun, input, inputFieldsUsed, inputExtraFields);
       assert trimResult.right.isIdentity();
       newInputs.add(trimResult.left);
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java b/core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
index a04cbd6a6..198f0dcfa 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
@@ -80,7 +80,6 @@
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.SortedSetMultimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -97,6 +96,8 @@
 import java.util.SortedMap;
 import java.util.SortedSet;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 // TODO jvs 10-Feb-2005:  factor out generic rewrite helper, with the
@@ -194,7 +195,7 @@ private RelNode getCurrentRelOrThrow() {
   }
 
   public void updateRelInMap(SortedSetMultimap<RelNode, CorrelationId> mapRefRelToCorVar) {
-    for (RelNode rel : Lists.newArrayList(mapRefRelToCorVar.keySet())) {
+    for (RelNode rel : new ArrayList<>(mapRefRelToCorVar.keySet())) {
       if (oldToNewRelMap.containsKey(rel)) {
         SortedSet<CorrelationId> corVarSet = mapRefRelToCorVar.removeAll(rel);
         mapRefRelToCorVar.putAll(oldToNewRelMap.get(rel), corVarSet);
@@ -237,11 +238,11 @@ private RelNode tryRestructure(RelNode root, RelNode flattened) {
       // client.
       RelNode restructured =
           relBuilder.push(flattened).projectNamed(structuringExps, resultFieldNames, true).build();
-      restructured = RelOptUtil.copyRelHints(flattened, restructured);
+      return RelOptUtil.copyRelHints(flattened, restructured);
       // REVIEW jvs 23-Mar-2005:  How do we make sure that this
       // implementation stays in Java?  Fennel can't handle
       // structured types.
-      return restructured;
+
     } else {
       return flattened;
     }
@@ -846,7 +847,7 @@ private class RewriteRelVisitor extends RelVisitor {
           dispatcher.invokeVisitor(RelStructuredTypeFlattener.this, currentRel, visitMethodName);
       currentRel = null;
       if (!found) {
-        if (p.getInputs().size() == 0) {
+        if (p.getInputs().isEmpty()) {
           // for leaves, it's usually safe to assume that
           // no transformation is required
           rewriteGeneric(p);
@@ -954,16 +955,15 @@ private RelDataType removeDistinct(RelDataType type) {
           int oldOrdinal = ((RexInputRef) firstOp).getIndex();
           int newInnerOrdinal = getNewInnerOrdinal(firstOp, literalString);
           Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, newInnerOrdinal);
-          RexInputRef newRef = rexBuilder.makeInputRef(newField.e, newField.i);
-          return newRef;
+          return rexBuilder.makeInputRef(newField.e, newField.i);
+
         } else {
           RexNode newFirstOp = firstOp.accept(this);
           if (newFirstOp instanceof RexInputRef) {
             int newRefOrdinal =
                 ((RexInputRef) newFirstOp).getIndex() + getNewInnerOrdinal(firstOp, literalString);
             RelDataTypeField newField = getNewInputFieldByNewOrdinal(newRefOrdinal);
-            RexInputRef newRef = rexBuilder.makeInputRef(newField.getType(), newRefOrdinal);
-            return newRef;
+            return rexBuilder.makeInputRef(newField.getType(), newRefOrdinal);
           }
         }
       }
@@ -996,9 +996,7 @@ private RexNode flattenComparison(
       final PairList<RexNode, String> flattenedExps = PairList.of();
       flattenProjections(this, exprs, null, "", flattenedExps);
       int n = flattenedExps.size() / 2;
-      if (n == 0) {
-        throw new IllegalArgumentException("exprs must be non-empty");
-      }
+      checkArgument(n != 0, "exprs must be non-empty");
       boolean negate = false;
       if (op.getKind() == SqlKind.NOT_EQUALS) {
         negate = true;
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlNodeToRexConverterImpl.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlNodeToRexConverterImpl.java
index 5b378cb3d..1d96863ed 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlNodeToRexConverterImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlNodeToRexConverterImpl.java
@@ -33,10 +33,10 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import java.math.BigDecimal;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Standard implementation of {@link SqlNodeToRexConverter}. */
 public class SqlNodeToRexConverterImpl implements SqlNodeToRexConverter {
   // ~ Instance fields --------------------------------------------------------
@@ -93,7 +93,7 @@ public class SqlNodeToRexConverterImpl implements SqlNodeToRexConverter {
         return rexBuilder.makeLiteral(literal.getValueAs(Boolean.class));
       case BINARY:
         final BitString bitString = literal.getValueAs(BitString.class);
-        Preconditions.checkArgument((bitString.getBitCount() % 8) == 0, "incomplete octet");
+        checkArgument((bitString.getBitCount() % 8) == 0, "incomplete octet");
 
         // An even number of hexits (e.g. X'ABCD') makes whole number
         // of bytes.
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
index 09ca6019c..546ab3ba6 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
@@ -645,11 +645,11 @@ public static boolean isOrdered(SqlNode query) {
     switch (query.getKind()) {
       case SELECT:
         SqlNodeList orderList = ((SqlSelect) query).getOrderList();
-        return orderList != null && orderList.size() > 0;
+        return orderList != null && !orderList.isEmpty();
       case WITH:
         return isOrdered(((SqlWith) query).body);
       case ORDER_BY:
-        return ((SqlOrderBy) query).orderList.size() > 0;
+        return !((SqlOrderBy) query).orderList.isEmpty();
       default:
         return false;
     }
@@ -899,7 +899,7 @@ protected void convertOrder(
     // we can't represent the real collation.
     //
     // If it is the top node, use the real collation, but don't trim fields.
-    if (orderExprList.size() > 0 && !bb.top) {
+    if (!orderExprList.isEmpty() && !bb.top) {
       final List<RexNode> exprs = new ArrayList<>();
       final RelDataType rowType = bb.root().getRowType();
       final int fieldCount = rowType.getFieldCount() - orderExprList.size();
@@ -1595,7 +1595,7 @@ public RelNode convertToSingleValueSubq(SqlNode query, RelNode plan) {
       SqlNodeList selectList = select.getSelectList();
       SqlNodeList groupList = select.getGroup();
 
-      if ((selectList.size() == 1) && ((groupList == null) || (groupList.size() == 0))) {
+      if ((selectList.size() == 1) && ((groupList == null) || groupList.isEmpty())) {
         SqlNode selectExpr = selectList.get(0);
         if (selectExpr instanceof SqlCall) {
           SqlCall selectExprCall = (SqlCall) selectExpr;
@@ -1887,7 +1887,7 @@ private RexLiteral convertLiteral(SqlLiteral sqlLiteral, Blackboard bb, RelDataT
   }
 
   private static boolean isRowConstructor(SqlNode node) {
-    if (!(node.getKind() == SqlKind.ROW)) {
+    if (node.getKind() != SqlKind.ROW) {
       return false;
     }
     SqlCall call = (SqlCall) node;
@@ -2031,7 +2031,7 @@ private void findSubQueries(
    * @return Converted expression
    */
   public RexNode convertExpression(SqlNode node) {
-    Map<String, RelDataType> nameToTypeMap = Collections.emptyMap();
+    Map<String, RelDataType> nameToTypeMap = ImmutableMap.of();
     final ParameterScope scope = new ParameterScope((SqlValidatorImpl) validator(), nameToTypeMap);
     final Blackboard bb = createBlackboard(scope, null, false);
     replaceSubQueries(bb, node, RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);
@@ -2105,7 +2105,7 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {
         // ROW_NUMBER() expects specific kind of framing.
         rows = true;
       }
-    } else if (orderList.size() == 0) {
+    } else if (orderList.isEmpty()) {
       // Without ORDER BY, there must be no bracketing.
       sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);
       sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);
@@ -2125,7 +2125,7 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {
     }
     final RexNode lowerBound = bb.convertExpression(requireNonNull(sqlLowerBound, "sqlLowerBound"));
     final RexNode upperBound = bb.convertExpression(requireNonNull(sqlUpperBound, "sqlUpperBound"));
-    if (orderList.size() == 0 && !rows) {
+    if (orderList.isEmpty() && !rows) {
       // A logical range requires an ORDER BY clause. Use the implicit
       // ordering of this relation. There must be one, otherwise it would
       // have failed validation.
@@ -2175,7 +2175,7 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {
   }
 
   protected void convertFrom(Blackboard bb, @Nullable SqlNode from) {
-    convertFrom(bb, from, Collections.emptyList());
+    convertFrom(bb, from, ImmutableList.of());
   }
 
   /**
@@ -2334,7 +2334,7 @@ private void convertUnnest(Blackboard bb, SqlCall call, @Nullable List<String> f
           final String alias = SqlValidatorUtil.alias(node, i);
           exprs.add(relBuilder.alias(e, alias));
         });
-    RelNode child = (null != bb.root) ? bb.root : LogicalValues.createOneRow(cluster);
+    RelNode child = bb.root != null ? bb.root : LogicalValues.createOneRow(cluster);
     RelNode uncollect;
     if (validator().config().conformance().allowAliasUnnestItems()) {
       uncollect =
@@ -2350,7 +2350,7 @@ private void convertUnnest(Blackboard bb, SqlCall call, @Nullable List<String> f
           relBuilder
               .push(child)
               .project(exprs)
-              .uncollect(Collections.emptyList(), operator.withOrdinality)
+              .uncollect(ImmutableList.of(), operator.withOrdinality)
               .let(r -> fieldNames == null ? r : r.rename(fieldNames))
               .build();
     }
@@ -2543,7 +2543,7 @@ protected void convertPivot(Blackboard bb, SqlPivot pivot) {
     // 3. Gather columns used as arguments to aggregate functions.
     pivotBb.agg = aggConverter;
     final List<@Nullable String> aggAliasList = new ArrayList<>();
-    assert aggConverter.aggCalls.size() == 0;
+    assert aggConverter.aggCalls.isEmpty();
     pivot.forEachAgg(
         (alias, call) -> {
           call.accept(aggConverter);
@@ -2661,7 +2661,7 @@ private void convertIdentifier(
     RelOptTable table =
         SqlValidatorUtil.getRelOptTable(fromNamespace, catalogReader, datasetName, usedDataset);
     assert table != null : "getRelOptTable returned null for " + fromNamespace;
-    if (extendedColumns != null && extendedColumns.size() > 0) {
+    if (extendedColumns != null && !extendedColumns.isEmpty()) {
       final SqlValidatorTable validatorTable = table.unwrapOrThrow(SqlValidatorTable.class);
       final List<RelDataTypeField> extendedFields =
           SqlValidatorUtil.getExtendedColumns(validator(), validatorTable, extendedColumns);
@@ -2711,7 +2711,7 @@ protected void convertCollectionTable(Blackboard bb, SqlCall call) {
       TableExpressionFactory expressionFunction =
           clazz ->
               Schemas.getTableExpression(
-                  Objects.requireNonNull(schema, "schema").plus(),
+                  requireNonNull(schema, "schema").plus(),
                   Util.last(udf.getNameAsId().names),
                   table,
                   clazz);
@@ -3007,7 +3007,7 @@ private boolean isSubQueryNonCorrelated(RelNode subq, Blackboard bb) {
    * @return List of system fields
    */
   protected List<RelDataTypeField> getSystemFields() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   private void convertJoin(Blackboard bb, SqlJoin join) {
@@ -3072,8 +3072,7 @@ private RexNode convertUsingCondition(
       SqlJoin join, SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace) {
     final SqlNodeList list =
         requireNonNull((SqlNodeList) join.getCondition(), () -> "getCondition for join " + join);
-    return convertUsing(
-        leftNamespace, rightNamespace, ImmutableList.copyOf(SqlIdentifier.simpleNames(list)));
+    return convertUsing(leftNamespace, rightNamespace, SqlIdentifier.simpleNames(list));
   }
 
   /**
@@ -3116,7 +3115,7 @@ private Pair<RexNode, RelNode> convertOnCondition(
     bb.setRoot(ImmutableList.of(leftRel, rightRel));
     replaceSubQueries(bb, condition, RelOptUtil.Logic.UNKNOWN_AS_FALSE);
     final RelNode newRightRel =
-        bb.root == null || bb.registered.size() == 0 ? rightRel : bb.reRegister(rightRel);
+        bb.root == null || bb.registered.isEmpty() ? rightRel : bb.reRegister(rightRel);
     bb.setRoot(ImmutableList.of(leftRel, newRightRel));
     RexNode conditionExp = bb.convertExpression(condition);
     if (conditionExp instanceof RexInputRef && newRightRel != rightRel) {
@@ -3939,7 +3938,7 @@ protected void collectInsertTargets(
         RelDataTypeField field =
             SqlValidatorUtil.getTargetField(
                 tableRowType, typeFactory, id, catalogReader, targetTable);
-        assert field != null : "column " + id.toString() + " not found";
+        assert field != null : "column " + id + " not found";
         targetColumnNames.add(field.getName());
       }
     }
@@ -4048,7 +4047,7 @@ private RelNode convertMerge(SqlMerge call) {
         RelDataTypeField field =
             SqlValidatorUtil.getTargetField(
                 targetRowType, typeFactory, id, catalogReader, targetTable);
-        assert field != null : "column " + id.toString() + " not found";
+        assert field != null : "column " + id + " not found";
         targetColumnNameList.add(field.getName());
       }
     }
@@ -4231,7 +4230,7 @@ private RelNode convertMultisets(final List<SqlNode> operands, Blackboard bb) {
           final SqlNodeList list = new SqlNodeList(call.getOperandList(), call.getParserPosition());
           CollectNamespace nss = getNamespaceOrNull(call);
           Blackboard usedBb;
-          if (null != nss) {
+          if (nss != null) {
             usedBb = createBlackboard(nss.getScope(), null, false);
           } else {
             usedBb =
@@ -4264,7 +4263,7 @@ private RelNode convertMultisets(final List<SqlNode> operands, Blackboard bb) {
           continue;
       }
 
-      if (lastList.size() > 0) {
+      if (!lastList.isEmpty()) {
         joinList.add(lastList);
       }
       lastList = new ArrayList<>();
@@ -4274,7 +4273,7 @@ private RelNode convertMultisets(final List<SqlNode> operands, Blackboard bb) {
       joinList.add(relBuilder.build());
     }
 
-    if (joinList.size() == 0) {
+    if (joinList.isEmpty()) {
       joinList.add(lastList);
     }
 
@@ -4569,7 +4568,7 @@ private void convertValuesImpl(
           rowConstructor.getOperandList(),
           (operand, i) ->
               exps.add(tmpBb.convertExpression(operand), SqlValidatorUtil.alias(operand, i)));
-      RelNode in = (null == tmpBb.root) ? LogicalValues.createOneRow(cluster) : tmpBb.root;
+      RelNode in = tmpBb.root == null ? LogicalValues.createOneRow(cluster) : tmpBb.root;
       relBuilder.push(in).project(exps.leftList(), exps.rightList());
     }
 
@@ -4803,7 +4802,7 @@ public RelNode reRegister(RelNode root) {
      *     are not leaves, but set expressions are.
      */
     public void setRoot(RelNode root, boolean leaf) {
-      setRoot(Collections.singletonList(root), root, root instanceof LogicalJoin);
+      setRoot(ImmutableList.of(root), root, root instanceof LogicalJoin);
       if (leaf) {
         leaves.put(root, root.getRowType().getFieldCount());
       }
@@ -5752,7 +5751,7 @@ private static class AggregateFinder extends SqlBasicVisitor<Void> {
         final SqlNode aggCall = call.getOperandList().get(0);
         final SqlNodeList distinctList = (SqlNodeList) call.getOperandList().get(1);
         list.add(aggCall);
-        distinctList.getList().forEach(this.distinctList::add);
+        this.distinctList.addAll(distinctList.getList());
         return null;
       }
 
@@ -5960,7 +5959,7 @@ private class NestedJsonFunctionRelRewriter extends RelShuttleImpl {
     @Override public RelNode visit(LogicalProject project) {
       final Set<Integer> jsonInputFields = findJsonInputs(project.getInput());
       final Set<Integer> requiredJsonFieldsFromParent =
-          stack.size() > 0 ? requiredJsonOutputFromParent(stack.getLast()) : Collections.emptySet();
+          !stack.isEmpty() ? requiredJsonOutputFromParent(stack.getLast()) : ImmutableSet.of();
 
       final List<RexNode> originalProjections = project.getProjects();
       final ImmutableList.Builder<RexNode> newProjections = ImmutableList.builder();
@@ -5984,7 +5983,7 @@ private class NestedJsonFunctionRelRewriter extends RelShuttleImpl {
 
     private Set<Integer> requiredJsonOutputFromParent(RelNode relNode) {
       if (!(relNode instanceof Aggregate)) {
-        return Collections.emptySet();
+        return ImmutableSet.of();
       }
       final Aggregate aggregate = (Aggregate) relNode;
       final List<AggregateCall> aggregateCalls = aggregate.getAggCallList();
@@ -6001,7 +6000,7 @@ private Set<Integer> requiredJsonOutputFromParent(RelNode relNode) {
 
     private Set<Integer> findJsonInputs(RelNode relNode) {
       if (!(relNode instanceof Aggregate)) {
-        return Collections.emptySet();
+        return ImmutableSet.of();
       }
       final Aggregate aggregate = (Aggregate) relNode;
       final List<AggregateCall> aggregateCalls = aggregate.getAggCallList();
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java b/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
index 56fe1ae18..896c329c2 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
@@ -82,7 +82,6 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.initialization.qual.UnknownInitialization;
@@ -94,7 +93,6 @@
 import java.util.List;
 import java.util.Objects;
 import java.util.function.UnaryOperator;
-import java.util.stream.Collectors;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
@@ -103,6 +101,7 @@
 import static org.apache.calcite.util.Util.first;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /** Standard implementation of {@link SqlRexConvertletTable}. */
 public class StandardConvertletTable extends ReflectiveConvertletTable {
@@ -643,7 +642,7 @@ protected RexNode convertCast(
       validator.setValidatedNodeType(left, type);
       return cx.convertExpression(left);
     }
-    if (null != dataType.getCollectionsTypeName()) {
+    if (dataType.getCollectionsTypeName() != null) {
       RelDataType argComponentType = arg.getType().getComponentType();
 
       // arg.getType() may be ANY
@@ -682,7 +681,7 @@ protected RexNode convertFloorCeil(SqlRexContext cx, SqlCall call) {
       RexNode rexInterval = cx.convertExpression(literal);
 
       final RexBuilder rexBuilder = cx.getRexBuilder();
-      RexNode zero = rexBuilder.makeExactLiteral(BigDecimal.valueOf(0));
+      RexNode zero = rexBuilder.makeExactLiteral(BigDecimal.ZERO);
       RexNode cond = ge(rexBuilder, rexInterval, zero);
 
       RexNode pad = rexBuilder.makeExactLiteral(val.subtract(BigDecimal.ONE));
@@ -977,7 +976,7 @@ private static List<RexNode> convertOperands(
       operandList =
           call.getOperandList().stream()
               .filter(operand -> operand.getKind() != SqlKind.SET_SEMANTICS_TABLE)
-              .collect(Collectors.toList());
+              .collect(toList());
     } else {
       operandList = call.getOperandList();
     }
@@ -1661,7 +1660,7 @@ private static class SubstrConvertlet implements SqlRexConvertlet {
 
     SubstrConvertlet(SqlLibrary library) {
       this.library = library;
-      Preconditions.checkArgument(
+      checkArgument(
           library == SqlLibrary.ORACLE
               || library == SqlLibrary.MYSQL
               || library == SqlLibrary.BIG_QUERY
diff --git a/core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java b/core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java
index 4c35c6951..1a7ea04cc 100644
--- a/core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java
+++ b/core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java
@@ -21,14 +21,15 @@
 import org.apache.calcite.plan.RelOptTable;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 
 import java.util.Arrays;
 import java.util.List;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Implementation of {@link SqlStatisticProvider} that looks up values in a table.
@@ -135,14 +136,14 @@ public enum MapSqlStatisticProvider implements SqlStatisticProvider {
   private static List<String> columnNames(RelOptTable table, List<Integer> columns) {
     return columns.stream()
         .map(columnOrdinal -> table.getRowType().getFieldNames().get(columnOrdinal))
-        .collect(Collectors.toList());
+        .collect(toList());
   }
 
   /** Helper during construction. */
   private static class Initializer {
     final ImmutableMap.Builder<String, Double> cardinalityMapBuilder = ImmutableMap.builder();
     final ImmutableMultimap.Builder<String, ImmutableList<String>> keyMapBuilder =
-        ImmutableMultimap.builder();
+        ImmutableListMultimap.builder();
 
     Initializer put(String schema, String table, int count, Object... keys) {
       String qualifiedName = Arrays.asList(schema, table).toString();
diff --git a/core/src/main/java/org/apache/calcite/statistic/QuerySqlStatisticProvider.java b/core/src/main/java/org/apache/calcite/statistic/QuerySqlStatisticProvider.java
index d9fe5d0b3..e243d769f 100644
--- a/core/src/main/java/org/apache/calcite/statistic/QuerySqlStatisticProvider.java
+++ b/core/src/main/java/org/apache/calcite/statistic/QuerySqlStatisticProvider.java
@@ -41,10 +41,10 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
-import java.util.stream.Collectors;
 import javax.sql.DataSource;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /** Implementation of {@link SqlStatisticProvider} that generates and executes SQL queries. */
 public class QuerySqlStatisticProvider implements SqlStatisticProvider {
@@ -132,7 +132,7 @@ public QuerySqlStatisticProvider(Consumer<String> sqlConsumer) {
               .filter(
                   fromColumns.stream()
                       .map(column -> relBuilder.isNotNull(relBuilder.field(column)))
-                      .collect(Collectors.toList()))
+                      .collect(toList()))
               .project(relBuilder.fields(fromColumns))
               .push(toTable.toRel(toRelContext))
               .project(relBuilder.fields(toColumns))
diff --git a/core/src/main/java/org/apache/calcite/tools/Frameworks.java b/core/src/main/java/org/apache/calcite/tools/Frameworks.java
index 783442ef8..8bfc8a2a9 100644
--- a/core/src/main/java/org/apache/calcite/tools/Frameworks.java
+++ b/core/src/main/java/org/apache/calcite/tools/Frameworks.java
@@ -50,10 +50,11 @@
 
 import java.sql.Connection;
 import java.util.List;
-import java.util.Objects;
 import java.util.Properties;
 import java.util.function.Supplier;
 
+import static java.util.Objects.requireNonNull;
+
 /** Tools for invoking Calcite functionality without initializing a container / server first. */
 public class Frameworks {
 
@@ -289,22 +290,22 @@ public FrameworkConfig build() {
     }
 
     public ConfigBuilder context(Context c) {
-      this.context = Objects.requireNonNull(c, "c");
+      this.context = requireNonNull(c, "c");
       return this;
     }
 
     public ConfigBuilder executor(RexExecutor executor) {
-      this.executor = Objects.requireNonNull(executor, "executor");
+      this.executor = requireNonNull(executor, "executor");
       return this;
     }
 
     public ConfigBuilder convertletTable(SqlRexConvertletTable convertletTable) {
-      this.convertletTable = Objects.requireNonNull(convertletTable, "convertletTable");
+      this.convertletTable = requireNonNull(convertletTable, "convertletTable");
       return this;
     }
 
     public ConfigBuilder operatorTable(SqlOperatorTable operatorTable) {
-      this.operatorTable = Objects.requireNonNull(operatorTable, "operatorTable");
+      this.operatorTable = requireNonNull(operatorTable, "operatorTable");
       return this;
     }
 
@@ -323,18 +324,18 @@ public ConfigBuilder traitDefs(RelTraitDef... traitDefs) {
     }
 
     public ConfigBuilder parserConfig(SqlParser.Config parserConfig) {
-      this.parserConfig = Objects.requireNonNull(parserConfig, "parserConfig");
+      this.parserConfig = requireNonNull(parserConfig, "parserConfig");
       return this;
     }
 
     public ConfigBuilder sqlValidatorConfig(SqlValidator.Config sqlValidatorConfig) {
-      this.sqlValidatorConfig = Objects.requireNonNull(sqlValidatorConfig, "sqlValidatorConfig");
+      this.sqlValidatorConfig = requireNonNull(sqlValidatorConfig, "sqlValidatorConfig");
       return this;
     }
 
     public ConfigBuilder sqlToRelConverterConfig(SqlToRelConverter.Config sqlToRelConverterConfig) {
       this.sqlToRelConverterConfig =
-          Objects.requireNonNull(sqlToRelConverterConfig, "sqlToRelConverterConfig");
+          requireNonNull(sqlToRelConverterConfig, "sqlToRelConverterConfig");
       return this;
     }
 
@@ -353,7 +354,7 @@ public ConfigBuilder ruleSets(RuleSet... ruleSets) {
     }
 
     public ConfigBuilder ruleSets(List<RuleSet> ruleSets) {
-      return programs(Programs.listOf(Objects.requireNonNull(ruleSets, "ruleSets")));
+      return programs(Programs.listOf(requireNonNull(ruleSets, "ruleSets")));
     }
 
     public ConfigBuilder programs(List<Program> programs) {
@@ -367,7 +368,7 @@ public ConfigBuilder programs(Program... programs) {
     }
 
     public ConfigBuilder typeSystem(RelDataTypeSystem typeSystem) {
-      this.typeSystem = Objects.requireNonNull(typeSystem, "typeSystem");
+      this.typeSystem = requireNonNull(typeSystem, "typeSystem");
       return this;
     }
 
@@ -377,7 +378,7 @@ public ConfigBuilder evolveLattice(boolean evolveLattice) {
     }
 
     public ConfigBuilder statisticProvider(SqlStatisticProvider statisticProvider) {
-      this.statisticProvider = Objects.requireNonNull(statisticProvider, "statisticProvider");
+      this.statisticProvider = requireNonNull(statisticProvider, "statisticProvider");
       return this;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/tools/Hoist.java b/core/src/main/java/org/apache/calcite/tools/Hoist.java
index a94b41249..186ff043e 100644
--- a/core/src/main/java/org/apache/calcite/tools/Hoist.java
+++ b/core/src/main/java/org/apache/calcite/tools/Hoist.java
@@ -25,8 +25,6 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.sql.util.SqlShuttle;
 
-import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -35,9 +33,12 @@
 import java.sql.PreparedStatement;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 import java.util.function.Function;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Utility that extracts constants from a SQL query.
  *
@@ -78,7 +79,7 @@ public static Hoist create(Config config) {
   }
 
   private Hoist(Config config) {
-    this.config = Objects.requireNonNull(config, "config");
+    this.config = requireNonNull(config, "config");
   }
 
   /** Converts a {@link Variable} to a string "?N", where N is the {@link Variable#ordinal}. */
@@ -142,18 +143,18 @@ public static class Variable {
     public final int end;
 
     private Variable(String originalSql, int ordinal, SqlNode node) {
-      this.originalSql = Objects.requireNonNull(originalSql, "originalSql");
+      this.originalSql = requireNonNull(originalSql, "originalSql");
       this.ordinal = ordinal;
-      this.node = Objects.requireNonNull(node, "node");
+      this.node = requireNonNull(node, "node");
       final SqlParserPos pos = node.getParserPosition();
       start = SqlParserUtil.lineColToIndex(originalSql, pos.getLineNum(), pos.getColumnNum());
       end =
           SqlParserUtil.lineColToIndex(originalSql, pos.getEndLineNum(), pos.getEndColumnNum()) + 1;
 
-      Preconditions.checkArgument(ordinal >= 0);
-      Preconditions.checkArgument(start >= 0);
-      Preconditions.checkArgument(start <= end);
-      Preconditions.checkArgument(end <= originalSql.length());
+      checkArgument(ordinal >= 0);
+      checkArgument(start >= 0);
+      checkArgument(start <= end);
+      checkArgument(end <= originalSql.length());
     }
 
     /** Returns SQL text of the region of the statement covered by this Variable. */
@@ -169,7 +170,7 @@ public static class Hoisted {
 
     Hoisted(String originalSql, List<Variable> variables) {
       this.originalSql = originalSql;
-      this.variables = ImmutableList.copyOf(variables);
+      this.variables = variables;
     }
 
     @Override public String toString() {
diff --git a/core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java b/core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java
index 773f68cdf..76b03d448 100644
--- a/core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java
+++ b/core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java
@@ -35,6 +35,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Extension to {@link RelBuilder} for Pig relational operators. */
@@ -161,14 +163,10 @@ public PigRelBuilder group(
   }
 
   protected void validateGroupList(List<GroupKey> groupKeyList) {
-    if (groupKeyList.isEmpty()) {
-      throw new IllegalArgumentException("must have at least one group");
-    }
+    checkArgument(!groupKeyList.isEmpty(), "must have at least one group");
     final int groupCount = groupKeyList.get(0).groupKeyCount();
     for (GroupKey groupKey : groupKeyList) {
-      if (groupKey.groupKeyCount() != groupCount) {
-        throw new IllegalArgumentException("group key size mismatch");
-      }
+      checkArgument(groupKey.groupKeyCount() == groupCount, "group key size mismatch");
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/tools/RelBuilder.java b/core/src/main/java/org/apache/calcite/tools/RelBuilder.java
index dcaf658d6..e5af5d315 100644
--- a/core/src/main/java/org/apache/calcite/tools/RelBuilder.java
+++ b/core/src/main/java/org/apache/calcite/tools/RelBuilder.java
@@ -116,7 +116,6 @@
 import org.apache.calcite.util.mapping.Mapping;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -152,7 +151,8 @@
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.UnaryOperator;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.rel.rules.AggregateRemoveRule.canFlattenStatic;
@@ -160,6 +160,8 @@
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toList;
 
 /**
  * Builder for relational expressions.
@@ -198,7 +200,7 @@ protected RelBuilder(
     final RexExecutor executor =
         context
             .maybeUnwrap(RexExecutor.class)
-            .orElse(Util.first(cluster.getPlanner().getExecutor(), RexUtil.EXECUTOR));
+            .orElseGet(() -> Util.first(cluster.getPlanner().getExecutor(), RexUtil.EXECUTOR));
     final RelOptPredicateList predicates = RelOptPredicateList.EMPTY;
     this.simplifier = new RexSimplify(cluster.getRexBuilder(), predicates, executor);
   }
@@ -294,9 +296,7 @@ public <R> R let(Function<RelBuilder, R> consumer) {
    * RelNodes on the stack.
    */
   @Override public String toString() {
-    return stack.stream()
-        .map(frame -> RelOptUtil.toString(frame.rel))
-        .collect(Collectors.joining(""));
+    return stack.stream().map(frame -> RelOptUtil.toString(frame.rel)).collect(joining());
   }
 
   /** Returns the type factory. */
@@ -405,7 +405,7 @@ public RelNode peek(int n) {
   private Frame peek_(int n) {
     if (n == 0) {
       // more efficient than starting an iterator
-      return Objects.requireNonNull(stack.peek(), "stack.peek");
+      return requireNonNull(stack.peek(), "stack.peek");
     }
     return Iterables.get(stack, n);
   }
@@ -578,13 +578,11 @@ private RexNode field(int inputCount, int inputOrdinal, int fieldOrdinal, boolea
     final Frame frame = peek_(inputCount, inputOrdinal);
     final RelNode input = frame.rel;
     final RelDataType rowType = input.getRowType();
-    if (fieldOrdinal < 0 || fieldOrdinal > rowType.getFieldCount()) {
-      throw new IllegalArgumentException(
-          "field ordinal ["
-              + fieldOrdinal
-              + "] out of range; input fields are: "
-              + rowType.getFieldNames());
-    }
+    checkArgument(
+        fieldOrdinal >= 0 && fieldOrdinal <= rowType.getFieldCount(),
+        "field ordinal [%s] out of range; input fields are: %s",
+        fieldOrdinal,
+        rowType.getFieldNames());
     final RelDataTypeField field = rowType.getFieldList().get(fieldOrdinal);
     final int offset = inputOffset(inputCount, inputOrdinal);
     final RexInputRef ref =
@@ -1399,14 +1397,12 @@ public GroupKey groupKey(
       boolean indicator,
       @Nullable ImmutableList<ImmutableBitSet> groupSets) {
     Aggregate.checkIndicator(indicator);
-    return groupKey_(
-        groupSet, groupSets == null ? ImmutableList.of(groupSet) : ImmutableList.copyOf(groupSets));
+    return groupKey_(groupSet, groupSets == null ? ImmutableList.of(groupSet) : groupSets.asList());
   }
 
   private GroupKey groupKey_(ImmutableBitSet groupSet, ImmutableList<ImmutableBitSet> groupSets) {
-    if (groupSet.length() > peek().getRowType().getFieldCount()) {
-      throw new IllegalArgumentException("out of bounds: " + groupSet);
-    }
+    checkArgument(
+        groupSet.length() <= peek().getRowType().getFieldCount(), "out of bounds: %s", groupSet);
     requireNonNull(groupSets, "groupSets");
     final ImmutableList<RexNode> nodes = fields(groupSet);
     return groupKey_(nodes, Util.transform(groupSets, this::fields));
@@ -1887,9 +1883,7 @@ public RelBuilder snapshot(RexNode period) {
    * @return RexCall to CURSOR function
    */
   public RexNode cursor(int inputCount, int ordinal) {
-    if (inputCount <= ordinal || ordinal < 0) {
-      throw new IllegalArgumentException("bad input count or ordinal");
-    }
+    checkArgument(inputCount > ordinal && ordinal >= 0, "bad input count or ordinal");
     // Refer to the "ordinal"th input as if it were a field
     // (because that's how things are laid out inside a TableFunctionScan)
     final RelNode input = peek(inputCount, ordinal);
@@ -1905,9 +1899,7 @@ public RelBuilder functionScan(SqlOperator operator, int inputCount, RexNode...
   /** Creates a {@link TableFunctionScan}. */
   public RelBuilder functionScan(
       SqlOperator operator, int inputCount, Iterable<? extends RexNode> operands) {
-    if (inputCount < 0 || inputCount > stack.size()) {
-      throw new IllegalArgumentException("bad input count");
-    }
+    checkArgument(inputCount >= 0 && inputCount <= stack.size(), "bad input count");
 
     // Gets inputs.
     final List<RelNode> inputs = new ArrayList<>();
@@ -2086,13 +2078,11 @@ public RelBuilder projectExcept(Iterable<RexNode> expressions) {
     List<RexNode> allExpressions = new ArrayList<>(fields());
     Set<RexNode> excludeExpressions = new HashSet<>();
     for (RexNode excludeExp : expressions) {
-      if (!excludeExpressions.add(excludeExp)) {
-        throw new IllegalArgumentException(
-            "Input list contains duplicates. Expression " + excludeExp + " exists multiple times.");
-      }
-      if (!allExpressions.remove(excludeExp)) {
-        throw new IllegalArgumentException("Expression " + excludeExp.toString() + " not found.");
-      }
+      checkArgument(
+          excludeExpressions.add(excludeExp),
+          "Input list contains duplicates. Expression %s exists multiple times.",
+          excludeExp);
+      checkArgument(allExpressions.remove(excludeExp), "Expression %s not found.", excludeExp);
     }
     return this.project(allExpressions);
   }
@@ -2198,7 +2188,7 @@ private RelBuilder project_(
 
     // Simplify expressions.
     if (config.simplify()) {
-      nodeList.replaceAll(e -> simplifier.simplifyPreservingType(e));
+      nodeList.replaceAll(simplifier::simplifyPreservingType);
     }
 
     // Replace null names with generated aliases.
@@ -2261,7 +2251,7 @@ private RelBuilder project_(
     // N times.
     final int rowCount;
     if (config.simplifyValues()
-        && nodeList.stream().allMatch(e -> e instanceof RexLiteral)
+        && nodeList.stream().allMatch(RexLiteral.class::isInstance)
         && (rowCount = fixedRowCount(frame)) >= 0) {
       RelNode unused = build();
       final RelDataTypeFactory.Builder typeBuilder = getTypeFactory().builder();
@@ -2269,18 +2259,14 @@ private RelBuilder project_(
           fieldNameList,
           nodeList,
           (name, expr) -> typeBuilder.add(requireNonNull(name, "name"), expr.getType()));
-      @SuppressWarnings({"unchecked", "rawtypes"})
+      @SuppressWarnings({"rawtypes", "unchecked"})
       final List<RexLiteral> tuple = (List<RexLiteral>) (List) nodeList;
       return values(Collections.nCopies(rowCount, tuple), typeBuilder.build());
     }
 
     final RelNode project =
         struct.projectFactory.createProject(
-            frame.rel,
-            ImmutableList.copyOf(hints),
-            ImmutableList.copyOf(nodeList),
-            fieldNameList,
-            variables);
+            frame.rel, ImmutableList.copyOf(hints), nodeList, fieldNameList, variables);
     stack.pop();
     stack.push(new Frame(project, fields.build()));
     return this;
@@ -2343,7 +2329,7 @@ public RelBuilder projectNamed(
       @Nullable Iterable<? extends @Nullable String> fieldNames,
       boolean force,
       Iterable<CorrelationId> variablesSet) {
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     final List<? extends RexNode> nodeList =
         nodes instanceof List ? (List) nodes : ImmutableList.copyOf(nodes);
     final List<@Nullable String> fieldNameList =
@@ -2423,8 +2409,7 @@ public RelBuilder uncollect(List<String> itemAliases, boolean withOrdinality) {
    */
   public RelBuilder rename(List<? extends @Nullable String> fieldNames) {
     final List<String> oldFieldNames = peek().getRowType().getFieldNames();
-    Preconditions.checkArgument(
-        fieldNames.size() <= oldFieldNames.size(), "More names than fields");
+    checkArgument(fieldNames.size() <= oldFieldNames.size(), "More names than fields");
     final List<String> newFieldNames = new ArrayList<>(oldFieldNames);
     for (int i = 0; i < fieldNames.size(); i++) {
       final String s = fieldNames.get(i);
@@ -2484,7 +2469,7 @@ public RelBuilder distinct() {
   }
 
   /** Creates an {@link Aggregate} with an array of calls. */
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   public RelBuilder aggregate(GroupKey groupKey, AggCall... aggCalls) {
     return aggregate_((GroupKeyImpl) groupKey, (ImmutableList) ImmutableList.copyOf(aggCalls));
   }
@@ -2505,7 +2490,7 @@ public RelBuilder aggregate(GroupKey groupKey, List<AggregateCall> aggregateCall
   }
 
   /** Creates an {@link Aggregate} with multiple calls. */
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   public RelBuilder aggregate(GroupKey groupKey, Iterable<? extends AggCall> aggCalls) {
     return aggregate_(
         (GroupKeyImpl) groupKey, ImmutableList.<AggCallPlus>copyOf((Iterable) aggCalls));
@@ -2548,10 +2533,10 @@ private RelBuilder aggregate_(GroupKeyImpl groupKey, final ImmutableList<AggCall
       for (ImmutableList<RexNode> nodeList : groupKey.nodeLists) {
         final ImmutableBitSet groupSet2 =
             ImmutableBitSet.of(registrar.registerExpressions(nodeList));
-        if (!groupSet.contains(groupSet2)) {
-          throw new IllegalArgumentException(
-              "group set element " + nodeList + " must be a subset of group key");
-        }
+        checkArgument(
+            groupSet.contains(groupSet2),
+            "group set element %s must be a subset of group key",
+            nodeList);
         groupSetList.add(groupSet2);
       }
       final ImmutableSortedMultiset<ImmutableBitSet> groupSetMultiset =
@@ -2560,13 +2545,11 @@ private RelBuilder aggregate_(GroupKeyImpl groupKey, final ImmutableList<AggCall
           || !ImmutableBitSet.ORDERING.isStrictlyOrdered(groupSetMultiset)) {
         return rewriteAggregateWithDuplicateGroupSets(groupSet, groupSetMultiset, aggCalls);
       }
-      groupSets = ImmutableList.copyOf(groupSetMultiset.elementSet());
-      if (registrar.extraNodes.size() > sizeBefore) {
-        throw new IllegalArgumentException(
-            "group sets contained expressions "
-                + "not in group key: "
-                + Util.skip(registrar.extraNodes, sizeBefore));
-      }
+      groupSets = groupSetMultiset.elementSet().asList();
+      checkArgument(
+          registrar.extraNodes.size() <= sizeBefore,
+          "group sets contained expressions not in group key: %s",
+          Util.skip(registrar.extraNodes, sizeBefore));
     } else {
       groupSets = ImmutableList.of(groupSet);
     }
@@ -2874,7 +2857,7 @@ private RelBuilder setOp(boolean all, SqlKind kind, int n) {
 
     if (config.simplifyValues()
         && kind == UNION
-        && inputs.stream().allMatch(r -> r instanceof Values)) {
+        && inputs.stream().allMatch(Values.class::isInstance)) {
       List<RelDataType> inputTypes = Util.transform(inputs, RelNode::getRowType);
       RelDataType rowType = getTypeFactory().leastRestrictive(inputTypes);
       requireNonNull(rowType, () -> "leastRestrictive(" + inputTypes + ")");
@@ -3308,22 +3291,18 @@ public RelBuilder as(final String alias) {
    */
   public RelBuilder values(@Nullable String[] fieldNames, @Nullable Object... values) {
     requireNonNull(fieldNames, "fieldNames");
-    if (fieldNames.length == 0
-        || values.length % fieldNames.length != 0
-        || values.length < fieldNames.length) {
-      throw new IllegalArgumentException("Value count must be a positive multiple of field count");
-    }
+    checkArgument(
+        fieldNames.length != 0
+            && values.length % fieldNames.length == 0
+            && values.length >= fieldNames.length,
+        "Value count must be a positive multiple of field count");
     final int rowCount = values.length / fieldNames.length;
     for (Ord<@Nullable String> fieldName : Ord.zip(fieldNames)) {
-      if (allNull(values, fieldName.i, fieldNames.length)) {
-        throw new IllegalArgumentException(
-            "All values of field '"
-                + fieldName.e
-                + "' (field index "
-                + fieldName.i
-                + ")"
-                + " are null; cannot deduce type");
-      }
+      checkArgument(
+          !allNull(values, fieldName.i, fieldNames.length),
+          "All values of field '%s' (field index %s) are null; cannot deduce type",
+          fieldName.e,
+          fieldName.i);
     }
     final ImmutableList<ImmutableList<RexLiteral>> tupleList = tupleList(fieldNames.length, values);
     assert tupleList.size() == rowCount;
@@ -3414,8 +3393,7 @@ public RelBuilder empty() {
   public RelBuilder values(RelDataType rowType, Object... columnValues) {
     final ImmutableList<ImmutableList<RexLiteral>> tupleList =
         tupleList(rowType.getFieldCount(), columnValues);
-    RelNode values =
-        struct.valuesFactory.createValues(cluster, rowType, ImmutableList.copyOf(tupleList));
+    RelNode values = struct.valuesFactory.createValues(cluster, rowType, tupleList.asList());
     push(values);
     return this;
   }
@@ -3549,14 +3527,14 @@ public RelBuilder sortLimit(
       @Nullable RexNode fetchNode,
       Iterable<? extends RexNode> nodes) {
     if (offsetNode != null) {
-      if (!(offsetNode instanceof RexLiteral || offsetNode instanceof RexDynamicParam)) {
-        throw new IllegalArgumentException("OFFSET node must be RexLiteral or RexDynamicParam");
-      }
+      checkArgument(
+          (offsetNode instanceof RexLiteral || offsetNode instanceof RexDynamicParam),
+          "OFFSET node must be RexLiteral or RexDynamicParam");
     }
     if (fetchNode != null) {
-      if (!(fetchNode instanceof RexLiteral || fetchNode instanceof RexDynamicParam)) {
-        throw new IllegalArgumentException("FETCH node must be RexLiteral or RexDynamicParam");
-      }
+      checkArgument(
+          (fetchNode instanceof RexLiteral || fetchNode instanceof RexDynamicParam),
+          "FETCH node must be RexLiteral or RexDynamicParam");
     }
 
     final Registrar registrar = new Registrar(fields(), ImmutableList.of());
@@ -3857,10 +3835,11 @@ public RelBuilder pivot(
         values,
         (alias, expressions) -> {
           final List<RexNode> expressionList = ImmutableList.copyOf(expressions);
-          if (expressionList.size() != axisList.size()) {
-            throw new IllegalArgumentException(
-                "value count must match axis count [" + expressionList + "], [" + axisList + "]");
-          }
+          checkArgument(
+              expressionList.size() == axisList.size(),
+              "value count must match axis count [%s], [%s]",
+              expressionList,
+              axisList);
           aggCalls.forEach(
               aggCall -> {
                 final String alias2 = alias + "_" + ((AggCallPlus) aggCall).alias();
@@ -3946,22 +3925,16 @@ public RelBuilder unpivot(
     // Check that counts match.
     map.forEach(
         (valueList, inputMeasureList) -> {
-          if (inputMeasureList.size() != measureNameList.size()) {
-            throw new IllegalArgumentException(
-                "Number of measures ("
-                    + inputMeasureList.size()
-                    + ") must match number of measure names ("
-                    + measureNameList.size()
-                    + ")");
-          }
-          if (valueList.size() != axisNameList.size()) {
-            throw new IllegalArgumentException(
-                "Number of axis values ("
-                    + valueList.size()
-                    + ") match match number of axis names ("
-                    + axisNameList.size()
-                    + ")");
-          }
+          checkArgument(
+              inputMeasureList.size() == measureNameList.size(),
+              "Number of measures (%s) must match number of measure names (%s)",
+              inputMeasureList.size(),
+              measureNameList.size());
+          checkArgument(
+              valueList.size() == axisNameList.size(),
+              "Number of axis values (%s) match match number of axis names (%s)",
+              valueList.size(),
+              axisNameList.size());
         });
 
     final RelDataType leftRowType = peek().getRowType();
@@ -3976,7 +3949,7 @@ public RelBuilder unpivot(
                 }));
 
     // Create "VALUES (('commission'), ('salary')) AS t (remuneration_type)"
-    values(ImmutableList.copyOf(map.leftList()), axisNameList);
+    values(map.leftList(), axisNameList);
 
     join(JoinRelType.INNER);
 
@@ -4253,10 +4226,10 @@ private boolean checkIfCorrelated(
       return true;
     }
     CorrelationId id = Iterables.getOnlyElement(variablesSet);
-    if (!RelOptUtil.notContainsCorrelation(leftNode, id, Litmus.IGNORE)) {
-      throw new IllegalArgumentException(
-          "variable " + id + " must not be used by left input to correlation");
-    }
+    checkArgument(
+        RelOptUtil.notContainsCorrelation(leftNode, id, Litmus.IGNORE),
+        "variable %s must not be used by left input to correlation",
+        id);
     switch (joinType) {
       case RIGHT:
       case FULL:
@@ -4319,15 +4292,15 @@ private class AggCallImpl implements AggCallPlus {
       if (distinct) {
         b.append("DISTINCT ");
       }
-      if (preOperands.size() > 0) {
+      if (!preOperands.isEmpty()) {
         b.append(preOperands.get(0));
         for (int i = 1; i < preOperands.size(); i++) {
           b.append(", ");
           b.append(preOperands.get(i));
         }
-        b.append(operands.size() > 0 ? "; " : ";");
+        b.append(!operands.isEmpty() ? "; " : ";");
       }
-      if (operands.size() > 0) {
+      if (!operands.isEmpty()) {
         b.append(operands.get(0));
         for (int i = 1; i < operands.size(); i++) {
           b.append(", ");
@@ -4375,12 +4348,9 @@ private class AggCallImpl implements AggCallPlus {
     @Override public AggregateCall aggregateCall(Registrar registrar, ImmutableBitSet groupSet, RelNode r) {
       List<Integer> args = registrar.registerExpressions(this.operands);
       final int filterArg = this.filter == null ? -1 : registrar.registerExpression(this.filter);
-      if (this.distinct && !this.aggFunction.isQuantifierAllowed()) {
-        throw new IllegalArgumentException("DISTINCT not allowed");
-      }
-      if (this.filter != null && !this.aggFunction.allowsFilter()) {
-        throw new IllegalArgumentException("FILTER not allowed");
-      }
+      checkArgument(
+          !this.distinct || this.aggFunction.isQuantifierAllowed(), "DISTINCT not allowed");
+      checkArgument(this.filter == null || this.aggFunction.allowsFilter(), "FILTER not allowed");
       final @Nullable ImmutableBitSet distinctKeys =
           this.distinctKeys == null
               ? null
@@ -4394,8 +4364,8 @@ private class AggCallImpl implements AggCallPlus {
                               orderKey,
                               RelFieldCollation.Direction.ASCENDING,
                               null,
-                              Collections.emptyList()))
-                  .collect(Collectors.toList()));
+                              ImmutableList.of()))
+                  .collect(toList()));
       if (aggFunction instanceof SqlCountAggFunction && !distinct) {
         args = args.stream().filter(r::fieldIsNullable).collect(Util.toImmutableList());
       }
@@ -5064,7 +5034,7 @@ List<RelFieldCollation> registerFieldCollations(Iterable<? extends RexNode> orde
           fieldCollations.add(collation);
         }
       }
-      return ImmutableList.copyOf(fieldCollations);
+      return fieldCollations;
     }
 
     /** Returns the number of fields added. */
diff --git a/core/src/main/java/org/apache/calcite/util/BarfingInvocationHandler.java b/core/src/main/java/org/apache/calcite/util/BarfingInvocationHandler.java
index 11242c824..1ccb3161d 100644
--- a/core/src/main/java/org/apache/calcite/util/BarfingInvocationHandler.java
+++ b/core/src/main/java/org/apache/calcite/util/BarfingInvocationHandler.java
@@ -81,7 +81,7 @@ protected UnsupportedOperationException noMethod(Method method) {
             + "."
             + method.getName()
             + "("
-            + buf.toString()
+            + buf
             + ")";
     return new UnsupportedOperationException(signature);
   }
diff --git a/core/src/main/java/org/apache/calcite/util/Benchmark.java b/core/src/main/java/org/apache/calcite/util/Benchmark.java
index 0f6a47add..2814aef72 100644
--- a/core/src/main/java/org/apache/calcite/util/Benchmark.java
+++ b/core/src/main/java/org/apache/calcite/util/Benchmark.java
@@ -104,7 +104,7 @@ private void printDurations() {
         y += x * x;
       }
       final double stddev = Math.sqrt(y / count);
-      if (durations.size() == 0) {
+      if (durations.isEmpty()) {
         LOGGER.debug("{}: {}", desc, "no runs");
       } else {
         LOGGER.debug(
diff --git a/core/src/main/java/org/apache/calcite/util/BitString.java b/core/src/main/java/org/apache/calcite/util/BitString.java
index 02690e8d6..fa1054864 100644
--- a/core/src/main/java/org/apache/calcite/util/BitString.java
+++ b/core/src/main/java/org/apache/calcite/util/BitString.java
@@ -20,7 +20,8 @@
 
 import java.math.BigInteger;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * String of bits.
@@ -45,7 +46,7 @@ public class BitString {
   // ~ Constructors -----------------------------------------------------------
 
   protected BitString(String bits, int bitCount) {
-    assert bits.replace("1", "").replace("0", "").length() == 0
+    assert bits.replace("1", "").replace("0", "").isEmpty()
         : "bit string '" + bits + "' contains digits other than {0, 1}";
     this.bits = bits;
     this.bitCount = bitCount;
@@ -141,7 +142,7 @@ public static byte[] toByteArrayFromBitString(String bits, int bitCount) {
     }
     int byteCount = (bitCount + 7) / 8;
     byte[] srcBytes;
-    if (bits.length() > 0) {
+    if (!bits.isEmpty()) {
       BigInteger bigInt = new BigInteger(bits, 2);
       srcBytes = bigInt.toByteArray();
     } else {
@@ -185,7 +186,7 @@ public static BitString concat(List<BitString> args) {
    * @return BitString
    */
   public static BitString createFromBytes(byte[] bytes) {
-    int bitCount = Objects.requireNonNull(bytes, "bytes").length * 8;
+    int bitCount = requireNonNull(bytes, "bytes").length * 8;
     StringBuilder sb = new StringBuilder(bitCount);
     for (byte b : bytes) {
       final String s = Integer.toBinaryString(Byte.toUnsignedInt(b));
diff --git a/core/src/main/java/org/apache/calcite/util/BlackholeMap.java b/core/src/main/java/org/apache/calcite/util/BlackholeMap.java
index e1c60ab16..de526d462 100644
--- a/core/src/main/java/org/apache/calcite/util/BlackholeMap.java
+++ b/core/src/main/java/org/apache/calcite/util/BlackholeMap.java
@@ -92,13 +92,13 @@ public static <T> Set<T> of() {
 
   private BlackholeMap() {}
 
-  @SuppressWarnings("contracts.postcondition.not.satisfied")
-  @Override public @Nullable V put(K key, V value) {
+  @Override @SuppressWarnings("contracts.postcondition.not.satisfied")
+  public @Nullable V put(K key, V value) {
     return null;
   }
 
-  @SuppressWarnings("override.return.invalid")
-  @Override public Set<Entry<K, V>> entrySet() {
+  @Override @SuppressWarnings("override.return.invalid")
+  public Set<Entry<K, V>> entrySet() {
     return BHSet.of();
   }
 
diff --git a/core/src/main/java/org/apache/calcite/util/CancelFlag.java b/core/src/main/java/org/apache/calcite/util/CancelFlag.java
index b010283e0..2f5a99e69 100644
--- a/core/src/main/java/org/apache/calcite/util/CancelFlag.java
+++ b/core/src/main/java/org/apache/calcite/util/CancelFlag.java
@@ -19,9 +19,10 @@
 import org.apache.calcite.plan.Context;
 import org.apache.calcite.plan.RelOptPlanner;
 
-import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * CancelFlag is used to post and check cancellation requests.
  *
@@ -34,7 +35,7 @@ public class CancelFlag {
   public final AtomicBoolean atomicBoolean;
 
   public CancelFlag(AtomicBoolean atomicBoolean) {
-    this.atomicBoolean = Objects.requireNonNull(atomicBoolean, "atomicBoolean");
+    this.atomicBoolean = requireNonNull(atomicBoolean, "atomicBoolean");
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/util/ChunkList.java b/core/src/main/java/org/apache/calcite/util/ChunkList.java
index 407b47aa1..60a16aab2 100644
--- a/core/src/main/java/org/apache/calcite/util/ChunkList.java
+++ b/core/src/main/java/org/apache/calcite/util/ChunkList.java
@@ -25,6 +25,9 @@
 import java.util.ListIterator;
 import java.util.NoSuchElementException;
 
+import static com.google.common.base.Preconditions.checkPositionIndex;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -183,9 +186,7 @@ private static <E> void setElement(E[] chunk, int index, @Nullable E element) {
   }
 
   private ChunkListIterator locate(int index) {
-    if (index < 0 || index > size) {
-      throw new IndexOutOfBoundsException();
-    }
+    checkPositionIndex(index, size);
     if (first == null) {
       // Create an iterator positioned before the first element.
       return new ChunkListIterator(null, 0, 0, -1, 0);
@@ -285,9 +286,7 @@ private E[] currentChunk() {
     }
 
     @Override public void remove() {
-      if (lastRet < 0) {
-        throw new IllegalStateException();
-      }
+      checkState(lastRet >= 0);
       --size;
       --cursor;
       if (end == start + 1) {
@@ -364,9 +363,7 @@ private E[] currentChunk() {
     }
 
     @Override public void set(E e) {
-      if (lastRet < 0) {
-        throw new IllegalStateException();
-      }
+      checkState(lastRet >= 0);
       E[] c = currentChunk();
       int p = lastRet;
       int s = start;
diff --git a/core/src/main/java/org/apache/calcite/util/CompositeMap.java b/core/src/main/java/org/apache/calcite/util/CompositeMap.java
index 0239e77f8..ce73e7100 100644
--- a/core/src/main/java/org/apache/calcite/util/CompositeMap.java
+++ b/core/src/main/java/org/apache/calcite/util/CompositeMap.java
@@ -58,7 +58,7 @@ private static <E> ImmutableList<E> list(E e, E[] es) {
   }
 
   @Override public int size() {
-    return keySet().size();
+    return this.size();
   }
 
   @Override public boolean isEmpty() {
@@ -71,8 +71,8 @@ private static <E> ImmutableList<E> list(E e, E[] es) {
     return true;
   }
 
-  @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
-  @Override public boolean containsKey(@Nullable Object key) {
+  @Override @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
+  public boolean containsKey(@Nullable Object key) {
     for (Map<K, V> map : maps) {
       if (map.containsKey(key)) {
         return true;
@@ -120,8 +120,8 @@ private static <E> ImmutableList<E> list(E e, E[] es) {
     throw new UnsupportedOperationException();
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public Set<@KeyFor("this") K> keySet() {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public Set<@KeyFor("this") K> keySet() {
     final Set<K> keys = new LinkedHashSet<>();
     for (Map<K, V> map : maps) {
       keys.addAll(map.keySet());
@@ -146,8 +146,8 @@ private Map<K, V> combinedMap() {
     return combinedMap().values();
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public Set<Entry<@KeyFor("this") K, V>> entrySet() {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public Set<Entry<@KeyFor("this") K, V>> entrySet() {
     return combinedMap().entrySet();
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/util/DateString.java b/core/src/main/java/org/apache/calcite/util/DateString.java
index 39dd57d3b..e6be3a738 100644
--- a/core/src/main/java/org/apache/calcite/util/DateString.java
+++ b/core/src/main/java/org/apache/calcite/util/DateString.java
@@ -21,13 +21,14 @@
 import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonIgnore;
 import com.fasterxml.jackson.annotation.JsonProperty;
-import com.google.common.base.Preconditions;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Calendar;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Date literal.
  *
@@ -48,12 +49,10 @@ private DateString(String v, @SuppressWarnings("unused") boolean ignore) {
   @SuppressWarnings("method.invocation.invalid")
   public DateString(String v) {
     this(v, false);
-    Preconditions.checkArgument(PATTERN.matcher(v).matches(), "Invalid date format:", v);
-    Preconditions.checkArgument(
-        getYear() >= 1 && getYear() <= 9999, "Year out of range:", getYear());
-    Preconditions.checkArgument(
-        getMonth() >= 1 && getMonth() <= 12, "Month out of range:", getMonth());
-    Preconditions.checkArgument(getDay() >= 1 && getDay() <= 31, "Day out of range:", getDay());
+    checkArgument(PATTERN.matcher(v).matches(), "Invalid date format:", v);
+    checkArgument(getYear() >= 1 && getYear() <= 9999, "Year out of range:", getYear());
+    checkArgument(getMonth() >= 1 && getMonth() <= 12, "Month out of range:", getMonth());
+    checkArgument(getDay() >= 1 && getDay() <= 31, "Day out of range:", getDay());
   }
 
   /** Creates a DateString for year, month, day values. */
@@ -63,9 +62,9 @@ public DateString(int year, int month, int day) {
 
   /** Validates a year-month-date and converts to a string. */
   private static String ymd(int year, int month, int day) {
-    Preconditions.checkArgument(year >= 1 && year <= 9999, "Year out of range:", year);
-    Preconditions.checkArgument(month >= 1 && month <= 12, "Month out of range:", month);
-    Preconditions.checkArgument(day >= 1 && day <= 31, "Day out of range:", day);
+    checkArgument(year >= 1 && year <= 9999, "Year out of range:", year);
+    checkArgument(month >= 1 && month <= 12, "Month out of range:", month);
+    checkArgument(day >= 1 && day <= 31, "Day out of range:", day);
     final StringBuilder b = new StringBuilder();
     DateTimeStringUtils.ymd(b, year, month, day);
     return b.toString();
diff --git a/core/src/main/java/org/apache/calcite/util/EquivalenceSet.java b/core/src/main/java/org/apache/calcite/util/EquivalenceSet.java
index 2a35eaafb..2dad2d02c 100644
--- a/core/src/main/java/org/apache/calcite/util/EquivalenceSet.java
+++ b/core/src/main/java/org/apache/calcite/util/EquivalenceSet.java
@@ -28,6 +28,8 @@
 import java.util.Objects;
 import java.util.SortedSet;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Set of elements organized into equivalence classes.
  *
@@ -56,7 +58,7 @@ public class EquivalenceSet<E extends Comparable<E>> {
    * the element's parent.
    */
   public E add(E e) {
-    final E parent = parents.get(Objects.requireNonNull(e, "e"));
+    final E parent = parents.get(requireNonNull(e, "e"));
     if (parent == null) {
       // Element is new. Add it to the map, as its own parent.
       parents.put(e, e);
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java b/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
index 68d94dd5e..b27409636 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
@@ -49,6 +49,8 @@
 import java.util.function.IntPredicate;
 import java.util.stream.Collector;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -234,12 +236,8 @@ public static ImmutableBitSet fromBitSet(BitSet input) {
    * @return Bit set
    */
   public static ImmutableBitSet range(int fromIndex, int toIndex) {
-    if (fromIndex > toIndex) {
-      throw new IllegalArgumentException();
-    }
-    if (toIndex < 0) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(fromIndex <= toIndex);
+    checkArgument(toIndex >= 0);
     if (fromIndex == toIndex) {
       return EMPTY;
     }
@@ -889,9 +887,7 @@ public ImmutableBitSet permute(Map<Integer, Integer> map) {
     final Builder builder = builder();
     for (int i = nextSetBit(0); i >= 0; i = nextSetBit(i + 1)) {
       Integer value = map.get(i);
-      if (value == null) {
-        throw new NullPointerException("Index " + i + " is not mapped in " + map);
-      }
+      requireNonNull(value, "Index " + i + " is not mapped in " + map);
       builder.set(value);
     }
     return builder.build();
@@ -1014,9 +1010,7 @@ private Builder(long[] words) {
      * <p>After calling this method, the Builder cannot be used again.
      */
     public ImmutableBitSet build() {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       if (words.length == 0) {
         return EMPTY;
       }
@@ -1031,9 +1025,7 @@ public ImmutableBitSet build() {
      * <p>After calling this method, the Builder may be used again.
      */
     public ImmutableBitSet buildAndReset() {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       if (words.length == 0) {
         return EMPTY;
       }
@@ -1069,9 +1061,7 @@ public ImmutableBitSet build(ImmutableBitSet bitSet) {
     }
 
     public Builder set(int bit) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       int wordIndex = wordIndex(bit);
       if (wordIndex >= words.length) {
         words = Arrays.copyOf(words, wordIndex + 1);
@@ -1081,9 +1071,7 @@ public Builder set(int bit) {
     }
 
     public boolean get(int bitIndex) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       if (bitIndex < 0) {
         throw new IndexOutOfBoundsException("bitIndex < 0: " + bitIndex);
       }
@@ -1092,9 +1080,7 @@ public boolean get(int bitIndex) {
     }
 
     private void trim(int wordCount) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       while (wordCount > 0 && words[wordCount - 1] == 0L) {
         --wordCount;
       }
@@ -1109,9 +1095,7 @@ private void trim(int wordCount) {
     }
 
     public Builder clear(int bit) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       int wordIndex = wordIndex(bit);
       if (wordIndex < words.length) {
         words[wordIndex] &= ~(1L << bit);
@@ -1125,29 +1109,21 @@ public Builder clear(int bit) {
      * set.
      */
     public boolean wouldEqual(ImmutableBitSet bitSet) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       return Arrays.equals(words, bitSet.words);
     }
 
     /** Returns the number of set bits. */
     public int cardinality() {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       return countBits(words);
     }
 
     /** Merges another builder. Does not modify the other builder. */
     public Builder combine(Builder builder) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       long[] otherWords = builder.words;
-      if (otherWords == null) {
-        throw new IllegalArgumentException("Given builder is empty");
-      }
+      checkArgument(otherWords != null, "Given builder is empty");
       if (this.words.length < otherWords.length) {
         // Right has more bits. Copy the right and OR in the words of the
         // previous left.
@@ -1191,16 +1167,9 @@ public Builder removeAll(ImmutableBitSet bitSet) {
 
     /** Sets a range of bits, from {@code from} to {@code to} - 1. */
     public Builder set(int fromIndex, int toIndex) {
-      if (fromIndex > toIndex) {
-        throw new IllegalArgumentException(
-            "fromIndex(" + fromIndex + ")" + " > toIndex(" + toIndex + ")");
-      }
-      if (toIndex < 0) {
-        throw new IllegalArgumentException("toIndex(" + toIndex + ") < 0");
-      }
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(fromIndex <= toIndex, "fromIndex(%s) > toIndex(%s)", fromIndex, toIndex);
+      checkArgument(toIndex >= 0, "toIndex(%s) < 0", toIndex);
+      checkArgument(words != null, "can only use builder once");
       if (fromIndex < toIndex) {
         // Increase capacity if necessary
         int startWordIndex = wordIndex(fromIndex);
@@ -1227,16 +1196,12 @@ public Builder set(int fromIndex, int toIndex) {
     }
 
     public boolean isEmpty() {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       return words.length == 0;
     }
 
     public void intersect(ImmutableBitSet that) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       int x = Math.min(words.length, that.words.length);
       for (int i = 0; i < x; i++) {
         words[i] &= that.words[i];
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableIntList.java b/core/src/main/java/org/apache/calcite/util/ImmutableIntList.java
index 7b70661e2..cd75f2c99 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableIntList.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableIntList.java
@@ -20,7 +20,6 @@
 import org.apache.calcite.runtime.FlatLists;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.UnmodifiableListIterator;
@@ -39,6 +38,8 @@
 import java.util.function.Consumer;
 import java.util.function.IntConsumer;
 
+import static com.google.common.base.Preconditions.checkPositionIndex;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -104,8 +105,8 @@ private static ImmutableIntList copyFromCollection(Collection<? extends Number>
     return Arrays.hashCode(ints);
   }
 
-  @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
-  @Override public boolean equals(@Nullable Object obj) {
+  @Override @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
+  public boolean equals(@Nullable Object obj) {
     return ((this == obj) || (obj instanceof ImmutableIntList))
         ? Arrays.equals(ints, ((ImmutableIntList) obj).ints)
         : ((obj instanceof List) && obj.equals(this));
@@ -307,13 +308,13 @@ private static class EmptyImmutableIntList extends ImmutableIntList {
       return a;
     }
 
-    @SuppressWarnings("ImmutableListOf")
-    @Override public Iterator<Integer> iterator() {
+    @Override @SuppressWarnings("ImmutableListOf")
+    public Iterator<Integer> iterator() {
       return Collections.<Integer>emptyList().iterator();
     }
 
-    @SuppressWarnings("ImmutableListOf")
-    @Override public ListIterator<Integer> listIterator() {
+    @Override @SuppressWarnings("ImmutableListOf")
+    public ListIterator<Integer> listIterator() {
       return Collections.<Integer>emptyList().listIterator();
     }
   }
@@ -330,7 +331,7 @@ private abstract static class AbstractIndexedListIterator<E> extends Unmodifiabl
     protected abstract E get(int index);
 
     protected AbstractIndexedListIterator(int size, int position) {
-      Preconditions.checkPositionIndex(position, size);
+      checkPositionIndex(position, size);
       this.size = size;
       this.position = position;
     }
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java b/core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java
index 20070c88c..8410e751d 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java
@@ -25,10 +25,11 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
+import static java.util.Collections.EMPTY_LIST;
+
 /**
  * An immutable list that may contain null values.
  *
@@ -37,7 +38,7 @@
  * @param <E> Element type
  */
 public class ImmutableNullableList<E> extends AbstractList<E> {
-  private static final List SINGLETON_NULL = Collections.singletonList(null);
+  private static final List SINGLETON_NULL = ImmutableList.of(null);
 
   private final E[] elements;
 
@@ -59,7 +60,7 @@ public static <E> List<E> copyOf(Collection<? extends E> elements) {
       //noinspection unchecked
       return (List<E>) elements;
     }
-    if (elements == Collections.EMPTY_LIST) {
+    if (elements == EMPTY_LIST) {
       return ImmutableList.of();
     }
     // If there are no nulls, ImmutableList is better.
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java b/core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java
index 006b16c8f..bfd439a74 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java
@@ -20,13 +20,16 @@
 import com.google.common.collect.ImmutableSortedMap;
 
 import java.util.AbstractMap;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.SortedMap;
 import java.util.TreeMap;
 
+import static java.util.Collections.emptyNavigableMap;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Collections.unmodifiableNavigableMap;
+
 /**
  * An immutable map that may contain null values.
  *
@@ -37,7 +40,7 @@
  */
 public abstract class ImmutableNullableMap<K, V> extends AbstractMap<K, V> {
 
-  private static final Map<Integer, Integer> SINGLETON_MAP = Collections.singletonMap(0, 0);
+  private static final Map<Integer, Integer> SINGLETON_MAP = ImmutableMap.of(0, 0);
 
   private ImmutableNullableMap() {}
 
@@ -46,12 +49,12 @@ private ImmutableNullableMap() {}
    *
    * <p>Behavior is as {@link ImmutableMap#copyOf(Iterable)} except that this map allows nulls.
    */
-  @SuppressWarnings({"JdkObsolete", "unchecked", "rawtypes"})
+  @SuppressWarnings({"JdkObsolete", "rawtypes", "unchecked"})
   public static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
     if (map instanceof ImmutableNullableMap
         || map instanceof ImmutableMap
-        || map == Collections.emptyMap()
-        || map == Collections.emptyNavigableMap()
+        || map == ImmutableMap.of()
+        || map == emptyNavigableMap()
         || map.getClass() == SINGLETON_MAP.getClass()) {
       return (Map<K, V>) map;
     }
@@ -69,7 +72,7 @@ public static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
         // and wrapping it to prevent modification. Unfortunately, if we see
         // it again we will not recognize that it is immutable and we will make
         // another copy.
-        return Collections.unmodifiableNavigableMap(new TreeMap<>(sortedMap));
+        return unmodifiableNavigableMap(new TreeMap<>(sortedMap));
       }
     } else {
       try {
@@ -79,7 +82,7 @@ public static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
         // and wrapping it to prevent modification. Unfortunately, if we see
         // it again we will not recognize that it is immutable and we will make
         // another copy.
-        return Collections.unmodifiableMap(new HashMap<>(map));
+        return unmodifiableMap(new HashMap<>(map));
       }
     }
   }
@@ -89,12 +92,12 @@ public static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
    *
    * <p>Behavior is as {@link ImmutableSortedMap#copyOf(Map)} except that this map allows nulls.
    */
-  @SuppressWarnings({"JdkObsolete", "unchecked", "rawtypes"})
+  @SuppressWarnings({"JdkObsolete", "rawtypes", "unchecked"})
   public static <K, V> Map<K, V> copyOf(SortedMap<? extends K, ? extends V> map) {
     if (map instanceof ImmutableNullableMap
         || map instanceof ImmutableMap
-        || map == Collections.emptyMap()
-        || map == Collections.emptyNavigableMap()) {
+        || map == ImmutableMap.of()
+        || map == emptyNavigableMap()) {
       return (Map<K, V>) map;
     }
     final SortedMap<K, V> sortedMap = (SortedMap) map;
@@ -110,7 +113,7 @@ public static <K, V> Map<K, V> copyOf(SortedMap<? extends K, ? extends V> map) {
       // and wrapping it to prevent modification. Unfortunately, if we see
       // it again we will not recognize that it is immutable and we will make
       // another copy.
-      return Collections.unmodifiableNavigableMap(new TreeMap<>(sortedMap));
+      return unmodifiableNavigableMap(new TreeMap<>(sortedMap));
     }
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java b/core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java
index 716e56e79..34d6454e9 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java
@@ -30,14 +30,15 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Objects;
 import java.util.Set;
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Collections.emptySortedSet;
+import static java.util.Objects.requireNonNull;
+
 /**
  * An immutable set that may contain null values.
  *
@@ -52,12 +53,12 @@ public class ImmutableNullableSet<E> extends AbstractSet<E> {
   private static final Set SINGLETON_NULL =
       new ImmutableNullableSet(ImmutableSet.of(NullSentinel.INSTANCE));
 
-  private static final Set<Integer> SINGLETON = Collections.singleton(0);
+  private static final Set<Integer> SINGLETON = ImmutableSet.of(0);
 
   private final ImmutableSet<Object> elements;
 
   private ImmutableNullableSet(ImmutableSet<Object> elements) {
-    this.elements = Objects.requireNonNull(elements, "elements");
+    this.elements = requireNonNull(elements, "elements");
   }
 
   @Override public Iterator<E> iterator() {
@@ -86,12 +87,12 @@ private ImmutableNullableSet(ImmutableSet<Object> elements) {
    *
    * <p>Behavior is as {@link ImmutableSet#copyOf(Iterable)} except that this set allows nulls.
    */
-  @SuppressWarnings({"unchecked", "StaticPseudoFunctionalStyleMethod"})
+  @SuppressWarnings({"StaticPseudoFunctionalStyleMethod", "unchecked"})
   public static <E> Set<E> copyOf(Iterable<? extends E> elements) {
     if (elements instanceof ImmutableNullableSet
         || elements instanceof ImmutableSet
-        || elements == Collections.emptySet()
-        || elements == Collections.emptySortedSet()
+        || elements == ImmutableSet.of()
+        || elements == emptySortedSet()
         || elements == SINGLETON_NULL
         || elements.getClass() == SINGLETON.getClass()) {
       return (Set<E>) elements;
@@ -143,7 +144,7 @@ private static <E> Set<E> copyOf(E[] elements, boolean needCopy) {
         objects[i] = NullSentinel.INSTANCE;
       }
     }
-    @SuppressWarnings({"nullness", "NullableProblems"})
+    @SuppressWarnings({"NullableProblems", "nullness"})
     @NonNull
     Object[] nonNullObjects = objects;
     return new ImmutableNullableSet<E>(ImmutableSet.copyOf(nonNullObjects));
diff --git a/core/src/main/java/org/apache/calcite/util/IntegerIntervalSet.java b/core/src/main/java/org/apache/calcite/util/IntegerIntervalSet.java
index 8ae1f14d3..b5deaf400 100644
--- a/core/src/main/java/org/apache/calcite/util/IntegerIntervalSet.java
+++ b/core/src/main/java/org/apache/calcite/util/IntegerIntervalSet.java
@@ -71,8 +71,8 @@ public static Set<Integer> of(String s) {
     return new IntegerIntervalSet(s);
   }
 
-  @SuppressWarnings("NullableProblems")
-  @Override public Iterator<Integer> iterator() {
+  @Override @SuppressWarnings("NullableProblems")
+  public Iterator<Integer> iterator() {
     return Linq4j.enumeratorIterator(enumerator());
   }
 
diff --git a/core/src/main/java/org/apache/calcite/util/JdbcTypeImpl.java b/core/src/main/java/org/apache/calcite/util/JdbcTypeImpl.java
index 44f3256db..f43faa12d 100644
--- a/core/src/main/java/org/apache/calcite/util/JdbcTypeImpl.java
+++ b/core/src/main/java/org/apache/calcite/util/JdbcTypeImpl.java
@@ -16,14 +16,14 @@
  */
 package org.apache.calcite.util;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.math.BigDecimal;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -49,7 +49,7 @@ enum JdbcTypeImpl implements JdbcType {
   BOOLEAN(Boolean.class, false) {
     @Override public Boolean get(int column, ResultSet resultSet) throws SQLException {
       boolean v = resultSet.getBoolean(column);
-      Preconditions.checkArgument(v || !resultSet.wasNull());
+      checkArgument(v || !resultSet.wasNull());
       return v;
     }
   },
@@ -64,7 +64,7 @@ enum JdbcTypeImpl implements JdbcType {
   DOUBLE(Double.class, false) {
     @Override public Double get(int column, ResultSet resultSet) throws SQLException {
       double v = resultSet.getDouble(column);
-      Preconditions.checkArgument(v != 0 || !resultSet.wasNull());
+      checkArgument(v != 0 || !resultSet.wasNull());
       return v;
     }
   },
@@ -79,7 +79,7 @@ enum JdbcTypeImpl implements JdbcType {
   INTEGER(Integer.class, false) {
     @Override public Integer get(int column, ResultSet resultSet) throws SQLException {
       int v = resultSet.getInt(column);
-      Preconditions.checkArgument(v != 0 || !resultSet.wasNull());
+      checkArgument(v != 0 || !resultSet.wasNull());
       return v;
     }
   },
diff --git a/core/src/main/java/org/apache/calcite/util/MonotonicSupplier.java b/core/src/main/java/org/apache/calcite/util/MonotonicSupplier.java
index fabfea6d3..a5c87229e 100644
--- a/core/src/main/java/org/apache/calcite/util/MonotonicSupplier.java
+++ b/core/src/main/java/org/apache/calcite/util/MonotonicSupplier.java
@@ -21,6 +21,8 @@
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -40,16 +42,12 @@ public class MonotonicSupplier<E> implements Consumer<E>, Supplier<E> {
    * <p>Sets the value once and for all.
    */
   @Override public void accept(E e) {
-    if (this.e != null) {
-      throw new IllegalArgumentException("accept has been called already");
-    }
+    checkArgument(this.e == null, "accept has been called already");
     this.e = requireNonNull(e, "element must not be null");
   }
 
   @Override public E get() {
-    if (e == null) {
-      throw new IllegalArgumentException("accept has not been called");
-    }
+    checkArgument(e != null, "accept has not been called");
     return e;
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/util/NameMap.java b/core/src/main/java/org/apache/calcite/util/NameMap.java
index 61b78cf8d..cf1141f76 100644
--- a/core/src/main/java/org/apache/calcite/util/NameMap.java
+++ b/core/src/main/java/org/apache/calcite/util/NameMap.java
@@ -22,13 +22,14 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.TreeMap;
 
 import static org.apache.calcite.util.CaseInsensitiveComparator.COMPARATOR;
 
+import static java.util.Collections.unmodifiableNavigableMap;
+
 /**
  * Map whose keys are names and can be accessed with and without case sensitivity.
  *
@@ -84,7 +85,7 @@ public NavigableMap<String, V> range(String name, boolean caseSensitive) {
       ceilingKey = COMPARATOR.ceilingKey(name);
     }
     NavigableMap subMap = ((NavigableMap) map).subMap(floorKey, true, ceilingKey, true);
-    return Collections.unmodifiableNavigableMap((NavigableMap<String, V>) subMap);
+    return unmodifiableNavigableMap((NavigableMap<String, V>) subMap);
   }
 
   /** Returns whether this map contains a given key, with a given case-sensitivity. */
diff --git a/core/src/main/java/org/apache/calcite/util/NameMultimap.java b/core/src/main/java/org/apache/calcite/util/NameMultimap.java
index beb0bcb4c..9550b60df 100644
--- a/core/src/main/java/org/apache/calcite/util/NameMultimap.java
+++ b/core/src/main/java/org/apache/calcite/util/NameMultimap.java
@@ -22,14 +22,15 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.util.CaseInsensitiveComparator.COMPARATOR;
 
+import static java.util.Collections.unmodifiableList;
+import static java.util.stream.Collectors.toList;
+
 /**
  * Multimap whose keys are names and can be accessed with and without case sensitivity.
  *
@@ -87,8 +88,8 @@ public Collection<Map.Entry<String, V>> range(String name, boolean caseSensitive
     List<Pair<String, V>> result =
         range.entrySet().stream()
             .flatMap(e -> e.getValue().stream().map(v -> Pair.of(e.getKey(), v)))
-            .collect(Collectors.toList());
-    return Collections.unmodifiableList(result);
+            .collect(toList());
+    return unmodifiableList(result);
   }
 
   /** Returns whether this map contains a given key, with a given case-sensitivity. */
diff --git a/core/src/main/java/org/apache/calcite/util/NameSet.java b/core/src/main/java/org/apache/calcite/util/NameSet.java
index e6ccc0cb7..26259895c 100644
--- a/core/src/main/java/org/apache/calcite/util/NameSet.java
+++ b/core/src/main/java/org/apache/calcite/util/NameSet.java
@@ -21,10 +21,11 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.Set;
 
+import static java.util.Collections.unmodifiableSet;
+
 /** Set of names that can be accessed with and without case sensitivity. */
 public class NameSet {
   public static final Comparator<String> COMPARATOR = CaseInsensitiveComparator.COMPARATOR;
@@ -84,6 +85,6 @@ public boolean contains(String name, boolean caseSensitive) {
 
   /** Returns the contents as an iterable. */
   public Iterable<String> iterable() {
-    return Collections.unmodifiableSet(names.map().keySet());
+    return unmodifiableSet(names.map().keySet());
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/util/NlsString.java b/core/src/main/java/org/apache/calcite/util/NlsString.java
index 633e2093e..cae3a28e8 100644
--- a/core/src/main/java/org/apache/calcite/util/NlsString.java
+++ b/core/src/main/java/org/apache/calcite/util/NlsString.java
@@ -42,6 +42,8 @@
 import java.util.Locale;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
@@ -137,13 +139,10 @@ private NlsString(
       this.charsetName = null;
       this.charset = null;
     }
-    if ((stringValue != null) == (bytesValue != null)) {
-      throw new IllegalArgumentException("Specify stringValue or bytesValue");
-    }
+    checkArgument(
+        (stringValue != null) != (bytesValue != null), "Specify stringValue or bytesValue");
     if (bytesValue != null) {
-      if (charset == null) {
-        throw new IllegalArgumentException("Bytes value requires charset");
-      }
+      checkArgument(charset != null, "Bytes value requires charset");
       SqlUtil.validateCharset(bytesValue, charset);
     } else {
       //noinspection ConstantConditions
@@ -246,9 +245,9 @@ public String asSql(boolean prefix, boolean suffix, SqlDialect dialect) {
 
     // NOTE jvs 3-Feb-2005:  see FRG-78 for why this should go away
     if (false) {
-      if (suffix && (null != collation)) {
+      if (suffix && collation != null) {
         ret.append(" ");
-        ret.append(collation.toString());
+        ret.append(collation);
       }
     }
     return ret.toString();
@@ -281,12 +280,11 @@ public static NlsString concat(List<NlsString> args) {
     for (int i = 1; i < args.size(); i++) {
       final NlsString arg = args.get(i);
       length += arg.getValue().length();
-      if (!((arg.charsetName == null) || arg.charsetName.equals(charSetName))) {
-        throw new IllegalArgumentException("mismatched charsets");
-      }
-      if (!((arg.collation == null) || arg.collation.equals(collation))) {
-        throw new IllegalArgumentException("mismatched collations");
-      }
+      checkArgument(
+          ((arg.charsetName == null) || arg.charsetName.equals(charSetName)),
+          "mismatched charsets");
+      checkArgument(
+          ((arg.collation == null) || arg.collation.equals(collation)), "mismatched collations");
     }
 
     StringBuilder sb = new StringBuilder(length);
diff --git a/core/src/main/java/org/apache/calcite/util/NumberUtil.java b/core/src/main/java/org/apache/calcite/util/NumberUtil.java
index 5a8c6cab6..fa3059e0c 100644
--- a/core/src/main/java/org/apache/calcite/util/NumberUtil.java
+++ b/core/src/main/java/org/apache/calcite/util/NumberUtil.java
@@ -116,7 +116,7 @@ public static BigDecimal toBigDecimal(Number number, int scale) {
     } else if (number instanceof BigInteger) {
       return new BigDecimal((BigInteger) number);
     } else {
-      return new BigDecimal(number.longValue());
+      return BigDecimal.valueOf(number.longValue());
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/util/Pair.java b/core/src/main/java/org/apache/calcite/util/Pair.java
index cb8422523..7ade27017 100644
--- a/core/src/main/java/org/apache/calcite/util/Pair.java
+++ b/core/src/main/java/org/apache/calcite/util/Pair.java
@@ -22,7 +22,6 @@
 
 import java.io.Serializable;
 import java.util.AbstractList;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -31,6 +30,11 @@
 import java.util.Objects;
 import java.util.function.BiConsumer;
 
+import static java.util.Collections.emptyIterator;
+import static java.util.Comparator.naturalOrder;
+import static java.util.Comparator.nullsFirst;
+import static java.util.Objects.requireNonNull;
+
 /**
  * Pair of objects.
  *
@@ -45,8 +49,7 @@ public class Pair<T1 extends @Nullable Object, T2 extends @Nullable Object>
     implements Comparable<Pair<T1, T2>>, Map.Entry<T1, T2>, Serializable {
 
   @SuppressWarnings({"rawtypes", "unchecked"})
-  private static final Comparator NULLS_FIRST_COMPARATOR =
-      Comparator.nullsFirst((Comparator) Comparator.naturalOrder());
+  private static final Comparator NULLS_FIRST_COMPARATOR = nullsFirst((Comparator) naturalOrder());
 
   // ~ Instance fields --------------------------------------------------------
 
@@ -356,7 +359,7 @@ public static <T> Iterable<Pair<T, T>> adjacents(final Iterable<? extends T> ite
     return () -> {
       final Iterator<? extends T> iterator = iterable.iterator();
       if (!iterator.hasNext()) {
-        return Collections.emptyIterator();
+        return emptyIterator();
       }
       return new AdjacentIterator<>(iterator);
     };
@@ -375,7 +378,7 @@ public static <T> Iterable<Pair<T, T>> firstAnd(final Iterable<? extends T> iter
     return () -> {
       final Iterator<? extends T> iterator = iterable.iterator();
       if (!iterator.hasNext()) {
-        return Collections.emptyIterator();
+        return emptyIterator();
       }
       final T first = iterator.next();
       return new FirstAndIterator<>(iterator, first);
@@ -392,7 +395,7 @@ private static class FirstAndIterator<E> implements Iterator<Pair<E, E>> {
     private final E first;
 
     FirstAndIterator(Iterator<? extends E> iterator, E first) {
-      this.iterator = Objects.requireNonNull(iterator, "iterator");
+      this.iterator = requireNonNull(iterator, "iterator");
       this.first = first;
     }
 
@@ -420,8 +423,8 @@ private static class ZipIterator<L, R> implements Iterator<Pair<L, R>> {
     private final Iterator<? extends R> rightIterator;
 
     ZipIterator(Iterator<? extends L> leftIterator, Iterator<? extends R> rightIterator) {
-      this.leftIterator = Objects.requireNonNull(leftIterator, "leftIterator");
-      this.rightIterator = Objects.requireNonNull(rightIterator, "rightIterator");
+      this.leftIterator = requireNonNull(leftIterator, "leftIterator");
+      this.rightIterator = requireNonNull(rightIterator, "rightIterator");
     }
 
     @Override public boolean hasNext() {
@@ -449,7 +452,7 @@ private static class AdjacentIterator<E> implements Iterator<Pair<E, E>> {
     E previous;
 
     AdjacentIterator(Iterator<? extends E> iterator) {
-      this.iterator = Objects.requireNonNull(iterator, "iterator");
+      this.iterator = requireNonNull(iterator, "iterator");
       this.first = iterator.next();
       previous = first;
     }
@@ -514,8 +517,8 @@ private static class MutableZipList<K, V> extends AbstractList<Pair<K, V>> {
     private final List<V> vs;
 
     MutableZipList(List<K> ks, List<V> vs) {
-      this.ks = Objects.requireNonNull(ks, "ks");
-      this.vs = Objects.requireNonNull(vs, "vs");
+      this.ks = requireNonNull(ks, "ks");
+      this.vs = requireNonNull(vs, "vs");
     }
 
     @Override public Pair<K, V> get(int index) {
diff --git a/core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java b/core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
index 7a80d85f4..976741197 100644
--- a/core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
+++ b/core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
@@ -26,7 +26,6 @@
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -110,8 +109,8 @@ public PartiallyOrderedSet(
     this(ordering, new HashMap<>(), childFunction, parentFunction);
   }
 
-  @SuppressWarnings({"Guava", "UnnecessaryMethodReference"})
-  @Deprecated // to be removed before 2.0
+  @Deprecated
+  @SuppressWarnings({"Guava", "UnnecessaryMethodReference"}) // to be removed before 2.0
   public PartiallyOrderedSet(
       Ordering<E> ordering,
       com.google.common.base.Function<E, Iterable<E>> childFunction,
@@ -154,8 +153,8 @@ private PartiallyOrderedSet(
     this.bottomNode.parentList.add(topNode);
   }
 
-  @SuppressWarnings("NullableProblems")
-  @Override public Iterator<E> iterator() {
+  @Override @SuppressWarnings("NullableProblems")
+  public Iterator<E> iterator() {
     final Iterator<E> iterator = map.keySet().iterator();
     return new Iterator<E>() {
       @Nullable E previous;
@@ -366,7 +365,7 @@ private static <T> void replace(List<T> list, T remove, T add) {
    * @param fail Whether to throw an assertion error
    * @return Whether valid
    */
-  @SuppressWarnings({"ConstantConditions"})
+  @SuppressWarnings("ConstantConditions")
   public boolean isValid(boolean fail) {
     // Top has no parents.
     // Bottom has no children.
@@ -450,7 +449,7 @@ public boolean isValid(boolean fail) {
           }
         }
         if (lt12 && lt21) {
-          if (!(node1 == node2)) {
+          if (node1 != node2) {
             assert !fail
                 : "node "
                     + node1.e
@@ -631,17 +630,17 @@ public void out(StringBuilder buf) {
     if (node == null) {
       if (hypothetical) {
         if (parentFunction != null) {
-          final ImmutableList.Builder<E> list = new ImmutableList.Builder<>();
+          final ImmutableList.Builder<E> list = ImmutableList.builder();
           closure(parentFunction, e, list, new HashSet<>());
           return list.build();
         } else {
-          return ImmutableList.copyOf(strip(findParents(e)));
+          return strip(findParents(e)).asList();
         }
       } else {
         return null;
       }
     } else {
-      return ImmutableList.copyOf(strip(node.parentList));
+      return strip(node.parentList);
     }
   }
 
@@ -753,12 +752,12 @@ private List<E> descendants(E e, boolean up) {
       c = up ? node.childList : node.parentList;
     }
     if (c.size() == 1 && c.iterator().next().e == null) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     final Deque<Node<E>> deque = new ArrayDeque<>(c);
 
     final Set<Node<E>> seen = new HashSet<>();
-    final ImmutableList.Builder<E> list = new ImmutableList.Builder<>();
+    final ImmutableList.Builder<E> list = ImmutableList.builder();
     while (!deque.isEmpty()) {
       Node<E> node1 = deque.pop();
       list.add(node1.e);
diff --git a/core/src/main/java/org/apache/calcite/util/Permutation.java b/core/src/main/java/org/apache/calcite/util/Permutation.java
index 9332ab365..57972ae67 100644
--- a/core/src/main/java/org/apache/calcite/util/Permutation.java
+++ b/core/src/main/java/org/apache/calcite/util/Permutation.java
@@ -28,6 +28,8 @@
 import java.util.Arrays;
 import java.util.Iterator;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Represents a mapping which reorders elements in an array. */
 public class Permutation implements Mapping, Mappings.TargetMapping {
   // ~ Instance fields --------------------------------------------------------
@@ -67,13 +69,9 @@ public Permutation(int[] targets) {
     Arrays.fill(sources, -1);
     for (int i = 0; i < targets.length; i++) {
       int target = targets[i];
-      if (target < 0 || target >= sources.length) {
-        throw new IllegalArgumentException("target out of range");
-      }
-      if (sources[target] != -1) {
-        throw new IllegalArgumentException(
-            "more than one permutation element maps to position " + target);
-      }
+      checkArgument(target >= 0 && target < sources.length, "target out of range");
+      checkArgument(
+          sources[target] == -1, "more than one permutation element maps to position %s", target);
       sources[target] = i;
     }
     assert isValid(true);
diff --git a/core/src/main/java/org/apache/calcite/util/Puffin.java b/core/src/main/java/org/apache/calcite/util/Puffin.java
index 0a4f19059..f22891402 100644
--- a/core/src/main/java/org/apache/calcite/util/Puffin.java
+++ b/core/src/main/java/org/apache/calcite/util/Puffin.java
@@ -302,7 +302,7 @@ private static class ProgramImpl<G, F> implements Program<G> {
 
     @SuppressWarnings("Convert2MethodRef")
     private final LoadingCache<String, Pattern> patternCache0 =
-        CacheBuilder.newBuilder().build(CacheLoader.from(regex -> Pattern.compile(regex)));
+        CacheBuilder.newBuilder().build(CacheLoader.from(Pattern::compile));
 
     private final Function<String, Pattern> patternCache = patternCache0::getUnchecked;
 
diff --git a/core/src/main/java/org/apache/calcite/util/RangeSets.java b/core/src/main/java/org/apache/calcite/util/RangeSets.java
index 88bd7810d..6014edcda 100644
--- a/core/src/main/java/org/apache/calcite/util/RangeSets.java
+++ b/core/src/main/java/org/apache/calcite/util/RangeSets.java
@@ -43,7 +43,7 @@ private RangeSets() {}
   public static <C extends Comparable<C>> RangeSet<C> minus(RangeSet<C> rangeSet, Range<C> range) {
     final TreeRangeSet<C> mutableRangeSet = TreeRangeSet.create(rangeSet);
     mutableRangeSet.remove(range);
-    return mutableRangeSet.equals(rangeSet) ? rangeSet : ImmutableRangeSet.copyOf(mutableRangeSet);
+    return mutableRangeSet.equals(rangeSet) ? rangeSet : mutableRangeSet;
   }
 
   /** Returns the unrestricted range set. */
diff --git a/core/src/main/java/org/apache/calcite/util/ReflectUtil.java b/core/src/main/java/org/apache/calcite/util/ReflectUtil.java
index 070306c39..2e2844cff 100644
--- a/core/src/main/java/org/apache/calcite/util/ReflectUtil.java
+++ b/core/src/main/java/org/apache/calcite/util/ReflectUtil.java
@@ -29,11 +29,12 @@
 import java.lang.reflect.Modifier;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 /** Static utilities for Java reflection. */
@@ -253,7 +254,7 @@ private static boolean invokeVisitorInternal(
    */
   public static @Nullable Method lookupVisitMethod(
       Class<?> visitorClass, Class<?> visiteeClass, String visitMethodName) {
-    return lookupVisitMethod(visitorClass, visiteeClass, visitMethodName, Collections.emptyList());
+    return lookupVisitMethod(visitorClass, visiteeClass, visitMethodName, ImmutableList.of());
   }
 
   /**
@@ -372,8 +373,7 @@ ReflectiveVisitDispatcher<R, E> createDispatcher(
           Class<? extends R> visitorClass,
           Class<? extends E> visiteeClass,
           String visitMethodName) {
-        return lookupVisitMethod(
-            visitorClass, visiteeClass, visitMethodName, Collections.emptyList());
+        return lookupVisitMethod(visitorClass, visiteeClass, visitMethodName, ImmutableList.of());
       }
 
       @Override public @Nullable Method lookupVisitMethod(
@@ -454,7 +454,7 @@ public static <E extends Object, T> MethodDispatcher<T> createMethodDispatcher(
       final Class<E> arg0Clazz,
       final Class... otherArgClasses) {
     final List<Class> otherArgClassList = ImmutableList.copyOf(otherArgClasses);
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings("unchecked")
     final ReflectiveVisitDispatcher<ReflectiveVisitor, E> dispatcher =
         createDispatcher((Class<ReflectiveVisitor>) visitor.getClass(), arg0Clazz);
     return new MethodDispatcher<T>() {
@@ -480,9 +480,7 @@ public static <E extends Object, T> MethodDispatcher<T> createMethodDispatcher(
       }
 
       private Method lookupMethod(final Object arg0) {
-        if (!arg0Clazz.isInstance(arg0)) {
-          throw new IllegalArgumentException();
-        }
+        checkArgument(arg0Clazz.isInstance(arg0));
         Method method =
             dispatcher.lookupVisitMethod(
                 visitor.getClass(),
diff --git a/core/src/main/java/org/apache/calcite/util/SaffronProperties.java b/core/src/main/java/org/apache/calcite/util/SaffronProperties.java
index 3708382f0..e0cff1c03 100644
--- a/core/src/main/java/org/apache/calcite/util/SaffronProperties.java
+++ b/core/src/main/java/org/apache/calcite/util/SaffronProperties.java
@@ -54,16 +54,16 @@ public interface SaffronProperties {
    * will consider adding converters of infinite cost in order to convert a relational expression
    * from one calling convention to another. The default value is <code>true</code>.
    */
-  @Resource("saffron.opt.allowInfiniteCostConverters")
   @Default("true")
+  @Resource("saffron.opt.allowInfiniteCostConverters")
   BooleanProp allowInfiniteCostConverters();
 
   /**
    * The string property "saffron.default.charset" is the name of the default character set. The
    * default is "ISO-8859-1". It is used in {@link org.apache.calcite.sql.validate.SqlValidator}.
    */
-  @Resource("saffron.default.charset")
   @Default("ISO-8859-1")
+  @Resource("saffron.default.charset")
   StringProp defaultCharset();
 
   /**
@@ -72,8 +72,8 @@ public interface SaffronProperties {
    * the {@link #defaultCharset}. The default is "ISO-8859-1". It is used in {@link
    * org.apache.calcite.sql.SqlLiteral#SqlLiteral}
    */
-  @Resource("saffron.default.nationalcharset")
   @Default("ISO-8859-1")
+  @Resource("saffron.default.nationalcharset")
   StringProp defaultNationalCharset();
 
   /**
@@ -81,8 +81,8 @@ public interface SaffronProperties {
    * default is "ISO-8859-1$en_US". Used in {@link org.apache.calcite.sql.SqlCollation} and {@link
    * org.apache.calcite.sql.SqlLiteral#SqlLiteral}
    */
-  @Resource("saffron.default.collation.name")
   @Default("ISO-8859-1$en_US")
+  @Resource("saffron.default.collation.name")
   StringProp defaultCollation();
 
   /**
@@ -90,8 +90,8 @@ public interface SaffronProperties {
    * collation. The default is "primary". Used in {@link org.apache.calcite.sql.SqlCollation} and
    * {@link org.apache.calcite.sql.SqlLiteral#SqlLiteral}
    */
-  @Resource("saffron.default.collation.strength")
   @Default("primary")
+  @Resource("saffron.default.collation.strength")
   StringProp defaultCollationStrength();
 
   /**
@@ -101,8 +101,8 @@ public interface SaffronProperties {
    *
    * <p>If the value is less than 0, there is no limit. The default is 1,000.
    */
-  @Resource("saffron.metadata.handler.cache.maximum.size")
   @Default("1000")
+  @Resource("saffron.metadata.handler.cache.maximum.size")
   IntProp metadataHandlerCacheMaximumSize();
 
   SaffronProperties INSTANCE = Helper.instance();
diff --git a/core/src/main/java/org/apache/calcite/util/SimpleNamespaceContext.java b/core/src/main/java/org/apache/calcite/util/SimpleNamespaceContext.java
index 9562d0331..7fde584d4 100644
--- a/core/src/main/java/org/apache/calcite/util/SimpleNamespaceContext.java
+++ b/core/src/main/java/org/apache/calcite/util/SimpleNamespaceContext.java
@@ -16,9 +16,10 @@
  */
 package org.apache.calcite.util;
 
+import com.google.common.collect.ImmutableSet;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
@@ -27,6 +28,8 @@
 import javax.xml.XMLConstants;
 import javax.xml.namespace.NamespaceContext;
 
+import static java.util.Collections.unmodifiableSet;
+
 /**
  * Simple {@link javax.xml.namespace.NamespaceContext} implementation. Follows the standard
  * NamespaceContext contract, and is loadable via a {@link java.util.Map}
@@ -62,7 +65,7 @@ public SimpleNamespaceContext(Map<String, String> bindings) {
 
   private Set<String> getPrefixesSet(String namespaceUri) {
     Set<String> prefixes = this.namespaceUriToPrefixes.get(namespaceUri);
-    return prefixes != null ? Collections.unmodifiableSet(prefixes) : Collections.emptySet();
+    return prefixes != null ? unmodifiableSet(prefixes) : ImmutableSet.of();
   }
 
   private void bindNamespaceUri(String prefix, String namespaceUri) {
diff --git a/core/src/main/java/org/apache/calcite/util/SourceStringReader.java b/core/src/main/java/org/apache/calcite/util/SourceStringReader.java
index 3ff5a3e49..82e32c937 100644
--- a/core/src/main/java/org/apache/calcite/util/SourceStringReader.java
+++ b/core/src/main/java/org/apache/calcite/util/SourceStringReader.java
@@ -17,7 +17,8 @@
 package org.apache.calcite.util;
 
 import java.io.StringReader;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Extension to {@link StringReader} that allows the original string to be recovered. */
 public class SourceStringReader extends StringReader {
@@ -29,7 +30,7 @@ public class SourceStringReader extends StringReader {
    * @param s String providing the character stream
    */
   public SourceStringReader(String s) {
-    super(Objects.requireNonNull(s, "s"));
+    super(requireNonNull(s, "s"));
     this.s = s;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/util/Sources.java b/core/src/main/java/org/apache/calcite/util/Sources.java
index 5d8dc3866..4dd215136 100644
--- a/core/src/main/java/org/apache/calcite/util/Sources.java
+++ b/core/src/main/java/org/apache/calcite/util/Sources.java
@@ -31,14 +31,15 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.Locale;
-import java.util.Objects;
 import java.util.Optional;
 import java.util.zip.GZIPInputStream;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Objects.requireNonNull;
+
 /** Utilities for {@link Source}. */
 public abstract class Sources {
   private Sources() {}
@@ -100,7 +101,7 @@ private static class GuavaCharSource implements Source {
     private final CharSource charSource;
 
     private GuavaCharSource(CharSource charSource) {
-      this.charSource = Objects.requireNonNull(charSource, "charSource");
+      this.charSource = requireNonNull(charSource, "charSource");
     }
 
     private UnsupportedOperationException unsupported() {
@@ -130,7 +131,7 @@ private UnsupportedOperationException unsupported() {
 
     @Override public InputStream openStream() throws IOException {
       // use charSource.asByteSource() once calcite can use guava v21+
-      return new ReaderInputStream(reader(), StandardCharsets.UTF_8);
+      return new ReaderInputStream(reader(), UTF_8);
     }
 
     @Override public String protocol() {
@@ -167,19 +168,19 @@ private static class FileSource implements Source {
     private final boolean urlGenerated;
 
     private FileSource(URL url) {
-      this.url = Objects.requireNonNull(url, "url");
+      this.url = requireNonNull(url, "url");
       this.file = urlToFile(url);
       this.urlGenerated = false;
     }
 
     private FileSource(File file) {
-      this.file = Objects.requireNonNull(file, "file");
+      this.file = requireNonNull(file, "file");
       this.url = fileToUrl(file);
       this.urlGenerated = true;
     }
 
     private File fileNonNull() {
-      return Objects.requireNonNull(file, "file");
+      return requireNonNull(file, "file");
     }
 
     private static @Nullable File urlToFile(URL url) {
@@ -275,7 +276,7 @@ private static URL fileToUrl(File file) {
       } else {
         is = openStream();
       }
-      return new InputStreamReader(is, StandardCharsets.UTF_8);
+      return new InputStreamReader(is, UTF_8);
     }
 
     @Override public InputStream openStream() throws IOException {
diff --git a/core/src/main/java/org/apache/calcite/util/Template.java b/core/src/main/java/org/apache/calcite/util/Template.java
index 36e437c5a..c1ed7f4dc 100644
--- a/core/src/main/java/org/apache/calcite/util/Template.java
+++ b/core/src/main/java/org/apache/calcite/util/Template.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.util;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.text.MessageFormat;
@@ -26,6 +24,8 @@
 import java.util.Locale;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * String template.
  *
@@ -104,7 +104,7 @@ public static Template of(String pattern, Locale locale) {
 
   private Template(String pattern, List<String> parameterNames, Locale locale) {
     super(pattern, locale);
-    this.parameterNames = ImmutableList.copyOf(parameterNames);
+    this.parameterNames = parameterNames;
   }
 
   /**
@@ -179,9 +179,7 @@ private static String process(String pattern, List<String> parameterNames) {
         }
       }
     }
-    if (braceStack == 0 && part != 0) {
-      throw new IllegalArgumentException("Unmatched braces in the pattern.");
-    }
+    checkArgument(braceStack != 0 || part == 0, "Unmatched braces in the pattern.");
     return segments[0].toString();
   }
 
@@ -198,11 +196,11 @@ private static void makeFormat(StringBuilder[] segments, List<String> parameterN
     segments[0].append("{");
     segments[0].append(parameterOrdinal);
     final String two = segments[2].toString();
-    if (two.length() > 0) {
+    if (!two.isEmpty()) {
       segments[0].append(",").append(two);
     }
     final String three = segments[3].toString();
-    if (three.length() > 0) {
+    if (!three.isEmpty()) {
       segments[0].append(",").append(three);
     }
     segments[0].append("}");
diff --git a/core/src/main/java/org/apache/calcite/util/TimeString.java b/core/src/main/java/org/apache/calcite/util/TimeString.java
index 0eafd5794..b14ca6f82 100644
--- a/core/src/main/java/org/apache/calcite/util/TimeString.java
+++ b/core/src/main/java/org/apache/calcite/util/TimeString.java
@@ -20,7 +20,6 @@
 
 import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonProperty;
-import com.google.common.base.Preconditions;
 import com.google.common.base.Strings;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -28,6 +27,8 @@
 import java.util.Calendar;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.lang.Math.floorMod;
 
 /**
@@ -51,12 +52,10 @@ private TimeString(String v, @SuppressWarnings("unused") boolean ignore) {
   @SuppressWarnings("method.invocation.invalid")
   public TimeString(String v) {
     this(v, false);
-    Preconditions.checkArgument(PATTERN.matcher(v).matches(), "Invalid time format:", v);
-    Preconditions.checkArgument(getHour() >= 0 && getHour() < 24, "Hour out of range:", getHour());
-    Preconditions.checkArgument(
-        getMinute() >= 0 && getMinute() < 60, "Minute out of range:", getMinute());
-    Preconditions.checkArgument(
-        getSecond() >= 0 && getSecond() < 60, "Second out of range:", getSecond());
+    checkArgument(PATTERN.matcher(v).matches(), "Invalid time format:", v);
+    checkArgument(getHour() >= 0 && getHour() < 24, "Hour out of range:", getHour());
+    checkArgument(getMinute() >= 0 && getMinute() < 60, "Minute out of range:", getMinute());
+    checkArgument(getSecond() >= 0 && getSecond() < 60, "Second out of range:", getSecond());
   }
 
   /** Creates a TimeString for hour, minute, second and millisecond values. */
@@ -66,9 +65,9 @@ public TimeString(int h, int m, int s) {
 
   /** Validates an hour-minute-second value and converts to a string. */
   private static String hms(int h, int m, int s) {
-    Preconditions.checkArgument(h >= 0 && h < 24, "Hour out of range:", h);
-    Preconditions.checkArgument(m >= 0 && m < 60, "Minute out of range:", m);
-    Preconditions.checkArgument(s >= 0 && s < 60, "Second out of range:", s);
+    checkArgument(h >= 0 && h < 24, "Hour out of range:", h);
+    checkArgument(m >= 0 && m < 60, "Minute out of range:", m);
+    checkArgument(s >= 0 && s < 60, "Second out of range:", s);
     final StringBuilder b = new StringBuilder();
     DateTimeStringUtils.hms(b, h, m, s);
     return b.toString();
@@ -82,7 +81,7 @@ private static String hms(int h, int m, int s) {
    * '1970-01-01 02:03:04.056'}.
    */
   public TimeString withMillis(int millis) {
-    Preconditions.checkArgument(millis >= 0 && millis < 1000);
+    checkArgument(millis >= 0 && millis < 1000);
     return withFraction(DateTimeStringUtils.pad(3, millis));
   }
 
@@ -94,7 +93,7 @@ public TimeString withMillis(int millis) {
    * '1970-01-01 02:03:04.000056789'}.
    */
   public TimeString withNanos(int nanos) {
-    Preconditions.checkArgument(nanos >= 0 && nanos < 1000000000);
+    checkArgument(nanos >= 0 && nanos < 1000000000);
     return withFraction(DateTimeStringUtils.pad(9, nanos));
   }
 
@@ -114,7 +113,7 @@ public TimeString withFraction(String fraction) {
     while (fraction.endsWith("0")) {
       fraction = fraction.substring(0, fraction.length() - 1);
     }
-    if (fraction.length() > 0) {
+    if (!fraction.isEmpty()) {
       v = v + "." + fraction;
     }
     return new TimeString(v);
@@ -152,7 +151,7 @@ public static TimeString fromMillisOfDay(@JsonProperty("millisOfDay") int i) {
   }
 
   public TimeString round(int precision) {
-    Preconditions.checkArgument(precision >= 0);
+    checkArgument(precision >= 0);
     int targetLength = 9 + precision;
     if (v.length() <= targetLength) {
       return this;
@@ -210,7 +209,7 @@ public Calendar toCalendar() {
    * Converts this TimestampString to a string, truncated or padded with zeros to a given precision.
    */
   public String toString(int precision) {
-    Preconditions.checkArgument(precision >= 0);
+    checkArgument(precision >= 0);
     final int p = precision();
     if (precision < p) {
       return round(precision).toString(precision);
diff --git a/core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java b/core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java
index 56c600b31..3044ad4f7 100644
--- a/core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java
+++ b/core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java
@@ -18,8 +18,6 @@
 
 import org.apache.calcite.avatica.util.DateTimeUtils;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.text.SimpleDateFormat;
@@ -27,6 +25,8 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.lang.Math.floorMod;
 
 /**
@@ -45,14 +45,14 @@ public class TimeWithTimeZoneString implements Comparable<TimeWithTimeZoneString
   public TimeWithTimeZoneString(TimeString localTime, TimeZone timeZone) {
     this.localTime = localTime;
     this.timeZone = timeZone;
-    this.v = localTime.toString() + " " + timeZone.getID();
+    this.v = localTime + " " + timeZone.getID();
   }
 
   /** Creates a TimeWithTimeZoneString. */
   public TimeWithTimeZoneString(String v) {
     this.localTime = new TimeString(v.substring(0, 8));
     String timeZoneString = v.substring(9);
-    Preconditions.checkArgument(DateTimeStringUtils.isValidTimeZone(timeZoneString));
+    checkArgument(DateTimeStringUtils.isValidTimeZone(timeZoneString));
     this.timeZone = TimeZone.getTimeZone(timeZoneString);
     this.v = v;
   }
@@ -62,7 +62,7 @@ public TimeWithTimeZoneString(String v) {
    * time-zone.
    */
   public TimeWithTimeZoneString(int h, int m, int s, String timeZone) {
-    this(DateTimeStringUtils.hms(new StringBuilder(), h, m, s).toString() + " " + timeZone);
+    this(DateTimeStringUtils.hms(new StringBuilder(), h, m, s) + " " + timeZone);
   }
 
   /**
@@ -73,7 +73,7 @@ public TimeWithTimeZoneString(int h, int m, int s, String timeZone) {
    * yields {@code TIME WITH LOCAL TIME ZONE '1970-01-01 02:03:04.056 UTC'}.
    */
   public TimeWithTimeZoneString withMillis(int millis) {
-    Preconditions.checkArgument(millis >= 0 && millis < 1000);
+    checkArgument(millis >= 0 && millis < 1000);
     return withFraction(DateTimeStringUtils.pad(3, millis));
   }
 
@@ -85,7 +85,7 @@ public TimeWithTimeZoneString withMillis(int millis) {
    * yields {@code TIME WITH LOCAL TIME ZONE '1970-01-01 02:03:04.000056789 UTC'}.
    */
   public TimeWithTimeZoneString withNanos(int nanos) {
-    Preconditions.checkArgument(nanos >= 0 && nanos < 1000000000);
+    checkArgument(nanos >= 0 && nanos < 1000000000);
     return withFraction(DateTimeStringUtils.pad(9, nanos));
   }
 
@@ -108,7 +108,7 @@ public TimeWithTimeZoneString withFraction(String fraction) {
     while (fraction.endsWith("0")) {
       fraction = fraction.substring(0, fraction.length() - 1);
     }
-    if (fraction.length() > 0) {
+    if (!fraction.isEmpty()) {
       v = v + "." + fraction;
     }
     v = v + this.v.substring(8); // time-zone
@@ -171,7 +171,7 @@ public TimeWithTimeZoneString withTimeZone(TimeZone timeZone) {
   }
 
   public TimeWithTimeZoneString round(int precision) {
-    Preconditions.checkArgument(precision >= 0);
+    checkArgument(precision >= 0);
     return new TimeWithTimeZoneString(localTime.round(precision), timeZone);
   }
 
@@ -186,7 +186,7 @@ public static TimeWithTimeZoneString fromMillisOfDay(int i) {
    * precision.
    */
   public String toString(int precision) {
-    Preconditions.checkArgument(precision >= 0);
+    checkArgument(precision >= 0);
     return localTime.toString(precision) + " " + timeZone.getID();
   }
 
diff --git a/core/src/main/java/org/apache/calcite/util/TimestampString.java b/core/src/main/java/org/apache/calcite/util/TimestampString.java
index e1bbdc4c5..4b2fa20c4 100644
--- a/core/src/main/java/org/apache/calcite/util/TimestampString.java
+++ b/core/src/main/java/org/apache/calcite/util/TimestampString.java
@@ -111,7 +111,7 @@ public TimestampString withFraction(String fraction) {
     while (fraction.endsWith("0")) {
       fraction = fraction.substring(0, fraction.length() - 1);
     }
-    if (fraction.length() > 0) {
+    if (!fraction.isEmpty()) {
       v = v + "." + fraction;
     }
     return new TimestampString(v);
diff --git a/core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java b/core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java
index 5736fb09f..659c726eb 100644
--- a/core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java
+++ b/core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java
@@ -18,8 +18,6 @@
 
 import org.apache.calcite.avatica.util.DateTimeUtils;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.text.SimpleDateFormat;
@@ -27,6 +25,8 @@
 import java.util.Locale;
 import java.util.TimeZone;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.lang.Math.floorMod;
 
 /**
@@ -45,14 +45,14 @@ public class TimestampWithTimeZoneString implements Comparable<TimestampWithTime
   public TimestampWithTimeZoneString(TimestampString localDateTime, TimeZone timeZone) {
     this.localDateTime = localDateTime;
     this.timeZone = timeZone;
-    this.v = localDateTime.toString() + " " + timeZone.getID();
+    this.v = localDateTime + " " + timeZone.getID();
   }
 
   /** Creates a TimestampWithTimeZoneString. */
   public TimestampWithTimeZoneString(String v) {
     this.localDateTime = new TimestampString(v.substring(0, v.indexOf(' ', 11)));
     String timeZoneString = v.substring(v.indexOf(' ', 11) + 1);
-    Preconditions.checkArgument(DateTimeStringUtils.isValidTimeZone(timeZoneString));
+    checkArgument(DateTimeStringUtils.isValidTimeZone(timeZoneString));
     this.timeZone = TimeZone.getTimeZone(timeZoneString);
     this.v = v;
   }
@@ -64,7 +64,7 @@ public TimestampWithTimeZoneString(String v) {
   public TimestampWithTimeZoneString(
       int year, int month, int day, int h, int m, int s, String timeZone) {
     this(
-        DateTimeStringUtils.ymdhms(new StringBuilder(), year, month, day, h, m, s).toString()
+        DateTimeStringUtils.ymdhms(new StringBuilder(), year, month, day, h, m, s)
             + " "
             + timeZone);
   }
@@ -78,7 +78,7 @@ public TimestampWithTimeZoneString(
    * GMT'}.
    */
   public TimestampWithTimeZoneString withMillis(int millis) {
-    Preconditions.checkArgument(millis >= 0 && millis < 1000);
+    checkArgument(millis >= 0 && millis < 1000);
     return withFraction(DateTimeStringUtils.pad(3, millis));
   }
 
@@ -91,7 +91,7 @@ public TimestampWithTimeZoneString withMillis(int millis) {
    * 02:03:04.000056789 GMT'}.
    */
   public TimestampWithTimeZoneString withNanos(int nanos) {
-    Preconditions.checkArgument(nanos >= 0 && nanos < 1000000000);
+    checkArgument(nanos >= 0 && nanos < 1000000000);
     return withFraction(DateTimeStringUtils.pad(9, nanos));
   }
 
@@ -170,7 +170,7 @@ public TimestampWithTimeZoneString withTimeZone(TimeZone timeZone) {
   }
 
   public TimestampWithTimeZoneString round(int precision) {
-    Preconditions.checkArgument(precision >= 0);
+    checkArgument(precision >= 0);
     return new TimestampWithTimeZoneString(localDateTime.round(precision), timeZone);
   }
 
@@ -189,7 +189,7 @@ public static TimestampWithTimeZoneString fromMillisSinceEpoch(long millis) {
    * given precision.
    */
   public String toString(int precision) {
-    Preconditions.checkArgument(precision >= 0);
+    checkArgument(precision >= 0);
     return localDateTime.toString(precision) + " " + timeZone.getID();
   }
 
diff --git a/core/src/main/java/org/apache/calcite/util/UnmodifiableArrayList.java b/core/src/main/java/org/apache/calcite/util/UnmodifiableArrayList.java
index 1d91692bb..fed2f8c83 100644
--- a/core/src/main/java/org/apache/calcite/util/UnmodifiableArrayList.java
+++ b/core/src/main/java/org/apache/calcite/util/UnmodifiableArrayList.java
@@ -17,9 +17,10 @@
 package org.apache.calcite.util;
 
 import java.util.AbstractList;
-import java.util.Objects;
 import java.util.RandomAccess;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * A view onto an array that cannot be modified by the client.
  *
@@ -35,7 +36,7 @@ public class UnmodifiableArrayList<E> extends AbstractList<E> implements RandomA
   private final E[] elements;
 
   private UnmodifiableArrayList(E[] elements) {
-    this.elements = Objects.requireNonNull(elements, "elements");
+    this.elements = requireNonNull(elements, "elements");
   }
 
   public static <E> UnmodifiableArrayList<E> of(E... elements) {
diff --git a/core/src/main/java/org/apache/calcite/util/Util.java b/core/src/main/java/org/apache/calcite/util/Util.java
index 5403d68e6..e40b8b1ff 100644
--- a/core/src/main/java/org/apache/calcite/util/Util.java
+++ b/core/src/main/java/org/apache/calcite/util/Util.java
@@ -31,6 +31,7 @@
 import org.apache.calcite.sql.util.SqlBasicVisitor;
 
 import com.google.common.base.Preconditions;
+import com.google.common.base.Strings;
 import com.google.common.base.Throwables;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
@@ -73,7 +74,6 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.Statement;
@@ -114,8 +114,11 @@
 import java.util.regex.Pattern;
 import java.util.stream.Collector;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.Objects.requireNonNull;
 
 /** Miscellaneous utility functions. */
@@ -615,8 +618,7 @@ public static String stripDoubleQuotes(String value) {
     String s4 = Util.replace(s5, "\\r", "\r");
     String s3 = Util.replace(s4, "\\n", "\n");
     String s2 = Util.replace(s3, "\\\"", "\"");
-    String s1 = Util.replace(s2, "\\\\", "\\");
-    return s1;
+    return Util.replace(s2, "\\\\", "\\");
   }
 
   /**
@@ -718,7 +720,7 @@ public static <T> List<T> toList(Iterator<T> iter) {
 
   /** Returns whether s == null or if s.length() == 0. */
   public static boolean isNullOrEmpty(@Nullable String s) {
-    return (null == s) || (s.length() == 0);
+    return Strings.isNullOrEmpty(s);
   }
 
   /**
@@ -1036,7 +1038,7 @@ public static void permAssert(boolean b, String description) {
   public static RuntimeException needToImplement(@Nullable Object o) {
     String description = null;
     if (o != null) {
-      description = o.getClass().toString() + ": " + o.toString();
+      description = o.getClass() + ": " + o;
     }
     throw new UnsupportedOperationException(description);
   }
@@ -2249,9 +2251,7 @@ public static List<String> stringToList(String s) {
     int i = 0;
     for (; ; ) {
       char c = s.charAt(i);
-      if (c != '"') {
-        throw new IllegalArgumentException();
-      }
+      checkArgument(c == '"');
       for (; ; ) {
         c = s.charAt(++i);
         if (c == '"') {
@@ -2263,9 +2263,7 @@ public static List<String> stringToList(String s) {
           if (c == '.') {
             break;
           }
-          if (c != '"') {
-            throw new IllegalArgumentException();
-          }
+          checkArgument(c == '"');
         }
         b.append(c);
       }
@@ -2355,15 +2353,15 @@ public static <K, V> Map<K, V> asIndexMapJ(
           }
         };
     return new AbstractMap<K, V>() {
-      @SuppressWarnings("override.return.invalid")
-      @Override public Set<Entry<K, V>> entrySet() {
+      @Override @SuppressWarnings("override.return.invalid")
+      public Set<Entry<K, V>> entrySet() {
         return entrySet;
       }
     };
   }
 
-  @SuppressWarnings({"Guava", "UnnecessaryMethodReference"})
   @Deprecated
+  @SuppressWarnings({"Guava", "UnnecessaryMethodReference"})
   public static <K, V> Map<K, V> asIndexMap(
       final Collection<V> values, final com.google.common.base.Function<V, K> function) {
     return asIndexMapJ(values, function::apply);
@@ -2421,7 +2419,7 @@ public static <E> List<List<E>> immutableCopy(Iterable<? extends Iterable<E>> li
    * <p>Does not use the default character set.
    */
   public static PrintWriter printWriter(OutputStream out) {
-    return new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8)));
+    return new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, UTF_8)));
   }
 
   /**
@@ -2439,7 +2437,7 @@ public static PrintWriter printWriter(File file) throws FileNotFoundException {
    * <p>Does not use the default character set.
    */
   public static BufferedReader reader(InputStream in) {
-    return new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
+    return new BufferedReader(new InputStreamReader(in, UTF_8));
   }
 
   /**
@@ -2854,9 +2852,7 @@ private static class QuotientList<E> extends AbstractList<E> implements RandomAc
     private final int size;
 
     QuotientList(List<E> list, int n, int k) {
-      if (k < 0 || n <= 0 || k >= n) {
-        throw new IllegalArgumentException("n must be positive; k must be between 0 and n - 1");
-      }
+      checkArgument(k >= 0 && n > 0 && k < n, "n must be positive; k must be between 0 and n - 1");
       this.list = list;
       this.n = n;
       this.k = k;
diff --git a/core/src/main/java/org/apache/calcite/util/XmlOutput.java b/core/src/main/java/org/apache/calcite/util/XmlOutput.java
index 3630cb33a..5c970713c 100644
--- a/core/src/main/java/org/apache/calcite/util/XmlOutput.java
+++ b/core/src/main/java/org/apache/calcite/util/XmlOutput.java
@@ -565,7 +565,7 @@ public String escapeString(String s) {
         String escape;
         // codes >= 128 (e.g. Euro sign) are always escaped
         if (c > 127) {
-          escape = "&#" + Integer.toString(c) + ";";
+          escape = "&#" + c + ";";
         } else if (c >= requireNonNull(translationTable, "translationTable").length) {
           escape = null;
         } else {
diff --git a/core/src/main/java/org/apache/calcite/util/format/FormatModels.java b/core/src/main/java/org/apache/calcite/util/format/FormatModels.java
index e1e2cd485..41ce998b7 100644
--- a/core/src/main/java/org/apache/calcite/util/format/FormatModels.java
+++ b/core/src/main/java/org/apache/calcite/util/format/FormatModels.java
@@ -17,7 +17,6 @@
 package org.apache.calcite.util.format;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 
 import java.util.Date;
 import java.util.LinkedHashMap;
@@ -239,7 +238,7 @@ private static class FormatModelImpl implements FormatModel {
 
     FormatModelImpl(Pattern pattern, Map<String, FormatElement> elementMap) {
       this.pattern = requireNonNull(pattern, "pattern");
-      this.elementMap = ImmutableMap.copyOf(elementMap);
+      this.elementMap = elementMap;
     }
 
     @Override public Map<String, FormatElement> getElementMap() {
@@ -306,7 +305,7 @@ private static class CompositeFormatElement implements FormatElement {
     private final List<FormatElement> formatElements;
 
     CompositeFormatElement(List<FormatElement> formatElements, String description) {
-      this.formatElements = ImmutableList.copyOf(formatElements);
+      this.formatElements = formatElements;
       this.description = requireNonNull(description, "description");
     }
 
diff --git a/core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java b/core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java
index dc09e69bc..7f84d5a0f 100644
--- a/core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java
+++ b/core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java
@@ -25,7 +25,6 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -33,8 +32,12 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Collections.unmodifiableSet;
+
 /**
  * Default implementation of {@link DirectedGraph}.
  *
@@ -98,14 +101,12 @@ private String toString(Ordering<V> vertexOrdering, Ordering<E> edgeOrdering) {
   protected final VertexInfo<V, E> getVertex(V vertex) {
     @SuppressWarnings("argument.type.incompatible")
     final VertexInfo<V, E> info = vertexMap.get(vertex);
-    if (info == null) {
-      throw new IllegalArgumentException("no vertex " + vertex);
-    }
+    checkArgument(info != null, "no vertex %s", vertex);
     return info;
   }
 
   @Override public Set<E> edgeSet() {
-    return Collections.unmodifiableSet(edges);
+    return unmodifiableSet(edges);
   }
 
   @Override public @Nullable E addEdge(V vertex, V targetVertex) {
@@ -161,8 +162,8 @@ protected final VertexInfo<V, E> getVertex(V vertex) {
     return outRemoved;
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public Set<V> vertexSet() {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public Set<V> vertexSet() {
     // Set<V extends @KeyFor("this.vertexMap") Object> -> Set<V>
     return vertexMap.keySet();
   }
diff --git a/core/src/main/java/org/apache/calcite/util/graph/DefaultEdge.java b/core/src/main/java/org/apache/calcite/util/graph/DefaultEdge.java
index a060ef0cc..e7e1355f3 100644
--- a/core/src/main/java/org/apache/calcite/util/graph/DefaultEdge.java
+++ b/core/src/main/java/org/apache/calcite/util/graph/DefaultEdge.java
@@ -18,7 +18,7 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /** Default implementation of Edge. */
 public class DefaultEdge {
@@ -26,8 +26,8 @@ public class DefaultEdge {
   public final Object target;
 
   public DefaultEdge(Object source, Object target) {
-    this.source = Objects.requireNonNull(source, "source");
-    this.target = Objects.requireNonNull(target, "target");
+    this.source = requireNonNull(source, "source");
+    this.target = requireNonNull(target, "target");
   }
 
   @Override public int hashCode() {
diff --git a/core/src/main/java/org/apache/calcite/util/graph/Graphs.java b/core/src/main/java/org/apache/calcite/util/graph/Graphs.java
index c2fbae549..15fd74dee 100644
--- a/core/src/main/java/org/apache/calcite/util/graph/Graphs.java
+++ b/core/src/main/java/org/apache/calcite/util/graph/Graphs.java
@@ -22,13 +22,13 @@
 
 import java.util.AbstractList;
 import java.util.ArrayList;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import static java.util.Comparator.comparingInt;
 import static java.util.Objects.requireNonNull;
 
 /** Miscellaneous graph utilities. */
@@ -117,7 +117,7 @@ public List<List<V>> getPaths(V from, V to) {
         list.add(ImmutableList.of(from));
       }
       findPaths(from, to, list);
-      list.sort(Comparator.comparingInt(List::size));
+      list.sort(comparingInt(List::size));
       return list;
     }
 
@@ -162,7 +162,7 @@ private void findPathsExcluding(
           if (target.equals(to)) {
             // We found a path.
             prefix.add(target);
-            list.add(ImmutableList.copyOf(prefix));
+            list.add(prefix);
             prefix.remove(prefix.size() - 1);
           } else if (excludedNodes.contains(target)) {
             // ignore it
diff --git a/core/src/main/java/org/apache/calcite/util/javac/JaninoCompiler.java b/core/src/main/java/org/apache/calcite/util/javac/JaninoCompiler.java
index fbe4c35f9..053cc255d 100644
--- a/core/src/main/java/org/apache/calcite/util/javac/JaninoCompiler.java
+++ b/core/src/main/java/org/apache/calcite/util/javac/JaninoCompiler.java
@@ -27,10 +27,10 @@
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.nio.charset.StandardCharsets;
 import java.util.HashMap;
 import java.util.Map;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -69,8 +69,7 @@ public JaninoCompiler() {}
     }
 
     Map<String, byte[]> sourceMap = new HashMap<>();
-    sourceMap.put(
-        ClassFile.getSourceResourceName(fullClassName), source.getBytes(StandardCharsets.UTF_8));
+    sourceMap.put(ClassFile.getSourceResourceName(fullClassName), source.getBytes(UTF_8));
     MapResourceFinder sourceFinder = new MapResourceFinder(sourceMap);
 
     AccountingClassLoader classLoader =
diff --git a/core/src/main/java/org/apache/calcite/util/mapping/AbstractSourceMapping.java b/core/src/main/java/org/apache/calcite/util/mapping/AbstractSourceMapping.java
index cd144ac38..dd7b185ca 100644
--- a/core/src/main/java/org/apache/calcite/util/mapping/AbstractSourceMapping.java
+++ b/core/src/main/java/org/apache/calcite/util/mapping/AbstractSourceMapping.java
@@ -56,8 +56,8 @@ protected AbstractSourceMapping(int sourceCount, int targetCount) {
     return MappingType.INVERSE_PARTIAL_FUNCTION;
   }
 
-  @SuppressWarnings("method.invocation.invalid")
-  @Override public Iterator<IntPair> iterator() {
+  @Override @SuppressWarnings("method.invocation.invalid")
+  public Iterator<IntPair> iterator() {
     return new Iterator<IntPair>() {
       int source;
       int target = -1;
diff --git a/core/src/main/java/org/apache/calcite/util/mapping/AbstractTargetMapping.java b/core/src/main/java/org/apache/calcite/util/mapping/AbstractTargetMapping.java
index cbe88fc5a..8378955c9 100644
--- a/core/src/main/java/org/apache/calcite/util/mapping/AbstractTargetMapping.java
+++ b/core/src/main/java/org/apache/calcite/util/mapping/AbstractTargetMapping.java
@@ -56,8 +56,8 @@ protected AbstractTargetMapping(int sourceCount, int targetCount) {
     return MappingType.PARTIAL_FUNCTION;
   }
 
-  @SuppressWarnings("method.invocation.invalid")
-  @Override public Iterator<IntPair> iterator() {
+  @Override @SuppressWarnings("method.invocation.invalid")
+  public Iterator<IntPair> iterator() {
     return new Iterator<IntPair>() {
       int source = -1;
       int target;
diff --git a/core/src/main/java/org/apache/calcite/util/mapping/MappingType.java b/core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
index 2e6bca2a6..5727d427e 100644
--- a/core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
+++ b/core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
@@ -162,22 +162,22 @@ public boolean isBijection() {
 
   /** Constraint that every source has at least one target. */
   public boolean isMandatoryTarget() {
-    return !((ordinal() & OPTIONAL_TARGET) == OPTIONAL_TARGET);
+    return (ordinal() & OPTIONAL_TARGET) != OPTIONAL_TARGET;
   }
 
   /** Constraint that every source has at most one target. */
   public boolean isSingleTarget() {
-    return !((ordinal() & MULTIPLE_TARGET) == MULTIPLE_TARGET);
+    return (ordinal() & MULTIPLE_TARGET) != MULTIPLE_TARGET;
   }
 
   /** Constraint that every target has at least one source. */
   public boolean isMandatorySource() {
-    return !((ordinal() & OPTIONAL_SOURCE) == OPTIONAL_SOURCE);
+    return (ordinal() & OPTIONAL_SOURCE) != OPTIONAL_SOURCE;
   }
 
   /** Constraint that every target has at most one source. */
   public boolean isSingleSource() {
-    return !((ordinal() & MULTIPLE_SOURCE) == MULTIPLE_SOURCE);
+    return (ordinal() & MULTIPLE_SOURCE) != MULTIPLE_SOURCE;
   }
 
   /** Allow less than one source for a given target. */
diff --git a/core/src/main/java/org/apache/calcite/util/mapping/Mappings.java b/core/src/main/java/org/apache/calcite/util/mapping/Mappings.java
index 76a92d06e..d615ef46a 100644
--- a/core/src/main/java/org/apache/calcite/util/mapping/Mappings.java
+++ b/core/src/main/java/org/apache/calcite/util/mapping/Mappings.java
@@ -37,6 +37,10 @@
 import java.util.Map;
 import java.util.function.IntFunction;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Utility functions related to mappings.
  *
@@ -105,9 +109,7 @@ public static Mapping invert(Mapping mapping) {
    * @return Mapping mapping3 such that mapping1 = mapping2 . mapping3
    */
   public static Mapping divide(Mapping mapping1, Mapping mapping2) {
-    if (mapping1.getSourceCount() != mapping2.getSourceCount()) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(mapping1.getSourceCount() == mapping2.getSourceCount());
     Mapping remaining =
         create(
             MappingType.INVERSE_SURJECTION, mapping2.getTargetCount(), mapping1.getTargetCount());
@@ -132,9 +134,7 @@ public static Mapping divide(Mapping mapping1, Mapping mapping2) {
    * @return Mapping mapping3 such that mapping1 = mapping2 . mapping3
    */
   public static Mapping multiply(Mapping mapping1, Mapping mapping2) {
-    if (mapping1.getTargetCount() != mapping2.getSourceCount()) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(mapping1.getTargetCount() == mapping2.getSourceCount());
     Mapping product =
         create(
             MappingType.INVERSE_SURJECTION, mapping1.getSourceCount(), mapping2.getTargetCount());
@@ -319,10 +319,7 @@ public static List<Integer> asListNonNull(final TargetMapping mapping) {
     return new AbstractList<Integer>() {
       @Override public Integer get(int source) {
         int target = mapping.getTargetOpt(source);
-        if (target < 0) {
-          throw new IllegalArgumentException(
-              "Element " + source + " is not found in mapping " + mapping);
-        }
+        checkArgument(target >= 0, "Element %s is not found in mapping %s", source, mapping);
         return target;
       }
 
@@ -404,9 +401,7 @@ public static Mapping bijection(Map<Integer, Integer> targets) {
     int[] ints = new int[targets.size()];
     for (int i = 0; i < targets.size(); i++) {
       Integer value = targets.get(i);
-      if (value == null) {
-        throw new NullPointerException("Index " + i + " is not mapped in " + targets);
-      }
+      requireNonNull(value, "Index " + i + " is not mapped in " + targets);
       ints[i] = value;
     }
     return new Permutation(ints);
@@ -620,9 +615,7 @@ public static TargetMapping offsetSource(final TargetMapping mapping, final int
    */
   public static TargetMapping offsetSource(
       final TargetMapping mapping, final int offset, final int sourceCount) {
-    if (sourceCount < mapping.getSourceCount() + offset) {
-      throw new IllegalArgumentException("new source count too low");
-    }
+    checkArgument(sourceCount >= mapping.getSourceCount() + offset, "new source count too low");
     return target(
         (IntFunction<@Nullable Integer>)
             source -> {
@@ -662,9 +655,7 @@ public static TargetMapping offsetTarget(final TargetMapping mapping, final int
    */
   public static TargetMapping offsetTarget(
       final TargetMapping mapping, final int offset, final int targetCount) {
-    if (targetCount < mapping.getTargetCount() + offset) {
-      throw new IllegalArgumentException("new target count too low");
-    }
+    checkArgument(targetCount >= mapping.getTargetCount() + offset, "new target count too low");
     return target(
         (IntFunction<@Nullable Integer>)
             source -> {
@@ -690,9 +681,7 @@ public static TargetMapping offsetTarget(
    */
   public static TargetMapping offset(
       final TargetMapping mapping, final int offset, final int sourceCount) {
-    if (sourceCount < mapping.getSourceCount() + offset) {
-      throw new IllegalArgumentException("new source count too low");
-    }
+    checkArgument(sourceCount >= mapping.getSourceCount() + offset, "new source count too low");
     return target(
         (IntFunction<@Nullable Integer>)
             source -> {
@@ -1311,10 +1300,7 @@ static class SurjectionWithInverse extends PartialMapping {
     @Override public void set(int source, int target) {
       assert isValid();
       final int prevTarget = targets[source];
-      if (prevTarget != -1) {
-        throw new IllegalArgumentException(
-            "source #" + source + " is already mapped to target #" + target);
-      }
+      checkArgument(prevTarget == -1, "source #%s is already mapped to target #%s", source, target);
       targets[source] = target;
       sources[target] = source;
     }
@@ -1568,15 +1554,11 @@ private static class PartialFunctionImpl extends AbstractMapping implements Targ
 
     PartialFunctionImpl(int sourceCount, int targetCount, MappingType mappingType) {
       super();
-      if (sourceCount < 0) {
-        throw new IllegalArgumentException("Sources must be finite");
-      }
+      checkArgument(sourceCount >= 0, "Sources must be finite");
       this.sourceCount = sourceCount;
       this.targetCount = targetCount;
       this.mappingType = mappingType;
-      if (!mappingType.isSingleTarget()) {
-        throw new IllegalArgumentException("Must have at most one target");
-      }
+      checkArgument(mappingType.isSingleTarget(), "Must have at most one target");
       this.targets = new int[sourceCount];
       Arrays.fill(targets, -1);
     }
@@ -1603,8 +1585,8 @@ private static class PartialFunctionImpl extends AbstractMapping implements Targ
       return size;
     }
 
-    @SuppressWarnings("method.invocation.invalid")
-    @Override public Iterator<IntPair> iterator() {
+    @Override @SuppressWarnings("method.invocation.invalid")
+    public Iterator<IntPair> iterator() {
       return new Iterator<IntPair>() {
         int i = -1;
 
@@ -1649,12 +1631,11 @@ private void advance() {
     }
 
     @Override public void set(int source, int target) {
-      if ((target < 0) && mappingType.isMandatorySource()) {
-        throw new IllegalArgumentException("Target is required");
-      }
-      if ((target >= targetCount) && (targetCount >= 0)) {
-        throw new IllegalArgumentException("Target must be less than target count, " + targetCount);
-      }
+      checkArgument(target >= 0 || !mappingType.isMandatorySource(), "Target is required");
+      checkArgument(
+          target < targetCount || targetCount < 0,
+          "Target must be less than target count, %s",
+          targetCount);
       targets[source] = target;
     }
 
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java b/druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java
index 3b4e819ad..8cc966df8 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java
@@ -23,6 +23,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Binary operator conversion utility class; used to convert expressions like {@code exp1 Operator
  * exp2}.
@@ -49,12 +51,10 @@ public BinaryOperatorConversion(final SqlOperator operator, final String druidOp
     if (druidExpressions == null) {
       return null;
     }
-    if (druidExpressions.size() != 2) {
-      throw new IllegalStateException(
-          DruidQuery.format(
-              "Got binary operator[%s] with %s args?",
-              operator.getName(), druidExpressions.size()));
-    }
+    checkState(
+        druidExpressions.size() == 2,
+        DruidQuery.format(
+            "Got binary operator[%s] with %s args?", operator.getName(), druidExpressions.size()));
 
     return DruidQuery.format(
         "(%s %s %s)", druidExpressions.get(0), druidOperator, druidExpressions.get(1));
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java b/druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java
index cc05cc861..4025cce4c 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java
@@ -19,6 +19,8 @@
 import org.apache.calcite.rel.core.AggregateCall;
 import org.apache.calcite.sql.SqlKind;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Stores information about available complex metrics in the Druid Adapter. */
 public class ComplexMetric {
 
@@ -35,9 +37,7 @@ public ComplexMetric(String metricName, DruidType type) {
   }
 
   private static void validate(DruidType type) {
-    if (!type.isComplex()) {
-      throw new IllegalArgumentException("Druid type: " + type + " is not complex");
-    }
+    checkArgument(type.isComplex(), "Druid type: %s is not complex", type);
   }
 
   public String getMetricName() {
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DefaultDimensionSpec.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DefaultDimensionSpec.java
index 7abfa38b5..a7ae5f2eb 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DefaultDimensionSpec.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DefaultDimensionSpec.java
@@ -19,7 +19,8 @@
 import com.fasterxml.jackson.core.JsonGenerator;
 
 import java.io.IOException;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Default implementation of DimensionSpec.
@@ -34,8 +35,8 @@ public class DefaultDimensionSpec implements DimensionSpec {
   private final DruidType outputType;
 
   public DefaultDimensionSpec(String dimension, String outputName, DruidType outputType) {
-    this.dimension = Objects.requireNonNull(dimension, "dimension");
-    this.outputName = Objects.requireNonNull(outputName, "outputName");
+    this.dimension = requireNonNull(dimension, "dimension");
+    this.outputName = requireNonNull(outputName, "outputName");
     this.outputType = outputType == null ? DruidType.STRING : outputType;
   }
 
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
index af22fd4d2..122f444a9 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidConnectionImpl.java
@@ -43,7 +43,6 @@
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.charset.StandardCharsets;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
@@ -52,7 +51,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
-import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.BlockingQueue;
@@ -63,6 +61,9 @@
 import static org.apache.calcite.util.DateTimeStringUtils.ISO_DATETIME_FRACTIONAL_SECOND_FORMAT;
 import static org.apache.calcite.util.DateTimeStringUtils.getDateFormatter;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Objects.requireNonNull;
+
 /** Implementation of {@link DruidConnection}. */
 class DruidConnectionImpl implements DruidConnection {
   private final String url;
@@ -78,8 +79,8 @@ class DruidConnectionImpl implements DruidConnection {
   }
 
   DruidConnectionImpl(String url, String coordinatorUrl) {
-    this.url = Objects.requireNonNull(url, "url");
-    this.coordinatorUrl = Objects.requireNonNull(coordinatorUrl, "coordinatorUrl");
+    this.url = requireNonNull(url, "url");
+    this.coordinatorUrl = requireNonNull(coordinatorUrl, "coordinatorUrl");
   }
 
   /**
@@ -126,8 +127,7 @@ private static void parse(
     if (CalciteSystemProperty.DEBUG.value()) {
       try {
         final byte[] bytes = AvaticaUtils.readFullyToBytes(in);
-        System.out.println(
-            "Response: " + new String(bytes, StandardCharsets.UTF_8)); // CHECKSTYLE: IGNORE 0
+        System.out.println("Response: " + new String(bytes, UTF_8)); // CHECKSTYLE: IGNORE 0
         in = new ByteArrayInputStream(bytes);
       } catch (IOException e) {
         throw new RuntimeException(e);
@@ -561,8 +561,8 @@ public Enumerable<Row> enumerable(
                 enumerator.done.set(true);
               }
 
-              @SuppressWarnings("deprecation")
-              @Override public void setSourceEnumerable(Enumerable<Row> enumerable)
+              @Override @SuppressWarnings("deprecation")
+              public void setSourceEnumerable(Enumerable<Row> enumerable)
                   throws InterruptedException {
                 for (Row row : enumerable) {
                   send(row);
@@ -676,8 +676,7 @@ private static InputStream traceResponse(InputStream in) {
       try {
         final byte[] bytes = AvaticaUtils.readFullyToBytes(in);
         in.close();
-        System.out.println(
-            "Response: " + new String(bytes, StandardCharsets.UTF_8)); // CHECKSTYLE: IGNORE 0
+        System.out.println("Response: " + new String(bytes, UTF_8)); // CHECKSTYLE: IGNORE 0
         in = new ByteArrayInputStream(bytes);
       } catch (IOException e) {
         throw new RuntimeException(e);
@@ -745,7 +744,7 @@ static class Page {
   }
 
   /** Result of a "segmentMetadata" call, populated by Jackson. */
-  @SuppressWarnings({"WeakerAccess", "unused"})
+  @SuppressWarnings({"unused", "WeakerAccess"})
   private static class JsonSegmentMetadata {
     public String id;
     public List<String> intervals;
@@ -759,7 +758,7 @@ private static class JsonSegmentMetadata {
    * Element of the "columns" collection in the result of a "segmentMetadata" call, populated by
    * Jackson.
    */
-  @SuppressWarnings({"WeakerAccess", "unused"})
+  @SuppressWarnings({"unused", "WeakerAccess"})
   private static class JsonColumn {
     public String type;
     public boolean hasMultipleValues;
@@ -772,7 +771,7 @@ private static class JsonColumn {
    * Element of the "aggregators" collection in the result of a "segmentMetadata" call, populated by
    * Jackson.
    */
-  @SuppressWarnings({"WeakerAccess", "unused"})
+  @SuppressWarnings({"unused", "WeakerAccess"})
   private static class JsonAggregator {
     public String type;
     public String name;
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java
index 351f09243..9cb7bf805 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java
@@ -98,7 +98,7 @@ protected static List<Interval> toInterval(List<Range<Long>> ranges) {
               return new Interval(start, end, ISOChronology.getInstanceUTC());
             });
     if (LOGGER.isDebugEnabled()) {
-      LOGGER.debug("Converted time ranges " + ranges + " to interval " + intervals);
+      LOGGER.debug("Converted time ranges {} to interval {}", ranges, intervals);
     }
     return intervals;
   }
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
index b48285202..547b81c98 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
@@ -39,11 +39,12 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
-import java.util.Objects;
 
 import static org.apache.calcite.util.DateTimeStringUtils.ISO_DATETIME_FRACTIONAL_SECOND_FORMAT;
 import static org.apache.calcite.util.DateTimeStringUtils.getDateFormatter;
 
+import static java.util.Objects.requireNonNull;
+
 /** Filter element of a Druid "groupBy" or "topN" query. */
 abstract class DruidJsonFilter implements DruidJson {
 
@@ -237,7 +238,7 @@ abstract class DruidJsonFilter implements DruidJson {
     if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {
       val = String.valueOf(RexLiteral.value(rhsLiteral));
     } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {
-      val = String.valueOf(RexLiteral.stringValue(rhsLiteral));
+      val = RexLiteral.stringValue(rhsLiteral);
     } else if (SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE == rhsLiteral.getTypeName()
         || SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName()
         || SqlTypeName.DATE == rhsLiteral.getTypeName()) {
@@ -472,7 +473,7 @@ public static class JsonExpressionFilter extends DruidJsonFilter {
 
     JsonExpressionFilter(String expression) {
       super(Type.EXPRESSION);
-      this.expression = Objects.requireNonNull(expression, "expression");
+      this.expression = requireNonNull(expression, "expression");
     }
 
     @Override public void write(JsonGenerator generator) throws IOException {
@@ -630,7 +631,7 @@ protected JsonInFilter(
 
   public static DruidJsonFilter getSelectorFilter(
       String column, String value, ExtractionFunction extractionFunction) {
-    Objects.requireNonNull(column, "column");
+    requireNonNull(column, "column");
     return new JsonSelector(column, value, extractionFunction);
   }
 
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
index 84416a3dd..41e566ef0 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
@@ -88,6 +88,8 @@
 import java.util.TimeZone;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static java.util.Objects.requireNonNull;
 
 /** Relational expression representing a scan of a Druid data set. */
@@ -975,7 +977,7 @@ protected CalciteConnectionConfig getConnectionConfig() {
       } else {
         filterNode = null;
       }
-      if (aggCall.getArgList().size() == 0) {
+      if (aggCall.getArgList().isEmpty()) {
         fieldName = null;
         expression = null;
       } else {
@@ -1197,9 +1199,7 @@ protected QuerySpec getQuery(
             limit,
             havingJsonFilter);
 
-    if (groupByQuery == null) {
-      throw new IllegalStateException("Cannot plan Druid Query");
-    }
+    checkState(groupByQuery != null, "Cannot plan Druid Query");
     return new QuerySpec(QueryType.GROUP_BY, groupByQuery, queryOutputFieldNames);
   }
 
@@ -1310,9 +1310,9 @@ private static JsonLimit computeSort(
       writeFieldIf(generator, "filter", jsonFilter);
       writeField(generator, "aggregations", aggregations);
       writeFieldIf(
-          generator, "virtualColumns", virtualColumnList.size() > 0 ? virtualColumnList : null);
+          generator, "virtualColumns", !virtualColumnList.isEmpty() ? virtualColumnList : null);
       writeFieldIf(
-          generator, "postAggregations", postAggregations.size() > 0 ? postAggregations : null);
+          generator, "postAggregations", !postAggregations.isEmpty() ? postAggregations : null);
       writeField(generator, "intervals", intervals);
       generator.writeFieldName("context");
       // The following field is necessary to conform with SQL semantics (CALCITE-1589)
@@ -1365,12 +1365,12 @@ private static JsonLimit computeSort(
       writeField(generator, "granularity", Granularities.all());
       writeField(generator, "dimension", groupByKeyDims.get(0));
       writeFieldIf(
-          generator, "virtualColumns", virtualColumnList.size() > 0 ? virtualColumnList : null);
+          generator, "virtualColumns", !virtualColumnList.isEmpty() ? virtualColumnList : null);
       generator.writeStringField("metric", topNMetricColumnName);
       writeFieldIf(generator, "filter", jsonFilter);
       writeField(generator, "aggregations", aggregations);
       writeFieldIf(
-          generator, "postAggregations", postAggregations.size() > 0 ? postAggregations : null);
+          generator, "postAggregations", !postAggregations.isEmpty() ? postAggregations : null);
       writeField(generator, "intervals", intervals);
       generator.writeNumberField("threshold", limit.limit);
       generator.writeEndObject();
@@ -1400,12 +1400,12 @@ private static JsonLimit computeSort(
       writeField(generator, "granularity", Granularities.all());
       writeField(generator, "dimensions", groupByKeyDims);
       writeFieldIf(
-          generator, "virtualColumns", virtualColumnList.size() > 0 ? virtualColumnList : null);
+          generator, "virtualColumns", !virtualColumnList.isEmpty() ? virtualColumnList : null);
       writeFieldIf(generator, "limitSpec", limit);
       writeFieldIf(generator, "filter", jsonFilter);
       writeField(generator, "aggregations", aggregations);
       writeFieldIf(
-          generator, "postAggregations", postAggregations.size() > 0 ? postAggregations : null);
+          generator, "postAggregations", !postAggregations.isEmpty() ? postAggregations : null);
       writeField(generator, "intervals", intervals);
       writeFieldIf(
           generator,
@@ -1460,7 +1460,7 @@ public String toQuery() {
         writeField(generator, "intervals", intervals);
         writeFieldIf(generator, "filter", jsonFilter);
         writeFieldIf(
-            generator, "virtualColumns", virtualColumnList.size() > 0 ? virtualColumnList : null);
+            generator, "virtualColumns", !virtualColumnList.isEmpty() ? virtualColumnList : null);
         writeField(generator, "columns", columns);
         generator.writeStringField("resultFormat", "compactedList");
         if (fetchLimit != null) {
@@ -1657,7 +1657,7 @@ public static class QuerySpec {
     QuerySpec(QueryType queryType, String queryString, List<String> fieldNames) {
       this.queryType = requireNonNull(queryType, "queryType");
       this.queryString = requireNonNull(queryString, "queryString");
-      this.fieldNames = ImmutableList.copyOf(fieldNames);
+      this.fieldNames = fieldNames;
     }
 
     @Override public int hashCode() {
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
index efc387f13..580b19f4c 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
@@ -58,14 +58,12 @@
 import org.apache.commons.lang3.tuple.Triple;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
 import org.immutables.value.Value;
 import org.joda.time.Interval;
 import org.slf4j.Logger;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -415,7 +413,7 @@ private static Pair<List<RexNode>, List<RexNode>> splitProjects(
       }
       final List<RexNode> belowNodes = new ArrayList<>();
       final List<RelDataType> belowTypes = new ArrayList<>();
-      final List<Integer> positions = Lists.newArrayList(visitor.inputPosReferenced);
+      final List<Integer> positions = new ArrayList<>(visitor.inputPosReferenced);
       for (int i : positions) {
         final RexNode node = rexBuilder.makeInputRef(input, i);
         belowNodes.add(node);
@@ -606,7 +604,7 @@ protected DruidAggregateProjectRule(DruidAggregateProjectRuleConfig config) {
           aggregate.copy(aggregate.getTraitSet(), ImmutableList.of(newProject));
       List<Integer> filterRefs = getFilterRefs(aggregate.getAggCallList());
       final DruidQuery query2;
-      if (filterRefs.size() > 0) {
+      if (!filterRefs.isEmpty()) {
         query2 =
             optimizeFilteredAggregations(
                 call, query, (Project) newProject, (Aggregate) newAggregate);
@@ -670,7 +668,7 @@ private static DruidQuery optimizeFilteredAggregations(
       Set<Integer> uniqueFilterRefs = getUniqueFilterRefs(aggregate.getAggCallList());
 
       // One of the pre-conditions for this method
-      assert uniqueFilterRefs.size() > 0;
+      assert !uniqueFilterRefs.isEmpty();
 
       List<AggregateCall> newCalls = new ArrayList<>();
 
@@ -766,7 +764,7 @@ private static List<RelNode> constructNewNodes(
         // This is required so that each RelNode is linked to the one before it
         if (startIndex < oldNodes.size()) {
           RelNode next = oldNodes.get(startIndex);
-          newNodes.add(next.copy(next.getTraitSet(), Collections.singletonList(filter)));
+          newNodes.add(next.copy(next.getTraitSet(), ImmutableList.of(filter)));
           startIndex++;
         }
       }
@@ -778,7 +776,7 @@ private static List<RelNode> constructNewNodes(
 
       // Add the trailing nodes (need to link them)
       for (RelNode node : trailingNodes) {
-        newNodes.add(node.copy(node.getTraitSet(), Collections.singletonList(Util.last(newNodes))));
+        newNodes.add(node.copy(node.getTraitSet(), ImmutableList.of(Util.last(newNodes))));
       }
 
       return newNodes;
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java
index a470aea58..90a8d552e 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java
@@ -23,7 +23,6 @@
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 
 import java.util.HashMap;
@@ -31,9 +30,10 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.util.Objects.requireNonNull;
+
 /** Schema mapped onto a Druid instance. */
 public class DruidSchema extends AbstractSchema {
   final String url;
@@ -50,8 +50,8 @@ public class DruidSchema extends AbstractSchema {
    *     explicitly in the model
    */
   public DruidSchema(String url, String coordinatorUrl, boolean discoverTables) {
-    this.url = Objects.requireNonNull(url, "url");
-    this.coordinatorUrl = Objects.requireNonNull(coordinatorUrl, "coordinatorUrl");
+    this.url = requireNonNull(url, "url");
+    this.coordinatorUrl = requireNonNull(coordinatorUrl, "coordinatorUrl");
     this.discoverTables = discoverTables;
   }
 
@@ -66,7 +66,7 @@ public DruidSchema(String url, String coordinatorUrl, boolean discoverTables) {
 
       tableMap =
           Maps.asMap(
-              ImmutableSet.copyOf(tableNames),
+              tableNames,
               CacheBuilder.newBuilder().build(CacheLoader.from(name -> table(name, connection))));
     }
 
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchemaFactory.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchemaFactory.java
index 958588214..85175e417 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchemaFactory.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchemaFactory.java
@@ -62,7 +62,7 @@ public class DruidSchemaFactory implements SchemaFactory {
     // "tables" is a hidden attribute, copied in from the enclosing custom
     // schema
     final boolean containsTables =
-        operand.get("tables") instanceof List && ((List) operand.get("tables")).size() > 0;
+        operand.get("tables") instanceof List && !((List) operand.get("tables")).isEmpty();
     return new DruidSchema(url, coordinatorUrl, !containsTables);
   }
 }
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
index b0b1d24b0..5285034bb 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
@@ -37,7 +37,6 @@
 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
 import org.apache.calcite.sql.type.SqlTypeName;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -50,9 +49,12 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /** Table mapped onto a Druid table. */
 public class DruidTable extends AbstractTable implements TranslatableTable {
 
@@ -90,9 +92,9 @@ public DruidTable(
       List<Interval> intervals,
       Map<String, List<ComplexMetric>> complexMetrics,
       Map<String, SqlTypeName> allFields) {
-    this.timestampFieldName = Objects.requireNonNull(timestampFieldName, "timestampFieldName");
-    this.schema = Objects.requireNonNull(schema, "schema");
-    this.dataSource = Objects.requireNonNull(dataSource, "dataSource");
+    this.timestampFieldName = requireNonNull(timestampFieldName, "timestampFieldName");
+    this.schema = requireNonNull(schema, "schema");
+    this.dataSource = requireNonNull(dataSource, "dataSource");
     this.protoRowType = protoRowType;
     this.metricFieldNames = ImmutableSet.copyOf(metricFieldNames);
     this.intervals =
@@ -165,7 +167,7 @@ static Table create(
         druidSchema,
         dataSourceName,
         new MapRelProtoDataType(fields, timestampColumnName),
-        ImmutableSet.copyOf(metricNameSet),
+        metricNameSet,
         timestampColumnName,
         intervals,
         complexMetrics,
@@ -251,8 +253,8 @@ public boolean isComplexMetric(String alias) {
   @Override public RelDataType getRowType(RelDataTypeFactory typeFactory) {
     final RelDataType rowType = protoRowType.apply(typeFactory);
     final List<String> fieldNames = rowType.getFieldNames();
-    Preconditions.checkArgument(fieldNames.contains(timestampFieldName));
-    Preconditions.checkArgument(fieldNames.containsAll(metricFieldNames));
+    checkArgument(fieldNames.contains(timestampFieldName));
+    checkArgument(fieldNames.containsAll(metricFieldNames));
     return rowType;
   }
 
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java
index 7cb068e0e..015efd257 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java
@@ -37,6 +37,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Implementation of {@link TableFactory} for Druid.
  *
@@ -62,9 +64,7 @@ private DruidTableFactory() {}
     if (timestampInfo != null) {
       if (timestampInfo instanceof Map) {
         Map map = (Map) timestampInfo;
-        if (!(map.get("name") instanceof String)) {
-          throw new IllegalArgumentException("timestampColumn array must have name");
-        }
+        checkArgument((map.get("name") instanceof String), "timestampColumn array must have name");
         timestampColumnName = (String) map.get("name");
         if (!(map.get("type") instanceof String)
             || map.get("type").equals("timestamp with local time zone")) {
@@ -113,9 +113,7 @@ private DruidTableFactory() {}
 
         if (metric instanceof Map) {
           Map map2 = (Map) metric;
-          if (!(map2.get("name") instanceof String)) {
-            throw new IllegalArgumentException("metric must have name");
-          }
+          checkArgument((map2.get("name") instanceof String), "metric must have name");
           metricName = (String) map2.get("name");
 
           final String type = (String) map2.get("type");
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/ExtractionDimensionSpec.java b/druid/src/main/java/org/apache/calcite/adapter/druid/ExtractionDimensionSpec.java
index b067f63f6..88c8ac0b8 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/ExtractionDimensionSpec.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/ExtractionDimensionSpec.java
@@ -21,12 +21,13 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.io.IOException;
-import java.util.Objects;
 
 import static org.apache.calcite.adapter.druid.DruidQuery.writeField;
 import static org.apache.calcite.adapter.druid.DruidQuery.writeFieldIf;
 import static org.apache.calcite.util.DateTimeStringUtils.ISO_DATETIME_FRACTIONAL_SECOND_FORMAT;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Implementation of extraction function DimensionSpec.
  *
@@ -49,8 +50,8 @@ public ExtractionDimensionSpec(
       ExtractionFunction extractionFunction,
       String outputName,
       DruidType outputType) {
-    this.dimension = Objects.requireNonNull(dimension, "dimension");
-    this.extractionFunction = Objects.requireNonNull(extractionFunction, "extractionFunction");
+    this.dimension = requireNonNull(dimension, "dimension");
+    this.extractionFunction = requireNonNull(extractionFunction, "extractionFunction");
     this.outputName = outputName;
     this.outputType = outputType == null ? DruidType.STRING : outputType;
   }
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/Granularities.java b/druid/src/main/java/org/apache/calcite/adapter/druid/Granularities.java
index b0a51f8ab..3aee3bff7 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/Granularities.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/Granularities.java
@@ -21,10 +21,11 @@
 import com.fasterxml.jackson.core.JsonGenerator;
 
 import java.io.IOException;
-import java.util.Objects;
 
 import static org.apache.calcite.adapter.druid.DruidQuery.writeFieldIf;
 
+import static java.util.Objects.requireNonNull;
+
 /** Factory methods and helpers for {@link Granularity}. */
 public class Granularities {
   // Private constructor for utility class
@@ -87,9 +88,9 @@ private static class PeriodGranularity implements Granularity {
     private final String timeZone;
 
     private PeriodGranularity(Type type, String period, String timeZone) {
-      this.type = Objects.requireNonNull(type, "type");
-      this.period = Objects.requireNonNull(period, "period");
-      this.timeZone = Objects.requireNonNull(timeZone, "timeZone");
+      this.type = requireNonNull(type, "type");
+      this.period = requireNonNull(period, "period");
+      this.timeZone = requireNonNull(timeZone, "timeZone");
     }
 
     @Override public void write(JsonGenerator generator) throws IOException {
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/NaryOperatorConverter.java b/druid/src/main/java/org/apache/calcite/adapter/druid/NaryOperatorConverter.java
index 2c2c77a4c..a16cc0cf5 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/NaryOperatorConverter.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/NaryOperatorConverter.java
@@ -24,7 +24,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Converts Calcite n-ary operators to Druid expressions, for example {@code arg1 Op arg2 Op arg3}.
@@ -34,8 +35,8 @@ public class NaryOperatorConverter implements DruidSqlOperatorConverter {
   private final String druidOperatorName;
 
   public NaryOperatorConverter(SqlOperator operator, String druidOperatorName) {
-    this.operator = Objects.requireNonNull(operator, "operator");
-    this.druidOperatorName = Objects.requireNonNull(druidOperatorName, "druidOperatorName");
+    this.operator = requireNonNull(operator, "operator");
+    this.druidOperatorName = requireNonNull(druidOperatorName, "druidOperatorName");
   }
 
   @Override public SqlOperator calciteOperator() {
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/VirtualColumn.java b/druid/src/main/java/org/apache/calcite/adapter/druid/VirtualColumn.java
index ca0f837a0..bc0cf0f58 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/VirtualColumn.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/VirtualColumn.java
@@ -20,10 +20,11 @@
 
 import java.io.IOException;
 import java.util.Locale;
-import java.util.Objects;
 
 import static org.apache.calcite.adapter.druid.DruidQuery.writeFieldIf;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Druid Json Expression based Virtual Column. Virtual columns is used as "projection" concept
  * throughout Druid using expression.
@@ -36,8 +37,8 @@ public class VirtualColumn implements DruidJson {
   private final DruidType outputType;
 
   public VirtualColumn(String name, String expression, DruidType outputType) {
-    this.name = Objects.requireNonNull(name, "name");
-    this.expression = Objects.requireNonNull(expression, "expression");
+    this.name = requireNonNull(name, "name");
+    this.expression = requireNonNull(expression, "expression");
     this.outputType = outputType == null ? DruidType.FLOAT : outputType;
   }
 
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchEnumerators.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchEnumerators.java
index 8393b88dd..2fc6f6675 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchEnumerators.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchEnumerators.java
@@ -23,7 +23,8 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Util functions which convert {@link ElasticsearchJson.SearchHit} into calcite specific return
@@ -98,7 +99,7 @@ private static Function1<ElasticsearchJson.SearchHit, Object[]> listGetter(
 
   static Function1<ElasticsearchJson.SearchHit, Object> getter(
       List<Map.Entry<String, Class>> fields, Map<String, String> mapping) {
-    Objects.requireNonNull(fields, "fields");
+    requireNonNull(fields, "fields");
     //noinspection unchecked
     final Function1 getter;
     if (fields.size() == 1) {
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
index 8c6cbef1f..a8f6e5cf0 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
@@ -36,7 +36,8 @@
 import java.io.StringWriter;
 import java.io.UncheckedIOException;
 import java.util.Iterator;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Implementation of a {@link org.apache.calcite.rel.core.Filter} relational expression in
@@ -79,7 +80,7 @@ static class PredicateAnalyzerTranslator {
     private final ObjectMapper mapper;
 
     PredicateAnalyzerTranslator(final ObjectMapper mapper) {
-      this.mapper = Objects.requireNonNull(mapper, "mapper");
+      this.mapper = requireNonNull(mapper, "mapper");
     }
 
     String translateMatch(RexNode condition)
@@ -102,7 +103,7 @@ String translateMatch(RexNode condition)
       }
       generator.flush();
       generator.close();
-      return "{\"query\" : " + writer.toString() + "}";
+      return "{\"query\" : " + writer + "}";
     }
   }
 }
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java
index 1c3c91d9d..204bf5772 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java
@@ -27,13 +27,13 @@
 import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 
 import java.io.IOException;
 import java.time.Duration;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Deque;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -48,7 +48,11 @@
 import java.util.function.Predicate;
 import java.util.stream.StreamSupport;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Collections.unmodifiableList;
 import static java.util.Collections.unmodifiableMap;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Internal objects (and deserializers) used to parse Elasticsearch results (which are in JSON
@@ -63,8 +67,8 @@ private ElasticsearchJson() {}
 
   /** Visits leaves of the aggregation where all values are stored. */
   static void visitValueNodes(Aggregations aggregations, Consumer<Map<String, Object>> consumer) {
-    Objects.requireNonNull(aggregations, "aggregations");
-    Objects.requireNonNull(consumer, "consumer");
+    requireNonNull(aggregations, "aggregations");
+    requireNonNull(consumer, "consumer");
 
     Map<RowKey, List<MultiValue>> rows = new LinkedHashMap<>();
 
@@ -73,7 +77,7 @@ static void visitValueNodes(Aggregations aggregations, Consumer<Map<String, Obje
     aggregations.forEach(a -> visitValueNodes(a, new ArrayList<>(), cons));
     rows.forEach(
         (k, v) -> {
-          if (v.stream().allMatch(val -> val instanceof GroupValue)) {
+          if (v.stream().allMatch(GroupValue.class::isInstance)) {
             v.forEach(
                 tuple -> {
                   Map<String, Object> groupRow = new LinkedHashMap<>(k.keys);
@@ -95,14 +99,14 @@ static void visitValueNodes(Aggregations aggregations, Consumer<Map<String, Obje
    * represented as {@code foo.bar.qux}.
    */
   static void visitMappingProperties(ObjectNode mapping, BiConsumer<String, String> consumer) {
-    Objects.requireNonNull(mapping, "mapping");
-    Objects.requireNonNull(consumer, "consumer");
+    requireNonNull(mapping, "mapping");
+    requireNonNull(consumer, "consumer");
     visitMappingProperties(new ArrayDeque<>(), mapping, consumer);
   }
 
   private static void visitMappingProperties(
       Deque<String> path, ObjectNode mapping, BiConsumer<String, String> consumer) {
-    Objects.requireNonNull(mapping, "mapping");
+    requireNonNull(mapping, "mapping");
     if (mapping.isMissingNode()) {
       return;
     }
@@ -139,7 +143,7 @@ private static class RowKey {
     private final int hashCode;
 
     private RowKey(final Map<String, Object> keys) {
-      this.keys = Objects.requireNonNull(keys, "keys");
+      this.keys = requireNonNull(keys, "keys");
       this.hashCode = Objects.hashCode(keys);
     }
 
@@ -218,7 +222,7 @@ static class Result {
         @JsonProperty("aggregations") Aggregations aggregations,
         @JsonProperty("_scroll_id") String scrollId,
         @JsonProperty("took") long took) {
-      this.hits = Objects.requireNonNull(hits, "hits");
+      this.hits = requireNonNull(hits, "hits");
       this.aggregations = aggregations;
       this.scrollId = scrollId;
       this.took = took;
@@ -253,7 +257,7 @@ static class SearchHits {
         @JsonProperty("total") final SearchTotal total,
         @JsonProperty("hits") final List<SearchHit> hits) {
       this.total = total;
-      this.hits = Objects.requireNonNull(hits, "hits");
+      this.hits = requireNonNull(hits, "hits");
     }
 
     public List<SearchHit> hits() {
@@ -322,7 +326,7 @@ static class SearchHit {
         @JsonProperty(ElasticsearchConstants.ID) final String id,
         @JsonProperty("_source") final Map<String, Object> source,
         @JsonProperty("fields") final Map<String, Object> fields) {
-      this.id = Objects.requireNonNull(id, "id");
+      this.id = requireNonNull(id, "id");
 
       // both can't be null
       if (source == null && fields == null) {
@@ -353,7 +357,7 @@ public String id() {
     }
 
     Object valueOrNull(String name) {
-      Objects.requireNonNull(name, "name");
+      requireNonNull(name, "name");
 
       // for "select *" return whole document
       if (ElasticsearchConstants.isSelectAll(name)) {
@@ -428,7 +432,7 @@ static class Aggregations implements Iterable<Aggregation> {
     private Map<String, Aggregation> aggregationsAsMap;
 
     Aggregations(List<? extends Aggregation> aggregations) {
-      this.aggregations = Objects.requireNonNull(aggregations, "aggregations");
+      this.aggregations = requireNonNull(aggregations, "aggregations");
     }
 
     /** Iterates over the {@link Aggregation}s. */
@@ -438,7 +442,7 @@ static class Aggregations implements Iterable<Aggregation> {
 
     /** The list of {@link Aggregation}s. */
     final List<Aggregation> asList() {
-      return Collections.unmodifiableList(aggregations);
+      return unmodifiableList(aggregations);
     }
 
     /** Returns the {@link Aggregation}s keyed by aggregation name. Lazy init. */
@@ -516,8 +520,8 @@ static class Bucket implements HasAggregations, Aggregation {
 
     Bucket(final Object key, final String name, final Aggregations aggregations) {
       this.key = key; // key can be set after construction
-      this.name = Objects.requireNonNull(name, "name");
-      this.aggregations = Objects.requireNonNull(aggregations, "aggregations");
+      this.name = requireNonNull(name, "name");
+      this.aggregations = requireNonNull(aggregations, "aggregations");
     }
 
     /** Returns the key associated with the bucket. */
@@ -527,7 +531,7 @@ Object key() {
 
     /** Returns the key associated with the bucket as a string. */
     String keyAsString() {
-      return Objects.toString(key());
+      return String.valueOf(key());
     }
 
     /** Means current bucket has no aggregations. */
@@ -554,8 +558,8 @@ static class MultiValue implements Aggregation {
     private final Map<String, Object> values;
 
     MultiValue(final String name, final Map<String, Object> values) {
-      this.name = Objects.requireNonNull(name, "name");
-      this.values = Objects.requireNonNull(values, "values");
+      this.name = requireNonNull(name, "name");
+      this.values = requireNonNull(values, "values");
     }
 
     @Override public String getName() {
@@ -595,7 +599,7 @@ static class GroupValue extends MultiValue {
 
     /** Constructs a {@link GroupValue} instance with a single value. */
     static GroupValue of(String name, Object value) {
-      return new GroupValue(name, Collections.singletonMap("value", value));
+      return new GroupValue(name, ImmutableMap.of("value", value));
     }
   }
 
@@ -685,9 +689,7 @@ private static boolean isMissingBucket(JsonNode key) {
     private static Bucket parseBucket(JsonParser parser, String name, ObjectNode node)
         throws JsonProcessingException {
 
-      if (!node.has("key")) {
-        throw new IllegalArgumentException("No 'key' attribute for " + node);
-      }
+      checkArgument(node.has("key"), "No 'key' attribute for %s", node);
 
       final JsonNode keyNode = node.get("key");
       final Object key;
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java
index 445617541..0b478e283 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java
@@ -18,20 +18,21 @@
 
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
-import com.google.common.collect.ImmutableMap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.time.LocalDate;
-import java.time.ZoneOffset;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import static java.time.ZoneOffset.UTC;
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toMap;
+import static java.util.stream.Collectors.toSet;
+
 /**
  * Stores Elasticsearch <a
  * href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html">mapping</a>
@@ -47,13 +48,13 @@ class ElasticsearchMapping {
   private final Map<String, Datatype> mapping;
 
   ElasticsearchMapping(final String index, final Map<String, String> mapping) {
-    this.index = Objects.requireNonNull(index, "index");
-    Objects.requireNonNull(mapping, "mapping");
+    this.index = requireNonNull(index, "index");
+    requireNonNull(mapping, "mapping");
 
     final Map<String, Datatype> transformed =
         mapping.entrySet().stream()
-            .collect(Collectors.toMap(Map.Entry::getKey, e -> new Datatype(e.getValue())));
-    this.mapping = ImmutableMap.copyOf(transformed);
+            .collect(toMap(Map.Entry::getKey, e -> new Datatype(e.getValue())));
+    this.mapping = transformed;
   }
 
   /**
@@ -108,13 +109,13 @@ static class Datatype {
                 "string", // for ES2
                 "text", "keyword", "date", "long", "integer", "double", "float")
             .map(Datatype::missingValueForType)
-            .collect(Collectors.toSet());
+            .collect(toSet());
 
     private final String name;
     private final JsonNode missingValue;
 
     private Datatype(final String name) {
-      this.name = Objects.requireNonNull(name, "name");
+      this.name = requireNonNull(name, "name");
       this.missingValue = missingValueForType(name);
     }
 
@@ -151,7 +152,7 @@ private Datatype(final String name) {
         case "date":
           // sentinel for missing dates: 9999-12-31
           final long millisEpoch =
-              LocalDate.of(9999, 12, 31).atStartOfDay().toInstant(ZoneOffset.UTC).toEpochMilli();
+              LocalDate.of(9999, 12, 31).atStartOfDay().toInstant(UTC).toEpochMilli();
           // by default elastic returns dates as longs
           return FACTORY.numberNode(millisEpoch);
         default:
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java
index 5ddc100fa..fbb76f5e1 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java
@@ -35,7 +35,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /**
  * Implementation of {@link org.apache.calcite.rel.core.Project} relational expression in
@@ -116,7 +117,7 @@ public class ElasticsearchProject extends Project implements ElasticsearchRel {
               // _id field is available implicitly
               .filter(f -> !ElasticsearchConstants.ID.equals(f))
               .map(ElasticsearchRules::quote)
-              .collect(Collectors.toList());
+              .collect(toList());
 
       final String findString = String.join(", ", newList);
       query.append("\"_source\" : [").append(findString).append("]");
@@ -137,6 +138,6 @@ public class ElasticsearchProject extends Project implements ElasticsearchRel {
     }
 
     implementor.list.removeIf(l -> l.startsWith("\"_source\""));
-    implementor.add("{" + query.toString() + "}");
+    implementor.add("{" + query + "}");
   }
 }
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchRel.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchRel.java
index e506b2dc8..7f5f01184 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchRel.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchRel.java
@@ -27,7 +27,8 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Relational expression that uses Elasticsearch calling convention. */
 public interface ElasticsearchRel extends RelNode {
@@ -102,24 +103,24 @@ void add(String findOp) {
     }
 
     void addGroupBy(String field) {
-      Objects.requireNonNull(field, "field");
+      requireNonNull(field, "field");
       groupBy.add(field);
     }
 
     void addSort(String field, RelFieldCollation.Direction direction) {
-      Objects.requireNonNull(field, "field");
+      requireNonNull(field, "field");
       sort.add(new Pair<>(field, direction));
     }
 
     void addAggregation(String field, String expression) {
-      Objects.requireNonNull(field, "field");
-      Objects.requireNonNull(expression, "expression");
+      requireNonNull(field, "field");
+      requireNonNull(expression, "expression");
       aggregations.add(new Pair<>(field, expression));
     }
 
     void addExpressionItemMapping(String expressionId, String item) {
-      Objects.requireNonNull(expressionId, "expressionId");
-      Objects.requireNonNull(item, "item");
+      requireNonNull(expressionId, "expressionId");
+      requireNonNull(item, "item");
       expressionItemMap.put(expressionId, item);
     }
 
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
index 526409f8e..85c71959f 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
@@ -22,8 +22,8 @@
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 
 import org.elasticsearch.client.Request;
@@ -33,16 +33,18 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UncheckedIOException;
-import java.util.Collections;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toSet;
+
 /** Each table in the schema is an ELASTICSEARCH index. */
 public class ElasticsearchSchema extends AbstractSchema {
 
@@ -69,9 +71,9 @@ public ElasticsearchSchema(RestClient client, ObjectMapper mapper, String index)
   @VisibleForTesting
   ElasticsearchSchema(RestClient client, ObjectMapper mapper, String index, int fetchSize) {
     super();
-    this.client = Objects.requireNonNull(client, "client");
-    this.mapper = Objects.requireNonNull(mapper, "mapper");
-    Preconditions.checkArgument(fetchSize > 0, "invalid fetch size. Expected %s > 0", fetchSize);
+    this.client = requireNonNull(client, "client");
+    this.mapper = requireNonNull(mapper, "mapper");
+    checkArgument(fetchSize > 0, "invalid fetch size. Expected %s > 0", fetchSize);
     this.fetchSize = fetchSize;
 
     if (index == null) {
@@ -81,7 +83,7 @@ public ElasticsearchSchema(RestClient client, ObjectMapper mapper, String index)
         throw new UncheckedIOException("Couldn't get indices", e);
       }
     } else {
-      this.tableMap = createTables(Collections.singleton(index));
+      this.tableMap = createTables(ImmutableSet.of(index));
     }
   }
 
@@ -132,7 +134,7 @@ private Set<String> indicesFromElastic() throws IOException {
                   it ->
                       StreamSupport.stream(
                           Spliterators.spliteratorUnknownSize(it, Spliterator.ORDERED), false))
-              .collect(Collectors.toSet());
+              .collect(toSet());
       indices.addAll(aliases);
       return indices;
     }
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java
index 6ba29456d..7bd5b1220 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java
@@ -30,7 +30,6 @@
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.ObjectMapper;
-import com.google.common.base.Preconditions;
 import com.google.common.base.Strings;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -49,13 +48,16 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
-import java.util.stream.Collectors;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManager;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
+
 /**
  * Factory that creates an {@link ElasticsearchSchema}.
  *
@@ -135,8 +137,7 @@ public ElasticsearchSchemaFactory() {}
         final List<String> configHosts =
             mapper.readValue((String) map.get("hosts"), new TypeReference<List<String>>() {});
 
-        hosts =
-            configHosts.stream().map(host -> HttpHost.create(host)).collect(Collectors.toList());
+        hosts = configHosts.stream().map(HttpHost::create).collect(toList());
       } else if (map.containsKey("coordinates")) {
         final Map<String, Integer> coordinates =
             mapper.readValue(
@@ -145,7 +146,7 @@ public ElasticsearchSchemaFactory() {}
         hosts =
             coordinates.entrySet().stream()
                 .map(entry -> new HttpHost(entry.getKey(), entry.getValue()))
-                .collect(Collectors.toList());
+                .collect(toList());
 
         LOGGER.warn("Prefer using hosts, coordinates is deprecated.");
       } else {
@@ -192,8 +193,8 @@ private static RestClient connect(
       String password,
       boolean disableSSLVerification) {
 
-    Objects.requireNonNull(hosts, "hosts or coordinates");
-    Preconditions.checkArgument(!hosts.isEmpty(), "no ES hosts specified");
+    requireNonNull(hosts, "hosts or coordinates");
+    checkArgument(!hosts.isEmpty(), "no ES hosts specified");
     // Two lists are considered equal when all of their corresponding elements are equal
     // making a list of RestClient params a suitable cache key.
     List cacheKey = ImmutableList.of(hosts, pathPrefix, username, password);
@@ -227,7 +228,7 @@ private static RestClient connect(
                             .setSSLHostnameVerifier((host, session) -> true));
               }
 
-              if (pathPrefix != null && !pathPrefix.isEmpty()) {
+              if (!Strings.isNullOrEmpty(pathPrefix)) {
                 builder.setPathPrefix(pathPrefix);
               }
               return builder.build();
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSearchResult.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSearchResult.java
index 2e4418bd2..33ceb0599 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSearchResult.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSearchResult.java
@@ -25,7 +25,8 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Internal object used to parse elastic search result. Similar to {@code SearchHit}. Since we're
@@ -46,7 +47,7 @@ public class ElasticsearchSearchResult {
   @JsonCreator
   ElasticsearchSearchResult(
       @JsonProperty("hits") SearchHits hits, @JsonProperty("took") long took) {
-    this.hits = Objects.requireNonNull(hits, "hits");
+    this.hits = requireNonNull(hits, "hits");
     this.took = took;
   }
 
@@ -69,7 +70,7 @@ public static class SearchHits {
     SearchHits(
         @JsonProperty("total") final long total, @JsonProperty("hits") final List<SearchHit> hits) {
       this.total = total;
-      this.hits = Objects.requireNonNull(hits, "hits");
+      this.hits = requireNonNull(hits, "hits");
     }
 
     public List<SearchHit> hits() {
@@ -93,7 +94,7 @@ private SearchHit(
         @JsonProperty("_id") final String id,
         @JsonProperty("_source") final Map<String, Object> source,
         @JsonProperty("fields") final Map<String, Object> fields) {
-      this.id = Objects.requireNonNull(id, "id");
+      this.id = requireNonNull(id, "id");
 
       // both can't be null
       if (source == null && fields == null) {
@@ -130,7 +131,7 @@ public String id() {
      * @return value from result (_source or fields)
      */
     Object value(String name) {
-      Objects.requireNonNull(name, "name");
+      requireNonNull(name, "name");
 
       if (!sourceOrFields().containsKey(name)) {
         final String message =
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java
index 057e806c7..9e3c5c4ba 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java
@@ -43,17 +43,18 @@
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
-import java.util.stream.Collectors;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.Collectors.toSet;
 
 /** Table based on an Elasticsearch index. */
 public class ElasticsearchTable extends AbstractQueryableTable implements TranslatableTable {
@@ -69,7 +70,7 @@ public class ElasticsearchTable extends AbstractQueryableTable implements Transl
   /** Creates an ElasticsearchTable. */
   ElasticsearchTable(ElasticsearchTransport transport) {
     super(Object[].class);
-    this.transport = Objects.requireNonNull(transport, "transport");
+    this.transport = requireNonNull(transport, "transport");
     this.version = transport.version;
     this.indexName = transport.indexName;
     this.mapper = transport.mapper();
@@ -143,7 +144,7 @@ private Enumerable<Object> find(
     }
 
     final Function1<ElasticsearchJson.SearchHit, Object> getter =
-        ElasticsearchEnumerators.getter(fields, ImmutableMap.copyOf(mappings));
+        ElasticsearchEnumerators.getter(fields, mappings);
 
     Iterable<ElasticsearchJson.SearchHit> iter;
     if (offset == null) {
@@ -198,17 +199,14 @@ private Enumerable<Object> aggregate(
 
     // list of expressions which are count(*)
     final Set<String> countAll =
-        aggregations.stream()
-            .filter(isCountStar)
-            .map(Map.Entry::getKey)
-            .collect(Collectors.toSet());
+        aggregations.stream().filter(isCountStar).map(Map.Entry::getKey).collect(toSet());
 
     final Map<String, String> fieldMap = new HashMap<>();
 
     // due to ES aggregation format. fields in "order by" clause should go first
     // if "order by" is missing. order in "group by" is un-important
     final Set<String> orderedGroupBy = new LinkedHashSet<>();
-    orderedGroupBy.addAll(sort.stream().map(Map.Entry::getKey).collect(Collectors.toList()));
+    orderedGroupBy.addAll(sort.stream().map(Map.Entry::getKey).collect(toList()));
     orderedGroupBy.addAll(groupBy);
 
     // construct nested aggregations node(s)
@@ -280,7 +278,7 @@ private Enumerable<Object> aggregate(
       query.put("track_total_hits", true);
     }
 
-    ElasticsearchJson.Result res = transport.search(Collections.emptyMap()).apply(query);
+    ElasticsearchJson.Result res = transport.search(ImmutableMap.of()).apply(query);
 
     final List<Map<String, Object>> result = new ArrayList<>();
     if (res.aggregations() != null) {
@@ -312,14 +310,14 @@ private Enumerable<Object> aggregate(
     }
 
     final Function1<ElasticsearchJson.SearchHit, Object> getter =
-        ElasticsearchEnumerators.getter(fields, ImmutableMap.copyOf(mapping));
+        ElasticsearchEnumerators.getter(fields, mapping);
 
     ElasticsearchJson.SearchHits hits =
         new ElasticsearchJson.SearchHits(
             res.searchHits().total(),
             result.stream()
                 .map(r -> new ElasticsearchJson.SearchHit("_id", r, null))
-                .collect(Collectors.toList()));
+                .collect(toList()));
 
     return Linq4j.asEnumerable(hits.hits()).select(getter);
   }
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTableScan.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTableScan.java
index 28a8be2e6..655349eb2 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTableScan.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTableScan.java
@@ -33,7 +33,8 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Relational expression representing a scan of an Elasticsearch type.
@@ -60,7 +61,7 @@ public class ElasticsearchTableScan extends TableScan implements ElasticsearchRe
       ElasticsearchTable elasticsearchTable,
       RelDataType projectRowType) {
     super(cluster, traitSet, ImmutableList.of(), table);
-    this.elasticsearchTable = Objects.requireNonNull(elasticsearchTable, "elasticsearchTable");
+    this.elasticsearchTable = requireNonNull(elasticsearchTable, "elasticsearchTable");
     this.projectRowType = projectRowType;
 
     assert getConvention() == ElasticsearchRel.CONVENTION;
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchToEnumerableConverter.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchToEnumerableConverter.java
index d036dc787..bcec6e95b 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchToEnumerableConverter.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchToEnumerableConverter.java
@@ -41,7 +41,8 @@
 
 import java.util.AbstractList;
 import java.util.List;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /** Relational expression representing a scan of a table in an Elasticsearch data source. */
 public class ElasticsearchToEnumerableConverter extends ConverterImpl implements EnumerableRel {
@@ -138,6 +139,6 @@ private static <T> MethodCallExpression constantArrayList(List<T> values, Class
    * @return list of constant expressions
    */
   private static <T> List<Expression> constantList(List<T> values) {
-    return values.stream().map(Expressions::constant).collect(Collectors.toList());
+    return values.stream().map(Expressions::constant).collect(toList());
   }
 }
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java
index 5e2232363..98d6c77a2 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java
@@ -49,13 +49,13 @@
 import java.io.UncheckedIOException;
 import java.net.URI;
 import java.net.URISyntaxException;
-import java.util.Collections;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.function.Function;
 import java.util.stream.StreamSupport;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Set of predefined functions for REST interaction with elastic search API. Performs HTTP requests
  * and JSON (de)serialization.
@@ -89,9 +89,9 @@ final class ElasticsearchTransport {
       final ObjectMapper mapper,
       final String indexName,
       final int fetchSize) {
-    this.mapper = Objects.requireNonNull(mapper, "mapper");
-    this.restClient = Objects.requireNonNull(restClient, "restClient");
-    this.indexName = Objects.requireNonNull(indexName, "indexName");
+    this.mapper = requireNonNull(mapper, "mapper");
+    this.restClient = requireNonNull(restClient, "restClient");
+    this.indexName = requireNonNull(indexName, "indexName");
     this.fetchSize = fetchSize;
     this.version = version(); // cache version
     this.mapping = fetchAndCreateMapping(); // cache mapping
@@ -135,7 +135,7 @@ Function<HttpRequest, Response> rawHttp() {
   }
 
   <T> Function<HttpRequest, T> rawHttp(Class<T> responseType) {
-    Objects.requireNonNull(responseType, "responseType");
+    requireNonNull(responseType, "responseType");
     return rawHttp().andThen(new JsonParserFn<>(mapper, responseType));
   }
 
@@ -159,7 +159,7 @@ Function<String, ElasticsearchJson.Result> scroll() {
   }
 
   void closeScroll(Iterable<String> scrollIds) {
-    Objects.requireNonNull(scrollIds, "scrollIds");
+    requireNonNull(scrollIds, "scrollIds");
 
     // delete current scroll
     final URI uri = URI.create("/_search/scroll");
@@ -189,12 +189,12 @@ void closeScroll(Iterable<String> scrollIds) {
   }
 
   Function<ObjectNode, ElasticsearchJson.Result> search() {
-    return search(Collections.emptyMap());
+    return search(ImmutableMap.of());
   }
 
   /** Search request using HTTP post. */
   Function<ObjectNode, ElasticsearchJson.Result> search(final Map<String, String> httpParams) {
-    Objects.requireNonNull(httpParams, "httpParams");
+    requireNonNull(httpParams, "httpParams");
     return query -> {
       Hook.QUERY_PLAN.run(query);
       String path = String.format(Locale.ROOT, "/%s/_search", indexName);
@@ -247,7 +247,7 @@ private static class HttpFunction implements Function<HttpRequest, Response> {
     private final RestClient restClient;
 
     HttpFunction(final RestClient restClient) {
-      this.restClient = Objects.requireNonNull(restClient, "restClient");
+      this.restClient = requireNonNull(restClient, "restClient");
     }
 
     @Override public Response apply(final HttpRequest request) {
@@ -260,7 +260,7 @@ private static class HttpFunction implements Function<HttpRequest, Response> {
 
     private Response applyInternal(final HttpRequest request) throws IOException {
 
-      Objects.requireNonNull(request, "request");
+      requireNonNull(request, "request");
       final HttpEntity entity =
           request instanceof HttpEntityEnclosingRequest
               ? ((HttpEntityEnclosingRequest) request).getEntity()
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchVersion.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchVersion.java
index 2fde33504..8d088a59b 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchVersion.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchVersion.java
@@ -17,7 +17,8 @@
 package org.apache.calcite.adapter.elasticsearch;
 
 import java.util.Locale;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Identifies current ES version at runtime. Some queries have different syntax depending on version
@@ -41,7 +42,7 @@ public int elasticVersionMajor() {
   }
 
   static ElasticsearchVersion fromString(String version) {
-    Objects.requireNonNull(version, "version");
+    requireNonNull(version, "version");
     if (!version.matches("\\d+\\.\\d+\\.\\d+")) {
       final String message =
           String.format(
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
index 36d206316..4ac24a711 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
@@ -32,7 +32,6 @@
 import org.apache.calcite.util.NlsString;
 import org.apache.calcite.util.Sarg;
 
-import com.google.common.base.Preconditions;
 import com.google.common.base.Throwables;
 import com.google.common.collect.Range;
 
@@ -42,9 +41,11 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.adapter.elasticsearch.QueryBuilders.boolQuery;
 import static org.apache.calcite.adapter.elasticsearch.QueryBuilders.existsQuery;
 import static org.apache.calcite.adapter.elasticsearch.QueryBuilders.rangeQuery;
@@ -102,7 +103,7 @@ private PredicateAnalyzer() {}
    * @throws ExpressionNotAnalyzableException when expression can't processed by this analyzer
    */
   static QueryBuilder analyze(RexNode expression) throws ExpressionNotAnalyzableException {
-    Objects.requireNonNull(expression, "expression");
+    requireNonNull(expression, "expression");
     try {
       // visits expression tree
       QueryExpression e = (QueryExpression) expression.accept(new Visitor());
@@ -273,8 +274,7 @@ static boolean isSearchWithComplementedPoints(RexCall search) {
 
     private static String convertQueryString(List<Expression> fields, Expression query) {
       int index = 0;
-      Preconditions.checkArgument(
-          query instanceof LiteralExpression, "Query string must be a string literal");
+      checkArgument(query instanceof LiteralExpression, "Query string must be a string literal");
       String queryString = ((LiteralExpression) query).stringValue();
       @SuppressWarnings("ModifiedButNotUsed")
       Map<String, String> fieldMap = new LinkedHashMap<>();
@@ -293,7 +293,7 @@ private static String convertQueryString(List<Expression> fields, Expression que
     }
 
     private QueryExpression prefix(RexCall call) {
-      Preconditions.checkArgument(
+      checkArgument(
           call.getKind() == SqlKind.NOT, "Expected %s got %s", SqlKind.NOT, call.getKind());
 
       if (call.getOperands().size() != 1) {
@@ -306,8 +306,7 @@ private QueryExpression prefix(RexCall call) {
     }
 
     private QueryExpression postfix(RexCall call) {
-      Preconditions.checkArgument(
-          call.getKind() == SqlKind.IS_NULL || call.getKind() == SqlKind.IS_NOT_NULL);
+      checkArgument(call.getKind() == SqlKind.IS_NULL || call.getKind() == SqlKind.IS_NOT_NULL);
       if (call.getOperands().size() != 1) {
         String message = String.format(Locale.ROOT, "Unsupported operator: [%s]", call);
         throw new PredicateAnalyzerException(message);
@@ -339,7 +338,7 @@ private QueryExpression binary(RexCall call) {
 
       checkForIncompatibleDateTimeOperands(call);
 
-      Preconditions.checkState(call.getOperands().size() == 2);
+      checkState(call.getOperands().size() == 2);
       final Expression a = call.getOperands().get(0).accept(this);
       final Expression b = call.getOperands().get(1).accept(this);
 
@@ -644,7 +643,7 @@ private CompoundQueryExpression(boolean partial) {
 
     private CompoundQueryExpression(boolean partial, BoolQueryBuilder builder) {
       this.partial = partial;
-      this.builder = Objects.requireNonNull(builder, "builder");
+      this.builder = requireNonNull(builder, "builder");
     }
 
     @Override public boolean isPartial() {
@@ -747,9 +746,7 @@ private SimpleQueryExpression(NamedFieldExpression rel) {
     }
 
     @Override public QueryBuilder builder() {
-      if (builder == null) {
-        throw new IllegalStateException("Builder was not initialized");
-      }
+      checkState(builder != null, "Builder was not initialized");
       return builder;
     }
 
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
index 9f03e3a55..8f4fb996d 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
@@ -21,7 +21,10 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkState;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Utility class to generate elastic search queries. Most query builders have been copied from ES
@@ -226,25 +229,25 @@ static class BoolQueryBuilder extends QueryBuilder {
     private final List<QueryBuilder> shouldClauses = new ArrayList<>();
 
     BoolQueryBuilder must(QueryBuilder queryBuilder) {
-      Objects.requireNonNull(queryBuilder, "queryBuilder");
+      requireNonNull(queryBuilder, "queryBuilder");
       mustClauses.add(queryBuilder);
       return this;
     }
 
     BoolQueryBuilder filter(QueryBuilder queryBuilder) {
-      Objects.requireNonNull(queryBuilder, "queryBuilder");
+      requireNonNull(queryBuilder, "queryBuilder");
       filterClauses.add(queryBuilder);
       return this;
     }
 
     BoolQueryBuilder mustNot(QueryBuilder queryBuilder) {
-      Objects.requireNonNull(queryBuilder, "queryBuilder");
+      requireNonNull(queryBuilder, "queryBuilder");
       mustNotClauses.add(queryBuilder);
       return this;
     }
 
     BoolQueryBuilder should(QueryBuilder queryBuilder) {
-      Objects.requireNonNull(queryBuilder, "queryBuilder");
+      requireNonNull(queryBuilder, "queryBuilder");
       shouldClauses.add(queryBuilder);
       return this;
     }
@@ -286,8 +289,8 @@ static class TermQueryBuilder extends QueryBuilder {
     private final Object value;
 
     private TermQueryBuilder(final String fieldName, final Object value) {
-      this.fieldName = Objects.requireNonNull(fieldName, "fieldName");
-      this.value = Objects.requireNonNull(value, "value");
+      this.fieldName = requireNonNull(fieldName, "fieldName");
+      this.value = requireNonNull(value, "value");
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
@@ -307,8 +310,8 @@ private static class TermsQueryBuilder extends QueryBuilder {
     private final Iterable<?> values;
 
     private TermsQueryBuilder(final String fieldName, final Iterable<?> values) {
-      this.fieldName = Objects.requireNonNull(fieldName, "fieldName");
-      this.values = Objects.requireNonNull(values, "values");
+      this.fieldName = requireNonNull(fieldName, "fieldName");
+      this.values = requireNonNull(values, "values");
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
@@ -332,8 +335,8 @@ static class MatchQueryBuilder extends QueryBuilder {
     private final Object value;
 
     private MatchQueryBuilder(final String fieldName, final Object value) {
-      this.fieldName = Objects.requireNonNull(fieldName, "fieldName");
-      this.value = Objects.requireNonNull(value, "value");
+      this.fieldName = requireNonNull(fieldName, "fieldName");
+      this.value = requireNonNull(value, "value");
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
@@ -353,8 +356,8 @@ private static class MatchesQueryBuilder extends QueryBuilder {
     private final Iterable<?> values;
 
     private MatchesQueryBuilder(final String fieldName, final Iterable<?> values) {
-      this.fieldName = Objects.requireNonNull(fieldName, "fieldName");
-      this.values = Objects.requireNonNull(values, "values");
+      this.fieldName = requireNonNull(fieldName, "fieldName");
+      this.values = requireNonNull(values, "values");
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
@@ -396,17 +399,17 @@ static class RangeQueryBuilder extends QueryBuilder {
     private String format;
 
     private RangeQueryBuilder(final String fieldName) {
-      this.fieldName = Objects.requireNonNull(fieldName, "fieldName");
+      this.fieldName = requireNonNull(fieldName, "fieldName");
     }
 
     private RangeQueryBuilder to(Object value, boolean lte) {
-      this.lt = Objects.requireNonNull(value, "value");
+      this.lt = requireNonNull(value, "value");
       this.lte = lte;
       return this;
     }
 
     private RangeQueryBuilder from(Object value, boolean gte) {
-      this.gt = Objects.requireNonNull(value, "value");
+      this.gt = requireNonNull(value, "value");
       this.gte = gte;
       return this;
     }
@@ -433,9 +436,7 @@ RangeQueryBuilder format(String format) {
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
-      if (lt == null && gt == null) {
-        throw new IllegalStateException("Either lower or upper bound should be provided");
-      }
+      checkState(lt != null || gt != null, "Either lower or upper bound should be provided");
 
       generator.writeStartObject();
       generator.writeFieldName("range");
@@ -488,7 +489,7 @@ static class ExistsQueryBuilder extends QueryBuilder {
     private final String fieldName;
 
     ExistsQueryBuilder(final String fieldName) {
-      this.fieldName = Objects.requireNonNull(fieldName, "fieldName");
+      this.fieldName = requireNonNull(fieldName, "fieldName");
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
@@ -510,7 +511,7 @@ static class ConstantScoreQueryBuilder extends QueryBuilder {
     private final QueryBuilder builder;
 
     private ConstantScoreQueryBuilder(final QueryBuilder builder) {
-      this.builder = Objects.requireNonNull(builder, "builder");
+      this.builder = requireNonNull(builder, "builder");
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
@@ -533,7 +534,7 @@ static class DisMaxQueryBuilder extends QueryBuilder {
     private final QueryBuilder builder;
 
     private DisMaxQueryBuilder(final QueryBuilder builder) {
-      this.builder = Objects.requireNonNull(builder, "builder");
+      this.builder = requireNonNull(builder, "builder");
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
index 844713a44..0ea03bbbd 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
@@ -17,15 +17,18 @@
 package org.apache.calcite.adapter.elasticsearch;
 
 import com.fasterxml.jackson.databind.node.ObjectNode;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.AbstractSequentialIterator;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterators;
 
-import java.util.Collections;
 import java.util.Iterator;
-import java.util.Objects;
 import java.util.function.Consumer;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * "Iterator" which retrieves results lazily and in batches. Uses <a
  * href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html">Elastic
@@ -39,14 +42,14 @@ class Scrolling {
   private final int fetchSize;
 
   Scrolling(ElasticsearchTransport transport) {
-    this.transport = Objects.requireNonNull(transport, "transport");
+    this.transport = requireNonNull(transport, "transport");
     final int fetchSize = transport.fetchSize;
-    Preconditions.checkArgument(fetchSize > 0, "invalid fetch size. Expected %s > 0", fetchSize);
+    checkArgument(fetchSize > 0, "invalid fetch size. Expected %s > 0", fetchSize);
     this.fetchSize = fetchSize;
   }
 
   Iterator<ElasticsearchJson.SearchHit> query(ObjectNode query) {
-    Objects.requireNonNull(query, "query");
+    requireNonNull(query, "query");
     final long limit;
     if (query.has("size")) {
       limit = query.get("size").asLong();
@@ -60,12 +63,12 @@ Iterator<ElasticsearchJson.SearchHit> query(ObjectNode query) {
 
     query.put("size", fetchSize);
     final ElasticsearchJson.Result first =
-        transport.search(Collections.singletonMap("scroll", "1m")).apply(query);
+        transport.search(ImmutableMap.of("scroll", "1m")).apply(query);
 
     AutoClosingIterator iterator =
         new AutoClosingIterator(
             new SequentialIterator(first, transport, limit),
-            scrollId -> transport.closeScroll(Collections.singleton(scrollId)));
+            scrollId -> transport.closeScroll(ImmutableSet.of(scrollId)));
 
     Iterator<ElasticsearchJson.SearchHit> result = flatten(iterator);
     // apply limit
@@ -147,7 +150,7 @@ private SequentialIterator(
         final long limit) {
       super(first);
       this.transport = transport;
-      Preconditions.checkArgument(limit >= 0, "limit: %s >= 0", limit);
+      checkArgument(limit >= 0, "limit: %s >= 0", limit);
       this.limit = limit;
     }
 
diff --git a/file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java b/file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java
index 127321b7d..1ec4f9f6d 100644
--- a/file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java
+++ b/file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java
@@ -44,7 +44,6 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Locale;
-import java.util.Objects;
 import java.util.TimeZone;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Matcher;
@@ -54,6 +53,8 @@
 
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Enumerator that reads from a CSV file.
  *
@@ -222,7 +223,7 @@ public static RelDataType deduceRowType(
   }
 
   static CSVReader openCsv(Source source) throws IOException {
-    Objects.requireNonNull(source, "source");
+    requireNonNull(source, "source");
     return new CSVReader(source.reader());
   }
 
@@ -310,47 +311,47 @@ abstract static class RowConverter<E> {
       }
       switch (fieldType.getSqlTypeName()) {
         case BOOLEAN:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Boolean.parseBoolean(string);
         case TINYINT:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Byte.parseByte(string);
         case SMALLINT:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Short.parseShort(string);
         case INTEGER:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Integer.parseInt(string);
         case BIGINT:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Long.parseLong(string);
         case FLOAT:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Float.parseFloat(string);
         case DOUBLE:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Double.parseDouble(string);
         case DECIMAL:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return parseDecimal(fieldType.getPrecision(), fieldType.getScale(), string);
         case DATE:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           try {
@@ -360,7 +361,7 @@ abstract static class RowConverter<E> {
             return null;
           }
         case TIME:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           try {
@@ -370,7 +371,7 @@ abstract static class RowConverter<E> {
             return null;
           }
         case TIMESTAMP:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           try {
@@ -415,15 +416,14 @@ protected static BigDecimal parseDecimal(int precision, int scale, String string
     }
     // Throws an exception if the parsed value has more digits to the left of the decimal point
     // than the specified value.
-    if (result.precision() - result.scale() > precision - scale) {
-      throw new IllegalArgumentException(
-          String.format(
-              Locale.ROOT,
-              "Decimal value %s exceeds declared precision (%d) and scale (%d).",
-              result,
-              precision,
-              scale));
-    }
+    checkArgument(
+        result.precision() - result.scale() <= precision - scale,
+        String.format(
+            Locale.ROOT,
+            "Decimal value %s exceeds declared precision (%d) and scale (%d).",
+            result,
+            precision,
+            scale));
     return result;
   }
 
diff --git a/file/src/main/java/org/apache/calcite/adapter/file/FileReader.java b/file/src/main/java/org/apache/calcite/adapter/file/FileReader.java
index c34702324..feab419a9 100644
--- a/file/src/main/java/org/apache/calcite/adapter/file/FileReader.java
+++ b/file/src/main/java/org/apache/calcite/adapter/file/FileReader.java
@@ -25,18 +25,19 @@
 
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.concurrent.TimeUnit;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /** Scrapes HTML tables from URLs using Jsoup. */
 public class FileReader implements Iterable<Elements> {
 
   private final Source source;
   private final String selector;
   private final Integer index;
-  private final Charset charset = StandardCharsets.UTF_8;
+  private final Charset charset = UTF_8;
   private Element tableElement;
   private Elements headings;
 
@@ -162,7 +163,7 @@ Elements getHeadings() throws FileReaderException {
       // first row must contain headings
       Elements headings = iterator.next("th");
       // if not, generate some default column names
-      if (headings.size() == 0) {
+      if (headings.isEmpty()) {
         // rewind and peek at the first row of data
         iterator = new FileReaderIterator(this.tableElement.select("tr"));
         Elements firstRow = iterator.next("td");
diff --git a/file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java b/file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
index 4e39f80ed..2059134e7 100644
--- a/file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
+++ b/file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
@@ -279,7 +279,7 @@ String read(Element cell) {
         while (m.find()) {
           allMatches.add(m.group());
         }
-        if (allMatches.size() != 0) {
+        if (!allMatches.isEmpty()) {
           return allMatches.get(this.matchSeq);
         } else {
           return null;
@@ -328,7 +328,7 @@ private java.util.Date parseDate(String string) {
 
     @SuppressWarnings("JavaUtilDate")
     private Object toObject(FileFieldType fieldType, String string) {
-      if ((string == null) || (string.length() == 0)) {
+      if ((string == null) || string.isEmpty()) {
         return null;
       }
 
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeEnumerator.java b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeEnumerator.java
index 8a5f9fd45..2728a85a5 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeEnumerator.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeEnumerator.java
@@ -28,12 +28,13 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
 import static org.apache.calcite.adapter.geode.util.GeodeUtils.convertToRowValues;
 
+import static java.util.Collections.emptyIterator;
+
 /** Enumerator that reads from a Geode Regions. */
 class GeodeEnumerator implements Enumerator<Object> {
 
@@ -53,7 +54,7 @@ class GeodeEnumerator implements Enumerator<Object> {
     if (results == null) {
       LOGGER.warn("Null OQL results!");
     }
-    this.iterator = (results == null) ? Collections.emptyIterator() : results.iterator();
+    this.iterator = (results == null) ? emptyIterator() : results.iterator();
     this.current = null;
 
     final RelDataTypeFactory typeFactory = new SqlTypeFactoryImpl(RelDataTypeSystem.DEFAULT);
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
index cb13de730..092c16c69 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
@@ -37,20 +37,22 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
-import java.util.stream.Collectors;
+
+import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.sql.type.SqlTypeName.CHAR;
 
+import static java.util.stream.Collectors.toList;
+
 /** Implementation of {@link Filter} relational expression in Geode. */
 public class GeodeFilter extends Filter implements GeodeRel {
 
@@ -78,7 +80,7 @@ public class GeodeFilter extends Filter implements GeodeRel {
   @Override public void implement(GeodeImplementContext geodeImplementContext) {
     // first call the input down the tree.
     geodeImplementContext.visitChild(getInput());
-    geodeImplementContext.addPredicates(Collections.singletonList(match));
+    geodeImplementContext.addPredicates(ImmutableList.of(match));
   }
 
   /** Translates {@link RexNode} expressions into Geode expression strings. */
@@ -110,14 +112,14 @@ private static String literalValue(RexLiteral literal) {
         case TIMESTAMP:
         case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
           assert valueComparable instanceof TimestampString;
-          return "TIMESTAMP '" + valueComparable.toString() + "'";
+          return "TIMESTAMP '" + valueComparable + "'";
         case DATE:
           assert valueComparable instanceof DateString;
-          return "DATE '" + valueComparable.toString() + "'";
+          return "DATE '" + valueComparable + "'";
         case TIME:
         case TIME_WITH_LOCAL_TIME_ZONE:
           assert valueComparable instanceof TimeString;
-          return "TIME '" + valueComparable.toString() + "'";
+          return "TIME '" + valueComparable + "'";
         default:
           return String.valueOf(literal.getValue3());
       }
@@ -211,7 +213,7 @@ private boolean useInSetQueryClause(List<RexNode> disjunctions) {
 
     /** Creates OQL {@code IN SET} predicate string. */
     private String translateInSet(List<RexNode> disjunctions) {
-      Preconditions.checkArgument(!disjunctions.isEmpty(), "empty disjunctions");
+      checkArgument(!disjunctions.isEmpty(), "empty disjunctions");
 
       RexNode firstNode = disjunctions.get(0);
       RexCall firstCall = (RexCall) firstNode;
@@ -252,7 +254,7 @@ private List<RexNode> getLeftNodeDisjunctions(RexNode node, List<RexNode> disjun
                       RexNode rexCallLeft = rexCall.operands.get(0);
                       return leftNodeFieldName.equals(getLeftNodeFieldName(rexCallLeft));
                     })
-                .collect(Collectors.toList());
+                .collect(toList());
       }
 
       return leftNodeDisjunctions;
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeRules.java b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeRules.java
index 1871e2bda..1c82e0c4f 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeRules.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeRules.java
@@ -40,13 +40,13 @@
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.sql.validate.SqlValidatorUtil;
 
-import com.google.common.base.Preconditions;
-
 import org.immutables.value.Value;
 
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Rules and relational operators for {@link GeodeRel#CONVENTION} calling convention. */
 public class GeodeRules {
 
@@ -142,8 +142,7 @@ protected GeodeProjectRule(Config config) {
 
     @Override public RelNode convert(RelNode rel) {
       final LogicalProject project = (LogicalProject) rel;
-      Preconditions.checkArgument(
-          project.getVariablesSet().isEmpty(), "GeodeProject does now allow variables");
+      checkArgument(project.getVariablesSet().isEmpty(), "GeodeProject does now allow variables");
       final RelTraitSet traitSet = project.getTraitSet().replace(getOutConvention());
       return new GeodeProject(
           project.getCluster(),
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSchema.java b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSchema.java
index efbd62658..f7d295d44 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSchema.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeSchema.java
@@ -28,7 +28,8 @@
 
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Schema mapped onto a Geode Region. */
 public class GeodeSchema extends AbstractSchema {
@@ -39,8 +40,8 @@ public class GeodeSchema extends AbstractSchema {
 
   public GeodeSchema(final GemFireCache gemFireCache, final Iterable<String> regionNames) {
     super();
-    this.cache = Objects.requireNonNull(gemFireCache, "gemFireCache");
-    this.regionNames = ImmutableList.copyOf(Objects.requireNonNull(regionNames, "regionNames"));
+    this.cache = requireNonNull(gemFireCache, "gemFireCache");
+    this.regionNames = ImmutableList.copyOf(requireNonNull(regionNames, "regionNames"));
   }
 
   @Override protected Map<String, Table> getTableMap() {
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java
index b3dd08d93..4257f6200 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java
@@ -185,7 +185,7 @@ public Enumerable<Object> query(
     final String oqlQuery = queryBuilder.toString();
 
     Hook.QUERY_PLAN.run(oqlQuery);
-    LOGGER.info("OQL: " + oqlQuery);
+    LOGGER.info("OQL: {}", oqlQuery);
 
     return new AbstractEnumerable<Object>() {
       @Override public Enumerator<Object> enumerator() {
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/simple/GeodeSimpleSchemaFactory.java b/geode/src/main/java/org/apache/calcite/adapter/geode/simple/GeodeSimpleSchemaFactory.java
index 15a311f8b..9b9c08d82 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/simple/GeodeSimpleSchemaFactory.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/simple/GeodeSimpleSchemaFactory.java
@@ -33,8 +33,8 @@ public class GeodeSimpleSchemaFactory implements SchemaFactory {
 
   public GeodeSimpleSchemaFactory() {}
 
-  @SuppressWarnings("rawtypes")
-  @Override public Schema create(SchemaPlus parentSchema, String name, Map<String, Object> operand) {
+  @Override @SuppressWarnings("rawtypes")
+  public Schema create(SchemaPlus parentSchema, String name, Map<String, Object> operand) {
     Map map = (Map) operand;
 
     String locatorHost = (String) map.get(LOCATOR_HOST);
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java b/geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java
index 08ee3d1fc..84661e9d5 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java
@@ -44,9 +44,10 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 
+import static java.util.Objects.requireNonNull;
+
 /** Utilities for the Geode adapter. */
 public class GeodeUtils {
 
@@ -80,15 +81,11 @@ public static synchronized ClientCache createClientCache(
     if (locatorPort != currentLocatorPort
         || !StringUtils.equalsIgnoreCase(currentLocatorHost, locatorHost)) {
       LOGGER.info(
-          "Close existing ClientCache ["
-              + currentLocatorHost
-              + ":"
-              + currentLocatorPort
-              + "] for new Locator connection at: ["
-              + locatorHost
-              + ":"
-              + locatorPort
-              + "]");
+          "Close existing ClientCache [{}:{}] for new Locator connection at: [{}:{}]",
+          currentLocatorHost,
+          currentLocatorPort,
+          locatorHost,
+          locatorPort);
       currentLocatorHost = locatorHost;
       currentLocatorPort = locatorPort;
       closeClientCache();
@@ -126,8 +123,8 @@ public static synchronized void closeClientCache() {
    * @return Returns a Region proxy to a remote (on the Server) regions.
    */
   public static synchronized Region createRegion(GemFireCache cache, String regionName) {
-    Objects.requireNonNull(cache, "cache");
-    Objects.requireNonNull(regionName, "regionName");
+    requireNonNull(cache, "cache");
+    requireNonNull(regionName, "regionName");
     Region region = REGION_MAP.get(regionName);
     if (region == null) {
       try {
@@ -286,7 +283,7 @@ private static Object convert(Object o, Class clazz) {
    * @return derived data type.
    */
   public static RelDataType autodetectRelTypeFromRegion(Region<?, ?> region) {
-    Objects.requireNonNull(region, "region");
+    requireNonNull(region, "region");
 
     // try to detect type using value constraints (if they exists)
     final Class<?> constraint = region.getAttributes().getValueConstraint();
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java
index 66916c761..e144b7388 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java
@@ -31,6 +31,8 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Index condition.
  *
@@ -93,19 +95,15 @@ private IndexCondition(
         implicitCollation != null
             ? implicitCollation
             : deduceImplicitCollation(fieldNames, indexColumnNames);
-    this.pushDownConditions =
-        pushDownConditions == null ? ImmutableList.of() : ImmutableList.copyOf(pushDownConditions);
+    this.pushDownConditions = pushDownConditions == null ? ImmutableList.of() : pushDownConditions;
     this.remainderConditions =
-        remainderConditions == null
-            ? ImmutableList.of()
-            : ImmutableList.copyOf(remainderConditions);
+        remainderConditions == null ? ImmutableList.of() : remainderConditions;
     this.queryType = queryType;
-    this.pointQueryKey =
-        pointQueryKey == null ? ImmutableList.of() : ImmutableList.copyOf(pointQueryKey);
-    this.rangeQueryLowerOp = Objects.requireNonNull(rangeQueryLowerOp, "rangeQueryLowerOp");
-    this.rangeQueryUpperOp = Objects.requireNonNull(rangeQueryUpperOp, "rangeQueryUpperOp");
-    this.rangeQueryLowerKey = ImmutableList.copyOf(rangeQueryLowerKey);
-    this.rangeQueryUpperKey = ImmutableList.copyOf(rangeQueryUpperKey);
+    this.pointQueryKey = pointQueryKey == null ? ImmutableList.of() : pointQueryKey;
+    this.rangeQueryLowerOp = requireNonNull(rangeQueryLowerOp, "rangeQueryLowerOp");
+    this.rangeQueryUpperOp = requireNonNull(rangeQueryUpperOp, "rangeQueryUpperOp");
+    this.rangeQueryLowerKey = rangeQueryLowerKey;
+    this.rangeQueryUpperKey = rangeQueryUpperKey;
   }
 
   static IndexCondition create(
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilter.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilter.java
index 939e7b088..fddc03be7 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilter.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilter.java
@@ -31,7 +31,7 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Objects;
+import static java.util.Objects.requireNonNull;
 
 /**
  * Implementation of a {@link org.apache.calcite.rel.core.Filter} relational expression for an
@@ -53,8 +53,8 @@ private InnodbFilter(
       @Nullable String forceIndexName) {
     super(cluster, traitSet, input, condition);
 
-    this.tableDef = Objects.requireNonNull(tableDef, "tableDef");
-    this.indexCondition = Objects.requireNonNull(indexCondition, "indexCondition");
+    this.tableDef = requireNonNull(tableDef, "tableDef");
+    this.indexCondition = requireNonNull(indexCondition, "indexCondition");
     this.forceIndexName = forceIndexName;
 
     assert getConvention() == InnodbRel.CONVENTION;
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilterTranslator.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilterTranslator.java
index 49afe4624..73b02d9d6 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilterTranslator.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilterTranslator.java
@@ -44,9 +44,10 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.Optional;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import static java.util.stream.Collectors.toList;
+
 /**
  * Translates {@link RexNode} expressions into {@link IndexCondition} which might be pushed down to
  * an InnoDB data source.
@@ -192,17 +193,8 @@ private IndexCondition findPushDownCondition(List<RexNode> rexNodeList, KeyMeta
             remainderRexNodeList,
             ">=",
             ">");
-    condition =
-        handleRangeQuery(
-            condition,
-            keyMeta,
-            leftMostKeyNodes,
-            pushDownRexNodeList,
-            remainderRexNodeList,
-            "<=",
-            "<");
-
-    return condition;
+    return handleRangeQuery(
+        condition, keyMeta, leftMostKeyNodes, pushDownRexNodeList, remainderRexNodeList, "<=", "<");
   }
 
   /**
@@ -219,9 +211,8 @@ private IndexCondition findPushDownCondition(List<RexNode> rexNodeList, KeyMeta
   private List<InternalRexNode> analyzePrefixMatches(List<RexNode> rexNodeList, KeyMeta keyMeta) {
     return rexNodeList.stream()
         .map(rexNode -> translateMatch2(rexNode, keyMeta))
-        .filter(Optional::isPresent)
-        .map(Optional::get)
-        .collect(Collectors.toList());
+        .flatMap(Optional::stream)
+        .collect(toList());
   }
 
   /**
@@ -243,7 +234,7 @@ private static IndexCondition handlePointQuery(
       List<RexNode> remainderRexNodeList) {
     Optional<InternalRexNode> leftMostEqOpNode = findFirstOp(leftMostKeyNodes, "=");
     if (leftMostEqOpNode.isPresent()) {
-      InternalRexNode node = leftMostEqOpNode.get();
+      InternalRexNode node = leftMostEqOpNode.orElseThrow();
 
       List<InternalRexNode> matchNodes = Lists.newArrayList(node);
       findSubsequentMatches(matchNodes, keyMeta.getNumOfColumns(), keyOrdToNodesMap, "=");
@@ -312,10 +303,10 @@ private static IndexCondition handleRangeQuery(
       String... opList) {
     Optional<InternalRexNode> node = findFirstOp(leftMostKeyNodes, opList);
     if (node.isPresent()) {
-      pushDownRexNodeList.add(node.get().node);
-      remainderRexNodeList.remove(node.get().node);
-      List<Object> key = createKey(Lists.newArrayList(node.get()));
-      ComparisonOperator op = ComparisonOperator.parse(node.get().op);
+      pushDownRexNodeList.add(node.orElseThrow().node);
+      remainderRexNodeList.remove(node.orElseThrow().node);
+      List<Object> key = createKey(Lists.newArrayList(node.orElseThrow()));
+      ComparisonOperator op = ComparisonOperator.parse(node.orElseThrow().op);
       if (ComparisonOperator.isLowerBoundOp(opList)) {
         return condition
             .withQueryType(QueryType.getRangeQuery(keyMeta.isSecondaryKey()))
@@ -364,8 +355,7 @@ private Optional<InternalRexNode> translateBinary(
     if (expression.isPresent()) {
       return expression;
     }
-    expression = translateBinary2(rop, right, left, call, keyMeta);
-    return expression;
+    return translateBinary2(rop, right, left, call, keyMeta);
   }
 
   /** Translates a call to a binary operator. Returns null on failure. */
@@ -411,7 +401,8 @@ private static Optional<InternalRexNode> translateOp2(
     // left-prefix index length should be less than search value literal.
     // For example, we cannot leverage index of EMAIL(3) upon search value
     // `someone@apache.org`, because the value length is longer than 3.
-    if (keyMeta.getVarLen(name).isPresent() && keyMeta.getVarLen(name).get() < value.length()) {
+    if (keyMeta.getVarLen(name).isPresent()
+        && keyMeta.getVarLen(name).orElseThrow() < value.length()) {
       return Optional.empty();
     }
     node.fieldName = name;
@@ -451,7 +442,7 @@ private static void findSubsequentMatches(
     for (int i = nodes.size(); i < numOfKeyColumns; i++) {
       Optional<InternalRexNode> eqOpNode = findFirstOp(keyOrdToNodesMap.get(i), op);
       if (eqOpNode.isPresent()) {
-        nodes.add(eqOpNode.get());
+        nodes.add(eqOpNode.orElseThrow());
       } else {
         break;
       }
@@ -459,7 +450,7 @@ private static void findSubsequentMatches(
   }
 
   private static List<Object> createKey(List<InternalRexNode> nodes) {
-    return nodes.stream().map(n -> n.right).collect(Collectors.toList());
+    return nodes.stream().map(n -> n.right).collect(toList());
   }
 
   /**
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbRules.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbRules.java
index 404823118..43b9493a6 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbRules.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbRules.java
@@ -260,7 +260,7 @@ protected boolean collationsCompatible(
       if (sortFieldCollations.size() > implicitFieldCollations.size()) {
         return false;
       }
-      if (sortFieldCollations.size() == 0) {
+      if (sortFieldCollations.isEmpty()) {
         return true;
       }
 
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbSort.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbSort.java
index 76f68a567..9feb0c1cc 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbSort.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbSort.java
@@ -72,9 +72,8 @@ public class InnodbSort extends Sort implements InnodbRel {
     // field collation should be in a series of ascending or descending collations
     checkState(
         allDesc || allNonDesc,
-        "ordering should be in a "
-            + "series of ascending or descending collations "
-            + sortCollations);
+        "ordering should be in a series of ascending or descending collations %s",
+        sortCollations);
     implementor.setAscOrder(!allDesc);
   }
 }
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTable.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTable.java
index 04c675bc5..1666ffd8e 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTable.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTable.java
@@ -57,7 +57,8 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.function.Supplier;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toList;
 
 /** Table based on an InnoDB data file. */
 public class InnodbTable extends AbstractQueryableTable implements TranslatableTable {
@@ -106,7 +107,7 @@ public Set<String> getIndexesNameSet() {
         .addAll(
             getTableDef().getSecondaryKeyMetaList().stream()
                 .map(KeyMeta::getName)
-                .collect(Collectors.toList()))
+                .collect(toList()))
         .build();
   }
 
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTableScan.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTableScan.java
index 0f5c691c8..9cfca08fd 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTableScan.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTableScan.java
@@ -112,11 +112,11 @@ private Optional<String> getForceIndexName(final List<RelHint> hints) {
         if (!hint.listOptions.isEmpty()) {
           Set<String> indexesNameSet = innodbTable.getIndexesNameSet();
           Optional<String> forceIndexName = hint.listOptions.stream().findFirst();
-          if (!forceIndexName.isPresent()) {
+          if (forceIndexName.isEmpty()) {
             return Optional.empty();
           }
           for (String indexName : indexesNameSet) {
-            if (indexName != null && indexName.equalsIgnoreCase(forceIndexName.get())) {
+            if (indexName != null && indexName.equalsIgnoreCase(forceIndexName.orElseThrow())) {
               return Optional.of(indexName);
             }
           }
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java
index fec65615b..0c4a3f1a9 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java
@@ -41,16 +41,17 @@
 import org.apache.calcite.util.Util;
 
 import com.alibaba.innodb.java.reader.comparator.ComparisonOperator;
+import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.AbstractList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import static java.util.stream.Collectors.toList;
+
 /** Relational expression representing a scan of a table in InnoDB data source. */
 public class InnodbToEnumerableConverter extends ConverterImpl implements EnumerableRel {
   protected InnodbToEnumerableConverter(RelOptCluster cluster, RelTraitSet traits, RelNode input) {
@@ -165,9 +166,7 @@ private static <T> Expression constantArrayList(List<T> values, Class clazz) {
       //   PairList.of("k0", "v0", "k1", "v1");
       final List<Object> keyValues =
           ((PairList<Object, Object>) values)
-              .stream()
-                  .flatMap(p -> Stream.of(p.getKey(), p.getValue()))
-                  .collect(Collectors.toList());
+              .stream().flatMap(p -> Stream.of(p.getKey(), p.getValue())).collect(toList());
       return Expressions.call(
           null, BuiltInMethod.PAIR_LIST_COPY_OF.method, constantList(keyValues));
     }
@@ -181,7 +180,7 @@ private static <T> Expression constantArrayList(List<T> values, Class clazz) {
    */
   private static <T> List<Expression> constantList(List<T> values) {
     if (values.isEmpty()) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     return Util.transform(values, Expressions::constant);
   }
diff --git a/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java b/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java
index 218e889f6..25c387f93 100644
--- a/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java
+++ b/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java
@@ -41,7 +41,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.Properties;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -81,7 +80,7 @@ public class KafkaStreamTable implements ScannableTable, StreamableTable {
           consumerConfig.putAll(tableOptions.getConsumerParams());
         }
         Consumer consumer = new KafkaConsumer<>(consumerConfig);
-        consumer.subscribe(Collections.singletonList(tableOptions.getTopicName()));
+        consumer.subscribe(ImmutableList.of(tableOptions.getTopicName()));
 
         return new KafkaMessageEnumerator(consumer, tableOptions.getRowConverter(), cancelFlag);
       }
diff --git a/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableFactory.java b/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableFactory.java
index 1e4be7e46..1ab8d2449 100644
--- a/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableFactory.java
+++ b/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableFactory.java
@@ -41,9 +41,8 @@ public KafkaTableFactory() {}
     final KafkaTableOptions tableOptionBuilder = new KafkaTableOptions();
 
     tableOptionBuilder.setBootstrapServers(
-        (String) operand.getOrDefault(KafkaTableConstants.SCHEMA_BOOTSTRAP_SERVERS, null));
-    tableOptionBuilder.setTopicName(
-        (String) operand.getOrDefault(KafkaTableConstants.SCHEMA_TOPIC_NAME, null));
+        (String) operand.get(KafkaTableConstants.SCHEMA_BOOTSTRAP_SERVERS));
+    tableOptionBuilder.setTopicName((String) operand.get(KafkaTableConstants.SCHEMA_TOPIC_NAME));
 
     final KafkaRowConverter rowConverter;
     if (operand.containsKey(KafkaTableConstants.SCHEMA_ROW_CONVERTER)) {
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/DefaultEnumerable.java b/linq4j/src/main/java/org/apache/calcite/linq4j/DefaultEnumerable.java
index 0f05064b3..c498da4ae 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/DefaultEnumerable.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/DefaultEnumerable.java
@@ -461,8 +461,8 @@ protected OrderedQueryable<T> asOrderedQueryable() {
     return EnumerableDefaults.longCount(getThis(), predicate);
   }
 
-  @SuppressWarnings("unchecked")
-  @Override public @Nullable T max() {
+  @Override @SuppressWarnings("unchecked")
+  public @Nullable T max() {
     return (@Nullable T) EnumerableDefaults.max((Enumerable) getThis());
   }
 
@@ -511,8 +511,8 @@ protected OrderedQueryable<T> asOrderedQueryable() {
     return EnumerableDefaults.max(getThis(), selector);
   }
 
-  @SuppressWarnings("unchecked")
-  @Override public @Nullable T min() {
+  @Override @SuppressWarnings("unchecked")
+  public @Nullable T min() {
     return (@Nullable T) EnumerableDefaults.min((Enumerable) getThis());
   }
 
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java b/linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
index 260dd0bf7..e5d313b57 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
@@ -54,7 +54,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -68,11 +67,15 @@
 import java.util.Set;
 import java.util.TreeMap;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Linq4j.CollectionEnumerable;
 import static org.apache.calcite.linq4j.Linq4j.ListEnumerable;
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.linq4j.function.Functions.adapt;
 
+import static java.util.Collections.reverseOrder;
 import static java.util.Objects.requireNonNull;
 
 /** Default implementations of methods in the {@link Enumerable} interface. */
@@ -1441,9 +1444,10 @@ public static <TSource, TInner, TResult> Enumerable<TResult> correlateJoin(
       final Enumerable<TSource> outer,
       final Function1<TSource, Enumerable<TInner>> inner,
       final Function2<TSource, ? super @Nullable TInner, TResult> resultSelector) {
-    if (joinType == JoinType.RIGHT || joinType == JoinType.FULL) {
-      throw new IllegalArgumentException("JoinType " + joinType + " is not valid for correlation");
-    }
+    checkArgument(
+        joinType != JoinType.RIGHT && joinType != JoinType.FULL,
+        "JoinType %s is not valid for correlation",
+        joinType);
 
     return new AbstractEnumerable<TResult>() {
       @Override public Enumerator<TResult> enumerator() {
@@ -1606,8 +1610,8 @@ public static <TSource, TInner, TResult> Enumerable<TResult> correlateBatchJoin(
           int i = -1; // outer position
           int j = -1; // inner position
 
-          @SuppressWarnings("argument.type.incompatible")
-          @Override public TResult current() {
+          @Override @SuppressWarnings("argument.type.incompatible")
+          public TResult current() {
             return resultSelector.apply(outerValue, innerValue);
           }
 
@@ -1980,9 +1984,10 @@ private static <TSource, TInner, TResult> Enumerable<TResult> nestedLoopJoinOpti
       final Predicate2<TSource, TInner> predicate,
       Function2<? super TSource, ? super @Nullable TInner, TResult> resultSelector,
       final JoinType joinType) {
-    if (joinType == JoinType.RIGHT || joinType == JoinType.FULL) {
-      throw new IllegalArgumentException("JoinType " + joinType + " is unsupported");
-    }
+    checkArgument(
+        joinType != JoinType.RIGHT && joinType != JoinType.FULL,
+        "JoinType %s is unsupported",
+        joinType);
 
     return new AbstractEnumerable<TResult>() {
       @Override public Enumerator<TResult> enumerator() {
@@ -2617,7 +2622,7 @@ public static <TSource, TKey> Enumerable<TSource> orderBy(
                   // for first entry, use a singleton list to save space
                   // when we go from 1 to 2 elements, switch to array list
                   if (l == null) {
-                    return Collections.singletonList(o);
+                    return ImmutableList.of(o);
                   }
                   if (l.size() == 1) {
                     l = new ArrayList<>(l);
@@ -2664,7 +2669,7 @@ public static <TSource, TKey> Enumerable<TSource> orderBy(
   /** Sorts the elements of a sequence in descending order according to a key. */
   public static <TSource, TKey extends Comparable> Enumerable<TSource> orderByDescending(
       Enumerable<TSource> source, Function1<TSource, TKey> keySelector) {
-    return orderBy(source, keySelector, Collections.reverseOrder());
+    return orderBy(source, keySelector, Comparator.reverseOrder());
   }
 
   /** Sorts the elements of a sequence in descending order by using a specified comparer. */
@@ -2672,7 +2677,7 @@ public static <TSource, TKey> Enumerable<TSource> orderByDescending(
       Enumerable<TSource> source,
       Function1<TSource, TKey> keySelector,
       Comparator<TKey> comparator) {
-    return orderBy(source, keySelector, Collections.reverseOrder(comparator));
+    return orderBy(source, keySelector, reverseOrder(comparator));
   }
 
   /** Inverts the order of the elements in a sequence. */
@@ -3017,9 +3022,7 @@ public static <TSource> TSource single(Enumerable<TSource> source) {
       if (os.moveNext()) {
         toRet = os.current();
 
-        if (os.moveNext()) {
-          throw new IllegalStateException();
-        }
+        checkState(!os.moveNext());
       }
       if (toRet != null) {
         return toRet;
@@ -3438,7 +3441,7 @@ static <TSource, TKey, TElement> LookupImpl<TKey, TElement> toLookup_(
         List<TElement> list = map.get(key);
         if (list == null) {
           // for first entry, use a singleton list to save space
-          list = Collections.singletonList(elementSelector.apply(o));
+          list = ImmutableList.of(elementSelector.apply(o));
         } else {
           if (list.size() == 1) {
             // when we go from 1 to 2 elements, switch to array list
@@ -3869,8 +3872,8 @@ protected WrapMap(Function0<Map<Wrapped<K>, V>> mapProvider, EqualityComparer<K>
 
     @Override public Set<Entry<@KeyFor("this") K, V>> entrySet() {
       return new AbstractSet<Entry<@KeyFor("this") K, V>>() {
-        @SuppressWarnings("override.return.invalid")
-        @Override public Iterator<Entry<K, V>> iterator() {
+        @Override @SuppressWarnings("override.return.invalid")
+        public Iterator<Entry<K, V>> iterator() {
           final Iterator<Entry<Wrapped<K>, V>> iterator = map.entrySet().iterator();
 
           return new Iterator<Entry<K, V>>() {
@@ -3895,8 +3898,8 @@ protected WrapMap(Function0<Map<Wrapped<K>, V>> mapProvider, EqualityComparer<K>
       };
     }
 
-    @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
-    @Override public boolean containsKey(@Nullable Object key) {
+    @Override @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
+    public boolean containsKey(@Nullable Object key) {
       return map.containsKey(wrap((K) key));
     }
 
@@ -3909,8 +3912,8 @@ private Wrapped<K> wrap(K key) {
       return map.get(wrap((K) key));
     }
 
-    @SuppressWarnings("contracts.postcondition.not.satisfied")
-    @Override public @Nullable V put(K key, V value) {
+    @Override @SuppressWarnings("contracts.postcondition.not.satisfied")
+    public @Nullable V put(K key, V value) {
       return map.put(wrap(key), value);
     }
 
@@ -4130,7 +4133,7 @@ private boolean advance() {
                   new CartesianProductJoinEnumerator<>(
                       resultSelector,
                       Linq4j.enumerator(lefts),
-                      Linq4j.enumerator(Collections.singletonList(null)));
+                      Linq4j.enumerator(ImmutableList.of(null)));
               return true;
             }
             if (!getLeftEnumerator().moveNext()) {
@@ -4184,7 +4187,7 @@ private boolean advance() {
                   ? new CartesianProductJoinEnumerator<>(
                       resultSelector,
                       Linq4j.enumerator(lefts),
-                      Linq4j.enumerator(Collections.singletonList(rights.get(0))))
+                      Linq4j.enumerator(ImmutableList.of(rights.get(0))))
                   : new CartesianProductJoinEnumerator<>(
                       resultSelector, Linq4j.enumerator(lefts), Linq4j.enumerator(rights));
         } else {
@@ -4223,15 +4226,11 @@ private boolean advanceLeft(TSource left, TKey leftKey) {
         }
         int c = compare(leftKey, leftKey2);
         if (c != 0) {
-          if (c > 0) {
-            throw new IllegalStateException(
-                "mergeJoin assumes inputs sorted in ascending order, "
-                    + "however '"
-                    + leftKey
-                    + "' is greater than '"
-                    + leftKey2
-                    + "'");
-          }
+          checkState(
+              c <= 0,
+              "mergeJoin assumes inputs sorted in ascending order, however '%s' is greater than '%s'",
+              leftKey,
+              leftKey2);
           return true;
         }
         lefts.add(left);
@@ -4260,15 +4259,11 @@ private boolean advanceRight(TInner right, TKey rightKey) {
         }
         int c = compare(rightKey, rightKey2);
         if (c != 0) {
-          if (c > 0) {
-            throw new IllegalStateException(
-                "mergeJoin assumes input sorted in ascending order, "
-                    + "however '"
-                    + rightKey
-                    + "' is greater than '"
-                    + rightKey2
-                    + "'");
-          }
+          checkState(
+              c <= 0,
+              "mergeJoin assumes input sorted in ascending order, however '%s' is greater than '%s'",
+              rightKey,
+              rightKey2);
           return true;
         }
         rights.add(right);
@@ -4354,8 +4349,8 @@ private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>
       this.resultSelector = resultSelector;
     }
 
-    @SuppressWarnings("unchecked")
-    @Override public TResult current() {
+    @Override @SuppressWarnings("unchecked")
+    public TResult current() {
       final TOuter outer = (TOuter) elements[0];
       final TInner inner = (TInner) elements[1];
       return this.resultSelector.apply(outer, inner);
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/GroupingImpl.java b/linq4j/src/main/java/org/apache/calcite/linq4j/GroupingImpl.java
index e6b253a73..3a8133699 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/GroupingImpl.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/GroupingImpl.java
@@ -20,7 +20,8 @@
 
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Implementation of {@link Grouping}.
@@ -35,8 +36,8 @@ class GroupingImpl<K extends Object, V> extends AbstractEnumerable<V>
   private final List<V> values;
 
   GroupingImpl(K key, List<V> values) {
-    this.key = Objects.requireNonNull(key, "key");
-    this.values = Objects.requireNonNull(values, "values");
+    this.key = requireNonNull(key, "key");
+    this.values = requireNonNull(values, "values");
   }
 
   @Override public String toString() {
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/Linq4j.java b/linq4j/src/main/java/org/apache/calcite/linq4j/Linq4j.java
index aa5d2b5d0..f222662ee 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/Linq4j.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/Linq4j.java
@@ -545,8 +545,8 @@ protected Collection<T> getCollection() {
       return getCollection().size();
     }
 
-    @SuppressWarnings("argument.type.incompatible")
-    @Override public boolean contains(T element) {
+    @Override @SuppressWarnings("argument.type.incompatible")
+    public boolean contains(T element) {
       return getCollection().contains(element);
     }
 
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java b/linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java
index 28775cc59..6ea0189d1 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java
@@ -81,8 +81,8 @@ class LookupImpl<K, V> extends AbstractEnumerable<Grouping<K, V>> implements Loo
     return map.isEmpty();
   }
 
-  @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
-  @Override public boolean containsKey(@Nullable Object key) {
+  @Override @SuppressWarnings("contracts.conditional.postcondition.not.satisfied")
+  public boolean containsKey(@Nullable Object key) {
     return map.containsKey(key);
   }
 
@@ -97,8 +97,8 @@ class LookupImpl<K, V> extends AbstractEnumerable<Grouping<K, V>> implements Loo
     return list == null ? null : Linq4j.asEnumerable(list);
   }
 
-  @SuppressWarnings("contracts.postcondition.not.satisfied")
-  @Override public @Nullable Enumerable<V> put(K key, Enumerable<V> value) {
+  @Override @SuppressWarnings("contracts.postcondition.not.satisfied")
+  public @Nullable Enumerable<V> put(K key, Enumerable<V> value) {
     final List<V> list = map.put(key, value.toList());
     return list == null ? null : Linq4j.asEnumerable(list);
   }
@@ -118,8 +118,8 @@ class LookupImpl<K, V> extends AbstractEnumerable<Grouping<K, V>> implements Loo
     map.clear();
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public Set<@KeyFor("this") K> keySet() {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public Set<@KeyFor("this") K> keySet() {
     return map.keySet();
   }
 
@@ -150,8 +150,8 @@ class LookupImpl<K, V> extends AbstractEnumerable<Grouping<K, V>> implements Loo
     };
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public Set<Entry<@KeyFor({"this"}) K, Enumerable<V>>> entrySet() {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public Set<Entry<@KeyFor("this") K, Enumerable<V>>> entrySet() {
     final Set<Entry<@KeyFor("map") K, List<V>>> entries = map.entrySet();
     return new AbstractSet<Entry<K, Enumerable<V>>>() {
       @Override public Iterator<Entry<K, Enumerable<V>>> iterator() {
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/MemoryFactory.java b/linq4j/src/main/java/org/apache/calcite/linq4j/MemoryFactory.java
index 8a56934a9..5985e7f1e 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/MemoryFactory.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/MemoryFactory.java
@@ -20,6 +20,8 @@
 
 import java.util.Arrays;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Contains the State and changes internally. with the {@link #create()} method one can get
  * immutable Snapshots.
@@ -81,17 +83,16 @@ public E get() {
     }
 
     public E get(int position) {
-      if (position < 0 && position < -1 * history) {
-        throw new IllegalArgumentException(
-            "History can only go back "
-                + history
-                + " points in time, you wanted "
-                + Math.abs(position));
-      }
-      if (position > 0 && position > future) {
-        throw new IllegalArgumentException(
-            "Future can only see next " + future + " points in time, you wanted " + position);
-      }
+      checkArgument(
+          position >= 0 || position >= -1 * history,
+          "History can only go back %s points in time, you wanted %s",
+          history,
+          Math.abs(position));
+      checkArgument(
+          position <= 0 || position <= future,
+          "Future can only see next %s points in time, you wanted %s",
+          future,
+          position);
       return (E) this.values[this.offset.plus(position - 1 - future).get()];
     }
   }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/ModularInteger.java b/linq4j/src/main/java/org/apache/calcite/linq4j/ModularInteger.java
index 6f9c07d47..39cdda6fa 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/ModularInteger.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/ModularInteger.java
@@ -16,10 +16,10 @@
  */
 package org.apache.calcite.linq4j;
 
-import com.google.common.base.Preconditions;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Represents an integer in modular arithmetic. Its {@code value} is between 0 and {@code m - 1} for
  * some modulus {@code m}.
@@ -32,7 +32,7 @@ class ModularInteger {
 
   /** Creates a ModularInteger. */
   ModularInteger(int value, int modulus) {
-    Preconditions.checkArgument(value >= 0 && value < modulus);
+    checkArgument(value >= 0 && value < modulus);
     this.value = value;
     this.modulus = modulus;
   }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/Nullness.java b/linq4j/src/main/java/org/apache/calcite/linq4j/Nullness.java
index 37402a8a3..784ece91f 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/Nullness.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/Nullness.java
@@ -31,7 +31,7 @@
  * <p>The class enables to remove checker-qual runtime dependency, and helps IDEs to see the
  * resulting types of {@code castNonNull} better.
  */
-@SuppressWarnings({"cast.unsafe", "RedundantCast", "contracts.postcondition.not.satisfied"})
+@SuppressWarnings({"cast.unsafe", "contracts.postcondition.not.satisfied", "RedundantCast"})
 public class Nullness {
   private Nullness() {}
 
@@ -64,9 +64,8 @@ private Nullness() {}
    * @param ref a reference of @Nullable type, that is non-null at run time
    * @return the argument, cast to have the type qualifier @NonNull
    */
-  @Pure
-  public static @EnsuresNonNull("#1") <T extends @Nullable Object> @NonNull T castNonNull(
-      @Nullable T ref) {
+  @EnsuresNonNull("#1")
+  public static @Pure <T extends @Nullable Object> @NonNull T castNonNull(@Nullable T ref) {
     //noinspection ConstantConditions
     return (@NonNull T) ref;
   }
@@ -78,8 +77,8 @@ private Nullness() {}
    * @param ts Array
    * @return the argument, cast so that elements are @NonNull
    */
-  @SuppressWarnings({"unchecked", "ConstantConditions"})
   @Pure
+  @SuppressWarnings({"ConstantConditions", "unchecked"})
   public static <T> @NonNull T[] castNonNullArray(@Nullable T[] ts) {
     return (@NonNull T[]) (Object) ts;
   }
@@ -91,8 +90,8 @@ private Nullness() {}
    * @param ts List
    * @return the argument, cast so that elements are @NonNull
    */
-  @SuppressWarnings({"unchecked", "rawtypes"})
   @Pure
+  @SuppressWarnings({"rawtypes", "unchecked"})
   public static <T> List<@NonNull T> castNonNullList(List<? extends @Nullable T> ts) {
     return (List) (Object) ts;
   }
@@ -105,8 +104,8 @@ private Nullness() {}
    * @param ref A reference that was @Uninitialized at some point but is now fully initialized
    * @return the argument, cast to have type qualifier @Initialized
    */
-  @SuppressWarnings({"unchecked"})
   @Pure
+  @SuppressWarnings("unchecked")
   public static <T> T castToInitialized(@UnderInitialization T ref) {
     // To throw CheckerFramework off the scent, we put the object into an array,
     // cast the array to an Object, and cast back to an array.
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/QueryableRecorder.java b/linq4j/src/main/java/org/apache/calcite/linq4j/QueryableRecorder.java
index f4a6f8a89..223ce0fe1 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/QueryableRecorder.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/QueryableRecorder.java
@@ -265,8 +265,8 @@ public static <T> QueryableRecorder<T> instance() {
     };
   }
 
-  @SuppressWarnings("return.type.incompatible")
-  @Override public Queryable<@PolyNull T> defaultIfEmpty(final Queryable<T> source, final @PolyNull T value) {
+  @Override @SuppressWarnings("return.type.incompatible")
+  public Queryable<@PolyNull T> defaultIfEmpty(final Queryable<T> source, final @PolyNull T value) {
     return new NonLeafReplayableQueryable<T>(source) {
       @Override public void replay(QueryableFactory<T> factory) {
         factory.defaultIfEmpty(source, value);
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Experimental.java b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Experimental.java
index c9a097dfb..2e9a16814 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Experimental.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Experimental.java
@@ -33,7 +33,7 @@
  * <p>And yes, it is flagged experimental. We may move it elsewhere in future, when we re-think the
  * maturity model.
  */
-@Target({PACKAGE, TYPE, FIELD, METHOD, CONSTRUCTOR})
+@Target({CONSTRUCTOR, FIELD, METHOD, PACKAGE, TYPE})
 @Retention(RetentionPolicy.SOURCE)
 @Experimental
 public @interface Experimental {}
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java
index 8f3245f7f..58e54873c 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.linq4j.function;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.framework.qual.DefaultQualifier;
 import org.checkerframework.framework.qual.TypeUseLocation;
@@ -26,7 +28,6 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
@@ -35,12 +36,16 @@
 import java.util.RandomAccess;
 import java.util.function.IntFunction;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Collections.unmodifiableMap;
+
 /** Utilities relating to functions. */
 public abstract class Functions {
   private Functions() {}
 
   public static final Map<Class<? extends Function>, Class> FUNCTION_RESULT_TYPES =
-      Collections.unmodifiableMap(
+      unmodifiableMap(
           map(
               Function0.class, Object.class,
               Function1.class, Object.class,
@@ -57,7 +62,7 @@ private Functions() {}
               NullableLongFunction1.class, Long.class));
 
   private static final Map<Class, Class<? extends Function>> FUNCTION1_CLASSES =
-      Collections.unmodifiableMap(new HashMap<>(inverse(FUNCTION_RESULT_TYPES)));
+      unmodifiableMap(new HashMap<>(inverse(FUNCTION_RESULT_TYPES)));
 
   private static final Comparator NULLS_FIRST_COMPARATOR = new NullsFirstComparator();
 
@@ -306,7 +311,7 @@ public static <E> List<E> filter(List<E> list, Predicate1<E> predicate) {
         }
       }
       if (hitCount == 0) {
-        return Collections.emptyList();
+        return ImmutableList.of();
       }
       if (missCount == 0) {
         return list;
@@ -345,9 +350,7 @@ public static <E> boolean all(List<? extends E> list, Predicate1<E> predicate) {
    * Returns a list generated by applying a function to each index between 0 and {@code size} - 1.
    */
   public static <E> List<E> generate(final int size, final IntFunction<E> fn) {
-    if (size < 0) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(size >= 0);
     return new GeneratingList<>(size, fn);
   }
 
@@ -579,10 +582,7 @@ private static final class Ignore<@Nullable R, T0, T1>
 
     @DefaultQualifier(
         value = Nullable.class,
-        locations = {
-          TypeUseLocation.LOWER_BOUND,
-          TypeUseLocation.UPPER_BOUND,
-        })
+        locations = {TypeUseLocation.LOWER_BOUND, TypeUseLocation.UPPER_BOUND})
     static final Ignore INSTANCE = new Ignore<>();
   }
 
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Parameter.java b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Parameter.java
index 3123e4173..d467ddfe0 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Parameter.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Parameter.java
@@ -51,7 +51,7 @@
  * will be mandatory.
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.PARAMETER})
+@Target(ElementType.PARAMETER)
 public @interface Parameter {
   /**
    * The name of the parameter.
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
index 090bcf633..69277406d 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
@@ -106,7 +106,7 @@ public Expression append(String name, BlockStatement block) {
    *     this if the expression has side-effects or a time-dependent value.
    */
   public Expression append(String name, BlockStatement block, boolean optimize) {
-    if (statements.size() > 0) {
+    if (!statements.isEmpty()) {
       Statement lastStatement = statements.get(statements.size() - 1);
       if (lastStatement instanceof GotoStatement) {
         // convert "return expr;" into "expr;"
@@ -199,7 +199,7 @@ public Expression append(String name, Expression expression) {
    * more than once.
    */
   public Expression append(String name, Expression expression, boolean optimize) {
-    if (statements.size() > 0) {
+    if (!statements.isEmpty()) {
       Statement lastStatement = statements.get(statements.size() - 1);
       if (lastStatement instanceof GotoStatement) {
         // convert "return expr;" into "expr;"
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/ConstantExpression.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/ConstantExpression.java
index bba77f08d..3770bfda4 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/ConstantExpression.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/ConstantExpression.java
@@ -28,9 +28,9 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
 
 /** Represents an expression that has a constant value. */
 public class ConstantExpression extends Expression {
@@ -211,7 +211,7 @@ private static ExpressionWriter write(
                       throw new RuntimeException(e);
                     }
                   })
-              .collect(Collectors.toList()),
+              .collect(toList()),
           "(\n",
           ",\n",
           ")");
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
index 6ec4b9af8..03f9ff843 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
@@ -171,8 +171,7 @@ && isMethodDeterministic(methodCallExpression.method)) {
       List<Expression> expressions) {
     Expression result = super.visit(methodCallExpression, targetExpression, expressions);
 
-    result = tryOptimizeMethodCall((MethodCallExpression) result);
-    return result;
+    return tryOptimizeMethodCall((MethodCallExpression) result);
   }
 
   @Override public Expression visit(MemberExpression memberExpression, @Nullable Expression expression) {
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
index 048326092..606e7c5b9 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
@@ -38,7 +38,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
 
@@ -63,7 +62,7 @@ public static String toString(List<? extends Node> expressions, String sep, bool
 
   /** Converts an expression to Java source code. */
   public static String toString(Node expression) {
-    return toString(Collections.singletonList(expression), "", true);
+    return toString(ImmutableList.of(expression), "", true);
   }
 
   /**
@@ -203,7 +202,7 @@ public static BinaryExpression andAssign(
    * Creates an expression that represents applying an array index operator to an array of rank one.
    */
   public static IndexExpression arrayIndex(Expression array, Expression indexExpression) {
-    return new IndexExpression(array, Collections.singletonList(indexExpression));
+    return new IndexExpression(array, ImmutableList.of(indexExpression));
   }
 
   /**
@@ -250,7 +249,7 @@ public static BlockStatement block(
       @Nullable Type type, Iterable<? extends Statement> expressions) {
     List<Statement> list = toList(expressions);
     if (type == null) {
-      if (list.size() > 0) {
+      if (!list.isEmpty()) {
         type = list.get(list.size() - 1).getType();
       } else {
         type = Void.TYPE;
@@ -1102,7 +1101,7 @@ public static ForStatement for_(
       @Nullable Expression condition,
       @Nullable Expression post,
       Statement body) {
-    return new ForStatement(Collections.singletonList(declaration), condition, post, body);
+    return new ForStatement(ImmutableList.of(declaration), condition, post, body);
   }
 
   /** Creates a ForEachExpression with the given body. */
@@ -2552,7 +2551,7 @@ private static <T> List<T> toList(Iterable<? extends T> iterable) {
 
   private static <T> List<T> toList(T[] ts) {
     if (ts.length == 0) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     } else {
       return Arrays.asList(ts);
     }
@@ -2598,9 +2597,9 @@ static List<Node> acceptNodes(List<Node> nodes, Shuttle shuttle) {
   static List<Expression> acceptParameterExpressions(
       List<ParameterExpression> parameterExpressions, Shuttle shuttle) {
     if (parameterExpressions.isEmpty()) {
-      return Collections.emptyList(); // short cut
+      return ImmutableList.of(); // short cut
     }
-    final ImmutableList.Builder<Expression> parameterExpressions1 = new ImmutableList.Builder<>();
+    final ImmutableList.Builder<Expression> parameterExpressions1 = ImmutableList.builder();
     for (ParameterExpression parameterExpression : parameterExpressions) {
       parameterExpressions1.add(parameterExpression.accept(shuttle));
     }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/ForEachStatement.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/ForEachStatement.java
index f1ececd47..c208a7a48 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/ForEachStatement.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/ForEachStatement.java
@@ -20,6 +20,8 @@
 
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /** Represents a "for-each" loop, "for (T v : iterable) { f(v); }". */
 public class ForEachStatement extends Statement {
   public final ParameterExpression parameter;
@@ -31,9 +33,9 @@ public class ForEachStatement extends Statement {
 
   public ForEachStatement(ParameterExpression parameter, Expression iterable, Statement body) {
     super(ExpressionType.ForEach, Void.TYPE);
-    this.parameter = Objects.requireNonNull(parameter, "parameter");
-    this.iterable = Objects.requireNonNull(iterable, "iterable");
-    this.body = Objects.requireNonNull(body, "body"); // may be empty block, not null
+    this.parameter = requireNonNull(parameter, "parameter");
+    this.iterable = requireNonNull(iterable, "iterable");
+    this.body = requireNonNull(body, "body"); // may be empty block, not null
   }
 
   @Override public ForEachStatement accept(Shuttle shuttle) {
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java
index fe9a3a012..cc3bc7557 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java
@@ -952,17 +952,17 @@ && ordinal() >= primitive.ordinal()
   public Number number(Number value) {
     switch (this) {
       case BYTE:
-        return Byte.valueOf(value.byteValue());
+        return value.byteValue();
       case DOUBLE:
-        return Double.valueOf(value.doubleValue());
+        return value.doubleValue();
       case FLOAT:
-        return Float.valueOf(value.floatValue());
+        return value.floatValue();
       case INT:
-        return Integer.valueOf(value.intValue());
+        return value.intValue();
       case LONG:
-        return Long.valueOf(value.longValue());
+        return value.longValue();
       case SHORT:
-        return Short.valueOf(value.shortValue());
+        return value.shortValue();
       default:
         throw new AssertionError(this + ": " + value);
     }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/TryStatement.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/TryStatement.java
index 5b4eb7813..f54f97463 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/TryStatement.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/TryStatement.java
@@ -22,6 +22,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static java.util.Objects.requireNonNull;
+
 /** Represents a {@code try ... catch ... finally} block. */
 public class TryStatement extends Statement {
   public final Statement body;
@@ -30,8 +32,8 @@ public class TryStatement extends Statement {
 
   public TryStatement(Statement body, List<CatchBlock> catchBlocks, @Nullable Statement fynally) {
     super(ExpressionType.Try, body.getType());
-    this.body = Objects.requireNonNull(body, "body");
-    this.catchBlocks = Objects.requireNonNull(catchBlocks, "catchBlocks");
+    this.body = requireNonNull(body, "body");
+    this.catchBlocks = requireNonNull(catchBlocks, "catchBlocks");
     this.fynally = fynally;
   }
 
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
index 09a8d526f..55165a8bc 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
@@ -18,6 +18,8 @@
 
 import org.apache.calcite.linq4j.Enumerator;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Array;
@@ -31,7 +33,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
@@ -90,9 +91,9 @@ public static Type of(Type type, Type... typeArguments) {
   private static <T> List<T> toList(T[] ts) {
     switch (ts.length) {
       case 0:
-        return Collections.emptyList();
+        return ImmutableList.of();
       case 1:
-        return Collections.singletonList(ts[0]);
+        return ImmutableList.of(ts[0]);
       default:
         return Arrays.asList(ts.clone());
     }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java
index c97ea6d0c..efbc3fb9a 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java
@@ -34,8 +34,7 @@ public VisitorImpl() {
 
   @Override public R visit(BinaryExpression binaryExpression) {
     R r0 = binaryExpression.expression0.accept(this);
-    R r1 = binaryExpression.expression1.accept(this);
-    return r1;
+    return binaryExpression.expression1.accept(this);
   }
 
   @Override public R visit(BlockStatement blockStatement) {
diff --git a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java
index 489d7e62b..d6927693c 100644
--- a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java
+++ b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java
@@ -158,7 +158,7 @@ public MongoAggregate(
   private static String toMongo(
       SqlAggFunction aggregation, List<String> inNames, List<Integer> args) {
     if (aggregation == SqlStdOperatorTable.COUNT) {
-      if (args.size() == 0) {
+      if (args.isEmpty()) {
         return "{$sum: 1}";
       } else {
         assert args.size() == 1;
diff --git a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
index a452cfaed..7a36b0665 100644
--- a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
+++ b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
@@ -216,7 +216,7 @@ protected RexToMongoTranslator(JavaTypeFactory typeFactory, List<String> inField
         return sb.toString();
       }
       throw new IllegalArgumentException(
-          "Translation of " + call.toString() + " is not supported by MongoProject");
+          "Translation of " + call + " is not supported by MongoProject");
     }
 
     private static String stripQuotes(String s) {
diff --git a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSchema.java b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSchema.java
index b82210986..03184d4d2 100644
--- a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSchema.java
+++ b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoSchema.java
@@ -28,7 +28,8 @@
 import com.mongodb.client.MongoDatabase;
 
 import java.util.Map;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Schema mapped onto a directory of MONGO files. Each table in the schema is a MONGO file in that
@@ -67,7 +68,7 @@ public class MongoSchema extends AbstractSchema {
   @VisibleForTesting
   MongoSchema(MongoDatabase mongoDb) {
     super();
-    this.mongoDb = Objects.requireNonNull(mongoDb, "mongoDb");
+    this.mongoDb = requireNonNull(mongoDb, "mongoDb");
   }
 
   @Override protected Map<String, Table> getTableMap() {
diff --git a/pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java b/pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java
index ac5fea049..d35557eef 100644
--- a/pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java
+++ b/pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java
@@ -104,7 +104,7 @@ private String getPigGroupBy(Implementor implementor) {
     final String relAlias = implementor.getPigRelationAlias(this);
     final List<RelDataTypeField> allFields = getInput().getRowType().getFieldList();
     final List<Integer> groupedFieldIndexes = groupSet.asList();
-    if (groupedFieldIndexes.size() < 1) {
+    if (groupedFieldIndexes.isEmpty()) {
       return relAlias + " = GROUP " + relAlias + " ALL;";
     } else {
       final List<String> groupedFieldNames = new ArrayList<>(groupedFieldIndexes.size());
@@ -175,7 +175,7 @@ private String getPigAggregateCall(String relAlias, AggregateCall aggCall) {
 
   private static PigAggFunction toPigAggFunc(AggregateCall aggCall) {
     return PigAggFunction.valueOf(
-        aggCall.getAggregation().getKind(), aggCall.getArgList().size() < 1);
+        aggCall.getAggregation().getKind(), aggCall.getArgList().isEmpty());
   }
 
   private List<String> getArgNames(String relAlias, AggregateCall aggCall) {
diff --git a/pig/src/main/java/org/apache/calcite/adapter/pig/PigFilter.java b/pig/src/main/java/org/apache/calcite/adapter/pig/PigFilter.java
index 9ec78ea58..1f0a542a8 100644
--- a/pig/src/main/java/org/apache/calcite/adapter/pig/PigFilter.java
+++ b/pig/src/main/java/org/apache/calcite/adapter/pig/PigFilter.java
@@ -27,11 +27,11 @@
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexNode;
 
-import com.google.common.base.Preconditions;
-
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.sql.SqlKind.INPUT_REF;
 import static org.apache.calcite.sql.SqlKind.LITERAL;
 
@@ -71,7 +71,7 @@ public PigFilter(RelOptCluster cluster, RelTraitSet traitSet, RelNode input, Rex
    * </blockquote>
    */
   private String getPigFilterStatement(Implementor implementor) {
-    Preconditions.checkState(containsOnlyConjunctions(condition));
+    checkState(containsOnlyConjunctions(condition));
     String relationAlias = implementor.getPigRelationAlias(this);
     List<String> filterConditionsConjunction = new ArrayList<>();
     for (RexNode node : RelOptUtil.conjunctions(condition)) {
diff --git a/pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java b/pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java
index eb681b881..8a7f35957 100644
--- a/pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java
+++ b/pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java
@@ -33,6 +33,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Implementation of {@link org.apache.calcite.rel.core.Join} in {@link PigRel#CONVENTION Pig
  * calling convention}.
@@ -86,13 +88,9 @@ public PigJoin(
    * Only supports simple equi-joins with single column on both sides of <code>=</code>.
    */
   private String getPigJoinStatement(Implementor implementor) {
-    if (!getCondition().isA(SqlKind.EQUALS)) {
-      throw new IllegalArgumentException("Only equi-join are supported");
-    }
+    checkArgument(getCondition().isA(SqlKind.EQUALS), "Only equi-join are supported");
     List<RexNode> operands = ((RexCall) getCondition()).getOperands();
-    if (operands.size() != 2) {
-      throw new IllegalArgumentException("Only equi-join are supported");
-    }
+    checkArgument(operands.size() == 2, "Only equi-join are supported");
     List<Integer> leftKeys = new ArrayList<>(1);
     List<Integer> rightKeys = new ArrayList<>(1);
     List<Boolean> filterNulls = new ArrayList<>(1);
diff --git a/pig/src/main/java/org/apache/calcite/adapter/pig/PigRelFactories.java b/pig/src/main/java/org/apache/calcite/adapter/pig/PigRelFactories.java
index c3fea4f0f..2fba58251 100644
--- a/pig/src/main/java/org/apache/calcite/adapter/pig/PigRelFactories.java
+++ b/pig/src/main/java/org/apache/calcite/adapter/pig/PigRelFactories.java
@@ -31,12 +31,13 @@
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Implementations of factories in {@link RelFactories} for the Pig adapter. */
 public class PigRelFactories {
 
@@ -73,7 +74,7 @@ public static class PigFilterFactory implements RelFactories.FilterFactory {
     public static final PigFilterFactory INSTANCE = new PigFilterFactory();
 
     @Override public RelNode createFilter(RelNode input, RexNode condition, Set<CorrelationId> variablesSet) {
-      Preconditions.checkArgument(variablesSet.isEmpty(), "PigFilter does not allow variables");
+      checkArgument(variablesSet.isEmpty(), "PigFilter does not allow variables");
       final RelTraitSet traitSet = input.getTraitSet().replace(PigRel.CONVENTION);
       return new PigFilter(input.getCluster(), traitSet, input, condition);
     }
diff --git a/pig/src/main/java/org/apache/calcite/adapter/pig/PigTableFactory.java b/pig/src/main/java/org/apache/calcite/adapter/pig/PigTableFactory.java
index 247bfc25e..a8592b25e 100644
--- a/pig/src/main/java/org/apache/calcite/adapter/pig/PigTableFactory.java
+++ b/pig/src/main/java/org/apache/calcite/adapter/pig/PigTableFactory.java
@@ -36,8 +36,8 @@ public class PigTableFactory implements TableFactory<PigTable> {
   // public constructor, per factory contract
   public PigTableFactory() {}
 
-  @SuppressWarnings("unchecked")
-  @Override public PigTable create(
+  @Override @SuppressWarnings("unchecked")
+  public PigTable create(
       SchemaPlus schema, String name, Map<String, Object> operand, @Nullable RelDataType rowType) {
     String fileName = (String) operand.get("file");
     File file = new File(fileName);
diff --git a/pig/src/main/java/org/apache/calcite/adapter/pig/PigTableScan.java b/pig/src/main/java/org/apache/calcite/adapter/pig/PigTableScan.java
index 8a1ad6d9b..8985d16da 100644
--- a/pig/src/main/java/org/apache/calcite/adapter/pig/PigTableScan.java
+++ b/pig/src/main/java/org/apache/calcite/adapter/pig/PigTableScan.java
@@ -33,7 +33,8 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Implementation of {@link org.apache.calcite.rel.core.TableScan} in {@link PigRel#CONVENTION Pig
@@ -58,7 +59,7 @@ public PigTableScan(RelOptCluster cluster, RelTraitSet traitSet, RelOptTable tab
 
   private PigTable getPigTable(String name) {
     final CalciteSchema schema = getTable().unwrapOrThrow(CalciteSchema.class);
-    return (PigTable) Objects.requireNonNull(schema.getTable(name, false)).getTable();
+    return (PigTable) requireNonNull(schema.getTable(name, false)).getTable();
   }
 
   private String getSchemaForPigStatement(Implementor implementor) {
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/Ast.java b/piglet/src/main/java/org/apache/calcite/piglet/Ast.java
index 3a7301504..df0242656 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/Ast.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/Ast.java
@@ -27,7 +27,8 @@
 
 import java.math.BigDecimal;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /**
  * Abstract syntax tree.
@@ -180,8 +181,8 @@ public abstract static class Node {
     public final SqlParserPos pos;
 
     protected Node(SqlParserPos pos, Op op) {
-      this.op = Objects.requireNonNull(op, "op");
-      this.pos = Objects.requireNonNull(pos, "pos");
+      this.op = requireNonNull(op, "op");
+      this.pos = requireNonNull(pos, "pos");
     }
   }
 
@@ -198,7 +199,7 @@ public abstract static class Assignment extends Stmt {
 
     protected Assignment(SqlParserPos pos, Op op, Identifier target) {
       super(pos, op);
-      this.target = Objects.requireNonNull(target, "target");
+      this.target = requireNonNull(target, "target");
     }
   }
 
@@ -208,7 +209,7 @@ public static class LoadStmt extends Assignment {
 
     public LoadStmt(SqlParserPos pos, Identifier target, Literal name) {
       super(pos, Op.LOAD, target);
-      this.name = Objects.requireNonNull(name, "name");
+      this.name = requireNonNull(name, "name");
     }
   }
 
@@ -225,7 +226,7 @@ public ValuesStmt(
         SqlParserPos pos, Identifier target, Schema schema, List<List<Node>> tupleList) {
       super(pos, Op.VALUES, target);
       this.schema = schema;
-      this.tupleList = ImmutableList.copyOf(tupleList);
+      this.tupleList = tupleList;
     }
   }
 
@@ -404,7 +405,7 @@ public static class GroupStmt extends Assignment1 {
     public GroupStmt(SqlParserPos pos, Identifier target, Identifier source, List<Node> keys) {
       super(pos, Op.GROUP, target, source);
       this.keys = keys;
-      assert keys == null || keys.size() >= 1;
+      assert keys == null || !keys.isEmpty();
     }
   }
 
@@ -414,7 +415,7 @@ public static class DumpStmt extends Stmt {
 
     public DumpStmt(SqlParserPos pos, Identifier relation) {
       super(pos, Op.DUMP);
-      this.relation = Objects.requireNonNull(relation, "relation");
+      this.relation = requireNonNull(relation, "relation");
     }
   }
 
@@ -424,7 +425,7 @@ public static class DescribeStmt extends Stmt {
 
     public DescribeStmt(SqlParserPos pos, Identifier relation) {
       super(pos, Op.DESCRIBE);
-      this.relation = Objects.requireNonNull(relation, "relation");
+      this.relation = requireNonNull(relation, "relation");
     }
   }
 
@@ -434,7 +435,7 @@ public static class Literal extends Node {
 
     public Literal(SqlParserPos pos, Object value) {
       super(pos, Op.LITERAL);
-      this.value = Objects.requireNonNull(value, "value");
+      this.value = requireNonNull(value, "value");
     }
 
     public static NumericLiteral createExactNumeric(String s, SqlParserPos pos) {
@@ -486,7 +487,7 @@ public static class Identifier extends Node {
 
     public Identifier(SqlParserPos pos, String value) {
       super(pos, Op.IDENTIFIER);
-      this.value = Objects.requireNonNull(value, "value");
+      this.value = requireNonNull(value, "value");
     }
 
     public boolean isStar() {
@@ -511,7 +512,7 @@ public static class Call extends Node {
 
     private Call(SqlParserPos pos, Op op, ImmutableList<Node> operands) {
       super(pos, op);
-      this.operands = ImmutableList.copyOf(operands);
+      this.operands = operands.asList();
     }
 
     public Call(SqlParserPos pos, Op op, Iterable<? extends Node> operands) {
@@ -550,8 +551,8 @@ public static class FieldSchema extends Node {
 
     public FieldSchema(SqlParserPos pos, Identifier id, Type type) {
       super(pos, Op.FIELD_SCHEMA);
-      this.id = Objects.requireNonNull(id, "id");
-      this.type = Objects.requireNonNull(type, "type");
+      this.id = requireNonNull(id, "id");
+      this.type = requireNonNull(type, "type");
     }
   }
 
@@ -571,7 +572,7 @@ public static class Schema extends Node {
 
     public Schema(SqlParserPos pos, List<FieldSchema> fieldSchemaList) {
       super(pos, Op.SCHEMA);
-      this.fieldSchemaList = ImmutableList.copyOf(fieldSchemaList);
+      this.fieldSchemaList = fieldSchemaList;
     }
   }
 
@@ -608,7 +609,7 @@ public static class TupleType extends Type {
 
     public TupleType(SqlParserPos pos, List<FieldSchema> fieldSchemaList) {
       super(pos, Op.TUPLE_TYPE);
-      this.fieldSchemaList = ImmutableList.copyOf(fieldSchemaList);
+      this.fieldSchemaList = fieldSchemaList;
     }
   }
 
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
index 872d30673..e60cb59a4 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
@@ -54,13 +54,13 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.function.UnaryOperator;
 
+import static java.util.Objects.requireNonNull;
+
 /** Extension to {@link RelBuilder} for Pig logical operators. */
 public class PigRelBuilder extends RelBuilder {
   private final Map<RelNode, String> reverseAliasMap = new HashMap<>();
@@ -222,7 +222,7 @@ void replaceTop(RelNode newRel) {
   public RelBuilder scan(RelOptTable userSchema, String... tableNames) {
     // First, look up the database schema to find the table schema with the given names
     final List<String> names = ImmutableList.copyOf(tableNames);
-    Objects.requireNonNull(relOptSchema, "relOptSchema");
+    requireNonNull(relOptSchema, "relOptSchema");
     final RelOptTable systemSchema = relOptSchema.getTableForMember(names);
 
     // Now we may end up with two different schemas.
@@ -502,8 +502,7 @@ public RelBuilder multiSetFlatten() {
     // [CALCITE-3193] Add RelBuilder.uncollect method, and interface
     // UncollectFactory, to instantiate Uncollect
     Uncollect uncollect =
-        Uncollect.create(
-            cluster.traitSetOf(Convention.NONE), build(), false, Collections.emptyList());
+        Uncollect.create(cluster.traitSetOf(Convention.NONE), build(), false, ImmutableList.of());
     push(uncollect);
     return this;
   }
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java
index 27a2f168f..8b74da9ec 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java
@@ -73,6 +73,8 @@
 import java.util.Deque;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Visits pig expression plans and converts them into corresponding RexNodes. */
 class PigRelExVisitor extends LogicalExpressionVisitor {
   /** Stack used during post-order walking process when processing a Pig expression plan. */
@@ -217,10 +219,8 @@ private ImmutableList<RexNode> buildBinaryOperands() {
               break;
             }
           }
-          if (index < 0) {
-            throw new IllegalArgumentException(
-                "field [" + fullAlias + "] not found; input fields are: " + fieldNames);
-          }
+          checkArgument(
+              index >= 0, "field [%s] not found; input fields are: %s", fullAlias, fieldNames);
         }
         inputRef = builder.field(inputCount, inputOrdinal, index);
       }
@@ -375,7 +375,7 @@ private static int optSize(List<Operator> list) {
   @Override public void visit(DereferenceExpression op) throws FrontendException {
     final RexNode parentField = stack.pop();
     List<Integer> cols = op.getBagColumns();
-    assert cols != null && cols.size() > 0;
+    assert cols != null && !cols.isEmpty();
 
     if (parentField.getType() instanceof MultisetSqlType) {
       // Calcite does not support projection on Multiset type. We build
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpInnerVisitor.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpInnerVisitor.java
index 8b36e2044..303b08d5a 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpInnerVisitor.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpInnerVisitor.java
@@ -46,6 +46,8 @@
 import java.util.Deque;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Visits Pig logical operators of Pig inner logical plans (in {@link
  * org.apache.pig.newplan.logical.relational.LOForEach}) and converts them into corresponding
@@ -86,7 +88,7 @@ class PigRelOpInnerVisitor extends PigRelOpVisitor {
     final List<Integer> multisetFlattens = new ArrayList<>();
     final List<String> flattenOutputAliases = new ArrayList<>();
     doGenerateWithoutMultisetFlatten(gen, multisetFlattens, flattenOutputAliases);
-    if (multisetFlattens.size() > 0) {
+    if (!multisetFlattens.isEmpty()) {
       builder.multiSetFlatten(multisetFlattens, flattenOutputAliases);
     }
   }
@@ -110,7 +112,7 @@ private void makeCorrelates() throws FrontendException {
         corRels.add(0, builder.build());
       }
 
-      assert corRels.size() > 0;
+      assert !corRels.isEmpty();
       builder.push(corRels.get(0));
       builder.collect();
       // Now collapse these rels to a single multiset row and join them together
@@ -144,10 +146,10 @@ private void doGenerateWithoutMultisetFlatten(
     final List<RexNode> innerCols = new ArrayList<>(); // For projection expressions
     final List<String> fieldAlias = new ArrayList<>(); // For projection names/alias
 
-    if (gen.getOutputPlanSchemas() == null) {
-      throw new IllegalArgumentException(
-          "Generate statement at line " + gen.getLocation().line() + " produces empty schema");
-    }
+    checkArgument(
+        gen.getOutputPlanSchemas() != null,
+        "Generate statement at line %s produces empty schema",
+        gen.getLocation().line());
 
     for (int i = 0; i < pigProjections.size(); i++) {
       final LogicalSchema outputFieldSchema = gen.getOutputPlanSchemas().get(i);
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java
index e80ca50d8..c05de04c2 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java
@@ -72,11 +72,12 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Visits Pig logical operators and converts them into corresponding relational algebra plans. */
 class PigRelOpVisitor extends PigRelOpWalker.PlanPreVisitor {
   // The relational algebra builder customized for Pig
@@ -291,7 +292,7 @@ private void processCube(GroupType groupType, LOCogroup loCogroup) throws Fronte
     preprocessCogroup(loCogroup, true);
 
     // Generate the group set for the corresponding group type.
-    ImmutableList.Builder<ImmutableBitSet> groupsetBuilder = new ImmutableList.Builder<>();
+    ImmutableList.Builder<ImmutableBitSet> groupsetBuilder = ImmutableList.builder();
     List<Integer> keyIndexs = new ArrayList<>();
     groupsetBuilder.add(ImmutableBitSet.of(keyIndexs));
     int groupCount = loCogroup.getExpressionPlans().get(0).size();
@@ -401,7 +402,7 @@ private List<RexNode> getGroupRowOperands(List<RexNode> fieldRels, boolean isCub
           cubeRowFields.add(field);
         }
       }
-      return ImmutableList.copyOf(cubeRowFields);
+      return cubeRowFields;
     }
     return rowFields;
   }
@@ -500,7 +501,7 @@ private static GroupType getGroupType(LOCogroup pigGroup) {
     boolean[] innerFlags = new boolean[numInputs];
     for (int i = 0; i < numInputs; i++) {
       // Adding empty join keys
-      joinPlans.put(i, Collections.emptyList());
+      joinPlans.put(i, ImmutableList.of());
       innerFlags[i] = true;
     }
     joinInternal(joinPlans, innerFlags);
@@ -568,11 +569,9 @@ private static JoinRelType getJoinType(boolean leftInner, boolean rightInner) {
     // support UNION of input with different schemas, so we need to make sure to have inputs
     // with same schema first.
     LogicalSchema unionSchema = loUnion.getSchema();
-    if (unionSchema == null) {
-      throw new IllegalArgumentException(
-          "UNION on incompatible types is not supported. "
-              + "Please consider using ONSCHEMA option");
-    }
+    checkArgument(
+        unionSchema != null,
+        "UNION on incompatible types is not supported. " + "Please consider using ONSCHEMA option");
     // First get the shared schema
     int numInputs = loUnion.getInputs().size();
     RelDataType unionRelType = PigTypes.convertSchema(unionSchema);
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java
index 3541fc530..8f800b30c 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java
@@ -51,7 +51,6 @@
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import static org.apache.calcite.piglet.PigTypes.TYPE_FACTORY;
@@ -318,9 +317,7 @@ public static Tuple buildBag(Object... elements) {
     if (elements != null) {
       // The first input contains a list of rows for the bag
       final List bag =
-          (elements[0] instanceof List)
-              ? (List) elements[0]
-              : Collections.singletonList(elements[0]);
+          (elements[0] instanceof List) ? (List) elements[0] : ImmutableList.of(elements[0]);
       for (Object row : bag) {
         tupleList.add(tupleFactory.newTuple(Arrays.asList(row)));
       }
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java b/piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java
index dc814d499..ff4628a6b 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java
@@ -396,7 +396,7 @@ private static List<Integer> getAggColumns(RexCall pigAggCall) {
 
   private static List<Integer> getColsFromMultisetProjection(RexCall multisetProjection) {
     final List<Integer> columns = new ArrayList<>();
-    assert multisetProjection.getOperands().size() >= 1;
+    assert !multisetProjection.getOperands().isEmpty();
     for (int i = 1; i < multisetProjection.getOperands().size(); i++) {
       final RexLiteral indexLiteral = (RexLiteral) multisetProjection.getOperands().get(i);
       columns.add(((BigDecimal) indexLiteral.getValue()).intValue());
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigTypes.java b/piglet/src/main/java/org/apache/calcite/piglet/PigTypes.java
index 184d2a0df..1e8e80634 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigTypes.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigTypes.java
@@ -28,6 +28,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Utility methods for converting Pig data types to SQL types. */
 class PigTypes {
   private PigTypes() {}
@@ -122,9 +124,10 @@ static RelDataType convertSchemaField(
       case DataType.TUPLE:
         {
           if (pigField.alias != null && pigField.alias.equals(PIG_TUPLE_WRAPPER)) {
-            if (pigField.schema == null || pigField.schema.size() != 1) {
-              throw new IllegalArgumentException("Expect one subfield from " + pigField.schema);
-            }
+            checkArgument(
+                pigField.schema != null && pigField.schema.size() == 1,
+                "Expect one subfield from %s",
+                pigField.schema);
             return convertSchemaField(pigField.schema.getField(0), nullable);
           }
           return convertSchema(pigField.schema, nullable);
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java
index 5279d48f0..db7e880e5 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java
@@ -158,7 +158,7 @@ private Enumerable<String> sourceMacOs() {
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
         JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
-        final List<String> fieldNames = ImmutableList.copyOf(rowType.getFieldNames());
+        final List<String> fieldNames = rowType.getFieldNames();
         final String osName = System.getProperty("os.name");
         final String osVersion = System.getProperty("os.version");
         Util.discard(osVersion);
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/GitCommitsTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/GitCommitsTableFunction.java
index ca502b3db..0906a0334 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/GitCommitsTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/GitCommitsTableFunction.java
@@ -75,7 +75,7 @@ public static ScannableTable eval(boolean b) {
                 objects = new Object[9];
                 for (; ; ) {
                   final String line = e.current();
-                  if (line.length() == 0) {
+                  if (line.isEmpty()) {
                     break; // next line will be start of comments
                   }
                   if (line.startsWith("commit ")) {
@@ -120,7 +120,7 @@ public static ScannableTable eval(boolean b) {
                     return true;
                   }
                   final String line = e.current();
-                  if (line.length() == 0) {
+                  if (line.isEmpty()) {
                     // We're seeing the empty line at the end of message
                     objects[8] = b.toString();
                     b.setLength(0);
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/Processes.java b/plus/src/main/java/org/apache/calcite/adapter/os/Processes.java
index 4619a97b9..352daf3d4 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/Processes.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/Processes.java
@@ -25,10 +25,11 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.function.Supplier;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /**
  * Utilities regarding operating system processes.
  *
@@ -78,7 +79,7 @@ private static class ProcessLinesEnumerator extends AbstractEnumerable<String> {
       final Process process = processSupplier.get();
       final InputStream is = process.getInputStream();
       final BufferedInputStream bis = new BufferedInputStream(is);
-      final InputStreamReader isr = new InputStreamReader(bis, StandardCharsets.UTF_8);
+      final InputStreamReader isr = new InputStreamReader(bis, UTF_8);
       final BufferedReader br = new BufferedReader(isr);
       return new Enumerator<String>() {
         private String line;
@@ -126,7 +127,7 @@ private static class SeparatedLinesEnumerable extends AbstractEnumerable<String>
       final Process process = processSupplier.get();
       final InputStream is = process.getInputStream();
       final BufferedInputStream bis = new BufferedInputStream(is);
-      final InputStreamReader isr = new InputStreamReader(bis, StandardCharsets.UTF_8);
+      final InputStreamReader isr = new InputStreamReader(bis, UTF_8);
       final BufferedReader br = new BufferedReader(isr);
       return new Enumerator<String>() {
         private final StringBuilder b = new StringBuilder();
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java
index da13c673c..93c9ea83a 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java
@@ -56,7 +56,7 @@ public static ScannableTable eval(boolean b) {
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
         JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
-        final List<String> fieldNames = ImmutableList.copyOf(rowType.getFieldNames());
+        final List<String> fieldNames = rowType.getFieldNames();
         final String[] args;
         final String osName = System.getProperty("os.name");
         final String osVersion = System.getProperty("os.version");
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/SqlShell.java b/plus/src/main/java/org/apache/calcite/adapter/os/SqlShell.java
index 538a8a039..ddcc8b55c 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/SqlShell.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/SqlShell.java
@@ -26,7 +26,6 @@
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
-import java.nio.charset.StandardCharsets;
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.ResultSet;
@@ -39,9 +38,11 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Set;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Objects.requireNonNull;
+
 /** Command that executes its arguments as a SQL query against Calcite's OS adapter. */
 public class SqlShell {
   static final String MODEL = model();
@@ -58,9 +59,9 @@ public class SqlShell {
 
   SqlShell(InputStreamReader in, PrintWriter out, PrintWriter err, String... args) {
     this.args = ImmutableList.copyOf(args);
-    this.in = Objects.requireNonNull(in, "in");
-    this.out = Objects.requireNonNull(out, "out");
-    this.err = Objects.requireNonNull(err, "err");
+    this.in = requireNonNull(in, "in");
+    this.out = requireNonNull(out, "out");
+    this.err = requireNonNull(err, "err");
   }
 
   private static String model() {
@@ -95,11 +96,9 @@ private static String model() {
   /** Main entry point. */
   @SuppressWarnings("CatchAndPrintStackTrace")
   public static void main(String[] args) {
-    try (PrintWriter err =
-            new PrintWriter(new OutputStreamWriter(System.err, StandardCharsets.UTF_8));
-        InputStreamReader in = new InputStreamReader(System.in, StandardCharsets.UTF_8);
-        PrintWriter out =
-            new PrintWriter(new OutputStreamWriter(System.out, StandardCharsets.UTF_8))) {
+    try (PrintWriter err = new PrintWriter(new OutputStreamWriter(System.err, UTF_8));
+        InputStreamReader in = new InputStreamReader(System.in, UTF_8);
+        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out, UTF_8))) {
       new SqlShell(in, out, err, args).run();
     } catch (Throwable e) {
       e.printStackTrace();
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/StdinTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/StdinTableFunction.java
index 45678889d..f78ee2725 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/StdinTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/StdinTableFunction.java
@@ -40,9 +40,10 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.nio.charset.StandardCharsets;
 import java.util.NoSuchElementException;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /** Table function that reads stdin and returns one row per line. */
 public class StdinTableFunction {
 
@@ -53,7 +54,7 @@ public static ScannableTable eval(boolean b) {
       @Override public Enumerable<Object[]> scan(DataContext root) {
         final InputStream is = DataContext.Variable.STDIN.get(root);
         return new AbstractEnumerable<Object[]>() {
-          final InputStreamReader in = new InputStreamReader(is, StandardCharsets.UTF_8);
+          final InputStreamReader in = new InputStreamReader(is, UTF_8);
           final BufferedReader br = new BufferedReader(in);
 
           @Override public Enumerator<Object[]> enumerator() {
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
index 2626a1893..3d0a09f46 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
@@ -49,7 +49,7 @@ public static ScannableTable eval(boolean b) {
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
         JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
-        final List<String> fieldNames = ImmutableList.copyOf(rowType.getFieldNames());
+        final List<String> fieldNames = rowType.getFieldNames();
         final String[] args;
         final String osName = System.getProperty("os.name");
         final String osVersion = System.getProperty("os.version");
diff --git a/plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java b/plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
index fe479d404..6be630545 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
@@ -206,11 +206,13 @@ private RelDataType type(RelDataTypeFactory typeFactory, Column column) {
           return typeFactory.createSqlType(SqlTypeName.BIGINT);
         case DECIMAL:
           return typeFactory.createSqlType(
-              SqlTypeName.DECIMAL, type.getPrecision().get(), type.getScale().get());
+              SqlTypeName.DECIMAL,
+              type.getPrecision().orElseThrow(),
+              type.getScale().orElseThrow());
         case VARCHAR:
-          return typeFactory.createSqlType(SqlTypeName.VARCHAR, type.getPrecision().get());
+          return typeFactory.createSqlType(SqlTypeName.VARCHAR, type.getPrecision().orElseThrow());
         case CHAR:
-          return typeFactory.createSqlType(SqlTypeName.CHAR, type.getPrecision().get());
+          return typeFactory.createSqlType(SqlTypeName.CHAR, type.getPrecision().orElseThrow());
         default:
           throw new AssertionError(type.getBase() + ": " + column);
       }
diff --git a/plus/src/main/java/org/apache/calcite/chinook/CodesFunction.java b/plus/src/main/java/org/apache/calcite/chinook/CodesFunction.java
index 837eeb071..5e13d740d 100644
--- a/plus/src/main/java/org/apache/calcite/chinook/CodesFunction.java
+++ b/plus/src/main/java/org/apache/calcite/chinook/CodesFunction.java
@@ -26,9 +26,10 @@
 import org.apache.calcite.schema.SchemaPlus;
 import org.apache.calcite.sql.type.SqlTypeName;
 
-import java.nio.charset.StandardCharsets;
 import java.util.Base64;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /** Example Table Function for lateral join checks. */
 public class CodesFunction {
 
@@ -53,10 +54,7 @@ public static QueryableTable getTable(String name) {
         return Linq4j.asEnumerable(
                 new String[][] {
                   new String[] {"HASHCODE", "" + name.hashCode()},
-                  new String[] {
-                    "BASE64",
-                    Base64.getEncoder().encodeToString(name.getBytes(StandardCharsets.UTF_8))
-                  }
+                  new String[] {"BASE64", Base64.getEncoder().encodeToString(name.getBytes(UTF_8))}
                 })
             .asQueryable();
       }
diff --git a/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchema.java b/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchema.java
index c81318f4b..2ce4f1098 100644
--- a/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchema.java
+++ b/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchema.java
@@ -24,7 +24,6 @@
 
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 
 import java.util.ArrayList;
@@ -33,7 +32,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.stream.Collectors;
+
+import static java.util.stream.Collectors.toSet;
 
 /**
  * Schema mapped onto a set of URLs / HTML tables. Each table in the schema is an HTML table on a
@@ -59,13 +59,9 @@ class RedisSchema extends AbstractSchema {
   @Override protected Map<String, Table> getTableMap() {
     JsonCustomTable[] jsonCustomTables = new JsonCustomTable[tables.size()];
     Set<String> tableNames =
-        Arrays.stream(tables.toArray(jsonCustomTables))
-            .map(e -> e.name)
-            .collect(Collectors.toSet());
+        Arrays.stream(tables.toArray(jsonCustomTables)).map(e -> e.name).collect(toSet());
     tableMap =
-        Maps.asMap(
-            ImmutableSet.copyOf(tableNames),
-            CacheBuilder.newBuilder().build(CacheLoader.from(this::table)));
+        Maps.asMap(tableNames, CacheBuilder.newBuilder().build(CacheLoader.from(this::table)));
     return tableMap;
   }
 
diff --git a/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchemaFactory.java b/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchemaFactory.java
index bc4b22d59..4bfdaa1bf 100644
--- a/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchemaFactory.java
+++ b/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchemaFactory.java
@@ -20,11 +20,11 @@
 import org.apache.calcite.schema.SchemaFactory;
 import org.apache.calcite.schema.SchemaPlus;
 
-import com.google.common.base.Preconditions;
-
 import java.util.List;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Factory that creates a {@link RedisSchema}.
  *
@@ -37,10 +37,10 @@ public class RedisSchemaFactory implements SchemaFactory {
   public RedisSchemaFactory() {}
 
   @Override public Schema create(SchemaPlus schema, String name, Map<String, Object> operand) {
-    Preconditions.checkArgument(operand.get("tables") != null, "tables must be specified");
-    Preconditions.checkArgument(operand.get("host") != null, "host must be specified");
-    Preconditions.checkArgument(operand.get("port") != null, "port must be specified");
-    Preconditions.checkArgument(operand.get("database") != null, "database must be specified");
+    checkArgument(operand.get("tables") != null, "tables must be specified");
+    checkArgument(operand.get("host") != null, "host must be specified");
+    checkArgument(operand.get("port") != null, "port must be specified");
+    checkArgument(operand.get("database") != null, "database must be specified");
 
     @SuppressWarnings("unchecked")
     List<Map<String, Object>> tables = (List) operand.get("tables");
diff --git a/server/src/main/java/org/apache/calcite/server/MutableArrayTable.java b/server/src/main/java/org/apache/calcite/server/MutableArrayTable.java
index 6310aa6ce..47e3ec628 100644
--- a/server/src/main/java/org/apache/calcite/server/MutableArrayTable.java
+++ b/server/src/main/java/org/apache/calcite/server/MutableArrayTable.java
@@ -36,7 +36,8 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Objects;
+
+import static java.util.Objects.requireNonNull;
 
 /** Table backed by a Java list. */
 class MutableArrayTable extends AbstractModifiableTable implements Wrapper {
@@ -63,10 +64,10 @@ class MutableArrayTable extends AbstractModifiableTable implements Wrapper {
       RelProtoDataType protoRowType,
       InitializerExpressionFactory initializerExpressionFactory) {
     super(name);
-    this.protoStoredRowType = Objects.requireNonNull(protoStoredRowType, "protoStoredRowType");
-    this.protoRowType = Objects.requireNonNull(protoRowType, "protoRowType");
+    this.protoStoredRowType = requireNonNull(protoStoredRowType, "protoStoredRowType");
+    this.protoRowType = requireNonNull(protoRowType, "protoRowType");
     this.initializerExpressionFactory =
-        Objects.requireNonNull(initializerExpressionFactory, "initializerExpressionFactory");
+        requireNonNull(initializerExpressionFactory, "initializerExpressionFactory");
   }
 
   @Override public Collection getModifiableCollection() {
diff --git a/server/src/main/java/org/apache/calcite/server/ServerDdlExecutor.java b/server/src/main/java/org/apache/calcite/server/ServerDdlExecutor.java
index 75e7975f5..9a67087f3 100644
--- a/server/src/main/java/org/apache/calcite/server/ServerDdlExecutor.java
+++ b/server/src/main/java/org/apache/calcite/server/ServerDdlExecutor.java
@@ -87,7 +87,6 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -101,10 +100,13 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
+
+import static com.google.common.base.Preconditions.checkArgument;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Executes DDL commands.
  *
@@ -243,7 +245,7 @@ public void execute(SqlCreateForeignSchema create, CalcitePrepare.Context contex
     final Schema subSchema;
     final String libraryName;
     if (create.type != null) {
-      Preconditions.checkArgument(create.library == null);
+      checkArgument(create.library == null);
       final String typeName = (String) value(create.type);
       final JsonSchema.Type type =
           Util.enumVal(JsonSchema.Type.class, typeName.toUpperCase(Locale.ROOT));
@@ -264,7 +266,7 @@ public void execute(SqlCreateForeignSchema create, CalcitePrepare.Context contex
             RESOURCE.schemaInvalidType(typeName, Arrays.toString(JsonSchema.Type.values())));
       }
     } else {
-      Preconditions.checkArgument(create.library != null);
+      checkArgument(create.library != null);
       libraryName = (String) value(create.library);
     }
     final SchemaFactory schemaFactory =
@@ -583,8 +585,8 @@ private static class ColumnDef {
     private ColumnDef(SqlNode expr, RelDataType type, ColumnStrategy strategy) {
       this.expr = expr;
       this.type = type;
-      this.strategy = Objects.requireNonNull(strategy, "strategy");
-      Preconditions.checkArgument(
+      this.strategy = requireNonNull(strategy, "strategy");
+      checkArgument(
           strategy == ColumnStrategy.NULLABLE
               || strategy == ColumnStrategy.NOT_NULLABLE
               || expr != null);
diff --git a/spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java b/spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
index 5cbe360d8..eebd86037 100644
--- a/spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
+++ b/spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
@@ -73,11 +73,12 @@
 import java.lang.reflect.Type;
 import java.util.AbstractList;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Random;
 
+import static java.util.Collections.emptyIterator;
+
 /**
  * Rules for the {@link SparkRel#CONVENTION Spark calling convention}.
  *
@@ -445,10 +446,9 @@ public static void main(String[] args) {
                 (FlatMapFunction<String, Pair<String, Integer>>)
                     x -> {
                       if (!x.startsWith("a")) {
-                        return Collections.emptyIterator();
+                        return emptyIterator();
                       }
-                      return Collections.singletonList(
-                              Pair.of(x.toUpperCase(Locale.ROOT), x.length()))
+                      return ImmutableList.of(Pair.of(x.toUpperCase(Locale.ROOT), x.length()))
                           .iterator();
                     })
             .take(5)
diff --git a/splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java b/splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java
index 0e7302975..9c52f14ed 100644
--- a/splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java
+++ b/splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java
@@ -31,6 +31,8 @@
 import java.util.Map;
 import java.util.Properties;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * JDBC driver for Splunk.
  *
@@ -59,20 +61,14 @@ protected SplunkDriver() {
     SplunkConnection splunkConnection;
     try {
       String url1 = info.getProperty("url");
-      if (url1 == null) {
-        throw new IllegalArgumentException("Must specify 'url' property");
-      }
+      checkArgument(url1 != null, "Must specify 'url' property");
       if (url1.equals("mock")) {
         splunkConnection = new MockSplunkConnection();
       } else {
         String user = info.getProperty("user");
-        if (user == null) {
-          throw new IllegalArgumentException("Must specify 'user' property");
-        }
+        checkArgument(user != null, "Must specify 'user' property");
         String password = info.getProperty("password");
-        if (password == null) {
-          throw new IllegalArgumentException("Must specify 'password' property");
-        }
+        checkArgument(password != null, "Must specify 'password' property");
         URL url2 = new URL(url1);
         splunkConnection = new SplunkConnectionImpl(url2, user, password);
       }
diff --git a/splunk/src/main/java/org/apache/calcite/adapter/splunk/search/SplunkConnectionImpl.java b/splunk/src/main/java/org/apache/calcite/adapter/splunk/search/SplunkConnectionImpl.java
index ab3827926..ee7b57c15 100644
--- a/splunk/src/main/java/org/apache/calcite/adapter/splunk/search/SplunkConnectionImpl.java
+++ b/splunk/src/main/java/org/apache/calcite/adapter/splunk/search/SplunkConnectionImpl.java
@@ -36,7 +36,6 @@
 import java.io.StringWriter;
 import java.net.MalformedURLException;
 import java.net.URL;
-import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
@@ -46,9 +45,13 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.runtime.HttpUtils.appendURLEncodedArgs;
 import static org.apache.calcite.runtime.HttpUtils.post;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /** Implementation of {@link SplunkConnection} based on Splunk's REST API. */
 public class SplunkConnectionImpl implements SplunkConnection {
   private static final Logger LOGGER = LoggerFactory.getLogger(SplunkConnectionImpl.class);
@@ -179,8 +182,7 @@ private Enumerator<Object> getSearchResults_(
   }
 
   private static void parseResults(InputStream in, SearchResultListener srl) {
-    try (CSVReader r =
-        new CSVReader(new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)))) {
+    try (CSVReader r = new CSVReader(new BufferedReader(new InputStreamReader(in, UTF_8)))) {
       String[] header = r.readNext();
       if (header != null && header.length > 0 && !(header.length == 1 && header[0].isEmpty())) {
         srl.setFieldNames(header);
@@ -204,10 +206,10 @@ public static void parseArgs(String[] args, Map<String, String> map) {
       String argName = args[i++];
       String argValue = i < args.length ? args[i] : "";
 
-      if (!argName.startsWith("-")) {
-        throw new IllegalArgumentException(
-            "invalid argument name: " + argName + ". Argument names must start with -");
-      }
+      checkArgument(
+          argName.startsWith("-"),
+          "invalid argument name: %s. Argument names must start with -",
+          argName);
       map.put(argName.substring(1), argValue);
     }
   }
@@ -332,8 +334,7 @@ public static class SplunkResultEnumerator implements Enumerator<Object> {
     private int source;
 
     public SplunkResultEnumerator(InputStream in, List<String> wantedFields) {
-      csvReader =
-          new CSVReader(new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)));
+      csvReader = new CSVReader(new BufferedReader(new InputStreamReader(in, UTF_8)));
       try {
         fieldNames = csvReader.readNext();
         if (fieldNames == null
diff --git a/splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java b/splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java
index 171bf95d7..d768a3f74 100644
--- a/splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java
+++ b/splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.adapter.splunk.util;
 
+import com.google.common.base.Strings;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -108,7 +110,7 @@ public static List<String> decodeList(CharSequence encoded, char delim) {
   }
 
   public static boolean parseBoolean(String str, boolean defaultVal, boolean missingVal) {
-    if (str == null || str.isEmpty()) {
+    if (Strings.isNullOrEmpty(str)) {
       return missingVal;
     }
     if (str.equalsIgnoreCase("t")
diff --git a/testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java b/testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java
index 0a777a03c..509e7726c 100644
--- a/testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java
+++ b/testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java
@@ -69,7 +69,6 @@
 import java.util.TreeSet;
 import java.util.function.Consumer;
 import java.util.function.UnaryOperator;
-import java.util.stream.Collectors;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 import static org.apache.calcite.util.Util.toLinux;
@@ -87,6 +86,8 @@
 import static org.junit.jupiter.api.Assumptions.assumeFalse;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 
+import static java.util.stream.Collectors.joining;
+
 /**
  * A <code>SqlParserTest</code> is a unit-test for {@link SqlParser the SQL parser}.
  *
@@ -2539,7 +2540,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
    * naturally arise whenever a production uses "&lt;IDENTIFIER&gt;") are removed, but reserved
    * words such as "AND" remain.
    */
-  @Test void testExceptionCleanup() {
+  @Test void exceptionCleanup() {
     sql("select 0.5e1^.1^ from sales.emps")
         .fails(
             "(?s).*Encountered \".1\" at line 1, column 13.\n"
@@ -2550,7 +2551,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
                 + ".*");
   }
 
-  @Test void testInvalidToken() {
+  @Test void invalidToken() {
     // Causes problems to the test infrastructure because the token mgr
     // throws a java.lang.Error. The usual case is that the parser throws
     // an exception.
@@ -2559,12 +2560,12 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   }
 
   // TODO: should fail in parser
-  @Test void testStarAsFails() {
+  @Test void starAsFails() {
     sql("select * as x from emp").ok("SELECT * AS `X`\n"
   + "FROM `EMP`");
   }
 
-  @Test void testFromStarFails() {
+  @Test void fromStarFails() {
     sql("select * from sales^.^*").fails("(?s)Encountered \"\\. \\*\" at .*");
     sql("select emp.empno AS x from sales^.^*").fails("(?s)Encountered \"\\. \\*\" at .*");
     sql("select * from emp^.^*").fails("(?s)Encountered \"\\. \\*\" at .*");
@@ -2572,13 +2573,13 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql("select emp.empno AS x from ^*^").fails("(?s)Encountered \"\\*\" at .*");
   }
 
-  @Test void testPercentileCont() {
+  @Test void percentileCont() {
     sql("select percentile_cont(.5) within group (order by 3) from t")
         .ok("SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY 3)\n"
   + "FROM `T`");
   }
 
-  @Test void testPercentileDisc() {
+  @Test void percentileDisc() {
     sql("select percentile_disc(.5) within group (order by 3) from t")
         .ok("SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY 3)\n"
   + "FROM `T`");
@@ -2588,7 +2589,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
    * Tests BigQuery's variant of PERCENTILE_CONT, which uses OVER rather than WITHIN GROUP, and
    * allows RESPECT/IGNORE NULLS inside the parentheses.
    */
-  @Test void testPercentileContBigQuery() {
+  @Test void percentileContBigQuery() {
     sql("select percentile_cont(x, .5) over() from unnest(array[1,2,3,4]) as x")
         .withDialect(BIG_QUERY)
         .ok("SELECT (PERCENTILE_CONT(x, 0.5) OVER ())\n"
@@ -2609,7 +2610,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
    * Tests BigQuery's variant of PERCENTILE_DISC, which uses OVER rather than WITHIN GROUP, and
    * allows RESPECT/IGNORE NULLS inside the parentheses.
    */
-  @Test void testPercentileDiscBigQuery() {
+  @Test void percentileDiscBigQuery() {
     sql("select percentile_disc(x, .5) over() from unnest(array[1,2,3,4]) as x")
         .withDialect(BIG_QUERY)
         .ok("SELECT (PERCENTILE_DISC(x, 0.5) OVER ())\n"
@@ -2626,7 +2627,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
                 + "FROM UNNEST((ARRAY[1, NULL, 3, 4])) AS x");
   }
 
-  @Test void testHyphenatedTableName() {
+  @Test void hyphenatedTableName() {
     sql("select * from bigquery^-^foo-bar.baz")
         .fails("(?s)Encountered \"-\" at .*")
         .withDialect(BIG_QUERY)
@@ -2724,7 +2725,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
         .fails("(?s)Encountered \"-\" at .*");
   }
 
-  @Test void testHyphenatedColumnName() {
+  @Test void hyphenatedColumnName() {
     // While BigQuery allows hyphenated table names, no dialect allows
     // hyphenated column names; they are parsed as arithmetic minus.
     final String expected = "SELECT (`FOO` - `BAR`)\n"
@@ -2734,14 +2735,14 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql("select foo-bar from emp").ok(expected).withDialect(BIG_QUERY).ok(expectedBigQuery);
   }
 
-  @Test void testDerivedColumnList() {
+  @Test void derivedColumnList() {
     sql("select * from emp as e (empno, gender) where true")
         .ok("SELECT *\n"
   + "FROM `EMP` AS `E` (`EMPNO`, `GENDER`)\n"
   + "WHERE TRUE");
   }
 
-  @Test void testDerivedColumnListInJoin() {
+  @Test void derivedColumnListInJoin() {
     final String sql =
         "select * from emp as e (empno, gender)\n"
             + " join dept as d (deptno, dname) on emp.deptno = dept.deptno";
@@ -2756,7 +2757,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
    * Test case that does not reproduce but is related to <a href="https://issues.apache.org/jira/browse/CALCITE-2637">[CALCITE-2637] Prefix '-' operator
    * failed between BETWEEN and AND</a>.
    */
-  @Test void testBetweenAnd() {
+  @Test void betweenAnd() {
     final String sql = "select * from emp\n"
   + "where deptno between - DEPTNO + 1 and 5";
     final String expected =
@@ -2766,7 +2767,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql(sql).ok(expected);
   }
 
-  @Test void testBetweenAnd2() {
+  @Test void betweenAnd2() {
     final String sql = "select * from emp\n"
   + "where deptno between - DEPTNO + 1 and - empno - 3";
     final String expected =
@@ -2778,40 +2779,40 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   }
 
   @Disabled
-  @Test void testDerivedColumnListNoAs() {
+  @Test void derivedColumnListNoAs() {
     sql("select * from emp e (empno, gender) where true").ok("foo");
   }
 
   // jdbc syntax
   @Disabled
-  @Test void testEmbeddedCall() {
+  @Test void embeddedCall() {
     expr("{call foo(?, ?)}").ok("foo");
   }
 
   @Disabled
-  @Test void testEmbeddedFunction() {
+  @Test void embeddedFunction() {
     expr("{? = call bar (?, ?)}").ok("foo");
   }
 
-  @Test void testColumnAliasWithAs() {
+  @Test void columnAliasWithAs() {
     sql("select 1 as foo from emp").ok("SELECT 1 AS `FOO`\n"
   + "FROM `EMP`");
   }
 
-  @Test void testColumnAliasWithoutAs() {
+  @Test void columnAliasWithoutAs() {
     sql("select 1 foo from emp").ok("SELECT 1 AS `FOO`\n"
   + "FROM `EMP`");
   }
 
-  @Test void testEmbeddedDate() {
+  @Test void embeddedDate() {
     expr("{d '1998-10-22'}").ok("DATE '1998-10-22'");
   }
 
-  @Test void testEmbeddedTime() {
+  @Test void embeddedTime() {
     expr("{t '16:22:34'}").ok("TIME '16:22:34'");
   }
 
-  @Test void testEmbeddedTimestamp() {
+  @Test void embeddedTimestamp() {
     expr("{ts '1998-10-22 16:22:34'}").ok("TIMESTAMP '1998-10-22 16:22:34'");
   }
 
@@ -2821,7 +2822,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   + "FROM `T`");
   }
 
-  @Test void testBooleanPrecedenceAndAssociativity() {
+  @Test void booleanPrecedenceAndAssociativity() {
     sql("select * from t where true and false")
         .ok("SELECT *\n"
   + "FROM `T`\n"
@@ -2842,7 +2843,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   + "WHERE (1 AND TRUE)");
   }
 
-  @Test void testLessThanAssociativity() {
+  @Test void lessThanAssociativity() {
     expr("NOT a = b").ok("(NOT (`A` = `B`))");
 
     // comparison operators are left-associative
@@ -2886,7 +2887,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
         .ok("((NOT (NOT (`A` = `B`))) OR (NOT (NOT (`C` = `D`))))");
   }
 
-  @Test void testIsBooleans() {
+  @Test void isBooleans() {
     String[] inOuts = {"NULL", "TRUE", "FALSE", "UNKNOWN"};
 
     for (String inOut : inOuts) {
@@ -2902,7 +2903,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     }
   }
 
-  @Test void testIsBooleanPrecedenceAndAssociativity() {
+  @Test void isBooleanPrecedenceAndAssociativity() {
     sql("select * from t where x is unknown is not unknown")
         .ok("SELECT *\n"
   + "FROM `T`\n"
@@ -2935,14 +2936,14 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql(sql).ok(expected);
   }
 
-  @Test void testEqualNotEqual() {
+  @Test void equalNotEqual() {
     expr("'abc'=123").ok("('abc' = 123)");
     expr("'abc'<>123").ok("('abc' <> 123)");
     expr("'abc'<>123='def'<>456").ok("((('abc' <> 123) = 'def') <> 456)");
     expr("'abc'<>123=('def'<>456)").ok("(('abc' <> 123) = ('def' <> 456))");
   }
 
-  @Test void testBangEqualIsBad() {
+  @Test void bangEqualIsBad() {
     // Quoth www.ocelot.ca:
     //   "Other relators besides '=' are what you'd expect if
     //   you've used any programming language: > and >= and < and <=. The
@@ -2955,7 +2956,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
         .fails("Bang equal '!=' is not allowed under the current SQL conformance level");
   }
 
-  @Test void testBetween() {
+  @Test void between() {
     sql("select * from t where price between 1 and 2")
         .ok("SELECT *\n"
   + "FROM `T`\n"
@@ -3038,13 +3039,13 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
         .ok("VALUES (ROW((`A` BETWEEN ASYMMETRIC ((`B` OR (`C` AND `D`)) OR `E`) AND `F`)))");
   }
 
-  @Test void testOperateOnColumn() {
+  @Test void operateOnColumn() {
     sql("select c1*1,c2  + 2,c3/3,c4-4,c5*c4  from t")
         .ok("SELECT (`C1` * 1), (`C2` + 2), (`C3` / 3), (`C4` - 4), (`C5` * `C4`)\n"
   + "FROM `T`");
   }
 
-  @Test void testRow() {
+  @Test void row() {
     sql("select t.r.\"EXPR$1\", t.r.\"EXPR$0\" from (select (1,2) r from sales.depts) t")
         .ok(
             "SELECT `T`.`R`.`EXPR$1`, `T`.`R`.`EXPR$0`\n"
@@ -3095,7 +3096,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql(whereRow2).withConformance(SqlConformanceEnum.SQL_SERVER_2008).ok(whereExpected);
   }
 
-  @Test void testRowValueExpression() {
+  @Test void rowValueExpression() {
     final String expected0 =
         "INSERT INTO \"EMPS\"\n"
   + "VALUES (ROW(1, 'Fred')),\n"
@@ -3127,7 +3128,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
                 + "WHERE (`DEPT`.`DEPTNO` = `EMP`.`DEPTNO`)), `EMP`.`ENAME`))");
   }
 
-  @Test void testRowWithDot() {
+  @Test void rowWithDot() {
     sql("select (1,2).a from c.t").ok("SELECT ((ROW(1, 2)).`A`)\n"
   + "FROM `C`.`T`");
     sql("select row(1,2).a from c.t").ok("SELECT ((ROW(1, 2)).`A`)\n"
@@ -3137,19 +3138,19 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   + "FROM `TBL`");
   }
 
-  @Test void testDotAfterParenthesizedIdentifier() {
+  @Test void dotAfterParenthesizedIdentifier() {
     sql("select (a).c.d from c.t").ok("SELECT ((`A`.`C`).`D`)\n"
   + "FROM `C`.`T`");
   }
 
-  @Test void testPeriod() {
+  @Test void period() {
     // We don't have a PERIOD constructor currently;
     // ROW constructor is sufficient for now.
     expr("period (date '1969-01-05', interval '2-3' year to month)")
         .ok("(ROW(DATE '1969-01-05', INTERVAL '2-3' YEAR TO MONTH))");
   }
 
-  @Test void testOverlaps() {
+  @Test void overlaps() {
     final String[] ops = {
       "overlaps", "equals", "precedes", "succeeds", "immediately precedes", "immediately succeeds"
     };
@@ -3183,35 +3184,35 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Parses a list of statements (that contains only one statement). */
-  @Test void testStmtListWithSelect() {
+  @Test void stmtListWithSelect() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
     sql("select * from emp, dept").list().ok(expected);
   }
 
-  @Test void testStmtListWithSelectAndSemicolon() {
+  @Test void stmtListWithSelectAndSemicolon() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
     sql("select * from emp, dept;").list().ok(expected);
   }
 
-  @Test void testStmtListWithTwoSelect() {
+  @Test void stmtListWithTwoSelect() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
     sql("select * from emp, dept ; select * from emp, dept").list().ok(expected, expected);
   }
 
-  @Test void testStmtListWithTwoSelectSemicolon() {
+  @Test void stmtListWithTwoSelectSemicolon() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
     sql("select * from emp, dept ; select * from emp, dept;").list().ok(expected, expected);
   }
 
-  @Test void testStmtListWithSelectDelete() {
+  @Test void stmtListWithSelectDelete() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
@@ -3219,7 +3220,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("select * from emp, dept; delete from emp").list().ok(expected, expected1);
   }
 
-  @Test void testStmtListWithSelectDeleteUpdate() {
+  @Test void stmtListWithSelectDeleteUpdate() {
     final String sql =
         "select * from emp, dept; " + "delete from emp; " + "update emps set empno = empno + 1";
     final String expected = "SELECT *\n"
@@ -3230,7 +3231,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).list().ok(expected, expected1, expected2);
   }
 
-  @Test void testStmtListWithSemiColonInComment() {
+  @Test void stmtListWithSemiColonInComment() {
     final String sql =
         "" + "select * from emp, dept; // comment with semicolon ; values 1\n"
   + "values 2";
@@ -3241,7 +3242,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).list().ok(expected, expected1);
   }
 
-  @Test void testStmtListWithSemiColonInWhere() {
+  @Test void stmtListWithSemiColonInWhere() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`\n"
   + "WHERE (`NAME` LIKE 'toto;')";
@@ -3251,7 +3252,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected, expected1);
   }
 
-  @Test void testStmtListWithInsertSelectInsert() {
+  @Test void stmtListWithInsertSelectInsert() {
     final String sql =
         "insert into dept (name, deptno) values ('a', 123); "
             + "select * from emp where name like 'toto;'; "
@@ -3267,14 +3268,14 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Should fail since the first statement lacks semicolon. */
-  @Test void testStmtListWithoutSemiColon1() {
+  @Test void stmtListWithoutSemiColon1() {
     sql("select * from emp where name like 'toto' " + "^delete^ from emp")
         .list()
         .fails("(?s).*Encountered \"delete\" at .*");
   }
 
   /** Should fail since the third statement lacks semicolon. */
-  @Test void testStmtListWithoutSemiColon2() {
+  @Test void stmtListWithoutSemiColon2() {
     sql("select * from emp where name like 'toto'; "
             + "delete from emp; "
             + "insert into dept (name, deptno) values ('a', 123) "
@@ -3283,7 +3284,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"select\" at .*");
   }
 
-  @Test void testIsDistinctFrom() {
+  @Test void isDistinctFrom() {
     sql("select x is distinct from y from t")
         .ok("SELECT (`X` IS DISTINCT FROM `Y`)\n"
   + "FROM `T`");
@@ -3314,7 +3315,7 @@ void checkPeriodPredicate(Checker checker) {
   + "WHERE ((TRUE IS DISTINCT FROM TRUE) IS TRUE)");
   }
 
-  @Test void testIsNotDistinct() {
+  @Test void isNotDistinct() {
     sql("select x is not distinct from y from t")
         .ok("SELECT (`X` IS NOT DISTINCT FROM `Y`)\n"
   + "FROM `T`");
@@ -3325,7 +3326,7 @@ void checkPeriodPredicate(Checker checker) {
   + "WHERE (TRUE IS NOT DISTINCT FROM TRUE)");
   }
 
-  @Test void testFloor() {
+  @Test void floor() {
     expr("floor(1.5)").ok("FLOOR(1.5)");
     expr("floor(x)").ok("FLOOR(`X`)");
 
@@ -3378,7 +3379,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok("FLOOR((`X` + INTERVAL '1:20' MINUTE TO SECOND) TO MILLENNIUM)");
   }
 
-  @Test void testCeil() {
+  @Test void ceil() {
     expr("ceil(3453.2)").ok("CEIL(3453.2)");
     expr("ceil(x)").ok("CEIL(`X`)");
     expr("ceil(x to second)").ok("CEIL(`X` TO SECOND)");
@@ -3430,7 +3431,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok("CEIL((`X` + INTERVAL '1:20' MINUTE TO SECOND) TO MILLENNIUM)");
   }
 
-  @Test void testCast() {
+  @Test void cast() {
     expr("cast(x as boolean)").ok("CAST(`X` AS BOOLEAN)");
     expr("cast(x as integer)").ok("CAST(`X` AS INTEGER)");
     expr("cast(x as varchar(1))").ok("CAST(`X` AS VARCHAR(1))");
@@ -3465,7 +3466,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("cast('foo' as bar)").ok("CAST('foo' AS `BAR`)");
   }
 
-  @Test void testCastFails() {
+  @Test void castFails() {
     expr("cast(x as time with ^time^ zone)").fails("(?s).*Encountered \"time\" at .*");
     expr("cast(x as time(0) with ^time^ zone)").fails("(?s).*Encountered \"time\" at .*");
     expr("cast(x as timestamp with ^time^ zone)").fails("(?s).*Encountered \"time\" at .*");
@@ -3480,7 +3481,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test for MSSQL CONVERT parsing, with focus on iffy DATE type and testing that the extra "style"
    * operand is parsed Other tests are defined in functions.iq
    */
-  @Test void testMssqlConvert() {
+  @Test void mssqlConvert() {
     expr("CONVERT(VARCHAR(5), 'xx')").same();
     expr("CONVERT(VARCHAR(5), 'xx')").same();
     expr("CONVERT(VARCHAR(5), NULL)").same();
@@ -3489,7 +3490,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("CONVERT(DATE, 'xx')").same();
   }
 
-  @Test void testLikeAndSimilar() {
+  @Test void likeAndSimilar() {
     sql("select * from t where x like '%abc%'")
         .ok("SELECT *\n"
   + "FROM `T`\n"
@@ -3580,7 +3581,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`A` LIKE `B` ESCAPE `C`)) ESCAPE `D`)))");
   }
 
-  @Test void testIlike() {
+  @Test void ilike() {
     // The ILIKE operator is only valid when the PostgreSQL function library is
     // enabled ('fun=postgresql'). But the parser can always parse it.
     final String expected = "SELECT *\n"
@@ -3596,7 +3597,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql1).ok(expected1);
   }
 
-  @Test void testRlike() {
+  @Test void rlike() {
     // The RLIKE operator is valid when the HIVE or SPARK function library is
     // enabled ('fun=spark' or 'fun=hive'). But the parser can always parse it.
     final String expected =
@@ -3614,7 +3615,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql1).ok(expected1);
   }
 
-  @Test void testArithmeticOperators() {
+  @Test void arithmeticOperators() {
     expr("1-2+3*4/5/6-7").ok("(((1 - 2) + (((3 * 4) / 5) / 6)) - 7)");
     expr("power(2,3)").ok("POWER(2, 3)");
     expr("aBs(-2.3e-2)").ok("ABS(-2.3E-2)");
@@ -3623,7 +3624,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("log10(- -.2  )").ok("LOG10(0.2)");
   }
 
-  @Test void testExists() {
+  @Test void exists() {
     sql("select * from dept where exists (select 1 from emp where emp.deptno = dept.deptno)")
         .ok(
             "SELECT *\n"
@@ -3633,7 +3634,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`EMP`.`DEPTNO` = `DEPT`.`DEPTNO`)))");
   }
 
-  @Test void testExistsInWhere() {
+  @Test void existsInWhere() {
     sql("select * from emp where 1 = 2 and exists (select 1 from dept) and 3 = 4")
         .ok(
             "SELECT *\n"
@@ -3642,7 +3643,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`))) AND (3 = 4))");
   }
 
-  @Test void testUnique() {
+  @Test void unique() {
     sql("select * from dept where unique (select 1 from emp where emp.deptno = dept.deptno)")
         .ok(
             "SELECT *\n"
@@ -3652,7 +3653,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`EMP`.`DEPTNO` = `DEPT`.`DEPTNO`)))");
   }
 
-  @Test void testUniqueInWhere() {
+  @Test void uniqueInWhere() {
     sql("select * from emp where 1 = 2 and unique (select 1 from dept) and 3 = 4")
         .ok(
             "SELECT *\n"
@@ -3661,7 +3662,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`))) AND (3 = 4))");
   }
 
-  @Test void testNotUnique() {
+  @Test void notUnique() {
     sql("select * from dept where not not unique (select * from emp) and true")
         .ok(
             "SELECT *\n"
@@ -3670,17 +3671,17 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMP`)))) AND TRUE)");
   }
 
-  @Test void testFromWithAs() {
+  @Test void fromWithAs() {
     sql("select 1 from emp as e where 1").ok("SELECT 1\n"
   + "FROM `EMP` AS `E`\n"
   + "WHERE 1");
   }
 
-  @Test void testConcat() {
+  @Test void concat() {
     expr("'a' || 'b'").ok("('a' || 'b')");
   }
 
-  @Test void testCStyleEscapedString() {
+  @Test void cStyleEscapedString() {
     expr("E'Apache\\tCalcite'").ok("_UTF16'Apache\tCalcite'");
     expr("E'Apache\\bCalcite'").ok("_UTF16'Apache\bCalcite'");
     expr("E'Apache\\fCalcite'").ok("_UTF16'Apache\fCalcite'");
@@ -3719,11 +3720,11 @@ void checkPeriodPredicate(Checker checker) {
     expr("^E'AB\\U0000006G'^").fails(RESOURCE.unicodeEscapeMalformed(2).str());
   }
 
-  @Test void testReverseSolidus() {
+  @Test void reverseSolidus() {
     expr("'\\'").same();
   }
 
-  @Test void testSubstring() {
+  @Test void substring() {
     expr("substring('a'\nFROM \t  1)").ok("SUBSTRING('a', 1)");
     expr("substring('a' FROM 1 FOR 3)").ok("SUBSTRING('a', 1, 3)");
     expr("substring('a' FROM 'reg' FOR '\\')").ok("SUBSTRING('a', 'reg', '\\')");
@@ -3733,7 +3734,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("substring('a' , 1)").ok("SUBSTRING('a', 1)");
   }
 
-  @Test void testFunction() {
+  @Test void function() {
     sql("select substring('Eggs and ham', 1, 3 + 2) || ' benedict' from emp")
         .ok("SELECT (SUBSTRING('Eggs and ham', 1, (3 + 2)) || ' benedict')\n"
   + "FROM `EMP`");
@@ -3747,7 +3748,7 @@ void checkPeriodPredicate(Checker checker) {
                 + " - (6 * LOG10(((7 / ABS(8)) + 9))))) * POWER(10, 11)))");
   }
 
-  @Test void testFunctionWithDistinct() {
+  @Test void functionWithDistinct() {
     expr("count(DISTINCT 1)").ok("COUNT(DISTINCT 1)");
     expr("count(ALL 1)").ok("COUNT(ALL 1)");
     expr("count(1)").ok("COUNT(1)");
@@ -3756,15 +3757,15 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `EMP`");
   }
 
-  @Test void testFunctionCallWithDot() {
+  @Test void functionCallWithDot() {
     expr("foo(a,b).c").ok("(`FOO`(`A`, `B`).`C`)");
   }
 
-  @Test void testFunctionInFunction() {
+  @Test void functionInFunction() {
     expr("ln(power(2,2))").ok("LN(POWER(2, 2))");
   }
 
-  @Test void testFunctionNamedArgument() {
+  @Test void functionNamedArgument() {
     expr("foo(x => 1)").ok("`FOO`(`X` => 1)");
     expr("foo(x => 1, \"y\" => 'a', z => x <= y)")
         .ok("`FOO`(`X` => 1, `y` => 'a', `Z` => (`X` <= `Y`))");
@@ -3772,7 +3773,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("foo(a => 1, x.y ^=>^ 2, c => 3)").fails("(?s).*Encountered \"=>\" at .*");
   }
 
-  @Test void testFunctionDefaultArgument() {
+  @Test void functionDefaultArgument() {
     sql("foo(1, DEFAULT, default, 'default', \"default\", 3)")
         .expression()
         .ok("`FOO`(1, DEFAULT, DEFAULT, 'default', `default`, 3)");
@@ -3812,7 +3813,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s)Incorrect syntax near the keyword 'DEFAULT' at .*");
   }
 
-  @Test void testAggregateFilter() {
+  @Test void aggregateFilter() {
     final String sql =
         "select\n"
             + " sum(sal) filter (where gender = 'F') as femaleSal,\n"
@@ -3828,7 +3829,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testGroup() {
+  @Test void group() {
     sql("select deptno, min(foo) as x from emp group by deptno, gender")
         .ok(
             "SELECT `DEPTNO`, MIN(`FOO`) AS `X`\n"
@@ -3836,7 +3837,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "GROUP BY `DEPTNO`, `GENDER`");
   }
 
-  @Test void testGroupEmpty() {
+  @Test void groupEmpty() {
     sql("select count(*) from emp group by ()")
         .ok("SELECT COUNT(*)\n"
   + "FROM `EMP`\n"
@@ -3867,7 +3868,7 @@ void checkPeriodPredicate(Checker checker) {
   + "GROUP BY (`EMPNO` + `DEPTNO`)");
   }
 
-  @Test void testHavingAfterGroup() {
+  @Test void havingAfterGroup() {
     final String sql =
         "select deptno from emp group by deptno, emp\n"
             + "having count(*) > 5 and 1 = 2 order by 5, 2";
@@ -3880,21 +3881,21 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testHavingBeforeGroupFails() {
+  @Test void havingBeforeGroupFails() {
     final String sql =
         "select deptno from emp\n"
   + "having count(*) > 5 and deptno < 4 ^group^ by deptno, emp";
     sql(sql).fails("(?s).*Encountered \"group\" at .*");
   }
 
-  @Test void testHavingNoGroup() {
+  @Test void havingNoGroup() {
     sql("select deptno from emp having count(*) > 5")
         .ok("SELECT `DEPTNO`\n"
   + "FROM `EMP`\n"
   + "HAVING (COUNT(*) > 5)");
   }
 
-  @Test void testGroupingSets() {
+  @Test void groupingSets() {
     sql("select deptno from emp\n"
   + "group by grouping sets (deptno, (deptno, gender), ())")
         .ok(
@@ -3935,7 +3936,7 @@ void checkPeriodPredicate(Checker checker) {
   + "GROUP BY GROUPING SETS(())");
   }
 
-  @Test void testGroupByCube() {
+  @Test void groupByCube() {
     final String sql = "select deptno from emp\n"
   + "group by cube ((a, b), (c, d))";
     final String expected =
@@ -3945,7 +3946,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testGroupByAllOrDistinct() {
+  @Test void groupByAllOrDistinct() {
     final String sql = "select deptno from emp\n"
   + "group by all cube (a, b), rollup (a, b)";
     final String expected =
@@ -3971,7 +3972,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql2).ok(expected2);
   }
 
-  @Test void testGroupByCube2() {
+  @Test void groupByCube2() {
     final String sql = "select deptno from emp\n"
   + "group by cube ((a, b), (c, d)) order by a";
     final String expected =
@@ -3986,7 +3987,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql2).fails("(?s)Encountered \"\\)\" at .*");
   }
 
-  @Test void testGroupByRollup() {
+  @Test void groupByRollup() {
     final String sql = "select deptno from emp\n"
   + "group by rollup (deptno, deptno + 1, gender)";
     final String expected =
@@ -4001,7 +4002,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql1).fails("(?s)Encountered \", rollup\" at .*");
   }
 
-  @Test void testGrouping() {
+  @Test void grouping() {
     final String sql =
         "select deptno, grouping(deptno) from emp\n"
             + "group by grouping sets (deptno, (deptno, gender), ())";
@@ -4012,7 +4013,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWith() {
+  @Test void with() {
     final String sql =
         "with femaleEmps as (select * from emps where gender = 'F')"
             + "select deptno from femaleEmps";
@@ -4024,7 +4025,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWith2() {
+  @Test void with2() {
     final String sql =
         "with femaleEmps as (select * from emps where gender = 'F'),\n"
             + "marriedFemaleEmps(x, y) as (select * from femaleEmps where maritaStatus = 'M')\n"
@@ -4039,7 +4040,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWithFails() {
+  @Test void withFails() {
     final String sql =
         "with femaleEmps as ^select^ *\n"
             + "from emps where gender = 'F'\n"
@@ -4047,7 +4048,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).fails("(?s)Encountered \"select\" at .*");
   }
 
-  @Test void testWithValues() {
+  @Test void withValues() {
     final String sql = "with v(i,c) as (values (1, 'a'), (2, 'bb'))\n"
   + "select c, i from v";
     final String expected =
@@ -4057,7 +4058,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWithNestedFails() {
+  @Test void withNestedFails() {
     // SQL standard does not allow WITH to contain WITH
     final String sql =
         "with emp2 as (select * from emp)\n"
@@ -4070,7 +4071,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5299">[CALCITE-5299] JDBC
    * adapter sometimes adds unnecessary parentheses around SELECT in WITH body</a>.
    */
-  @Test void testWithSelect() {
+  @Test void withSelect() {
     final String sql = "with emp2 as (select * from emp)\n"
   + "select * from emp2\n";
     final String expected = "WITH `EMP2` AS (SELECT *\n"
@@ -4083,7 +4084,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5299">[CALCITE-5299] JDBC
    * adapter sometimes adds unnecessary parentheses around SELECT in WITH body</a>.
    */
-  @Test void testWithOrderBy() {
+  @Test void withOrderBy() {
     final String sql =
         "with emp2 as (select * from emp)\n"
   + "select * from emp2 order by deptno\n";
@@ -4095,7 +4096,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWithNestedInSubQuery() {
+  @Test void withNestedInSubQuery() {
     // SQL standard does not allow sub-query to contain WITH but we do
     final String sql =
         "with emp2 as (select * from emp)\n"
@@ -4110,7 +4111,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWithUnion() {
+  @Test void withUnion() {
     // Per the standard WITH ... SELECT ... UNION is valid even without parens.
     final String sql =
         "with emp2 as (select * from emp)\n"
@@ -4131,7 +4132,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5252">[CALCITE-5252] JDBC
    * adapter sometimes miss parentheses around SELECT in WITH_ITEM body</a>.
    */
-  @Test void testWithAsUnion() {
+  @Test void withAsUnion() {
     final String sql =
         "with emp2 as (select * from emp union select * from emp)\n"
   + "select * from emp2\n";
@@ -4149,7 +4150,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5252">[CALCITE-5252] JDBC
    * adapter sometimes miss parentheses around SELECT in WITH_ITEM body</a>.
    */
-  @Test void testWithAsOrderBy() {
+  @Test void withAsOrderBy() {
     final String sql =
         "with emp2 as (select * from emp order by deptno)\n"
   + "select * from emp2\n";
@@ -4165,7 +4166,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5252">[CALCITE-5252] JDBC
    * adapter sometimes miss parentheses around SELECT in WITH_ITEM body</a>.
    */
-  @Test void testWithAsJoin() {
+  @Test void withAsJoin() {
     final String sql =
         "with emp2 as (select * from emp e1 join emp e2 on e1.deptno = e2.deptno)\n"
             + "select * from emp2\n";
@@ -4181,7 +4182,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5252">[CALCITE-5252] JDBC
    * adapter sometimes miss parentheses around SELECT in WITH_ITEM body</a>.
    */
-  @Test void testWithAsNestedInSubQuery() {
+  @Test void withAsNestedInSubQuery() {
     final String sql =
         "with emp3 as (with emp2 as (select * from emp) select * from emp2)\n"
             + "select * from emp3\n";
@@ -4193,7 +4194,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testIdentifier() {
+  @Test void identifier() {
     expr("ab").ok("`AB`");
     expr("     \"a  \"\" b!c\"").ok("`a  \" b!c`");
     expr("     ^`^a  \" b!c`").fails("(?s).*Encountered.*");
@@ -4208,7 +4209,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("VALUES \"a\".b").node(isQuoted(1, false));
   }
 
-  @Test void testBackTickIdentifier() {
+  @Test void backTickIdentifier() {
     SqlParserFixture f = fixture().withConfig(c -> c.withQuoting(Quoting.BACK_TICK)).expression();
     f.sql("ab").ok("`AB`");
     f.sql("     `a  \" b!c`").ok("`a  \" b!c`");
@@ -4226,7 +4227,7 @@ void checkPeriodPredicate(Checker checker) {
     f.sql("VALUES `a``b`").node(isQuoted(0, true));
   }
 
-  @Test void testBackTickBackslashIdentifier() {
+  @Test void backTickBackslashIdentifier() {
     SqlParserFixture f =
         fixture().withConfig(c -> c.withQuoting(Quoting.BACK_TICK_BACKSLASH)).expression();
     f.sql("ab").ok("`AB`");
@@ -4247,7 +4248,7 @@ void checkPeriodPredicate(Checker checker) {
     f.sql("VALUES `a\\`b`").node(isQuoted(0, true));
   }
 
-  @Test void testBracketIdentifier() {
+  @Test void bracketIdentifier() {
     SqlParserFixture f = fixture().withConfig(c -> c.withQuoting(Quoting.BRACKET)).expression();
     f.sql("ab").ok("`AB`");
     f.sql("     [a  \" b!c]").ok("`a  \" b!c`");
@@ -4276,7 +4277,7 @@ void checkPeriodPredicate(Checker checker) {
     f.sql("VALUES [a]").node(isQuoted(0, true));
   }
 
-  @Test void testBackTickQuery() {
+  @Test void backTickQuery() {
     sql("select `x`.`b baz` from `emp` as `x` where `x`.deptno in (10, 20)")
         .withConfig(c -> c.withQuoting(Quoting.BACK_TICK))
         .ok("SELECT `x`.`b baz`\n"
@@ -4288,7 +4289,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-4080">[CALCITE-4080] Allow
    * character literals as column aliases, if SqlConformance.allowCharLiteralAlias()</a>.
    */
-  @Test void testSingleQuotedAlias() {
+  @Test void singleQuotedAlias() {
     final String expectingAlias = "Expecting alias, found character literal";
 
     final String sql1 = "select 1 as ^'a b'^ from t";
@@ -4351,19 +4352,19 @@ void checkPeriodPredicate(Checker checker) {
     f5.withConformance(SqlConformanceEnum.SQL_SERVER_2008).fails(sql5b);
   }
 
-  @Test void testInList() {
+  @Test void inList() {
     sql("select * from emp where deptno in (10, 20) and gender = 'F'")
         .ok("SELECT *\n"
   + "FROM `EMP`\n"
   + "WHERE ((`DEPTNO` IN (10, 20)) AND (`GENDER` = 'F'))");
   }
 
-  @Test void testInListEmptyFails() {
+  @Test void inListEmptyFails() {
     sql("select * from emp where deptno in (^)^ and gender = 'F'")
         .fails("(?s).*Encountered \"\\)\" at line 1, column 36\\..*");
   }
 
-  @Test void testInQuery() {
+  @Test void inQuery() {
     sql("select * from emp where deptno in (select deptno from dept)")
         .ok(
             "SELECT *\n"
@@ -4372,7 +4373,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`))");
   }
 
-  @Test void testSomeEveryAndIntersectionAggQuery() {
+  @Test void someEveryAndIntersectionAggQuery() {
     sql("select some(deptno = 10), every(deptno > 0), intersection(multiset[1,2]) from dept")
         .ok(
             "SELECT SOME((`DEPTNO` = 10)), EVERY((`DEPTNO` > 0)), INTERSECTION((MULTISET[1, 2]))\n"
@@ -4380,7 +4381,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Tricky for the parser - looks like "IN (scalar, scalar)" but isn't. */
-  @Test void testInQueryWithComma() {
+  @Test void inQueryWithComma() {
     sql("select * from emp where deptno in (select deptno from dept group by 1, 2)")
         .ok(
             "SELECT *\n"
@@ -4390,7 +4391,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "GROUP BY 1, 2))");
   }
 
-  @Test void testInSetop() {
+  @Test void inSetop() {
     sql("select * from emp where deptno in (\n"
             + "(select deptno from dept union select * from dept)"
             + "except\n"
@@ -4408,7 +4409,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`)) AND FALSE)");
   }
 
-  @Test void testSome() {
+  @Test void some() {
     final String sql = "select * from emp\n"
   + "where sal > some (select comm from emp)";
     final String expected =
@@ -4443,7 +4444,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql5).ok(expected5);
   }
 
-  @Test void testAll() {
+  @Test void all() {
     final String sql =
         "select * from emp\n"
   + "where sal <= all (select comm from emp) or sal > 10";
@@ -4455,7 +4456,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testAllList() {
+  @Test void allList() {
     final String sql = "select * from emp\n"
   + "where sal <= all (12, 20, 30)";
     final String expected = "SELECT *\n"
@@ -4464,7 +4465,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testUnion() {
+  @Test void union() {
     sql("select * from a union select * from a")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4485,7 +4486,7 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `A`");
   }
 
-  @Test void testUnionOrder() {
+  @Test void unionOrder() {
     sql("select a, b from t " + "union all " + "select x, y from u " + "order by 1 asc, 2 desc")
         .ok(
             "SELECT `A`, `B`\n"
@@ -4496,7 +4497,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "ORDER BY 1, 2 DESC");
   }
 
-  @Test void testOrderUnion() {
+  @Test void orderUnion() {
     // ORDER BY inside UNION not allowed
     sql("select a from t order by a\n"
   + "^union^ all\n"
@@ -4504,7 +4505,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"union\" at .*");
   }
 
-  @Test void testLimitUnion() {
+  @Test void limitUnion() {
     // LIMIT inside UNION not allowed
     sql("select a from t limit 10\n"
   + "^union^ all\n"
@@ -4512,7 +4513,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"union\" at .*");
   }
 
-  @Test void testLimitUnion2() {
+  @Test void limitUnion2() {
     // LIMIT is allowed in a parenthesized sub-query inside UNION;
     // the result probably has more parentheses than strictly necessary.
     final String sql =
@@ -4530,7 +4531,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testUnionOffset() {
+  @Test void unionOffset() {
     // Note that the second sub-query has parentheses, to ensure that ORDER BY,
     // OFFSET, FETCH are associated with just that sub-query, not the UNION.
     final String sql =
@@ -4619,7 +4620,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql6).ok(expected6);
   }
 
-  @Test void testUnionIntersect() {
+  @Test void unionIntersect() {
     // Note that the union sub-query has parentheses.
     final String sql = "(select * from a union select * from b)\n"
   + "intersect select * from c";
@@ -4635,7 +4636,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testUnionOfNonQueryFails() {
+  @Test void unionOfNonQueryFails() {
     sql("select 1 from emp union ^2^ + 5")
         .fails("Non-query expression encountered in illegal context");
   }
@@ -4644,14 +4645,14 @@ void checkPeriodPredicate(Checker checker) {
    * In modern SQL, a query can occur almost everywhere that an expression can. This test tests the
    * few exceptions.
    */
-  @Test void testQueryInIllegalContext() {
+  @Test void queryInIllegalContext() {
     sql("select 0, multiset[^(^select * from emp), 2] from dept")
         .fails("Query expression encountered in illegal context");
     sql("select 0, multiset[1, ^(^select * from emp), 2, 3] from dept")
         .fails("Query expression encountered in illegal context");
   }
 
-  @Test void testExcept() {
+  @Test void except() {
     sql("select * from a except select * from a")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4676,7 +4677,7 @@ void checkPeriodPredicate(Checker checker) {
    * Tests MINUS, which is equivalent to EXCEPT but only supported in some conformance levels (e.g.
    * ORACLE).
    */
-  @Test void testSetMinus() {
+  @Test void setMinus() {
     final String pattern = "MINUS is not allowed under the current SQL conformance level";
     final String sql = "select col1 from table1 ^MINUS^ select col1 from table2";
     sql(sql).fails(pattern);
@@ -4704,13 +4705,13 @@ void checkPeriodPredicate(Checker checker) {
    * conformance, where it is not allowed as an alternative to EXCEPT. (It is reserved in Oracle but
    * not in any version of the SQL standard.)
    */
-  @Test void testMinusIsReserved() {
+  @Test void minusIsReserved() {
     sql("select ^minus^ from t").fails("(?s).*Encountered \"minus\" at .*");
     sql("select ^minus^ select").fails("(?s).*Encountered \"minus\" at .*");
     sql("select * from t as ^minus^ where x < y").fails("(?s).*Encountered \"minus\" at .*");
   }
 
-  @Test void testIntersect() {
+  @Test void intersect() {
     sql("select * from a intersect select * from a")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4731,14 +4732,14 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `A`");
   }
 
-  @Test void testJoinCross() {
+  @Test void joinCross() {
     sql("select * from a as a2 cross join b")
         .ok("SELECT *\n"
   + "FROM `A` AS `A2`\n"
   + "CROSS JOIN `B`");
   }
 
-  @Test void testJoinOn() {
+  @Test void joinOn() {
     sql("select * from a left join b on 1 = 1 and 2 = 2 where 3 = 3")
         .ok(
             "SELECT *\n"
@@ -4747,7 +4748,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (3 = 3)");
   }
 
-  @Test void testJoinOnParentheses() {
+  @Test void joinOnParentheses() {
     if (!Bug.TODO_FIXED) {
       return;
     }
@@ -4762,7 +4763,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Same as {@link #testJoinOnParentheses()} but fancy aliases. */
-  @Test void testJoinOnParenthesesPlus() {
+  @Test void joinOnParenthesesPlus() {
     if (!Bug.TODO_FIXED) {
       return;
     }
@@ -4777,7 +4778,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (3 = 3)");
   }
 
-  @Test void testExplicitTableInJoin() {
+  @Test void explicitTableInJoin() {
     sql("select * from a left join (table b) on 2 = 2 where 3 = 3")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4785,7 +4786,7 @@ void checkPeriodPredicate(Checker checker) {
   + "WHERE (3 = 3)");
   }
 
-  @Test void testSubQueryInJoin() {
+  @Test void subQueryInJoin() {
     if (!Bug.TODO_FIXED) {
       return;
     }
@@ -4801,7 +4802,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (4 = 4)");
   }
 
-  @Test void testOuterJoinNoiseWord() {
+  @Test void outerJoinNoiseWord() {
     sql("select * from a left outer join b on 1 = 1 and 2 = 2 where 3 = 3")
         .ok(
             "SELECT *\n"
@@ -4810,7 +4811,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (3 = 3)");
   }
 
-  @Test void testJoinQuery() {
+  @Test void joinQuery() {
     sql("select * from a join (select * from b) as b2 on true")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4818,24 +4819,24 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `B`) AS `B2` ON TRUE");
   }
 
-  @Test void testFullInnerJoinFails() {
+  @Test void fullInnerJoinFails() {
     // cannot have more than one of INNER, FULL, LEFT, RIGHT, CROSS
     sql("select * from a ^full^ inner join b").fails("(?s).*Encountered \"full inner\" at line .*");
   }
 
-  @Test void testFullOuterJoin() {
+  @Test void fullOuterJoin() {
     // OUTER is an optional extra to LEFT, RIGHT, or FULL
     sql("select * from a full outer join b").ok("SELECT *\n"
   + "FROM `A`\n"
   + "FULL JOIN `B`");
   }
 
-  @Test void testInnerOuterJoinFails() {
+  @Test void innerOuterJoinFails() {
     sql("select * from a ^inner^ outer join b")
         .fails("(?s).*Encountered \"inner outer\" at line .*");
   }
 
-  @Test void testJoinAssociativity() {
+  @Test void joinAssociativity() {
     // joins are left-associative
     // 1. no parens needed
     String expected =
@@ -4870,14 +4871,14 @@ void checkPeriodPredicate(Checker checker) {
   // Note: "select * from a natural cross join b" is actually illegal SQL
   // ("cross" is the only join type which cannot be modified with the
   // "natural") but the parser allows it; we and catch it at validate time
-  @Test void testNaturalCrossJoin() {
+  @Test void naturalCrossJoin() {
     sql("select * from a natural cross join b")
         .ok("SELECT *\n"
   + "FROM `A`\n"
   + "NATURAL CROSS JOIN `B`");
   }
 
-  @Test void testJoinUsing() {
+  @Test void joinUsing() {
     sql("select * from a join b using (x)")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4890,7 +4891,7 @@ void checkPeriodPredicate(Checker checker) {
    * Tests CROSS APPLY, which is equivalent to CROSS JOIN and LEFT JOIN but only supported in some
    * conformance levels (e.g. SQL Server).
    */
-  @Test void testApply() {
+  @Test void apply() {
     final String pattern = "APPLY operator is not allowed under the current SQL conformance level";
     final String sql = "select * from dept\n"
   + "cross apply table(ramp(deptno)) as t(a^)^";
@@ -4909,7 +4910,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Tests OUTER APPLY. */
-  @Test void testOuterApply() {
+  @Test void outerApply() {
     final String sql = "select * from dept outer apply table(ramp(deptno))";
     final String expected =
         "SELECT *\n"
@@ -4918,7 +4919,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).withConformance(SqlConformanceEnum.SQL_SERVER_2008).ok(expected);
   }
 
-  @Test void testOuterApplySubQuery() {
+  @Test void outerApplySubQuery() {
     final String sql =
         "select * from dept\n"
   + "outer apply (select * from emp where emp.deptno = dept.deptno)";
@@ -4931,7 +4932,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).withConformance(SqlConformanceEnum.SQL_SERVER_2008).ok(expected);
   }
 
-  @Test void testOuterApplyValues() {
+  @Test void outerApplyValues() {
     final String sql =
         "select * from dept\n"
   + "outer apply (select * from emp where emp.deptno = dept.deptno)";
@@ -4948,14 +4949,14 @@ void checkPeriodPredicate(Checker checker) {
    * Even in SQL Server conformance mode, we do not yet support 'function(args)' as an abbreviation
    * for 'table(function(args)'.
    */
-  @Test void testOuterApplyFunctionFails() {
+  @Test void outerApplyFunctionFails() {
     final String sql = "select * from dept outer apply ramp(deptno^)^)";
     sql(sql)
         .withConformance(SqlConformanceEnum.SQL_SERVER_2008)
         .fails("(?s).*Encountered \"\\)\" at .*");
   }
 
-  @Test void testCrossOuterApply() {
+  @Test void crossOuterApply() {
     final String sql =
         "select * from dept\n"
             + "cross apply table(ramp(deptno)) as t(a)\n"
@@ -4968,7 +4969,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).withConformance(SqlConformanceEnum.SQL_SERVER_2008).ok(expected);
   }
 
-  @Test void testTableSample() {
+  @Test void tableSample() {
     final String sql0 =
         "select * from ("
             + "  select * "
@@ -5024,7 +5025,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "can not be parsed to type 'java\\.lang\\.Integer'");
   }
 
-  @Test void testLiteral() {
+  @Test void literal() {
     expr("'foo'").same();
     expr("100").same();
     sql("select 1 as uno, 'x' as x, null as n from emp")
@@ -5042,7 +5043,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("NULL").same();
   }
 
-  @Test void testContinuedLiteral() {
+  @Test void continuedLiteral() {
     expr("'abba'\n'abba'").same();
     expr("'abba'\n'0001'").same();
     expr("N'yabba'\n'dabba'\n'doo'").ok("_ISO-8859-1'yabba'\n'dabba'\n'doo'");
@@ -5059,7 +5060,7 @@ void checkPeriodPredicate(Checker checker) {
    * Tests that ambiguity between extended string literals and character string aliases is always
    * resolved in favor of extended string literals.
    */
-  @Test void testContinuedLiteralAlias() {
+  @Test void continuedLiteralAlias() {
     final String expectingAlias = "Expecting alias, found character literal";
 
     // Not ambiguous, because of 'as'.
@@ -5106,7 +5107,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql2).withConformance(SqlConformanceEnum.BIG_QUERY).ok(sql2b);
   }
 
-  @Test void testMixedFrom() {
+  @Test void mixedFrom() {
     sql("select * from a join b using (x), c join d using (y)")
         .ok(
             "SELECT *\n"
@@ -5116,14 +5117,14 @@ void checkPeriodPredicate(Checker checker) {
                 + "INNER JOIN `D` USING (`Y`)");
   }
 
-  @Test void testMixedStar() {
+  @Test void mixedStar() {
     sql("select emp.*, 1 as foo from emp, dept")
         .ok("SELECT `EMP`.*, 1 AS `FOO`\n"
   + "FROM `EMP`,\n"
   + "`DEPT`");
   }
 
-  @Test void testSchemaTableStar() {
+  @Test void schemaTableStar() {
     sql("select schem.emp.*, emp.empno * dept.deptno\n"
   + "from schem.emp, dept")
         .ok(
@@ -5132,19 +5133,19 @@ void checkPeriodPredicate(Checker checker) {
                 + "`DEPT`");
   }
 
-  @Test void testCatalogSchemaTableStar() {
+  @Test void catalogSchemaTableStar() {
     sql("select cat.schem.emp.* from cat.schem.emp")
         .ok("SELECT `CAT`.`SCHEM`.`EMP`.*\n"
   + "FROM `CAT`.`SCHEM`.`EMP`");
   }
 
-  @Test void testAliasedStar() {
+  @Test void aliasedStar() {
     // OK in parser; validator will give error
     sql("select emp.* as foo from emp").ok("SELECT `EMP`.* AS `FOO`\n"
   + "FROM `EMP`");
   }
 
-  @Test void testNotExists() {
+  @Test void notExists() {
     sql("select * from dept where not not exists (select * from emp) and true")
         .ok(
             "SELECT *\n"
@@ -5153,7 +5154,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMP`)))) AND TRUE)");
   }
 
-  @Test void testOrder() {
+  @Test void order() {
     sql("select * from emp order by empno, gender desc, deptno asc, empno asc, name desc")
         .ok(
             "SELECT *\n"
@@ -5161,7 +5162,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "ORDER BY `EMPNO`, `GENDER` DESC, `DEPTNO`, `EMPNO`, `NAME` DESC");
   }
 
-  @Test void testOrderNullsFirst() {
+  @Test void orderNullsFirst() {
     final String sql =
         "select * from emp\n"
             + "order by gender desc nulls last,\n"
@@ -5175,7 +5176,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testOrderInternal() {
+  @Test void orderInternal() {
     sql("(select * from emp order by empno) union select * from emp")
         .ok(
             "(SELECT *\n"
@@ -5194,7 +5195,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`A` = `B`)");
   }
 
-  @Test void testOrderIllegalInExpression() {
+  @Test void orderIllegalInExpression() {
     sql("select (select 1 from foo order by x,y) from t where a = b")
         .ok(
             "SELECT (SELECT 1\n"
@@ -5205,7 +5206,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("select (1 ^order^ by x, y) from t where a = b").fails("ORDER BY unexpected");
   }
 
-  @Test void testOrderOffsetFetch() {
+  @Test void orderOffsetFetch() {
     sql("select a from foo order by b, c offset 1 row fetch first 2 row only")
         .ok(
             "SELECT `A`\n"
@@ -5277,7 +5278,7 @@ void checkPeriodPredicate(Checker checker) {
    * "LIMIT ... OFFSET ..." is the postgres equivalent of SQL:2008 "OFFSET ... FETCH". It all maps
    * down to a parse tree that looks like SQL:2008.
    */
-  @Test void testLimit() {
+  @Test void limit() {
     sql("select a from foo order by b, c limit 2 offset 1")
         .ok(
             "SELECT `A`\n"
@@ -5304,7 +5305,7 @@ void checkPeriodPredicate(Checker checker) {
    * <p>Similar to {@link #testLimit}, but parses and unparses in the Spark dialect, which uses
    * LIMIT and OFFSET rather than OFFSET and FETCH.
    */
-  @Test void testLimitSpark() {
+  @Test void limitSpark() {
     final String sql1 = "select a from foo order by b, c limit 2 offset 1";
     final String expected1 =
         "SELECT A\n"
@@ -5352,14 +5353,14 @@ void checkPeriodPredicate(Checker checker) {
    * Test case that does not reproduce but is related to <a href="https://issues.apache.org/jira/browse/CALCITE-1238">[CALCITE-1238] Unparsing LIMIT
    * without ORDER BY after validation</a>.
    */
-  @Test void testLimitWithoutOrder() {
+  @Test void limitWithoutOrder() {
     final String expected = "SELECT `A`\n"
   + "FROM `FOO`\n"
   + "FETCH NEXT 2 ROWS ONLY";
     sql("select a from foo limit 2").ok(expected);
   }
 
-  @Test void testLimitOffsetWithoutOrder() {
+  @Test void limitOffsetWithoutOrder() {
     final String expected =
         "SELECT `A`\n"
   + "FROM `FOO`\n"
@@ -5368,7 +5369,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("select a from foo limit 2 offset 1").ok(expected);
   }
 
-  @Test void testLimitStartCount() {
+  @Test void limitStartCount() {
     final String error =
         "'LIMIT start, count' is not allowed under the " + "current SQL conformance level";
     sql("select a from foo ^limit 1,2^").withConformance(SqlConformanceEnum.DEFAULT).fails(error);
@@ -5417,7 +5418,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5086">[CALCITE-5086]
    * Calcite supports OFFSET start LIMIT count expression</a>.
    */
-  @Test void testOffsetStartLimitCount() {
+  @Test void offsetStartLimitCount() {
     final String error =
         "'OFFSET start LIMIT count' is not allowed under the " + "current SQL conformance level";
     sql("select a from foo order by b, c offset 1 limit 2")
@@ -5454,7 +5455,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"all\" at line 1.*");
   }
 
-  @Test void testSqlInlineComment() {
+  @Test void sqlInlineComment() {
     sql("select 1 from t --this is a comment\n").ok("SELECT 1\n"
   + "FROM `T`");
     sql("select 1 from t--\n").ok("SELECT 1\n"
@@ -5468,7 +5469,7 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `T`");
   }
 
-  @Test void testMultilineComment() {
+  @Test void multilineComment() {
     // on single line
     sql("select 1 /* , 2 */, 3 from t").ok("SELECT 1, 3\n"
   + "FROM `T`");
@@ -5555,7 +5556,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   // expressions
-  @Test void testParseNumber() {
+  @Test void parseNumber() {
     // Exacts
     expr("1").same();
     expr("+1.").ok("1");
@@ -5593,45 +5594,45 @@ void checkPeriodPredicate(Checker checker) {
     expr("1+-2.*-3.e-1/-4").ok("(1 + ((-2 * -3E-1) / -4))");
   }
 
-  @Test void testParseNumberFails() {
+  @Test void parseNumberFails() {
     sql("SELECT 0.5e1^.1^ from t").fails("(?s).*Encountered .*\\.1.* at line 1.*");
   }
 
-  @Test void testMinusPrefixInExpression() {
+  @Test void minusPrefixInExpression() {
     expr("-(1+2)").ok("(- (1 + 2))");
   }
 
   // operator precedence
-  @Test void testPrecedence0() {
+  @Test void precedence0() {
     expr("1 + 2 * 3 * 4 + 5").ok("((1 + ((2 * 3) * 4)) + 5)");
   }
 
-  @Test void testPrecedence1() {
+  @Test void precedence1() {
     expr("1 + 2 * (3 * (4 + 5))").ok("(1 + (2 * (3 * (4 + 5))))");
   }
 
-  @Test void testPrecedence2() {
+  @Test void precedence2() {
     expr("- - 1").ok("1"); // special case for unary minus
   }
 
-  @Test void testPrecedence2b() {
+  @Test void precedence2b() {
     expr("not not 1").ok("(NOT (NOT 1))"); // two prefixes
   }
 
-  @Test void testPrecedence3() {
+  @Test void precedence3() {
     expr("- 1 is null").ok("(-1 IS NULL)"); // prefix vs. postfix
   }
 
-  @Test void testPrecedence4() {
+  @Test void precedence4() {
     expr("1 - -2").ok("(1 - -2)"); // infix, prefix '-'
   }
 
-  @Test void testPrecedence5() {
+  @Test void precedence5() {
     expr("1++2").ok("(1 + 2)"); // infix, prefix '+'
     expr("1+ +2").ok("(1 + 2)"); // infix, prefix '+'
   }
 
-  @Test void testPrecedenceSetOps() {
+  @Test void precedenceSetOps() {
     final String sql =
         "select * from a union "
             + "select * from b intersect "
@@ -5664,7 +5665,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQueryInFrom() {
+  @Test void queryInFrom() {
     // one query with 'as', the other without
     sql("select * from (select * from emp) as e join (select * from dept) d")
         .ok(
@@ -5675,14 +5676,14 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`) AS `D`");
   }
 
-  @Test void testQuotesInString() {
+  @Test void quotesInString() {
     expr("'a''b'").same();
     expr("'''x'").same();
     expr("''").same();
     expr("'Quoted strings aren''t \"hard\"'").same();
   }
 
-  @Test void testScalarQueryInWhere() {
+  @Test void scalarQueryInWhere() {
     sql("select * from emp where 3 = (select count(*) from dept where dept.deptno = emp.deptno)")
         .ok(
             "SELECT *\n"
@@ -5692,7 +5693,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`DEPT`.`DEPTNO` = `EMP`.`DEPTNO`)))");
   }
 
-  @Test void testScalarQueryInSelect() {
+  @Test void scalarQueryInSelect() {
     sql("select x, (select count(*) from dept where dept.deptno = emp.deptno) from emp")
         .ok(
             "SELECT `X`, (SELECT COUNT(*)\n"
@@ -5701,51 +5702,51 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMP`");
   }
 
-  @Test void testSelectList() {
+  @Test void selectList() {
     sql("select * from emp, dept").ok("SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`");
   }
 
-  @Test void testSelectWithoutFrom() {
+  @Test void selectWithoutFrom() {
     sql("select 2+2").ok("SELECT (2 + 2)");
   }
 
-  @Test void testSelectWithoutFrom2() {
+  @Test void selectWithoutFrom2() {
     sql("select 2+2 as x, 'a' as y").ok("SELECT (2 + 2) AS `X`, 'a' AS `Y`");
   }
 
-  @Test void testSelectDistinctWithoutFrom() {
+  @Test void selectDistinctWithoutFrom() {
     sql("select distinct 2+2 as x, 'a' as y").ok("SELECT DISTINCT (2 + 2) AS `X`, 'a' AS `Y`");
   }
 
-  @Test void testSelectWithoutFromWhereFails() {
+  @Test void selectWithoutFromWhereFails() {
     sql("select 2+2 as x ^where^ 1 > 2").fails("(?s).*Encountered \"where\" at line .*");
   }
 
-  @Test void testSelectWithoutFromGroupByFails() {
+  @Test void selectWithoutFromGroupByFails() {
     sql("select 2+2 as x ^group^ by 1, 2").fails("(?s).*Encountered \"group\" at line .*");
   }
 
-  @Test void testSelectWithoutFromHavingFails() {
+  @Test void selectWithoutFromHavingFails() {
     sql("select 2+2 as x ^having^ 1 > 2").fails("(?s).*Encountered \"having\" at line .*");
   }
 
-  @Test void testSelectList3() {
+  @Test void selectList3() {
     sql("select 1, emp.*, 2 from emp").ok("SELECT 1, `EMP`.*, 2\n"
   + "FROM `EMP`");
   }
 
-  @Test void testSelectList4() {
+  @Test void selectList4() {
     sql("select ^from^ emp").fails("(?s).*Encountered \"from\" at line .*");
   }
 
-  @Test void testStar() {
+  @Test void star() {
     sql("select * from emp").ok("SELECT *\n"
   + "FROM `EMP`");
   }
 
-  @Test void testCompoundStar() {
+  @Test void compoundStar() {
     final String sql =
         "select sales.emp.address.zipcode,\n"
   + " sales.emp.address.*\n"
@@ -5757,12 +5758,12 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testSelectDistinct() {
+  @Test void selectDistinct() {
     sql("select distinct foo from bar").ok("SELECT DISTINCT `FOO`\n"
   + "FROM `BAR`");
   }
 
-  @Test void testSelectAll() {
+  @Test void selectAll() {
     // "unique" is the default -- so drop the keyword
     sql("select * from (select all foo from bar) as xyz")
         .ok("SELECT *\n"
@@ -5770,30 +5771,30 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `BAR`) AS `XYZ`");
   }
 
-  @Test void testSelectStream() {
+  @Test void selectStream() {
     sql("select stream foo from bar").ok("SELECT STREAM `FOO`\n"
   + "FROM `BAR`");
   }
 
-  @Test void testSelectStreamDistinct() {
+  @Test void selectStreamDistinct() {
     sql("select stream distinct foo from bar").ok("SELECT STREAM DISTINCT `FOO`\n"
   + "FROM `BAR`");
   }
 
-  @Test void testWhere() {
+  @Test void where() {
     sql("select * from emp where empno > 5 and gender = 'F'")
         .ok("SELECT *\n"
   + "FROM `EMP`\n"
   + "WHERE ((`EMPNO` > 5) AND (`GENDER` = 'F'))");
   }
 
-  @Test void testNestedSelect() {
+  @Test void nestedSelect() {
     sql("select * from (select * from emp)").ok("SELECT *\n"
   + "FROM (SELECT *\n"
   + "FROM `EMP`)");
   }
 
-  @Test void testValues() {
+  @Test void values() {
     final String expected = "VALUES (ROW(1, 'two'))";
     final String pattern = "VALUE is not allowed under the current SQL conformance level";
     sql("values(1,'two')").ok(expected);
@@ -5804,11 +5805,11 @@ void checkPeriodPredicate(Checker checker) {
     sql("^value^(1,'two')").fails(pattern);
   }
 
-  @Test void testValuesExplicitRow() {
+  @Test void valuesExplicitRow() {
     sql("values row(1,'two')").ok("VALUES (ROW(1, 'two'))");
   }
 
-  @Test void testFromValues() {
+  @Test void fromValues() {
     sql("select * from (values(1,'two'), 3, (4, 'five'))")
         .ok("SELECT *\n"
   + "FROM (VALUES (ROW(1, 'two')),\n"
@@ -5816,7 +5817,7 @@ void checkPeriodPredicate(Checker checker) {
   + "(ROW(4, 'five')))");
   }
 
-  @Test void testFromValuesWithoutParens() {
+  @Test void fromValuesWithoutParens() {
     sql("select 1 from ^values^('x')")
         .fails(
             "(?s)Encountered \"values\" at line 1, column 15\\.\n"
@@ -5834,7 +5835,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "    \"\\(\" \\.\\.\\.\n.*");
   }
 
-  @Test void testEmptyValues() {
+  @Test void emptyValues() {
     sql("select * from (values(^)^)").fails("(?s).*Encountered \"\\)\" at .*");
   }
 
@@ -5842,7 +5843,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-493">[CALCITE-493] Add
    * EXTEND clause, for defining columns and their types at query/DML time</a>.
    */
-  @Test void testTableExtend() {
+  @Test void tableExtend() {
     sql("select * from emp extend (x int, y varchar(10) not null)")
         .ok("SELECT *\n"
   + "FROM `EMP` EXTEND (`X` INTEGER, `Y` VARCHAR(10))");
@@ -5877,34 +5878,34 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`X` = `Y`)");
   }
 
-  @Test void testExplicitTable() {
+  @Test void explicitTable() {
     sql("table emp").ok("(TABLE `EMP`)");
 
     sql("table ^123^").fails("(?s)Encountered \"123\" at line 1, column 7\\.\n.*");
   }
 
-  @Test void testExplicitTableOrdered() {
+  @Test void explicitTableOrdered() {
     sql("table emp order by name").ok("(TABLE `EMP`)\n"
   + "ORDER BY `NAME`");
   }
 
-  @Test void testSelectFromExplicitTable() {
+  @Test void selectFromExplicitTable() {
     sql("select * from (table emp)").ok("SELECT *\n"
   + "FROM (TABLE `EMP`)");
   }
 
-  @Test void testSelectFromBareExplicitTableFails() {
+  @Test void selectFromBareExplicitTableFails() {
     sql("select * from table ^emp^").fails("(?s).*Encountered \"emp\" at .*");
 
     sql("select * from (table (^select^ empno from emp))").fails("(?s)Encountered \"select\".*");
   }
 
-  @Test void testCollectionTable() {
+  @Test void collectionTable() {
     sql("select * from table(ramp(3, 4))").ok("SELECT *\n"
   + "FROM TABLE(`RAMP`(3, 4))");
   }
 
-  @Test void testDescriptor() {
+  @Test void descriptor() {
     sql("select * from table(ramp(descriptor(column_name)))")
         .ok("SELECT *\n"
   + "FROM TABLE(`RAMP`(DESCRIPTOR(`COLUMN_NAME`)))");
@@ -5917,14 +5918,14 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM TABLE(`RAMP`(DESCRIPTOR(`COLUMN_NAME1`, `COLUMN_NAME2`, `COLUMN_NAME3`)))");
   }
 
-  @Test void testCollectionTableWithCursorParam() {
+  @Test void collectionTableWithCursorParam() {
     sql("select * from table(dedup(cursor(select * from emps),'name'))")
         .ok("SELECT *\n"
   + "FROM TABLE(`DEDUP`((CURSOR ((SELECT *\n"
   + "FROM `EMPS`))), 'name'))");
   }
 
-  @Test void testCollectionTableWithColumnListParam() {
+  @Test void collectionTableWithColumnListParam() {
     sql("select * from table(dedup(cursor(select * from emps)," + "row(empno, name)))")
         .ok(
             "SELECT *\n"
@@ -5932,7 +5933,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMPS`))), (ROW(`EMPNO`, `NAME`))))");
   }
 
-  @Test void testLateral() {
+  @Test void lateral() {
     // Bad: LATERAL table
     sql("select * from lateral ^emp^").fails("(?s)Encountered \"emp\" at .*");
     sql("select * from lateral table ^emp^ as e").fails("(?s)Encountered \"emp\" at .*");
@@ -5958,7 +5959,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("select * from lateral (select * from emp) as t(x)").ok(expected2 + " AS `T` (`X`)");
   }
 
-  @Test void testTemporalTable() {
+  @Test void temporalTable() {
     final String sql0 =
         "select stream * from orders, products\n"
             + "for system_time as of TIMESTAMP '2011-01-02 00:00:00'";
@@ -6015,7 +6016,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql4).ok(expected4);
   }
 
-  @Test void testCollectionTableWithLateral() {
+  @Test void collectionTableWithLateral() {
     final String sql = "select * from dept, lateral table(ramp(dept.deptno))";
     final String expected =
         "SELECT *\n"
@@ -6024,7 +6025,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testCollectionTableWithLateral2() {
+  @Test void collectionTableWithLateral2() {
     final String sql =
         "select * from dept as d\n"
   + "cross join lateral table(ramp(dept.deptno)) as r";
@@ -6035,7 +6036,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testCollectionTableWithLateral3() {
+  @Test void collectionTableWithLateral3() {
     // LATERAL before first table in FROM clause doesn't achieve anything, but
     // it's valid.
     final String sql = "select * from lateral table(ramp(dept.deptno)), dept";
@@ -6046,14 +6047,14 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunction() {
+  @Test void tableFunction() {
     final String sql = "select * from table(score(table orders))";
     final String expected = "SELECT *\n"
   + "FROM TABLE(`SCORE`((TABLE `ORDERS`)))";
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithPartitionKey() {
+  @Test void tableFunctionWithPartitionKey() {
     // test one partition key for input table
     final String sql = "select * from table(topn(table orders partition by productid, 3))";
     final String expected =
@@ -6062,7 +6063,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithMultiplePartitionKeys() {
+  @Test void tableFunctionWithMultiplePartitionKeys() {
     // test multiple partition keys for input table
     final String sql =
         "select * from table(topn(table orders partition by (orderId, productid), 3))";
@@ -6072,7 +6073,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithOrderKey() {
+  @Test void tableFunctionWithOrderKey() {
     // test one order key for input table
     final String sql = "select * from table(topn(table orders order by orderId, 3))";
     final String expected =
@@ -6081,7 +6082,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithMultipleOrderKeys() {
+  @Test void tableFunctionWithMultipleOrderKeys() {
     // test multiple order keys for input table
     final String sql = "select * from table(topn(table orders order by (orderId, productid), 3))";
     final String expected =
@@ -6090,7 +6091,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithComplexOrderBy() {
+  @Test void tableFunctionWithComplexOrderBy() {
     // test complex order-by clause for input table
     final String sql =
         "select * from table(topn(table orders order by (orderId desc, productid asc), 3))";
@@ -6100,7 +6101,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithPartitionKeyAndOrderKey() {
+  @Test void tableFunctionWithPartitionKeyAndOrderKey() {
     // test partition by clause and order by clause for input table
     final String sql =
         "select * from table(topn(table orders partition by productid order by orderId, 3))";
@@ -6110,7 +6111,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithSubQuery() {
+  @Test void tableFunctionWithSubQuery() {
     // test partition by clause and order by clause for subquery
     final String sql =
         "select * from table(topn(select * from Orders partition by productid "
@@ -6122,7 +6123,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithMultipleInputTables() {
+  @Test void tableFunctionWithMultipleInputTables() {
     final String sql = "select * from table(similarlity(table emp, table emp_b))";
     final String expected =
         "SELECT *\n"
@@ -6130,7 +6131,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithMultipleInputTablesAndSubClauses() {
+  @Test void tableFunctionWithMultipleInputTablesAndSubClauses() {
     final String sql =
         "select * from table("
             + "similarlity("
@@ -6143,7 +6144,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testIllegalCursors() {
+  @Test void illegalCursors() {
     sql("select ^cursor^(select * from emps) from emps")
         .fails("CURSOR expression encountered in illegal context");
     sql("call list(^cursor^(select * from emps))")
@@ -6152,7 +6153,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("CURSOR expression encountered in illegal context");
   }
 
-  @Test void testExplain() {
+  @Test void explain() {
     final String sql = "explain plan for select * from emps";
     final String expected =
         "EXPLAIN PLAN"
@@ -6162,7 +6163,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testExplainAsXml() {
+  @Test void explainAsXml() {
     final String sql = "explain plan as xml for select * from emps";
     final String expected =
         "EXPLAIN PLAN"
@@ -6172,7 +6173,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testExplainAsDot() {
+  @Test void explainAsDot() {
     final String sql = "explain plan as dot for select * from emps";
     final String expected =
         "EXPLAIN PLAN"
@@ -6182,7 +6183,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testExplainAsJson() {
+  @Test void explainAsJson() {
     final String sql = "explain plan as json for select * from emps";
     final String expected =
         "EXPLAIN PLAN"
@@ -6192,7 +6193,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testExplainWithImpl() {
+  @Test void explainWithImpl() {
     sql("explain plan with implementation for select * from emps")
         .ok(
             "EXPLAIN PLAN INCLUDING ATTRIBUTES WITH IMPLEMENTATION FOR\n"
@@ -6200,7 +6201,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMPS`");
   }
 
-  @Test void testExplainWithoutImpl() {
+  @Test void explainWithoutImpl() {
     sql("explain plan without implementation for select * from emps")
         .ok(
             "EXPLAIN PLAN INCLUDING ATTRIBUTES WITHOUT IMPLEMENTATION FOR\n"
@@ -6208,18 +6209,18 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMPS`");
   }
 
-  @Test void testExplainWithType() {
+  @Test void explainWithType() {
     sql("explain plan with type for (values (true))")
         .ok("EXPLAIN PLAN INCLUDING ATTRIBUTES WITH TYPE FOR\n"
   + "(VALUES (ROW(TRUE)))");
   }
 
-  @Test void testExplainJsonFormat() {
+  @Test void explainJsonFormat() {
     SqlExplain sqlExplain = (SqlExplain) sql("explain plan as json for select * from emps").node();
     assertThat(sqlExplain.isJson(), is(true));
   }
 
-  @Test void testDescribeSchema() {
+  @Test void describeSchema() {
     sql("describe schema A").ok("DESCRIBE SCHEMA `A`");
     // Currently DESCRIBE DATABASE, DESCRIBE CATALOG become DESCRIBE SCHEMA.
     // See [CALCITE-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT
@@ -6227,7 +6228,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("describe catalog A").ok("DESCRIBE SCHEMA `A`");
   }
 
-  @Test void testDescribeTable() {
+  @Test void describeTable() {
     sql("describe emps").ok("DESCRIBE TABLE `EMPS`");
     sql("describe \"emps\"").ok("DESCRIBE TABLE `emps`");
     sql("describe s.emps").ok("DESCRIBE TABLE `S`.`EMPS`");
@@ -6246,7 +6247,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("describe emps c1^.^c2").fails("(?s).*Encountered \"\\.\" at .*");
   }
 
-  @Test void testDescribeStatement() {
+  @Test void describeStatement() {
     // Currently DESCRIBE STATEMENT becomes EXPLAIN.
     // See [CALCITE-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT
     final String expected0 =
@@ -6287,18 +6288,18 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"explain\" at .*");
   }
 
-  @Test void testSelectIsNotDdl() {
+  @Test void selectIsNotDdl() {
     sql("select 1 from t").node(not(isDdl()));
   }
 
-  @Test void testInsertSelect() {
+  @Test void insertSelect() {
     final String expected = "INSERT INTO `EMPS`\n"
   + "SELECT *\n"
   + "FROM `EMPS`";
     sql("insert into emps select * from emps").ok(expected).node(not(isDdl()));
   }
 
-  @Test void testInsertUnion() {
+  @Test void insertUnion() {
     final String expected =
         "INSERT INTO `EMPS`\n"
             + "SELECT *\n"
@@ -6309,7 +6310,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("insert into emps select * from emps1 union select * from emps2").ok(expected);
   }
 
-  @Test void testInsertValues() {
+  @Test void insertValues() {
     final String expected = "INSERT INTO `EMPS`\n"
   + "VALUES (ROW(1, 'Fredkin'))";
     final String pattern = "VALUE is not allowed under the current SQL conformance level";
@@ -6321,34 +6322,34 @@ void checkPeriodPredicate(Checker checker) {
     sql("insert into emps ^value^ (1, 'Fredkin')").fails(pattern);
   }
 
-  @Test void testInsertValuesDefault() {
+  @Test void insertValuesDefault() {
     final String expected = "INSERT INTO `EMPS`\n"
   + "VALUES (ROW(1, DEFAULT, 'Fredkin'))";
     sql("insert into emps values (1,DEFAULT,'Fredkin')").ok(expected).node(not(isDdl()));
   }
 
-  @Test void testInsertValuesRawDefault() {
+  @Test void insertValuesRawDefault() {
     final String expected = "INSERT INTO `EMPS`\n"
   + "VALUES (ROW(DEFAULT))";
     sql("insert into emps values ^default^").fails("(?s).*Encountered \"default\" at .*");
     sql("insert into emps values (default)").ok(expected).node(not(isDdl()));
   }
 
-  @Test void testInsertColumnList() {
+  @Test void insertColumnList() {
     final String expected = "INSERT INTO `EMPS` (`X`, `Y`)\n"
   + "SELECT *\n"
   + "FROM `EMPS`";
     sql("insert into emps(x,y) select * from emps").ok(expected);
   }
 
-  @Test void testInsertCaseSensitiveColumnList() {
+  @Test void insertCaseSensitiveColumnList() {
     final String expected = "INSERT INTO `emps` (`x`, `y`)\n"
   + "SELECT *\n"
   + "FROM `EMPS`";
     sql("insert into \"emps\"(\"x\",\"y\") select * from emps").ok(expected);
   }
 
-  @Test void testInsertExtendedColumnList() {
+  @Test void insertExtendedColumnList() {
     String expected =
         "INSERT INTO `EMPS` EXTEND (`Z` BOOLEAN) (`X`, `Y`)\n"
   + "SELECT *\n"
@@ -6363,7 +6364,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected);
   }
 
-  @Test void testUpdateExtendedColumnList() {
+  @Test void updateExtendedColumnList() {
     final String expected =
         "UPDATE `EMPDEFAULTS` EXTEND (`EXTRA` BOOLEAN, `NOTE` VARCHAR)"
             + " SET `DEPTNO` = 1"
@@ -6378,7 +6379,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected);
   }
 
-  @Test void testUpdateCaseSensitiveExtendedColumnList() {
+  @Test void updateCaseSensitiveExtendedColumnList() {
     final String expected =
         "UPDATE `EMPDEFAULTS` EXTEND (`extra` BOOLEAN, `NOTE` VARCHAR)"
             + " SET `DEPTNO` = 1"
@@ -6393,7 +6394,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected);
   }
 
-  @Test void testInsertCaseSensitiveExtendedColumnList() {
+  @Test void insertCaseSensitiveExtendedColumnList() {
     String expected =
         "INSERT INTO `emps` EXTEND (`z` BOOLEAN) (`x`, `y`)\n"
   + "SELECT *\n"
@@ -6408,7 +6409,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected);
   }
 
-  @Test void testExplainInsert() {
+  @Test void explainInsert() {
     final String expected =
         "EXPLAIN PLAN INCLUDING ATTRIBUTES"
             + " WITH IMPLEMENTATION FOR\n"
@@ -6418,7 +6419,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("explain plan for insert into emps1 select * from emps2").ok(expected).node(not(isDdl()));
   }
 
-  @Test void testUpsertValues() {
+  @Test void upsertValues() {
     final String expected = "UPSERT INTO `EMPS`\n"
   + "VALUES (ROW(1, 'Fredkin'))";
     final String sql = "upsert into emps values (1,'Fredkin')";
@@ -6427,7 +6428,7 @@ void checkPeriodPredicate(Checker checker) {
     }
   }
 
-  @Test void testUpsertSelect() {
+  @Test void upsertSelect() {
     final String sql = "upsert into emps select * from emp as e";
     final String expected = "UPSERT INTO `EMPS`\n"
   + "SELECT *\n"
@@ -6437,7 +6438,7 @@ void checkPeriodPredicate(Checker checker) {
     }
   }
 
-  @Test void testExplainUpsert() {
+  @Test void explainUpsert() {
     final String sql = "explain plan for upsert into emps1 values (1, 2)";
     final String expected =
         "EXPLAIN PLAN INCLUDING ATTRIBUTES"
@@ -6449,16 +6450,16 @@ void checkPeriodPredicate(Checker checker) {
     }
   }
 
-  @Test void testDelete() {
+  @Test void delete() {
     sql("delete from emps").ok("DELETE FROM `EMPS`").node(not(isDdl()));
   }
 
-  @Test void testDeleteWhere() {
+  @Test void deleteWhere() {
     sql("delete from emps where empno=12").ok("DELETE FROM `EMPS`\n"
   + "WHERE (`EMPNO` = 12)");
   }
 
-  @Test void testUpdate() {
+  @Test void update() {
     sql("update emps set empno = empno + 1, sal = sal - 1 where empno=12")
         .ok(
             "UPDATE `EMPS` SET `EMPNO` = (`EMPNO` + 1)"
@@ -6466,7 +6467,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`EMPNO` = 12)");
   }
 
-  @Test void testMergeSelectSource() {
+  @Test void mergeSelectSource() {
     final String sql =
         "merge into emps e "
             + "using (select * from tempemps where deptno is null) t "
@@ -6490,7 +6491,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Same as testMergeSelectSource but set with compound identifier. */
-  @Test void testMergeSelectSource2() {
+  @Test void mergeSelectSource2() {
     final String sql =
         "merge into emps e "
             + "using (select * from tempemps where deptno is null) t "
@@ -6513,7 +6514,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected).node(not(isDdl()));
   }
 
-  @Test void testMergeTableRefSource() {
+  @Test void mergeTableRefSource() {
     final String sql =
         "merge into emps e "
             + "using tempemps as t "
@@ -6535,7 +6536,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Same with testMergeTableRefSource but set with compound identifier. */
-  @Test void testMergeTableRefSource2() {
+  @Test void mergeTableRefSource2() {
     final String sql =
         "merge into emps e "
             + "using tempemps as t "
@@ -6556,7 +6557,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testMergeMismatchedParentheses() {
+  @Test void mergeMismatchedParentheses() {
     // Invalid; more '(' than ')'
     final String sql1 =
         "merge into emps as e\n"
@@ -6595,13 +6596,13 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql3).ok(expected);
   }
 
-  @Test void testBitStringNotImplemented() {
+  @Test void bitStringNotImplemented() {
     // Bit-string is longer part of the SQL standard. We do not support it.
     sql("select (B^'1011'^ || 'foobar') from (values (true))")
         .fails("(?s).*Encountered \"\\\\'1011\\\\'\" at .*");
   }
 
-  @Test void testHexAndBinaryString() {
+  @Test void hexAndBinaryString() {
     expr("x''=X'2'").ok("(X'' = X'2')");
     expr("x'fffff'=X''").ok("(X'FFFFF' = X'')");
     expr("x'1' \t\t\f\r\n"
@@ -6617,7 +6618,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("x'001'=X'000102'").ok("(X'001' = X'000102')");
   }
 
-  @Test void testHexAndBinaryStringFails() {
+  @Test void hexAndBinaryStringFails() {
     sql("select ^x'FeedGoats'^ from t")
         .fails("Binary literal string must contain only characters '0' - '9', 'A' - 'F'");
     sql("select ^x'abcdefG'^ from t")
@@ -6630,7 +6631,7 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `T`");
   }
 
-  @Test void testStringLiteral() {
+  @Test void stringLiteral() {
     expr("_latin1'hi'").ok("_LATIN1'hi'");
     expr("N'is it a plane? no it''s superman!'")
         .ok("_ISO-8859-1'is it a plane? no it''s superman!'");
@@ -6653,7 +6654,7 @@ void checkPeriodPredicate(Checker checker) {
         .same();
   }
 
-  @Test void testStringLiteralFails() {
+  @Test void stringLiteralFails() {
     sql("select (N ^'space'^)").fails("(?s).*Encountered .*space.* at line 1, column ...*");
     sql("select (_latin1\n^'newline'^)")
         .fails("(?s).*Encountered.*newline.* at line 2, column ...*");
@@ -6666,7 +6667,7 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `T`");
   }
 
-  @Test void testStringLiteralChain() {
+  @Test void stringLiteralChain() {
     final String fooBar = "'foo'\n"
   + "'bar'";
     final String fooBarBaz = "'foo'\n"
@@ -6683,7 +6684,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("   'foo' 'bar'").ok(fooBar);
   }
 
-  @Test void testStringLiteralDoubleQuoted() {
+  @Test void stringLiteralDoubleQuoted() {
     sql("select `deptno` as d, ^\"^deptno\" as d2 from emp")
         .withDialect(MYSQL)
         .fails("(?s)Encountered \"\\\\\"\" at .*")
@@ -6729,8 +6730,8 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     };
   }
 
-  @VisibleForTesting
-  @Test public void testCaseExpression() {
+  @Test @VisibleForTesting
+  void caseExpression() {
     // implicit simple "ELSE NULL" case
     expr("case \t col1 when 1 then 'one' end")
         .ok("(CASE WHEN (`COL1` = 1) THEN 'one' ELSE NULL END)");
@@ -6763,7 +6764,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql("case when b1, b2 ^when^ 2, 4 then 3 else 4 end").fails("(?s)Encountered \"when\" at .*");
   }
 
-  @Test void testCaseExpressionFails() {
+  @Test void caseExpressionFails() {
     // Missing 'END'
     sql("select case col1 when 1 then 'one' ^from^ t").fails("(?s).*from.*");
 
@@ -6781,20 +6782,20 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql("select 1 as if").ok("SELECT 1 AS `IF`");
   }
 
-  @Test void testNullIf() {
+  @Test void nullIf() {
     expr("nullif(v1,v2)").ok("NULLIF(`V1`, `V2`)");
     if (isReserved("NULLIF")) {
       expr("1 + ^nullif^ + 3").fails("(?s)Encountered \"nullif \\+\" at line 1, column 5.*");
     }
   }
 
-  @Test void testCoalesce() {
+  @Test void coalesce() {
     expr("coalesce(v1)").ok("COALESCE(`V1`)");
     expr("coalesce(v1,v2)").ok("COALESCE(`V1`, `V2`)");
     expr("coalesce(v1,v2,v3)").ok("COALESCE(`V1`, `V2`, `V3`)");
   }
 
-  @Test void testLiteralCollate() {
+  @Test void literalCollate() {
     if (!Bug.FRG78_FIXED) {
       return;
     }
@@ -6813,20 +6814,20 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .ok("('str1' COLLATE ISO-8859-1$sv_SE$primary <= 'str2' COLLATE ISO-8859-1$sv_FI$primary)");
   }
 
-  @Test void testCharLength() {
+  @Test void charLength() {
     expr("char_length('string')").ok("CHAR_LENGTH('string')");
     expr("character_length('string')").ok("CHARACTER_LENGTH('string')");
   }
 
-  @Test void testPosition() {
+  @Test void position() {
     expr("posiTion('mouse' in 'house')").ok("POSITION('mouse' IN 'house')");
   }
 
-  @Test void testReplace() {
+  @Test void replace() {
     expr("replace('x', 'y', 'z')").ok("REPLACE('x', 'y', 'z')");
   }
 
-  @Test void testDateLiteral() {
+  @Test void dateLiteral() {
     final String expected = "SELECT DATE '1980-01-01'\n"
   + "FROM `T`";
     sql("select date '1980-01-01' from t").ok(expected);
@@ -6848,7 +6849,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
    * Tests that on BigQuery, DATE, TIME and TIMESTAMP literals can use single- or double-quoted
    * strings.
    */
-  @Test void testDateLiteralBigQuery() {
+  @Test void dateLiteralBigQuery() {
     final SqlParserFixture f = fixture().withDialect(BIG_QUERY);
     f.sql("select date '2020-10-10'").ok("SELECT DATE '2020-10-10'");
     f.sql("select date\"2020-10-10\"").ok("SELECT DATE '2020-10-10'");
@@ -6858,7 +6859,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     f.sql("select time \"13:22:04\"").ok("SELECT TIME '13:22:04'");
   }
 
-  @Test void testIntervalLiteralBigQuery() {
+  @Test void intervalLiteralBigQuery() {
     final SqlParserFixture f = fixture().withDialect(BIG_QUERY).expression(true);
     f.sql("interval '1' day").ok("INTERVAL '1' DAY");
     f.sql("interval \"1\" day").ok("INTERVAL '1' DAY");
@@ -6867,7 +6868,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   }
 
   // check date/time functions.
-  @Test void testTimeDate() {
+  @Test void timeDate() {
     // CURRENT_TIME - returns time w/ timezone
     expr("CURRENT_TIME(3)").same();
 
@@ -6946,7 +6947,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   }
 
   /** Tests for casting to/from date/time types. */
-  @Test void testDateTimeCast() {
+  @Test void dateTimeCast() {
     //   checkExp("CAST(DATE '2001-12-21' AS CHARACTER VARYING)",
     // "CAST(2001-12-21)");
     expr("CAST('2001-12-21' AS DATE)").same();
@@ -6957,7 +6958,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr("Cast(DATE '2004-12-21' AS VARCHAR(10))").ok("CAST(DATE '2004-12-21' AS VARCHAR(10))");
   }
 
-  @Test void testTrim() {
+  @Test void trim() {
     expr("trim('mustache' FROM 'beard')").ok("TRIM(BOTH 'mustache' FROM 'beard')");
     expr("trim('mustache')").ok("TRIM(BOTH ' ' FROM 'mustache')");
     expr("trim(TRAILING FROM 'mustache')").ok("TRIM(TRAILING ' ' FROM 'mustache')");
@@ -6974,7 +6975,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql("trim(^from^ 'beard')").fails("(?s).*'FROM' without operands preceding it is illegal.*");
   }
 
-  @Test void testConvertAndTranslate() {
+  @Test void convertAndTranslate() {
     expr("convert('abc', utf8, utf16)").ok("CONVERT('abc', `UTF8`, `UTF16`)");
     sql("select convert(name, latin1, gbk) as newName from t")
         .ok("SELECT CONVERT(`NAME`, `LATIN1`, `GBK`) AS `NEWNAME`\n"
@@ -6991,17 +6992,17 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "FROM `T`");
   }
 
-  @Test void testTranslate3() {
+  @Test void translate3() {
     expr("translate('aaabbbccc', 'ab', '+-')").ok("TRANSLATE('aaabbbccc', 'ab', '+-')");
   }
 
-  @Test void testOverlay() {
+  @Test void overlay() {
     expr("overlay('ABCdef' placing 'abc' from 1)").ok("OVERLAY('ABCdef' PLACING 'abc' FROM 1)");
     expr("overlay('ABCdef' placing 'abc' from 1 for 3)")
         .ok("OVERLAY('ABCdef' PLACING 'abc' FROM 1 FOR 3)");
   }
 
-  @Test void testJdbcFunctionCall() {
+  @Test void jdbcFunctionCall() {
     expr("{fn apa(1,'1')}").ok("{fn APA(1, '1') }");
     expr("{ Fn apa(log10(ln(1))+2)}").ok("{fn APA((LOG10(LN(1)) + 2)) }");
     expr("{fN apa(*)}").ok("{fn APA(*) }");
@@ -7028,14 +7029,14 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr("{fn convert(1, ^INTERVAL^ YEAR)}").fails("(?s)Encountered \"INTERVAL\" at.*");
   }
 
-  @Test void testWindowReference() {
+  @Test void windowReference() {
     expr("sum(sal) over (w)").ok("(SUM(`SAL`) OVER (`W`))");
 
     // Only 1 window reference allowed
     expr("sum(sal) over (w ^w1^ partition by deptno)").fails("(?s)Encountered \"w1\" at.*");
   }
 
-  @Test void testWindowInSubQuery() {
+  @Test void windowInSubQuery() {
     final String sql =
         "select * from (\n"
             + " select sum(x) over w, sum(y) over w\n"
@@ -7049,7 +7050,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWindowSpec() {
+  @Test void windowSpec() {
     // Correct syntax
     final String sql1 =
         "select count(z) over w as foo\n"
@@ -7117,7 +7118,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .fails("(?s).*Encountered \"order\".*");
   }
 
-  @Test void testWindowSpecPartial() {
+  @Test void windowSpecPartial() {
     // ALLOW PARTIAL is the default, and is omitted when the statement is
     // unparsed.
     sql("select sum(x) over (order by x allow partial) from bids")
@@ -7137,7 +7138,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "FROM `BIDS`");
   }
 
-  @Test void testQualify() {
+  @Test void qualify() {
     final String sql =
         "SELECT empno, ename,\n"
             + " ROW_NUMBER() over (partition by ename order by deptno) as rn\n"
@@ -7151,7 +7152,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQualifyWithoutAlias() {
+  @Test void qualifyWithoutAlias() {
     final String sql =
         "SELECT empno, ename\n"
             + "FROM emp\n"
@@ -7163,7 +7164,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQualifyWithWindowClause() {
+  @Test void qualifyWithWindowClause() {
     final String sql =
         "SELECT empno, ename,\n"
             + " SUM(deptno) OVER myWindow as sumDeptNo\n"
@@ -7179,7 +7180,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQualifyWithEverything() {
+  @Test void qualifyWithEverything() {
     final String sql =
         "SELECT DISTINCT ename,\n"
             + " SUM(deptno) OVER (PARTITION BY ename) as r\n"
@@ -7203,7 +7204,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQualifyIllegalAfterOrder() {
+  @Test void qualifyIllegalAfterOrder() {
     final String sql = "SELECT x\n"
   + "FROM t\n"
   + "ORDER BY 1 DESC\n"
@@ -7211,7 +7212,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).fails("(?s).*Encountered \"QUALIFY\" at .*");
   }
 
-  @Test void testNullTreatment() {
+  @Test void nullTreatment() {
     sql("select lead(x) respect nulls over (w) from t")
         .ok("SELECT (LEAD(`X`) RESPECT NULLS OVER (`W`))\n"
   + "FROM `T`");
@@ -7249,7 +7250,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "FROM `T`");
   }
 
-  @Test void testAs() {
+  @Test void as() {
     // AS is optional for column aliases
     sql("select x y from t").ok("SELECT `X` AS `Y`\n"
   + "FROM `T`");
@@ -7283,7 +7284,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .fails("(?s).*Encountered \"over\".*");
   }
 
-  @Test void testAsAliases() {
+  @Test void asAliases() {
     sql("select x from t as t1 (a, b) where foo")
         .ok("SELECT `X`\n"
   + "FROM `T` AS `T1` (`A`, `B`)\n"
@@ -7315,7 +7316,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "    \",\" \\.\\.\\..*");
   }
 
-  @Test void testOver() {
+  @Test void over() {
     expr("sum(sal) over ()").ok("(SUM(`SAL`) OVER ())");
     expr("sum(sal) over (partition by x, y)").ok("(SUM(`SAL`) OVER (PARTITION BY `X`, `Y`))");
     expr("sum(sal) over (order by x desc, y asc)").ok("(SUM(`SAL`) OVER (ORDER BY `X` DESC, `Y`))");
@@ -7355,29 +7356,29 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
                 + "AND INTERVAL '5' DAY FOLLOWING))");
   }
 
-  @Test void testElementFunc() {
+  @Test void elementFunc() {
     expr("element(a)").ok("ELEMENT(`A`)");
   }
 
-  @Test void testCardinalityFunc() {
+  @Test void cardinalityFunc() {
     expr("cardinality(a)").ok("CARDINALITY(`A`)");
   }
 
-  @Test void testMemberOf() {
+  @Test void memberOf() {
     expr("a member of b").ok("(`A` MEMBER OF `B`)");
     expr("a member of multiset[b]").ok("(`A` MEMBER OF (MULTISET[`B`]))");
   }
 
-  @Test void testSubMultisetrOf() {
+  @Test void subMultisetrOf() {
     expr("a submultiset of b").ok("(`A` SUBMULTISET OF `B`)");
   }
 
-  @Test void testIsASet() {
+  @Test void isASet() {
     expr("b is a set").ok("(`B` IS A SET)");
     expr("a is a set").ok("(`A` IS A SET)");
   }
 
-  @Test void testMultiset() {
+  @Test void multiset() {
     expr("multiset[1]").ok("(MULTISET[1])");
     expr("multiset[1,2.3]").ok("(MULTISET[1, 2.3])");
     expr("multiset[1,    '2']").ok("(MULTISET[1, '2'])");
@@ -7388,25 +7389,25 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "FROM `T`)))");
   }
 
-  @Test void testMultisetUnion() {
+  @Test void multisetUnion() {
     expr("a multiset union b").ok("(`A` MULTISET UNION ALL `B`)");
     expr("a multiset union all b").ok("(`A` MULTISET UNION ALL `B`)");
     expr("a multiset union distinct b").ok("(`A` MULTISET UNION DISTINCT `B`)");
   }
 
-  @Test void testMultisetExcept() {
+  @Test void multisetExcept() {
     expr("a multiset EXCEPT b").ok("(`A` MULTISET EXCEPT ALL `B`)");
     expr("a multiset EXCEPT all b").ok("(`A` MULTISET EXCEPT ALL `B`)");
     expr("a multiset EXCEPT distinct b").ok("(`A` MULTISET EXCEPT DISTINCT `B`)");
   }
 
-  @Test void testMultisetIntersect() {
+  @Test void multisetIntersect() {
     expr("a multiset INTERSECT b").ok("(`A` MULTISET INTERSECT ALL `B`)");
     expr("a multiset INTERSECT all b").ok("(`A` MULTISET INTERSECT ALL `B`)");
     expr("a multiset INTERSECT distinct b").ok("(`A` MULTISET INTERSECT DISTINCT `B`)");
   }
 
-  @Test void testMultisetMixed() {
+  @Test void multisetMixed() {
     expr("multiset[1] MULTISET union b").ok("((MULTISET[1]) MULTISET UNION ALL `B`)");
     final String sql =
         "a MULTISET union b " + "multiset intersect c " + "multiset except d " + "multiset union e";
@@ -7417,32 +7418,32 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr(sql).ok(expected);
   }
 
-  @Test void testMapItem() {
+  @Test void mapItem() {
     expr("a['foo']").ok("`A`['foo']");
     expr("a['x' || 'y']").ok("`A`[('x' || 'y')]");
     expr("a['foo'] ['bar']").ok("`A`['foo']['bar']");
     expr("a['foo']['bar']").ok("`A`['foo']['bar']");
   }
 
-  @Test void testMapItemPrecedence() {
+  @Test void mapItemPrecedence() {
     expr("1 + a['foo'] * 3").ok("(1 + (`A`['foo'] * 3))");
     expr("1 * a['foo'] + 3").ok("((1 * `A`['foo']) + 3)");
     expr("a['foo']['bar']").ok("`A`['foo']['bar']");
     expr("a[b['foo' || 'bar']]").ok("`A`[`B`[('foo' || 'bar')]]");
   }
 
-  @Test void testArrayElement() {
+  @Test void arrayElement() {
     expr("a[1]").ok("`A`[1]");
     expr("a[b[1]]").ok("`A`[`B`[1]]");
     expr("a[b[1 + 2] + 3]").ok("`A`[(`B`[(1 + 2)] + 3)]");
   }
 
-  @Test void testArrayElementWithDot() {
+  @Test void arrayElementWithDot() {
     expr("a[1+2].b.c[2].d").ok("(((`A`[(1 + 2)].`B`).`C`)[2].`D`)");
     expr("a[b[1]].c.f0[d[1]]").ok("((`A`[`B`[1]].`C`).`F0`)[`D`[1]]");
   }
 
-  @Test void testArrayValueConstructor() {
+  @Test void arrayValueConstructor() {
     expr("array[1, 2]").ok("(ARRAY[1, 2])");
     expr("array [1, 2]").ok("(ARRAY[1, 2])"); // with space
 
@@ -7451,12 +7452,12 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr("array[(1, 'a'), (2, 'b')]").ok("(ARRAY[(ROW(1, 'a')), (ROW(2, 'b'))])");
   }
 
-  @Test void testArrayFunction() {
+  @Test void arrayFunction() {
     expr("array()").ok("ARRAY()");
     expr("array(1)").ok("ARRAY(1)");
   }
 
-  @Test void testArrayQueryConstructor() {
+  @Test void arrayQueryConstructor() {
     sql("SELECT array(SELECT x FROM (VALUES(1)) x)")
         .ok("SELECT (ARRAY ((SELECT `X`\n"
   + "FROM (VALUES (ROW(1))) AS `X`)))");
@@ -7470,7 +7471,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .fails("(?s)Incorrect syntax near the keyword 'SELECT'.*");
   }
 
-  @Test void testCastAsCollectionType() {
+  @Test void castAsCollectionType() {
     // test array type.
     expr("cast(a as int array)").ok("CAST(`A` AS INTEGER ARRAY)");
     expr("cast(a as varchar(5) array)").ok("CAST(`A` AS VARCHAR(5) ARRAY)");
@@ -7493,7 +7494,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr("cast(a as MyUDT array multiset)").ok("CAST(`A` AS `MYUDT` ARRAY MULTISET)");
   }
 
-  @Test void testCastAsRowType() {
+  @Test void castAsRowType() {
     expr("cast(a as row(f0 int, f1 varchar))").ok("CAST(`A` AS ROW(`F0` INTEGER, `F1` VARCHAR))");
     expr("cast(a as row(f0 int not null, f1 varchar null))")
         .ok("CAST(`A` AS ROW(`F0` INTEGER, `F1` VARCHAR NULL))");
@@ -7512,13 +7513,13 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .ok("CAST(`A` AS ROW(`F0` VARCHAR, `F1` TIMESTAMP NULL) MULTISET)");
   }
 
-  @Test void testMapValueConstructor() {
+  @Test void mapValueConstructor() {
     expr("map[1, 'x', 2, 'y']").ok("(MAP[1, 'x', 2, 'y'])");
     expr("map [1, 'x', 2, 'y']").ok("(MAP[1, 'x', 2, 'y'])");
     expr("map[]").ok("(MAP[])");
   }
 
-  @Test void testVisitSqlInsertWithSqlShuttle() {
+  @Test void visitSqlInsertWithSqlShuttle() {
     final String sql = "insert into emps select * from emps";
     final SqlNode sqlNode = sql(sql).node();
     final SqlNode sqlNodeVisited =
@@ -7533,7 +7534,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     assertThat(sqlNodeVisited.getKind(), is(SqlKind.INSERT));
   }
 
-  @Test void testSqlInsertSqlBasicCallToString() {
+  @Test void sqlInsertSqlBasicCallToString() {
     final String sql0 = "insert into emps select * from emps";
     final SqlNode sqlNode0 = sql(sql0).node();
     final SqlNode sqlNodeVisited0 =
@@ -7565,7 +7566,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     assertThat(str1, is(toLinux(sqlNodeVisited1.toString())));
   }
 
-  @Test void testVisitSqlMatchRecognizeWithSqlShuttle() {
+  @Test void visitSqlMatchRecognizeWithSqlShuttle() {
     final String sql =
         "select *\n"
             + "from emp \n"
@@ -7599,7 +7600,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
    * <p>A substantially identical set of tests exists in SqlValidatorTest, and any changes here
    * should be synchronized there.
    */
-  @Test void testIntervalLiterals() {
+  @Test void intervalLiterals() {
     final SqlParserFixture f = fixture();
     final IntervalTest.Fixture intervalFixture =
         new IntervalTest.Fixture() {
@@ -7632,7 +7633,7 @@ private IntervalTest.Fixture2 getFixture2(SqlParserFixture f2, String expectedSq
     new IntervalTest(intervalFixture).testAll();
   }
 
-  @Test void testUnparseableIntervalQualifiers() {
+  @Test void unparseableIntervalQualifiers() {
     // No qualifier
     expr("interval '1^'^")
         .fails(
@@ -7794,7 +7795,7 @@ private IntervalTest.Fixture2 getFixture2(SqlParserFixture f2, String expectedSq
     expr("interval '1-2' month(3) ^to^ second(2,6)").fails(ANY);
   }
 
-  @Test void testUnparseableIntervalQualifiers2() {
+  @Test void unparseableIntervalQualifiers2() {
     expr("interval '1-2' day(3) ^to^ year(2)").fails(ANY);
     expr("interval '1-2' day(3) ^to^ month(2)").fails(ANY);
     expr("interval '1-2' day(3) ^to^ day(2)").fails(ANY);
@@ -7861,7 +7862,7 @@ private IntervalTest.Fixture2 getFixture2(SqlParserFixture f2, String expectedSq
   }
 
   /** Tests that plural time units are allowed when not in strict mode. */
-  @Test void testIntervalPluralUnits() {
+  @Test void intervalPluralUnits() {
     expr("interval '2' years").hasWarning(checkWarnings("YEARS")).ok("INTERVAL '2' YEAR");
     expr("interval '2:1' years to months")
         .hasWarning(checkWarnings("YEARS", "MONTHS"))
@@ -7894,7 +7895,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     };
   }
 
-  @Test void testMiscIntervalQualifier() {
+  @Test void miscIntervalQualifier() {
     expr("interval '-' day").ok("INTERVAL '-' DAY");
 
     expr("interval '1 2:3:4.567' day to hour ^to^ second").fails("(?s)Encountered \"to\" at.*");
@@ -7903,7 +7904,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("interval '1:x:2' hour to second").ok("INTERVAL '1:x:2' HOUR TO SECOND");
   }
 
-  @Test void testIntervalExpression() {
+  @Test void intervalExpression() {
     expr("interval 0 day").ok("INTERVAL 0 DAY");
     expr("interval 0 days").ok("INTERVAL 0 DAY");
     expr("interval -10 days").ok("INTERVAL (- 10) DAY");
@@ -7918,7 +7919,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("interval '1 1' day to hour").ok("INTERVAL '1 1' DAY TO HOUR");
   }
 
-  @Test void testIntervalOperators() {
+  @Test void intervalOperators() {
     expr("-interval '1' day").ok("(- INTERVAL '1' DAY)");
     expr("interval '1' day + interval '1' day").ok("(INTERVAL '1' DAY + INTERVAL '1' DAY)");
     expr("interval '1' day - interval '1:2:3' hour to second")
@@ -7932,7 +7933,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("interval 'wael was here' HOUR").ok("INTERVAL 'wael was here' HOUR");
   }
 
-  @Test void testDateMinusDate() {
+  @Test void dateMinusDate() {
     expr("(date1 - date2) HOUR").ok("((`DATE1` - `DATE2`) HOUR)");
     expr("(date1 - date2) YEAR TO MONTH").ok("((`DATE1` - `DATE2`) YEAR TO MONTH)");
     expr("(date1 - date2) HOUR > interval '1' HOUR")
@@ -7947,7 +7948,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "Was expecting ..DATETIME - DATETIME. INTERVALQUALIFIER.*");
   }
 
-  @Test void testExtract() {
+  @Test void extract() {
     expr("extract(year from x)").ok("EXTRACT(YEAR FROM `X`)");
     expr("extract(month from x)").ok("EXTRACT(MONTH FROM `X`)");
     expr("extract(day from x)").ok("EXTRACT(DAY FROM `X`)");
@@ -7970,7 +7971,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Tests that EXTRACT, FLOOR, CEIL, DATE_TRUNC functions accept abbreviations for time units (such
    * as "Y" for "YEAR") when configured via {@link Config#timeUnitCodes()}.
    */
-  @Test protected void testTimeUnitCodes() {
+  @Test void timeUnitCodes() {
     // YEAR is a built-in time frame. When unparsed, it looks like a keyword.
     // (Note no backticks around YEAR.)
     expr("floor(d to year)").ok("FLOOR(`D` TO YEAR)");
@@ -8006,7 +8007,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("date_trunc(d , week(tuesday))").ok("(DATE_TRUNC(`D`, `WEEK_TUESDAY`))");
   }
 
-  @Test void testGeometry() {
+  @Test void geometry() {
     expr("cast(null as ^geometry^)")
         .fails("Geo-spatial extensions and the GEOMETRY data type are not enabled");
     expr("cast(null as geometry)")
@@ -8014,7 +8015,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("CAST(NULL AS GEOMETRY)");
   }
 
-  @Test void testIntervalArithmetics() {
+  @Test void intervalArithmetics() {
     expr("TIME '23:59:59' - interval '1' hour ").ok("(TIME '23:59:59' - INTERVAL '1' HOUR)");
     expr("TIMESTAMP '2000-01-01 23:59:59.1' - interval '1' hour ")
         .ok("(TIMESTAMP '2000-01-01 23:59:59.1' - INTERVAL '1' HOUR)");
@@ -8032,7 +8033,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("interval '1' hour / 8").ok("(INTERVAL '1' HOUR / 8)");
   }
 
-  @Test void testIntervalCompare() {
+  @Test void intervalCompare() {
     expr("interval '1' hour = interval '1' second").ok("(INTERVAL '1' HOUR = INTERVAL '1' SECOND)");
     expr("interval '1' hour <> interval '1' second")
         .ok("(INTERVAL '1' HOUR <> INTERVAL '1' SECOND)");
@@ -8044,7 +8045,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("(INTERVAL '1' HOUR >= INTERVAL '1' SECOND)");
   }
 
-  @Test void testCastToInterval() {
+  @Test void castToInterval() {
     expr("cast(x as interval year)").ok("CAST(`X` AS INTERVAL YEAR)");
     expr("cast(x as interval month)").ok("CAST(`X` AS INTERVAL MONTH)");
     expr("cast(x as interval year to month)").ok("CAST(`X` AS INTERVAL YEAR TO MONTH)");
@@ -8062,14 +8063,14 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("CAST(INTERVAL '3-2' YEAR TO MONTH AS CHAR(5))");
   }
 
-  @Test void testCastToVarchar() {
+  @Test void castToVarchar() {
     expr("cast(x as varchar(5))").ok("CAST(`X` AS VARCHAR(5))");
     expr("cast(x as varchar)").ok("CAST(`X` AS VARCHAR)");
     expr("cast(x as varBINARY(5))").ok("CAST(`X` AS VARBINARY(5))");
     expr("cast(x as varbinary)").ok("CAST(`X` AS VARBINARY)");
   }
 
-  @Test void testTimestampAdd() {
+  @Test void timestampAdd() {
     final String sql = "select * from t\n"
   + "where timestampadd(month, 5, hiredate) < curdate";
     final String expected =
@@ -8096,7 +8097,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("TIMESTAMPADD(`INCORRECT`, 1, CURRENT_TIMESTAMP)");
   }
 
-  @Test void testTimestampDiff() {
+  @Test void timestampDiff() {
     final String sql =
         "select * from t\n"
   + "where timestampdiff(microsecond, 5, hiredate) < curdate";
@@ -8124,7 +8125,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("TIMESTAMPDIFF(`INCORRECT`, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)");
   }
 
-  @Test void testTimeTrunc() {
+  @Test void timeTrunc() {
     final String sql = "select time_trunc(TIME '15:30:00', hour) from t";
     final String expected = "SELECT TIME_TRUNC(TIME '15:30:00', HOUR)\n"
   + "FROM `T`";
@@ -8144,7 +8145,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql3).ok(expected3);
   }
 
-  @Test void testTimestampTrunc() {
+  @Test void timestampTrunc() {
     final String sql = "select timestamp_trunc(timestamp '2008-12-25 15:30:00', week) from t";
     final String expected =
         "SELECT TIMESTAMP_TRUNC(TIMESTAMP '2008-12-25 15:30:00', WEEK)\n"
@@ -8158,7 +8159,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql3).ok(expected3);
   }
 
-  @Test void testUnnest() {
+  @Test void unnest() {
     sql("select*from unnest(x)").ok("SELECT *\n"
   + "FROM UNNEST(`X`)");
     sql("select*from unnest(x) AS T").ok("SELECT *\n"
@@ -8200,7 +8201,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql1).ok(expected1);
   }
 
-  @Test void testUnnestWithOrdinality() {
+  @Test void unnestWithOrdinality() {
     sql("select * from unnest(x) with ordinality")
         .ok("SELECT *\n"
   + "FROM UNNEST(`X`) WITH ORDINALITY");
@@ -8213,7 +8214,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql("select*from unnest(x) as T ^with^ ordinality").fails("(?s)Encountered \"with\" at .*");
   }
 
-  @Test void testParensInFrom() {
+  @Test void parensInFrom() {
     // UNNEST may not occur within parentheses.
     // FIXME should fail at "unnest"
     sql("select *from (^unnest(x)^)").fails("Expected query or join");
@@ -8269,7 +8270,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-35">[CALCITE-35] Support
    * parenthesized sub-clause in JOIN</a>.
    */
-  @Test void testParenthesizedJoins() {
+  @Test void parenthesizedJoins() {
     final String sql =
         "SELECT * FROM "
             + "(((S.C c INNER JOIN S.N n ON n.id = c.id) "
@@ -8300,7 +8301,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5194">[CALCITE-5194]
    * Cannot parse parenthesized UNION in FROM</a>.
    */
-  @Test void testParenthesizedUnionInFrom() {
+  @Test void parenthesizedUnionInFrom() {
     final String sql =
         "select *\n"
   + "from (\n"
@@ -8317,7 +8318,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testParenthesizedUnionAndJoinInFrom() {
+  @Test void parenthesizedUnionAndJoinInFrom() {
     final String sql =
         "select *\n"
             + "from (\n"
@@ -8341,7 +8342,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   /**
    * As {@link #testParenthesizedUnionAndJoinInFrom()} but the UNION is the first input to the JOIN.
    */
-  @Test void testParenthesizedUnionAndJoinInFrom2() {
+  @Test void parenthesizedUnionAndJoinInFrom2() {
     final String sql =
         "select *\n"
             + "from (\n"
@@ -8363,7 +8364,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** As {@link #testParenthesizedUnionAndJoinInFrom2()} but INNER JOIN rather than CROSS JOIN. */
-  @Test void testParenthesizedUnionAndJoinInFrom3() {
+  @Test void parenthesizedUnionAndJoinInFrom3() {
     final String sql =
         "select *\n"
             + "from (\n"
@@ -8384,7 +8385,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testParenthesizedUnion() {
+  @Test void parenthesizedUnion() {
     final String sql =
         "(select x from a\n"
             + "  union\n"
@@ -8403,7 +8404,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testFromExpr() {
+  @Test void fromExpr() {
     String sql0 = "select * from a cross join b";
     String sql1 = "select * from (a cross join b)";
     String expected = "SELECT *\n"
@@ -8414,7 +8415,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** Tests parsing parenthesized queries. */
-  @Test void testParenthesizedQueries() {
+  @Test void parenthesizedQueries() {
     final String expected = "SELECT *\n"
   + "FROM (SELECT *\n"
   + "FROM `TAB`) AS `X`";
@@ -8456,30 +8457,30 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql6).fails(message);
   }
 
-  @Test void testProcedureCall() {
+  @Test void procedureCall() {
     sql("call blubber(5)").ok("CALL `BLUBBER`(5)");
     sql("call \"blubber\"(5)").ok("CALL `blubber`(5)");
     sql("call whale.blubber(5)").ok("CALL `WHALE`.`BLUBBER`(5)");
   }
 
-  @Test void testNewSpecification() {
+  @Test void newSpecification() {
     expr("new udt()").ok("(NEW `UDT`())");
     expr("new my.udt(1, 'hey')").ok("(NEW `MY`.`UDT`(1, 'hey'))");
     expr("new udt() is not null").ok("((NEW `UDT`()) IS NOT NULL)");
     expr("1 + new udt()").ok("(1 + (NEW `UDT`()))");
   }
 
-  @Test void testMultisetCast() {
+  @Test void multisetCast() {
     expr("cast(multiset[1] as double multiset)").ok("CAST((MULTISET[1]) AS DOUBLE MULTISET)");
   }
 
-  @Test void testAddCarets() {
+  @Test void addCarets() {
     assertEquals("values (^foo^)", SqlParserUtil.addCarets("values (foo)", 1, 9, 1, 12));
     assertEquals("abc^def", SqlParserUtil.addCarets("abcdef", 1, 4, 1, 4));
     assertEquals("abcdef^", SqlParserUtil.addCarets("abcdef", 1, 7, 1, 7));
   }
 
-  @Test void testSnapshotForSystemTimeWithAlias() {
+  @Test void snapshotForSystemTimeWithAlias() {
     sql("SELECT * FROM orders LEFT JOIN products FOR SYSTEM_TIME AS OF "
             + "orders.proctime as products ON orders.product_id = products.pro_id")
         .ok(
@@ -8489,7 +8490,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + ".`PRODUCT_ID` = `PRODUCTS`.`PRO_ID`)");
   }
 
-  @Test protected void testMetadata() {
+  @Test void metadata() {
     SqlAbstractParserImpl.Metadata metadata = sql("").parser().getMetadata();
     assertThat(metadata.isReservedFunctionName("ABS"), is(true));
     assertThat(metadata.isReservedFunctionName("FOO"), is(false));
@@ -8535,7 +8536,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * #RESERVED_KEYWORDS} list. If not, add the keyword to the non-reserved keyword list in the
    * parser.
    */
-  @Test void testNoUnintendedNewReservedKeywords() {
+  @Test void noUnintendedNewReservedKeywords() {
     assumeTrue(isNotSubclass(), "don't run this test for sub-classes");
     final SqlAbstractParserImpl.Metadata metadata = fixture().parser().getMetadata();
 
@@ -8559,7 +8560,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     assertThat(reason, reservedKeywords, is(getReservedKeywords()));
   }
 
-  @Test void testTabStop() {
+  @Test void tabStop() {
     sql("SELECT *\n\tFROM mytable").ok("SELECT *\n"
   + "FROM `MYTABLE`");
 
@@ -8569,7 +8570,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .fails("(?s).*Encountered \"= =\" at line 1, column 32\\..*");
   }
 
-  @Test void testLongIdentifiers() {
+  @Test void longIdentifiers() {
     StringBuilder ident128Builder = new StringBuilder();
     for (int i = 0; i < 128; i++) {
       ident128Builder.append((char) ('a' + (i % 26)));
@@ -8602,7 +8603,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    *
    * <p>See {@code org.apache.calcite.test.SqlValidatorTest#testQuotedFunction()}.
    */
-  @Test void testQuotedFunction() {
+  @Test void quotedFunction() {
     expr("\"CAST\"(1 ^as^ double)").fails("(?s).*Encountered \"as\" at .*");
     expr("\"POSITION\"('b' ^in^ 'alphabet')")
         .fails("(?s).*Encountered \"in \\\\'alphabet\\\\'\" at .*");
@@ -8611,7 +8612,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** Tests applying a member function of a specific type as a suffix function. */
-  @Test void testMemberFunction() {
+  @Test void memberFunction() {
     sql("SELECT myColumn.func(a, b) FROM tbl")
         .ok("SELECT `MYCOLUMN`.`FUNC`(`A`, `B`)\n"
   + "FROM `TBL`");
@@ -8626,7 +8627,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   + "FROM `TBL`");
   }
 
-  @Test void testUnicodeLiteral() {
+  @Test void unicodeLiteral() {
     // Note that here we are constructing a SQL statement which directly
     // contains Unicode characters (not SQL Unicode escape sequences).  The
     // escaping here is Java-only, so by the time it gets to the SQL
@@ -8648,7 +8649,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(in3).ok(out3);
   }
 
-  @Test void testUnicodeEscapedLiteral() {
+  @Test void unicodeEscapedLiteral() {
     // Note that here we are constructing a SQL statement which
     // contains SQL-escaped Unicode characters to be handled
     // by the SQL parser.
@@ -8660,7 +8661,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(in.replace("\\", "!") + "UESCAPE '!'").ok(out);
   }
 
-  @Test void testIllegalUnicodeEscape() {
+  @Test void illegalUnicodeEscape() {
     expr("U&'abc' UESCAPE '!!'").fails(".*must be exactly one character.*");
     expr("U&'abc' UESCAPE ''").fails(".*must be exactly one character.*");
     expr("U&'abc' UESCAPE '0'").fails(".*hex digit.*");
@@ -8674,7 +8675,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("^U&'\\wxyz'^").fails(".*is not exactly four hex digits.*");
   }
 
-  @Test void testSqlOptions() {
+  @Test void sqlOptions() {
     SqlNode node = sql("alter system set schema = true").node();
     SqlSetOption opt = (SqlSetOption) node;
     assertThat(opt.getScope(), equalTo("SYSTEM"));
@@ -8718,7 +8719,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql("alter system set x = 1^,^ y = 2").fails("(?s)Encountered \",\" at line 1, column 23\\..*");
   }
 
-  @Test void testSequence() {
+  @Test void sequence() {
     sql("select next value for my_schema.my_seq from t")
         .ok("SELECT (NEXT VALUE FOR `MY_SCHEMA`.`MY_SEQ`)\n"
   + "FROM `T`");
@@ -8752,7 +8753,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   + "VALUES (ROW(1, (CURRENT VALUE FOR `MY_SEQ`)))");
   }
 
-  @Test void testPivot() {
+  @Test void pivot() {
     final String sql = "SELECT * FROM emp\n"
   + "PIVOT (sum(sal) AS sal FOR job in ('CLERK' AS c))";
     final String expected =
@@ -8768,7 +8769,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** As {@link #testPivot()} but composite FOR and two composite values. */
-  @Test void testPivotComposite() {
+  @Test void pivotComposite() {
     final String sql =
         "SELECT * FROM emp\n"
             + "PIVOT (sum(sal) AS sal FOR (job, deptno) IN\n"
@@ -8781,7 +8782,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** Pivot with no values. */
-  @Test void testPivotWithoutValues() {
+  @Test void pivotWithoutValues() {
     final String sql = "SELECT * FROM emp\n"
   + "PIVOT (sum(sal) AS sal FOR job IN ())";
     final String expected = "SELECT *\n"
@@ -8793,7 +8794,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-4746">[CALCITE-4746]
    * Pivots with pivotAgg without alias fail with Babel Parser Implementation</a>.
    */
-  @Test void testPivotWithoutAlias() {
+  @Test void pivotWithoutAlias() {
     final String sql = "SELECT * FROM emp\n"
   + "PIVOT (sum(sal) FOR job in ('CLERK'))";
     final String expected =
@@ -8803,7 +8804,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** In PIVOT, FOR clause must contain only simple identifiers. */
-  @Test void testPivotErrorExpressionInFor() {
+  @Test void pivotErrorExpressionInFor() {
     final String sql =
         "SELECT * FROM emp\n"
   + "PIVOT (sum(sal) AS sal FOR deptno ^-^10 IN (10, 20)";
@@ -8811,7 +8812,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** As {@link #testPivotErrorExpressionInFor()} but more than one column. */
-  @Test void testPivotErrorExpressionInCompositeFor() {
+  @Test void pivotErrorExpressionInCompositeFor() {
     final String sql =
         "SELECT * FROM emp\n"
             + "PIVOT (sum(sal) AS sal FOR (job, deptno ^-^10)\n"
@@ -8823,7 +8824,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * More complex PIVOT case (multiple aggregates, composite FOR, multiple values with and without
    * aliases).
    */
-  @Test void testPivot2() {
+  @Test void pivot2() {
     final String sql =
         "SELECT *\n"
             + "FROM (SELECT deptno, job, sal\n"
@@ -8846,7 +8847,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testUnpivot() {
+  @Test void unpivot() {
     final String sql =
         "SELECT *\n"
             + "FROM emp_pivoted\n"
@@ -8867,7 +8868,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testPivotThroughShuttle() {
+  @Test void pivotThroughShuttle() {
     final String sql =
         ""
             + "SELECT *\n"
@@ -8893,7 +8894,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     assertThat(toLinux(shuttled.toString()), is(expected));
   }
 
-  @Test void testMatchRecognize1() {
+  @Test void matchRecognize1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -8918,7 +8919,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize2() {
+  @Test void matchRecognize2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -8939,7 +8940,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize3() {
+  @Test void matchRecognize3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -8960,7 +8961,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize4() {
+  @Test void matchRecognize4() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -8981,7 +8982,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize5() {
+  @Test void matchRecognize5() {
     final String sql =
         "select *\n"
             + "  from (select * from t) match_recognize\n"
@@ -9003,7 +9004,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize6() {
+  @Test void matchRecognize6() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9024,7 +9025,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize7() {
+  @Test void matchRecognize7() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9045,7 +9046,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize8() {
+  @Test void matchRecognize8() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9066,7 +9067,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize9() {
+  @Test void matchRecognize9() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9087,7 +9088,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize10() {
+  @Test void matchRecognize10() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9111,7 +9112,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize11() {
+  @Test void matchRecognize11() {
     final String sql =
         "select *\n"
             + "  from t match_recognize (\n"
@@ -9130,7 +9131,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeDefineClause() {
+  @Test void matchRecognizeDefineClause() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9151,7 +9152,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeDefineClause2() {
+  @Test void matchRecognizeDefineClause2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9171,7 +9172,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeDefineClause3() {
+  @Test void matchRecognizeDefineClause3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9192,7 +9193,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeDefineClause4() {
+  @Test void matchRecognizeDefineClause4() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9212,7 +9213,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures1() {
+  @Test void matchRecognizeMeasures1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9243,7 +9244,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures2() {
+  @Test void matchRecognizeMeasures2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9269,7 +9270,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures3() {
+  @Test void matchRecognizeMeasures3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9295,7 +9296,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures4() {
+  @Test void matchRecognizeMeasures4() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9323,7 +9324,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures5() {
+  @Test void matchRecognizeMeasures5() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9350,7 +9351,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures6() {
+  @Test void matchRecognizeMeasures6() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9377,7 +9378,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip1() {
+  @Test void matchRecognizePatternSkip1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9400,7 +9401,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip2() {
+  @Test void matchRecognizePatternSkip2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9423,7 +9424,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip3() {
+  @Test void matchRecognizePatternSkip3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9446,7 +9447,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip4() {
+  @Test void matchRecognizePatternSkip4() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9469,7 +9470,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip5() {
+  @Test void matchRecognizePatternSkip5() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9496,7 +9497,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-2993">[CALCITE-2993]
    * ParseException may be thrown for legal SQL queries due to incorrect "LOOKAHEAD(1)" hints</a>.
    */
-  @Test void testMatchRecognizePatternSkip6() {
+  @Test void matchRecognizePatternSkip6() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9519,7 +9520,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeSubset1() {
+  @Test void matchRecognizeSubset1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9542,7 +9543,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeSubset2() {
+  @Test void matchRecognizeSubset2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9570,7 +9571,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeSubset3() {
+  @Test void matchRecognizeSubset3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9598,7 +9599,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeRowsPerMatch1() {
+  @Test void matchRecognizeRowsPerMatch1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9628,7 +9629,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeRowsPerMatch2() {
+  @Test void matchRecognizeRowsPerMatch2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9658,7 +9659,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeWithin() {
+  @Test void matchRecognizeWithin() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9688,7 +9689,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinGroupClause1() {
+  @Test void withinGroupClause1() {
     final String sql =
         "select col1,\n"
             + " collect(col2) within group (order by col3)\n"
@@ -9703,7 +9704,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinGroupClause2() {
+  @Test void withinGroupClause2() {
     final String sql =
         "select collect(col2) within group (order by col3)\n"
             + "from t\n"
@@ -9717,12 +9718,12 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinGroupClause3() {
+  @Test void withinGroupClause3() {
     final String sql = "select collect(col2) within group (^)^ " + "from t order by col1 limit 10";
     sql(sql).fails("(?s).*Encountered \"\\)\" at line 1, column 36\\..*");
   }
 
-  @Test void testWithinGroupClause4() {
+  @Test void withinGroupClause4() {
     final String sql =
         "select col1,\n"
             + " collect(col2) within group (order by col3, col4)\n"
@@ -9737,7 +9738,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinGroupClause5() {
+  @Test void withinGroupClause5() {
     final String sql =
         "select col1,\n"
             + " collect(col2) within group (\n"
@@ -9753,7 +9754,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testStringAgg() {
+  @Test void stringAgg() {
     final String sql =
         "select\n"
             + "  string_agg(ename order by deptno, ename) as c1,\n"
@@ -9774,7 +9775,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testArrayAgg() {
+  @Test void arrayAgg() {
     final String sql =
         "select\n"
             + "  array_agg(ename respect nulls order by deptno, ename) as c1,\n"
@@ -9793,7 +9794,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testGroupConcat() {
+  @Test void groupConcat() {
     final String sql =
         "select\n"
             + "  group_concat(ename order by deptno, ename desc) as c2,\n"
@@ -9810,7 +9811,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinDistinct() {
+  @Test void withinDistinct() {
     final String sql =
         "select col1,\n"
             + " sum(col2) within distinct (col3 + col4, col5)\n"
@@ -9825,7 +9826,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinDistinct2() {
+  @Test void withinDistinct2() {
     final String sql =
         "select col1,\n"
             + " sum(col2) within distinct (col3 + col4, col5)\n"
@@ -9843,7 +9844,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testJsonValueExpressionOperator() {
+  @Test void jsonValueExpressionOperator() {
     expr("foo format json").ok("`FOO` FORMAT JSON");
     // Currently, encoding js not valid
     expr("foo format json encoding utf8").ok("`FOO` FORMAT JSON");
@@ -9859,14 +9860,14 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   + "FROM `TAB`");
   }
 
-  @Test void testJsonExists() {
+  @Test void jsonExists() {
     expr("json_exists('{\"foo\": \"bar\"}', 'lax $.foo')")
         .ok("JSON_EXISTS('{\"foo\": \"bar\"}', 'lax $.foo')");
     expr("json_exists('{\"foo\": \"bar\"}', 'lax $.foo' error on error)")
         .ok("JSON_EXISTS('{\"foo\": \"bar\"}', 'lax $.foo' ERROR ON ERROR)");
   }
 
-  @Test void testJsonValue() {
+  @Test void jsonValue() {
     expr("json_value('{\"foo\": \"100\"}', 'lax $.foo' " + "returning integer)")
         .ok("JSON_VALUE('{\"foo\": \"100\"}', 'lax $.foo' " + "RETURNING INTEGER)");
     expr("json_value('{\"foo\": \"100\"}', 'lax $.foo' "
@@ -9876,7 +9877,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "RETURNING INTEGER DEFAULT 10 ON EMPTY ERROR ON ERROR)");
   }
 
-  @Test void testJsonQuery() {
+  @Test void jsonQuery() {
     expr("json_query('{\"foo\": \"bar\"}', 'lax $' WITHOUT ARRAY WRAPPER)")
         .ok(
             "JSON_QUERY('{\"foo\": \"bar\"}', "
@@ -9932,7 +9933,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "'lax $' WITHOUT ARRAY WRAPPER EMPTY ARRAY ON EMPTY EMPTY OBJECT ON ERROR)");
   }
 
-  @Test void testJsonObject() {
+  @Test void jsonObject() {
     expr("json_object('foo': 'bar')").ok("JSON_OBJECT(KEY 'foo' VALUE 'bar' NULL ON NULL)");
     expr("json_object('foo': 'bar', 'foo2': 'bar2')")
         .ok("JSON_OBJECT(KEY 'foo' VALUE 'bar', KEY 'foo2' VALUE 'bar2' NULL ON NULL)");
@@ -9960,7 +9961,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("json_object(key: value)").ok("JSON_OBJECT(KEY `KEY` VALUE `VALUE` NULL ON NULL)");
   }
 
-  @Test void testJsonType() {
+  @Test void jsonType() {
     expr("json_type('11.56')").ok("JSON_TYPE('11.56')");
     expr("json_type('{}')").ok("JSON_TYPE('{}')");
     expr("json_type(null)").ok("JSON_TYPE(NULL)");
@@ -9968,7 +9969,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("json_type('{\"foo\": \"100\"}')").ok("JSON_TYPE('{\"foo\": \"100\"}')");
   }
 
-  @Test void testJsonDepth() {
+  @Test void jsonDepth() {
     expr("json_depth('11.56')").ok("JSON_DEPTH('11.56')");
     expr("json_depth('{}')").ok("JSON_DEPTH('{}')");
     expr("json_depth(null)").ok("JSON_DEPTH(NULL)");
@@ -9976,7 +9977,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("json_depth('{\"foo\": \"100\"}')").ok("JSON_DEPTH('{\"foo\": \"100\"}')");
   }
 
-  @Test void testJsonLength() {
+  @Test void jsonLength() {
     expr("json_length('{\"foo\": \"bar\"}')").ok("JSON_LENGTH('{\"foo\": \"bar\"}')");
     expr("json_length('{\"foo\": \"bar\"}', 'lax $')")
         .ok("JSON_LENGTH('{\"foo\": \"bar\"}', 'lax $')");
@@ -9986,7 +9987,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("JSON_LENGTH('{\"foo\": \"bar\"}', 'invalid $')");
   }
 
-  @Test void testJsonKeys() {
+  @Test void jsonKeys() {
     expr("json_keys('{\"foo\": \"bar\"}', 'lax $')").ok("JSON_KEYS('{\"foo\": \"bar\"}', 'lax $')");
     expr("json_keys('{\"foo\": \"bar\"}', 'strict $')")
         .ok("JSON_KEYS('{\"foo\": \"bar\"}', 'strict $')");
@@ -9994,14 +9995,14 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("JSON_KEYS('{\"foo\": \"bar\"}', 'invalid $')");
   }
 
-  @Test void testJsonRemove() {
+  @Test void jsonRemove() {
     expr("json_remove('[\"a\", [\"b\", \"c\"], \"d\"]', '$')")
         .ok("JSON_REMOVE('[\"a\", [\"b\", \"c\"], \"d\"]', '$')");
     expr("json_remove('[\"a\", [\"b\", \"c\"], \"d\"]', '$[1]', '$[0]')")
         .ok("JSON_REMOVE('[\"a\", [\"b\", \"c\"], \"d\"]', '$[1]', '$[0]')");
   }
 
-  @Test void testJsonObjectAgg() {
+  @Test void jsonObjectAgg() {
     expr("json_objectagg(k_column: v_column)")
         .ok("JSON_OBJECTAGG(KEY `K_COLUMN` VALUE `V_COLUMN` NULL ON NULL)");
     expr("json_objectagg(k_column value v_column)")
@@ -10019,7 +10020,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "FORMAT JSON NULL ON NULL)");
   }
 
-  @Test void testJsonArray() {
+  @Test void jsonArray() {
     expr("json_array('foo')").ok("JSON_ARRAY('foo' ABSENT ON NULL)");
     expr("json_array(null)").ok("JSON_ARRAY(NULL ABSENT ON NULL)");
     expr("json_array(null null on null)").ok("JSON_ARRAY(NULL NULL ON NULL)");
@@ -10027,24 +10028,24 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("JSON_ARRAY(JSON_ARRAY('foo', 'bar' ABSENT ON NULL) FORMAT JSON ABSENT ON NULL)");
   }
 
-  @Test void testJsonPretty() {
+  @Test void jsonPretty() {
     expr("json_pretty('foo')").ok("JSON_PRETTY('foo')");
     expr("json_pretty(null)").ok("JSON_PRETTY(NULL)");
   }
 
-  @Test void testJsonStorageSize() {
+  @Test void jsonStorageSize() {
     expr("json_storage_size('foo')").ok("JSON_STORAGE_SIZE('foo')");
     expr("json_storage_size(null)").ok("JSON_STORAGE_SIZE(NULL)");
   }
 
-  @Test void testJsonArrayAgg1() {
+  @Test void jsonArrayAgg1() {
     expr("json_arrayagg(\"column\")").ok("JSON_ARRAYAGG(`column` ABSENT ON NULL)");
     expr("json_arrayagg(\"column\" null on null)").ok("JSON_ARRAYAGG(`column` NULL ON NULL)");
     expr("json_arrayagg(json_array(\"column\") format json)")
         .ok("JSON_ARRAYAGG(JSON_ARRAY(`column` ABSENT ON NULL) FORMAT JSON ABSENT ON NULL)");
   }
 
-  @Test void testJsonArrayAgg2() {
+  @Test void jsonArrayAgg2() {
     expr("json_arrayagg(\"column\" order by \"column\")")
         .ok("JSON_ARRAYAGG(`column` ABSENT ON NULL) WITHIN GROUP (ORDER BY `column`)");
     expr("json_arrayagg(\"column\") within group (order by \"column\")")
@@ -10055,7 +10056,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "in a single JSON_ARRAYAGG call is not allowed.*");
   }
 
-  @Test void testJsonPredicate() {
+  @Test void jsonPredicate() {
     expr("'{}' is json").ok("('{}' IS JSON VALUE)");
     expr("'{}' is json value").ok("('{}' IS JSON VALUE)");
     expr("'{}' is json object").ok("('{}' IS JSON OBJECT)");
@@ -10068,7 +10069,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("'100' is not json scalar").ok("('100' IS NOT JSON SCALAR)");
   }
 
-  @Test void testParseWithReader() throws Exception {
+  @Test void parseWithReader() throws Exception {
     String query = "select * from dual";
     SqlParser sqlParserReader = sqlParser(new StringReader(query), b -> b);
     SqlNode node1 = sqlParserReader.parseQuery();
@@ -10076,7 +10077,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     assertEquals(node2.toString(), node1.toString());
   }
 
-  @Test void testConfigureFromDialect() {
+  @Test void configureFromDialect() {
     // Calcite's default converts unquoted identifiers to upper case
     sql("select unquotedColumn from \"double\"\"QuotedTable\"")
         .withDialect(CALCITE)
@@ -10113,7 +10114,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-4230">[CALCITE-4230] In
    * Babel for BigQuery, split quoted table names that contain dots</a>.
    */
-  @Test void testSplitIdentifier() {
+  @Test void splitIdentifier() {
     final String sql = "select *\n"
   + "from `bigquery-public-data.samples.natality`";
     final String sql2 = "select *\n"
@@ -10135,7 +10136,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql2).withDialect(MYSQL).ok(expectedSplitMysql);
   }
 
-  @Test void testParenthesizedSubQueries() {
+  @Test void parenthesizedSubQueries() {
     final String expected = "SELECT *\n"
   + "FROM (SELECT *\n"
   + "FROM `TAB`) AS `X`";
@@ -10147,7 +10148,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql2).ok(expected);
   }
 
-  @Test void testQueryHint() {
+  @Test void queryHint() {
     final String sql1 =
         "select "
             + "/*+ properties(k1='v1', k2='v2', 'a.b.c'='v3'), "
@@ -10182,7 +10183,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql3).ok(expected3);
   }
 
-  @Test void testTableHintsInQuery() {
+  @Test void tableHintsInQuery() {
     final String hint = "/*+ PROPERTIES(K1 ='v1', K2 ='v2'), INDEX(IDX0, IDX1) */";
     final String sql1 = String.format(Locale.ROOT, "select * from t %s", hint);
     final String expected1 =
@@ -10217,7 +10218,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql3).ok(expected3);
   }
 
-  @Test void testTableHintsInInsert() {
+  @Test void tableHintsInInsert() {
     final String sql =
         "insert into emps\n"
             + "/*+ PROPERTIES(k1='v1', k2='v2'), INDEX(idx0, idx1) */\n"
@@ -10230,7 +10231,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testTableHintsInDelete() {
+  @Test void tableHintsInDelete() {
     final String sql =
         "delete from emps\n"
             + "/*+ properties(k1='v1', k2='v2'), index(idx1, idx2), no_hash_join */\n"
@@ -10242,7 +10243,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testTableHintsInUpdate() {
+  @Test void tableHintsInUpdate() {
     final String sql =
         "update emps\n"
             + "/*+ properties(k1='v1', k2='v2'), index(idx1, idx2), no_hash_join */\n"
@@ -10258,7 +10259,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testTableHintsInMerge() {
+  @Test void tableHintsInMerge() {
     final String sql =
         "merge into emps\n"
             + "/*+ properties(k1='v1', k2='v2'), index(idx1, idx2), no_hash_join */ e\n"
@@ -10283,7 +10284,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testHintThroughShuttle() {
+  @Test void hintThroughShuttle() {
     final String sql = "select * from emp /*+ options('key1' = 'val1') */";
     final SqlNode sqlNode = sql(sql).node();
     final SqlNode shuttled =
@@ -10300,7 +10301,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     assertThat(toLinux(shuttled.toString()), is(expected));
   }
 
-  @Test void testInvalidHintFormat() {
+  @Test void invalidHintFormat() {
     final String sql1 =
         "select "
             + "/*+ properties(^k1^=123, k2='v2'), no_hash_join() */ "
@@ -10325,7 +10326,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** Tests {@link Hoist}. */
-  @Test protected void testHoist() {
+  @Test void hoist() {
     final String sql =
         "select 1 as x,\n"
             + "  'ab' || 'c' as y\n"
@@ -10617,7 +10618,7 @@ static UnaryOperator<SqlWriterConfig> randomize(Random random) {
     static String toSqlString(SqlNodeList sqlNodeList, UnaryOperator<SqlWriterConfig> transform) {
       return sqlNodeList.stream()
           .map(node -> node.toSqlString(transform).getSql())
-          .collect(Collectors.joining(";"));
+          .collect(joining(";"));
     }
 
     static SqlWriterConfig.LineFolding nextLineFolding(Random random) {
diff --git a/testkit/src/main/java/org/apache/calcite/sql/test/ResultCheckers.java b/testkit/src/main/java/org/apache/calcite/sql/test/ResultCheckers.java
index f859b6ac0..6c6a6c444 100644
--- a/testkit/src/main/java/org/apache/calcite/sql/test/ResultCheckers.java
+++ b/testkit/src/main/java/org/apache/calcite/sql/test/ResultCheckers.java
@@ -30,9 +30,7 @@
 import java.sql.Types;
 import java.time.LocalDateTime;
 import java.time.LocalTime;
-import java.time.ZoneOffset;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.regex.Pattern;
@@ -43,6 +41,7 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.fail;
 
+import static java.time.ZoneOffset.UTC;
 import static java.util.Objects.requireNonNull;
 
 /** Utilities for {@link SqlTester.ResultChecker}. */
@@ -59,8 +58,7 @@ public static SqlTester.ResultChecker isExactly(String value) {
 
   public static SqlTester.ResultChecker isExactDateTime(LocalDateTime dateTime) {
     return new MatcherResultChecker<>(
-        is(BigDecimal.valueOf(dateTime.toInstant(ZoneOffset.UTC).toEpochMilli())),
-        JdbcType.BIG_DECIMAL);
+        is(BigDecimal.valueOf(dateTime.toInstant(UTC).toEpochMilli())), JdbcType.BIG_DECIMAL);
   }
 
   public static SqlTester.ResultChecker isExactTime(LocalTime time) {
@@ -97,7 +95,7 @@ public static SqlTester.ResultChecker isSet(String... values) {
   }
 
   public static SqlTester.ResultChecker isNullValue() {
-    return new RefSetResultChecker(Collections.singleton(null));
+    return new RefSetResultChecker(ImmutableSet.of(null));
   }
 
   /**
diff --git a/testkit/src/main/java/org/apache/calcite/sql/test/SqlTests.java b/testkit/src/main/java/org/apache/calcite/sql/test/SqlTests.java
index 4f1d0ba37..24108efed 100644
--- a/testkit/src/main/java/org/apache/calcite/sql/test/SqlTests.java
+++ b/testkit/src/main/java/org/apache/calcite/sql/test/SqlTests.java
@@ -212,7 +212,7 @@ public static String generateWinAggQuery(String expr, String windowSpec, String[
    */
   public static void checkEx(
       @Nullable Throwable ex, @Nullable String expectedMsgPattern, StringAndPos sap, Stage stage) {
-    if (null == ex) {
+    if (ex == null) {
       if (expectedMsgPattern == null) {
         // No error expected, and no error happened.
         return;
@@ -300,7 +300,7 @@ public static void checkEx(
       }
     }
 
-    if (null == expectedMsgPattern) {
+    if (expectedMsgPattern == null) {
       actualException.printStackTrace();
       fail(
           stage.componentName
diff --git a/testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java b/testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java
index 146edd264..9dd9f4b6f 100644
--- a/testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java
+++ b/testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java
@@ -125,9 +125,10 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 import java.util.function.Function;
-import java.util.stream.Collectors;
 import javax.sql.DataSource;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.test.Matchers.compose;
 import static org.apache.calcite.test.Matchers.containsStringLinux;
 import static org.apache.calcite.test.Matchers.isLinux;
@@ -145,6 +146,7 @@
 import static org.junit.jupiter.api.Assertions.fail;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.joining;
 
 /** Fluid DSL for testing Calcite connections and queries. */
 @SuppressWarnings("rawtypes")
@@ -1056,7 +1058,7 @@ public static void assertArrayEqual(String message, Object[] expected, Object[]
   private static String str(Object[] objects) {
     return objects == null
         ? null
-        : Arrays.stream(objects).map(Object::toString).collect(Collectors.joining("\n"));
+        : Arrays.stream(objects).map(Object::toString).collect(joining("\n"));
   }
 
   /** Returns a {@link PropBuilder}. */
@@ -1145,9 +1147,7 @@ public AssertThat with(String property, Object value) {
     }
 
     public AssertThat with(ConnectionProperty property, Object value) {
-      if (!property.type().valid(value, property.valueClass())) {
-        throw new IllegalArgumentException();
-      }
+      checkArgument(property.type().valid(value, property.valueClass()));
       return with(connectionFactory.with(property, value));
     }
 
@@ -1757,8 +1757,8 @@ public AssertQuery queryContains(Consumer<List> predicate1) {
 
     // CHECKSTYLE: IGNORE 1
     /** @deprecated Use {@link #queryContains(Consumer)}. */
-    @SuppressWarnings("Guava")
-    @Deprecated // to be removed before 2.0
+    @Deprecated
+    @SuppressWarnings("Guava") // to be removed before 2.0
     public final AssertQuery queryContains(com.google.common.base.Function<List, Void> predicate1) {
       return queryContains((Consumer<List>) predicate1::apply);
     }
diff --git a/testkit/src/main/java/org/apache/calcite/test/ConnectionFactories.java b/testkit/src/main/java/org/apache/calcite/test/ConnectionFactories.java
index 81ab196b1..7ede96bd2 100644
--- a/testkit/src/main/java/org/apache/calcite/test/ConnectionFactories.java
+++ b/testkit/src/main/java/org/apache/calcite/test/ConnectionFactories.java
@@ -38,6 +38,8 @@
 import java.util.Objects;
 import java.util.Properties;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -135,9 +137,7 @@ private static class MapConnectionFactory implements ConnectionFactory {
     }
 
     @Override public ConnectionFactory with(ConnectionProperty property, Object value) {
-      if (!property.type().valid(value, property.valueClass())) {
-        throw new IllegalArgumentException();
-      }
+      checkArgument(property.type().valid(value, property.valueClass()));
       return with(property.camelName(), value.toString());
     }
 
diff --git a/testkit/src/main/java/org/apache/calcite/test/DiffRepository.java b/testkit/src/main/java/org/apache/calcite/test/DiffRepository.java
index 744304d90..e1279be2d 100644
--- a/testkit/src/main/java/org/apache/calcite/test/DiffRepository.java
+++ b/testkit/src/main/java/org/apache/calcite/test/DiffRepository.java
@@ -58,6 +58,8 @@
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -270,18 +272,12 @@ public void checkActualAndReferenceFiles() {
 
     final String diff = DiffTestCase.diff(new File(resourceFile), logFile);
 
-    if (!diff.isEmpty()) {
-      throw new IllegalArgumentException(
-          "Actual and reference files differ. "
-              + "If you are adding new tests, replace the reference file with the "
-              + "current actual file, after checking its content."
-              + "\ndiff "
-              + logFile.getAbsolutePath()
-              + " "
-              + resourceFile
-              + "\n"
-              + diff);
-    }
+    checkArgument(
+        diff.isEmpty(),
+        "Actual and reference files differ. If you are adding new tests, replace the reference file with the current actual file, after checking its content.\ndiff %s %s\n%s",
+        logFile.getAbsolutePath(),
+        resourceFile,
+        diff);
   }
 
   private static URL findFile(Class<?> clazz, final String suffix) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java b/testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java
index 1e41d6ddb..b2dac776d 100644
--- a/testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java
+++ b/testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java
@@ -45,6 +45,8 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.fail;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /**
  * DiffTestCase is an abstract base for JUnit tests which produce multi-line output to be verified
  * by diffing against a pre-existing reference file.
@@ -126,7 +128,7 @@ protected Writer openTestLog() throws Exception {
     File testClassDir = new File(getTestlogRoot(), ReflectUtil.getUnqualifiedClassName(getClass()));
     testClassDir.mkdirs();
     File testLogFile = new File(testClassDir, testCaseName);
-    return new OutputStreamWriter(openTestLogOutputStream(testLogFile), StandardCharsets.UTF_8);
+    return new OutputStreamWriter(openTestLogOutputStream(testLogFile), UTF_8);
   }
 
   /** Returns the root directory under which testlogs should be written. */
@@ -140,10 +142,10 @@ protected Writer openTestLog() throws Exception {
   protected OutputStream openTestLogOutputStream(File testFileSansExt) throws IOException {
     assert logOutputStream == null;
 
-    logFile = new File(testFileSansExt.toString() + ".log");
+    logFile = new File(testFileSansExt + ".log");
     logFile.delete();
 
-    refFile = new File(testFileSansExt.toString() + ".ref");
+    refFile = new File(testFileSansExt + ".ref");
 
     logOutputStream = new FileOutputStream(logFile);
     return logOutputStream;
@@ -247,7 +249,7 @@ protected void diffFile(File logFile, File refFile) throws IOException {
    */
   protected void addDiffMask(String mask) {
     // diffMasks.add(mask);
-    if (diffMasks.length() == 0) {
+    if (diffMasks.isEmpty()) {
       diffMasks = mask;
     } else {
       diffMasks = diffMasks + "|" + mask;
@@ -257,7 +259,7 @@ protected void addDiffMask(String mask) {
   }
 
   protected void addIgnorePattern(String javaPattern) {
-    if (ignorePatterns.length() == 0) {
+    if (ignorePatterns.isEmpty()) {
       ignorePatterns = javaPattern;
     } else {
       ignorePatterns = ignorePatterns + "|" + javaPattern;
diff --git a/testkit/src/main/java/org/apache/calcite/test/Matchers.java b/testkit/src/main/java/org/apache/calcite/test/Matchers.java
index 4f0a7098b..87338fccb 100644
--- a/testkit/src/main/java/org/apache/calcite/test/Matchers.java
+++ b/testkit/src/main/java/org/apache/calcite/test/Matchers.java
@@ -24,7 +24,6 @@
 import org.apache.calcite.util.TestUtil;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 import com.google.common.collect.RangeSet;
 
@@ -49,6 +48,8 @@
 import java.util.regex.Pattern;
 import java.util.stream.StreamSupport;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.hamcrest.CoreMatchers.equalTo;
 
 /** Matchers for testing SQL queries. */
@@ -412,7 +413,7 @@ public static class IsWithin<T extends Number> extends BaseMatcher<T> {
     private final double epsilon;
 
     public IsWithin(T expectedValue, double epsilon) {
-      Preconditions.checkArgument(epsilon >= 0D);
+      checkArgument(epsilon >= 0D);
       this.expectedValue = expectedValue;
       this.epsilon = epsilon;
     }
diff --git a/testkit/src/main/java/org/apache/calcite/test/MockDdlExecutor.java b/testkit/src/main/java/org/apache/calcite/test/MockDdlExecutor.java
index d005d0688..ffd83a444 100644
--- a/testkit/src/main/java/org/apache/calcite/test/MockDdlExecutor.java
+++ b/testkit/src/main/java/org/apache/calcite/test/MockDdlExecutor.java
@@ -230,7 +230,7 @@ protected static void populate(
    * Calls an action for each (name, type) pair from {@code SqlCreateTable::columnList}, in which
    * they alternate.
    */
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   protected void forEachNameType(
       SqlCreateTable createTable, BiConsumer<SqlIdentifier, SqlDataTypeSpec> consumer) {
     createTable.columnList.forEach(
diff --git a/testkit/src/main/java/org/apache/calcite/test/MockRelOptPlanner.java b/testkit/src/main/java/org/apache/calcite/test/MockRelOptPlanner.java
index 9e727c614..ca01133b8 100644
--- a/testkit/src/main/java/org/apache/calcite/test/MockRelOptPlanner.java
+++ b/testkit/src/main/java/org/apache/calcite/test/MockRelOptPlanner.java
@@ -31,11 +31,11 @@
 import org.apache.calcite.util.Pair;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -201,7 +201,7 @@ private class MockRuleCall extends RelOptRuleCall {
      * @param rels List of matched relational expressions
      */
     MockRuleCall(RelOptPlanner planner, RelOptRuleOperand operand, RelNode[] rels) {
-      super(planner, operand, rels, Collections.emptyMap());
+      super(planner, operand, rels, ImmutableMap.of());
     }
 
     @Override public void transformTo(RelNode rel, Map<RelNode, RelNode> equiv, RelHintsPropagator handler) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/QuidemTest.java b/testkit/src/main/java/org/apache/calcite/test/QuidemTest.java
index 1ec5052eb..c8bde83df 100644
--- a/testkit/src/main/java/org/apache/calcite/test/QuidemTest.java
+++ b/testkit/src/main/java/org/apache/calcite/test/QuidemTest.java
@@ -214,8 +214,8 @@ private static String n2u(String s) {
     return File.separatorChar == '\\' ? s.replace('\\', '/') : s;
   }
 
-  @ParameterizedTest
   @MethodSource("getPath")
+  @ParameterizedTest
   public void test(String path) throws Exception {
     final Method method = findMethod(path);
     if (method != null) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/RelMetadataFixture.java b/testkit/src/main/java/org/apache/calcite/test/RelMetadataFixture.java
index 34290f907..721de12e4 100644
--- a/testkit/src/main/java/org/apache/calcite/test/RelMetadataFixture.java
+++ b/testkit/src/main/java/org/apache/calcite/test/RelMetadataFixture.java
@@ -41,7 +41,6 @@
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.util.ImmutableBitSet;
 
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
@@ -59,6 +58,8 @@
 import java.util.function.Supplier;
 import java.util.function.UnaryOperator;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.not;
@@ -205,8 +206,7 @@ public RelNode toRel() {
     metadataConfig.applyMetadata(rel.getCluster());
     if (convertAsCalc) {
       Project project = (Project) rel;
-      Preconditions.checkArgument(
-          project.getVariablesSet().isEmpty(), "Calc does not allow variables");
+      checkArgument(project.getVariablesSet().isEmpty(), "Calc does not allow variables");
       RexProgram program =
           RexProgram.create(
               project.getInput().getRowType(),
@@ -224,7 +224,7 @@ public RelNode toRel() {
   /**
    * Checks the CPU component of {@link RelNode#computeSelfCost(RelOptPlanner, RelMetadataQuery)}.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertCpuCost(Matcher<Double> matcher, String reason) {
     RelNode rel = toRel();
     RelOptCost cost = computeRelSelfCost(rel);
@@ -250,7 +250,7 @@ private static RelOptCost computeRelSelfCost(RelNode rel) {
   /**
    * Checks {@link RelMetadataQuery#areRowsUnique(RelNode)} for all values of {@code ignoreNulls}.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertRowsUnique(Matcher<Boolean> matcher, String reason) {
     return assertRowsUnique(false, matcher, reason).assertRowsUnique(true, matcher, reason);
   }
@@ -275,7 +275,7 @@ public RelMetadataFixture assertRowsUnique(
   }
 
   /** Checks {@link RelMetadataQuery#getPercentageOriginalRows(RelNode)}. */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertPercentageOriginalRows(Matcher<Double> matcher) {
     RelNode rel = toRel();
     final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();
@@ -297,7 +297,7 @@ private RelMetadataFixture checkColumnOrigin(Consumer<Set<RelColumnOrigin>> acti
    * Checks that {@link RelMetadataQuery#getColumnOrigins(RelNode, int)} for column 0 returns no
    * origins.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertColumnOriginIsEmpty() {
     return checkColumnOrigin(
         result -> {
@@ -324,7 +324,7 @@ private static void checkColumnOrigin(
    * Checks that {@link RelMetadataQuery#getColumnOrigins(RelNode, int)} for column 0 returns one
    * origin.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertColumnOriginSingle(
       String expectedTableName, String expectedColumnName, boolean expectedDerived) {
     return checkColumnOrigin(
@@ -340,7 +340,7 @@ public RelMetadataFixture assertColumnOriginSingle(
    * Checks that {@link RelMetadataQuery#getColumnOrigins(RelNode, int)} for column 0 returns two
    * origins.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertColumnOriginDouble(
       String expectedTableName1,
       String expectedColumnName1,
@@ -369,7 +369,7 @@ public RelMetadataFixture assertColumnOriginDouble(
   }
 
   /** Checks result of getting unique keys for SQL. */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertThatUniqueKeysAre(ImmutableBitSet... expectedUniqueKeys) {
     RelNode rel = toRel();
     final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();
@@ -425,7 +425,7 @@ private static boolean isUnique(Set<ImmutableBitSet> uniqueKeys, ImmutableBitSet
    * RelMetadataQuery#getMaxRowCount(RelNode)}, and {@link
    * RelMetadataQuery#getMinRowCount(RelNode)}.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertThatRowCount(
       Matcher<Number> rowCountMatcher,
       Matcher<Number> minRowCountMatcher,
@@ -550,7 +550,7 @@ public RelMetadataFixture assertThatAreColumnsUnique(
   }
 
   /** Checks {@link RelMetadataQuery#areRowsUnique(RelNode)}. */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertThatAreRowsUnique(Matcher<Boolean> matcher) {
     RelNode rel = toRel();
     final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();
diff --git a/testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java b/testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java
index d32481aa0..b8b74c5f1 100644
--- a/testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java
+++ b/testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java
@@ -148,7 +148,7 @@ public RexInputRef ref(int i, RelDataType type) {
     }
 
     public RexLiteral literal(int i) {
-      return rexBuilder.makeExactLiteral(new BigDecimal(i));
+      return rexBuilder.makeExactLiteral(BigDecimal.valueOf(i));
     }
 
     public RexNode gt(RexNode node1, RexNode node2) {
@@ -200,7 +200,7 @@ public RexNode shortLiteral(short value) {
     }
 
     public RexLiteral floatLiteral(double value) {
-      return rexBuilder.makeApproxLiteral(new BigDecimal(value));
+      return rexBuilder.makeApproxLiteral(BigDecimal.valueOf(value));
     }
 
     public RexLiteral charLiteral(String z) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java b/testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java
index d9231dee0..aadbec670 100644
--- a/testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java
+++ b/testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java
@@ -214,7 +214,7 @@ void forEachQueryValidateAndThen(
   }
 
   @Override public void checkBoolean(String expression, @Nullable Boolean result) {
-    if (null == result) {
+    if (result == null) {
       checkNull(expression);
     } else {
       SqlTester.ResultChecker resultChecker =
diff --git a/testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java b/testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
index 25bb61ee2..2fba4ee0d 100644
--- a/testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
+++ b/testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
@@ -192,7 +192,7 @@
  * </ul>
  */
 @SuppressWarnings("MethodCanBeStatic")
-public class SqlOperatorTest {
+final class SqlOperatorTest {
   // ~ Static fields/initializers ---------------------------------------------
 
   public static final TesterImpl TESTER = new TesterImpl();
@@ -249,9 +249,9 @@ enum Numeric {
     BIGINT(
         "BIGINT",
         Long.toString(Long.MIN_VALUE),
-        new BigDecimal(Long.MIN_VALUE).subtract(BigDecimal.ONE).toString(),
+        BigDecimal.valueOf(Long.MIN_VALUE).subtract(BigDecimal.ONE).toString(),
         Long.toString(Long.MAX_VALUE),
-        new BigDecimal(Long.MAX_VALUE).add(BigDecimal.ONE).toString()),
+        BigDecimal.valueOf(Long.MAX_VALUE).add(BigDecimal.ONE).toString()),
     DECIMAL5_2("DECIMAL(5, 2)", "-999.99", "-1000.00", "999.99", "1000.00"),
     REAL(
         "REAL",
@@ -369,9 +369,9 @@ protected SqlOperatorFixture fixture() {
   // --- Tests -----------------------------------------------------------
 
   /** For development. Put any old code in here. */
-  @Test void testDummy() {}
+  @Test void dummy() {}
 
-  @Test void testSqlOperatorOverloading() {
+  @Test void sqlOperatorOverloading() {
     final SqlStdOperatorTable operatorTable = SqlStdOperatorTable.instance();
     for (SqlOperator sqlOperator : operatorTable.getOperatorList()) {
       String operatorName = sqlOperator.getName();
@@ -386,7 +386,7 @@ protected SqlOperatorFixture fixture() {
     }
   }
 
-  @Test void testBetween() {
+  @Test void between() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.BETWEEN, VmName.EXPAND);
     f.checkBoolean("2 between 1 and 3", true);
@@ -416,7 +416,7 @@ protected SqlOperatorFixture fixture() {
     f.checkBoolean("x'0A00015A' between x'0A0001A0' and x'0A0001B0'", false);
   }
 
-  @Test void testNotBetween() {
+  @Test void notBetween() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_BETWEEN, VM_EXPAND);
     f.checkBoolean("2 not between 1 and 3", false);
@@ -447,9 +447,9 @@ static Stream<Arguments> safeParameters() {
    * Tests that CAST, SAFE_CAST and TRY_CAST are basically equivalent but SAFE_CAST is only
    * available in BigQuery library and TRY_CAST is only available in MSSQL library.
    */
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCast(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void cast(CastType castType, SqlOperatorFixture f) {
     // SAFE_CAST is available in BigQuery library but not by default.
     // TRY_CAST is available in MSSQL library but not by default.
     final SqlOperatorFixture f0 = fixture();
@@ -465,9 +465,9 @@ void testCast(CastType castType, SqlOperatorFixture f) {
     f.checkScalar(castType.name() + "(12 + 3 as varchar(10))", "15", "VARCHAR(10) NOT NULL");
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToString(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castToString(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     f.checkCastToString("cast(cast('abc' as char(4)) as varchar(6))", null, "abc ", castType);
 
@@ -549,9 +549,9 @@ void testCastToString(CastType castType, SqlOperatorFixture f) {
     f.checkString("cast(false as varchar(4))", "FALS", "VARCHAR(4) NOT NULL");
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastBooleanToNumeric(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castBooleanToNumeric(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     SqlOperatorFixture f0 = f.withConformance(SqlConformanceEnum.DEFAULT);
     f0.checkFails(
@@ -577,9 +577,9 @@ void testCastBooleanToNumeric(CastType castType, SqlOperatorFixture f) {
         false);
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastExactNumericLimits(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castExactNumericLimits(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // Test casting for min,max, out of range for exact numeric types
@@ -658,9 +658,9 @@ void testCastExactNumericLimits(CastType castType, SqlOperatorFixture f) {
         });
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToExactNumeric(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castToExactNumeric(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkCastToScalarOkay("1", "BIGINT", castType);
@@ -687,9 +687,9 @@ void testCastToExactNumeric(CastType castType, SqlOperatorFixture f) {
     f.checkScalarExact("cast('654342432412312' as bigint)", "BIGINT NOT NULL", "654342432412312");
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastStringToDecimal(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castStringToDecimal(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     if (!DECIMAL) {
       return;
@@ -704,9 +704,9 @@ void testCastStringToDecimal(CastType castType, SqlOperatorFixture f) {
     f.checkFails("cast(' -1.21e' as decimal(2,1))", INVALID_CHAR_MESSAGE, true);
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastIntervalToNumeric(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castIntervalToNumeric(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // interval to decimal
@@ -764,9 +764,9 @@ void testCastIntervalToNumeric(CastType castType, SqlOperatorFixture f) {
         "cast((INTERVAL '1' second - INTERVAL '2' second) as integer)", "INTEGER NOT NULL", "-1");
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToInterval(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castToInterval(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     f.checkScalar("cast(5 as interval second)", "+5.000000", "INTERVAL SECOND NOT NULL");
     f.checkScalar("cast(5 as interval minute)", "+5", "INTERVAL MINUTE NOT NULL");
@@ -786,9 +786,9 @@ void testCastToInterval(CastType castType, SqlOperatorFixture f) {
     f.checkScalar("cast(-5723 as interval minute(4))", "-5723", "INTERVAL MINUTE(4) NOT NULL");
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastIntervalToInterval(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castIntervalToInterval(CastType castType, SqlOperatorFixture f) {
     f.checkScalar(
         "cast(interval '2 5' day to hour as interval hour to minute)",
         "+53:00",
@@ -809,9 +809,9 @@ void testCastIntervalToInterval(CastType castType, SqlOperatorFixture f) {
         "INTERVAL DAY TO HOUR NOT NULL");
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastWithRoundingToScalar(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castWithRoundingToScalar(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkFails("cast(1.25 as int)", "INTEGER", true);
@@ -849,9 +849,9 @@ void testCastWithRoundingToScalar(CastType castType, SqlOperatorFixture f) {
     f.checkFails("cast(9.99 as decimal(2,1))", OUT_OF_RANGE_MESSAGE, true);
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastDecimalToDoubleToInteger(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castDecimalToDoubleToInteger(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkFails("cast( cast(1.25 as double) as integer)", OUT_OF_RANGE_MESSAGE, true);
@@ -865,9 +865,9 @@ void testCastDecimalToDoubleToInteger(CastType castType, SqlOperatorFixture f) {
     f.checkFails("cast( cast(-1.5 as double) as integer)", OUT_OF_RANGE_MESSAGE, true);
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastApproxNumericLimits(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castApproxNumericLimits(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // Test casting for min, max, out of range for approx numeric types
@@ -993,9 +993,9 @@ void testCastApproxNumericLimits(CastType castType, SqlOperatorFixture f) {
         });
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToApproxNumeric(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castToApproxNumeric(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkCastToApproxOkay("1", "DOUBLE", isExactly(1), castType);
@@ -1007,9 +1007,9 @@ void testCastToApproxNumeric(CastType castType, SqlOperatorFixture f) {
     f.checkCastToApproxOkay("0e0", "REAL", isExactly(0), castType);
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastNull(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castNull(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // null
@@ -1043,9 +1043,9 @@ void testCastNull(CastType castType, SqlOperatorFixture f) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-1439">[CALCITE-1439]
    * Handling errors during constant reduction</a>.
    */
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastInvalid(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castInvalid(CastType castType, SqlOperatorFixture f) {
     // Before CALCITE-1439 was fixed, constant reduction would kick in and
     // generate Java constants that throw when the class is loaded, thus
     // ExceptionInInitializerError.
@@ -1063,9 +1063,9 @@ void testCastInvalid(CastType castType, SqlOperatorFixture f) {
   }
 
   /** Test cast for DATE, TIME, TIMESTAMP types. */
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastDateTime(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castDateTime(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkScalar(
@@ -1129,9 +1129,9 @@ void testCastDateTime(CastType castType, SqlOperatorFixture f) {
         "TIMESTAMP(0) NOT NULL");
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastStringToDateTime(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castStringToDateTime(CastType castType, SqlOperatorFixture f) {
     f.checkScalar("cast('12:42:25' as TIME)", "12:42:25", "TIME(0) NOT NULL");
     f.checkScalar("cast('1:42:25' as TIME)", "01:42:25", "TIME(0) NOT NULL");
     f.checkScalar("cast('1:2:25' as TIME)", "01:02:25", "TIME(0) NOT NULL");
@@ -1221,7 +1221,7 @@ void testCastStringToDateTime(CastType castType, SqlOperatorFixture f) {
     f.checkNull("cast(cast(null as timestamp) as time)");
   }
 
-  @Test void testMssqlConvert() {
+  @Test void mssqlConvert() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.MSSQL_CONVERT, VmName.EXPAND);
     // happy-paths (no need to test all, proper functionality is tested by CAST already
@@ -1233,7 +1233,7 @@ void testCastStringToDateTime(CastType castType, SqlOperatorFixture f) {
     f.checkNull("convert(DATE, NULL)");
   }
 
-  @Test void testMssqlConvertWithStyle() {
+  @Test void mssqlConvertWithStyle() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.MSSQL_CONVERT, VmName.EXPAND);
     // ensure 'style' argument is ignored
@@ -1300,9 +1300,9 @@ protected static Calendar getCalendarNotTooNear(int timeUnit) {
     }
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castToBoolean(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // string to boolean
@@ -1322,7 +1322,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-4861">[CALCITE-4861]
    * Optimisation of chained cast calls can lead to unexpected behaviour.</a>.
    */
-  @Test void testChainedCast() {
+  @Test void chainedCast() {
     final SqlOperatorFixture f = fixture();
     f.checkFails(
         "CAST(CAST(CAST(123456 AS TINYINT) AS INT) AS BIGINT)",
@@ -1496,14 +1496,14 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
     // TODO: Check case with multisets
   }
 
-  @Test void testCaseNull() {
+  @Test void caseNull() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CASE, VmName.EXPAND);
     f.checkScalarExact("case when 1 = 1 then 10 else null end", 10);
     f.checkNull("case when 1 = 2 then 10 else null end");
   }
 
-  @Test void testCaseType() {
+  @Test void caseType() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CASE, VmName.EXPAND);
     f.checkType("case 1 when 1 then current_timestamp else null end", "TIMESTAMP(0)");
@@ -1520,7 +1520,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
    *
    * <p>See FRG-97 "Support for JDBC escape syntax is incomplete".
    */
-  @Test void testJdbcFn() {
+  @Test void jdbcFn() {
     final SqlOperatorFixture f = fixture();
     f.setFor(new SqlJdbcFunctionCall("dummy"), VmName.EXPAND);
 
@@ -1700,7 +1700,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
         false);
   }
 
-  @Test void testChr() {
+  @Test void chr() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.CHR, VM_FENNEL, VM_JAVA);
     f0.checkFails("^chr(97.1)^", "No match found for function signature CHR\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -1714,7 +1714,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
         list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE, SqlLibrary.POSTGRESQL), consumer);
   }
 
-  @Test void testSelect() {
+  @Test void select() {
     final SqlOperatorFixture f = fixture();
     f.check("select * from (values(1))", SqlTests.INTEGER_TYPE_CHECKER, 1);
 
@@ -1761,7 +1761,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
     }
   }
 
-  @Test void testLiteralChain() {
+  @Test void literalChain() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LITERAL_CHAIN, VM_EXPAND);
     f.checkString("'buttered'\n"
@@ -1786,19 +1786,19 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
   + "'ab' = x'ab'", true);
   }
 
-  @Test void testComplexLiteral() {
+  @Test void complexLiteral() {
     final SqlOperatorFixture f = fixture();
     f.check("select 2 * 2 * x from (select 2 as x)", SqlTests.INTEGER_TYPE_CHECKER, 8);
     f.check("select 1 * 2 * 3 * x from (select 2 as x)", SqlTests.INTEGER_TYPE_CHECKER, 12);
     f.check("select 1 + 2 + 3 + 4 + x from (select 2 as x)", SqlTests.INTEGER_TYPE_CHECKER, 12);
   }
 
-  @Test void testRow() {
+  @Test void row() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ROW, VM_FENNEL);
   }
 
-  @Test void testAndOperator() {
+  @Test void andOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.AND, VmName.EXPAND);
     f.checkBoolean("true and false", false);
@@ -1809,14 +1809,14 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
     f.checkBoolean("true and (not false)", true);
   }
 
-  @Test void testAndOperator2() {
+  @Test void andOperator2() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("case when false then unknown else true end and true", true);
     f.checkBoolean("case when false then cast(null as boolean) " + "else true end and true", true);
     f.checkBoolean("case when false then null else true end and true", true);
   }
 
-  @Test void testAndOperatorLazy() {
+  @Test void andOperatorLazy() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.AND, VmName.EXPAND);
 
@@ -1830,7 +1830,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
         new ValueOrExceptionResultChecker(false, INVALID_ARG_FOR_POWER, CODE_2201F));
   }
 
-  @Test void testConcatOperator() {
+  @Test void concatOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CONCAT, VmName.EXPAND);
     f.checkString(" 'a'||'b' ", "ab", "CHAR(2) NOT NULL");
@@ -1863,7 +1863,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
     f.checkNull("cast(null as integer array) || array[1]");
   }
 
-  @Test void testConcatFunc() {
+  @Test void concatFunc() {
     final SqlOperatorFixture f = fixture();
     checkConcatFunc(f.withLibrary(SqlLibrary.MYSQL));
     checkConcatFunc(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -1934,7 +1934,7 @@ private static void checkConcat2Func(SqlOperatorFixture f) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5741">[CALCITE-5741] Add
    * CONCAT_WS function (enabled in MSSQL, MySQL, Postgres libraries)</a>.
    */
-  @Test void testConcatWSFunc() {
+  @Test void concatWSFunc() {
     final SqlOperatorFixture f = fixture();
     checkConcatWithSeparator(f.withLibrary(SqlLibrary.MYSQL));
     checkConcatWithSeparator(f.withLibrary(SqlLibrary.POSTGRESQL));
@@ -1988,7 +1988,7 @@ private static void checkConcatWithSeparatorInMSSQL(SqlOperatorFixture f) {
     f.checkString("concat_ws('', '', '', '')", "", "VARCHAR(0) NOT NULL");
   }
 
-  @Test void testModOperator() {
+  @Test void modOperator() {
     // "%" is allowed under BIG_QUERY, MYSQL_5 SQL conformance levels
     final SqlOperatorFixture f0 = fixture().setFor(SqlStdOperatorTable.PERCENT_REMAINDER);
     final List<SqlConformanceEnum> conformances =
@@ -2039,7 +2039,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkFails("3 % case 'a' when 'a' then 0 end", DIVISION_BY_ZERO_MESSAGE, true);
   }
 
-  @Test void testDivideOperator() {
+  @Test void divideOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DIVIDE, VmName.EXPAND);
     f.checkScalarExact("10 / 5", "INTEGER NOT NULL", "2");
@@ -2059,7 +2059,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkScalarExact("100.1 / 0.00000000000000001", "DECIMAL(19, 0) NOT NULL", "1.001E+19");
   }
 
-  @Test void testDivideOperatorIntervals() {
+  @Test void divideOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar(
         "interval '-2:2' hour to minute / 3", "-0:41", "INTERVAL HOUR TO MINUTE NOT NULL");
@@ -2074,7 +2074,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkScalar("interval '3-4' year to month / 4.5", "+0-09", "INTERVAL YEAR TO MONTH NOT NULL");
   }
 
-  @Test void testEqualsOperator() {
+  @Test void equalsOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EQUALS, VmName.EXPAND);
     f.checkBoolean("1=1", true);
@@ -2102,7 +2102,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkNull("cast(null as varchar(10))='a'");
   }
 
-  @Test void testEqualsOperatorInterval() {
+  @Test void equalsOperatorInterval() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day = interval '1' day", false);
     f.checkBoolean("interval '2' day = interval '2' day", true);
@@ -2110,7 +2110,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkNull("cast(null as interval hour) = interval '2' minute");
   }
 
-  @Test void testGreaterThanOperator() {
+  @Test void greaterThanOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.GREATER_THAN, VmName.EXPAND);
     f.checkBoolean("1>2", false);
@@ -2138,7 +2138,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkBoolean("x'0A000130'>x'0A0001B0'", false);
   }
 
-  @Test void testGreaterThanOperatorIntervals() {
+  @Test void greaterThanOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day > interval '1' day", true);
     f.checkBoolean("interval '2' day > interval '5' day", false);
@@ -2152,7 +2152,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkNull("interval '2:2' hour to minute > cast(null as interval second)");
   }
 
-  @Test void testIsDistinctFromOperator() {
+  @Test void isDistinctFromOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_DISTINCT_FROM, VM_EXPAND);
     f.checkBoolean("1 is distinct from 1", false);
@@ -2175,7 +2175,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkBoolean("interval '10' hour is distinct from interval '10' hour", false);
   }
 
-  @Test void testIsNotDistinctFromOperator() {
+  @Test void isNotDistinctFromOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_DISTINCT_FROM, VM_EXPAND);
     f.checkBoolean("1 is not distinct from 1", true);
@@ -2198,7 +2198,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkBoolean("interval '10' hour is not distinct from interval '10' hour", true);
   }
 
-  @Test void testGreaterThanOrEqualOperator() {
+  @Test void greaterThanOrEqualOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.GREATER_THAN_OR_EQUAL, VmName.EXPAND);
     f.checkBoolean("1>=2", false);
@@ -2222,7 +2222,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkBoolean("x'0A0001B0'>=x'0A0001B0'", true);
   }
 
-  @Test void testGreaterThanOrEqualOperatorIntervals() {
+  @Test void greaterThanOrEqualOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day >= interval '1' day", true);
     f.checkBoolean("interval '2' day >= interval '5' day", false);
@@ -2236,7 +2236,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkNull("interval '2:2' hour to minute >= cast(null as interval second)");
   }
 
-  @Test void testInOperator() {
+  @Test void inOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IN, VM_EXPAND);
     f.checkBoolean("1 in (0, 1, 2)", true);
@@ -2260,7 +2260,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkFails("'foo' in (^)^", "(?s).*Encountered \"\\)\" at .*", false);
   }
 
-  @Test void testNotInOperator() {
+  @Test void notInOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_IN, VM_EXPAND);
     f.checkBoolean("1 not in (0, 1, 2)", false);
@@ -2284,7 +2284,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkFails("'foo' not in (^)^", "(?s).*Encountered \"\\)\" at .*", false);
   }
 
-  @Test void testOverlapsOperator() {
+  @Test void overlapsOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OVERLAPS, VM_EXPAND);
     f.checkBoolean(
@@ -2335,7 +2335,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
    * <p>Tests OVERLAP and similar period operators CONTAINS, EQUALS, PRECEDES, SUCCEEDS, IMMEDIATELY
    * PRECEDES, IMMEDIATELY SUCCEEDS for DATE, TIME and TIMESTAMP values.
    */
-  @Test void testPeriodOperators() {
+  @Test void periodOperators() {
     String[] times = {
       "TIME '01:00:00'", "TIME '02:00:00'", "TIME '03:00:00'", "TIME '04:00:00'",
     };
@@ -2478,7 +2478,7 @@ static void checkOverlaps(OverlapChecker c) {
     c.isTrue("($3,$0) IMMEDIATELY SUCCEEDS ($0,$0)");
   }
 
-  @Test void testLessThanOperator() {
+  @Test void lessThanOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LESS_THAN, VmName.EXPAND);
     f.checkBoolean("1<2", true);
@@ -2503,7 +2503,7 @@ static void checkOverlaps(OverlapChecker c) {
     f.checkBoolean("x'0A000130'<x'0A0001B0'", true);
   }
 
-  @Test void testLessThanOperatorInterval() {
+  @Test void lessThanOperatorInterval() {
     if (!DECIMAL) {
       return;
     }
@@ -2520,7 +2520,7 @@ static void checkOverlaps(OverlapChecker c) {
     f.checkNull("interval '2:2' hour to minute " + "< cast(null as interval second)");
   }
 
-  @Test void testLessThanOrEqualOperator() {
+  @Test void lessThanOrEqualOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LESS_THAN_OR_EQUAL, VmName.EXPAND);
     f.checkBoolean("1<=2", true);
@@ -2547,7 +2547,7 @@ static void checkOverlaps(OverlapChecker c) {
     f.checkBoolean("x'0A0001B0'<=x'0A0001B0'", true);
   }
 
-  @Test void testLessThanOrEqualOperatorInterval() {
+  @Test void lessThanOrEqualOperatorInterval() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day <= interval '1' day", false);
     f.checkBoolean("interval '2' day <= interval '5' day", true);
@@ -2561,7 +2561,7 @@ static void checkOverlaps(OverlapChecker c) {
     f.checkNull("interval '2:2' hour to minute " + "<= cast(null as interval second)");
   }
 
-  @Test void testMinusOperator() {
+  @Test void minusOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MINUS, VmName.EXPAND);
     f.checkScalarExact("-2-1", -3);
@@ -2591,7 +2591,7 @@ static void checkOverlaps(OverlapChecker c) {
     }
   }
 
-  @Test void testMinusIntervalOperator() {
+  @Test void minusIntervalOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MINUS, VmName.EXPAND);
     f.checkScalar("interval '2' day - interval '1' day", "+1", "INTERVAL DAY NOT NULL");
@@ -2663,7 +2663,7 @@ static void checkOverlaps(OverlapChecker c) {
         "date '2003-08-02' - interval '12-3' year to month", "1991-05-02", "DATE NOT NULL");
   }
 
-  @Test void testMinusDateOperator() {
+  @Test void minusDateOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MINUS_DATE, VmName.EXPAND);
     f.checkScalar(
@@ -2711,7 +2711,7 @@ static void checkOverlaps(OverlapChecker c) {
     // TODO: Add tests for year month intervals (currently not supported)
   }
 
-  @Test void testMultiplyOperator() {
+  @Test void multiplyOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTIPLY, VmName.EXPAND);
     f.checkScalarExact("2*3", 6);
@@ -2740,7 +2740,7 @@ static void checkOverlaps(OverlapChecker c) {
     }
   }
 
-  @Test void testMultiplyIntervals() {
+  @Test void multiplyIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("interval '2:2' hour to minute * 3", "+6:06", "INTERVAL HOUR TO MINUTE NOT NULL");
     f.checkScalar(
@@ -2757,7 +2757,7 @@ static void checkOverlaps(OverlapChecker c) {
     }
   }
 
-  @Test void testDatePlusInterval() {
+  @Test void datePlusInterval() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("date '2014-02-11' + interval '2' day", "2014-02-13", "DATE NOT NULL");
     // 60 days is more than 2^32 milliseconds
@@ -2768,7 +2768,7 @@ static void checkOverlaps(OverlapChecker c) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-1864">[CALCITE-1864] Allow
    * NULL literal as argument</a>.
    */
-  @Test void testNullOperand() {
+  @Test void nullOperand() {
     final SqlOperatorFixture f = fixture();
     checkNullOperand(f, "=");
     checkNullOperand(f, ">");
@@ -2788,7 +2788,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("null " + op + " null", null);
   }
 
-  @Test void testNotEqualsOperator() {
+  @Test void notEqualsOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_EQUALS, VmName.EXPAND);
     f.checkBoolean("1<>1", false);
@@ -2817,7 +2817,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.forEachConformance(conformances, consumer);
   }
 
-  @Test void testNotEqualsOperatorIntervals() {
+  @Test void notEqualsOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day <> interval '1' day", true);
     f.checkBoolean("interval '2' day <> interval '2' day", false);
@@ -2825,7 +2825,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("cast(null as interval hour) <> interval '2' minute");
   }
 
-  @Test void testOrOperator() {
+  @Test void orOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OR, VmName.EXPAND);
     f.checkBoolean("true or false", true);
@@ -2834,7 +2834,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("false or cast(null as boolean)");
   }
 
-  @Test void testOrOperatorLazy() {
+  @Test void orOperatorLazy() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OR, VmName.EXPAND);
 
@@ -2870,7 +2870,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("1 < cast(null as integer) or sqrt(4) = 2", true);
   }
 
-  @Test void testPlusOperator() {
+  @Test void plusOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PLUS, VmName.EXPAND);
     f.checkScalarExact("1+2", 3);
@@ -2902,13 +2902,13 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     }
   }
 
-  @Test void testPlusOperatorAny() {
+  @Test void plusOperatorAny() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PLUS, VmName.EXPAND);
     f.checkScalar("1+CAST(2 AS ANY)", "3", "ANY NOT NULL");
   }
 
-  @Test void testPlusIntervalOperator() {
+  @Test void plusIntervalOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PLUS, VmName.EXPAND);
     f.checkScalar("interval '2' day + interval '1' day", "+3", "INTERVAL DAY NOT NULL");
@@ -2983,26 +2983,26 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
         "TIMESTAMP(0) NOT NULL");
   }
 
-  @Test void testDescendingOperator() {
+  @Test void descendingOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DESC, VM_EXPAND);
   }
 
-  @Test void testIsNotNullOperator() {
+  @Test void isNotNullOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_NULL, VmName.EXPAND);
     f.checkBoolean("true is not null", true);
     f.checkBoolean("cast(null as boolean) is not null", false);
   }
 
-  @Test void testIsNullOperator() {
+  @Test void isNullOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NULL, VmName.EXPAND);
     f.checkBoolean("true is null", false);
     f.checkBoolean("cast(null as boolean) is null", true);
   }
 
-  @Test void testIsNotTrueOperator() {
+  @Test void isNotTrueOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_TRUE, VmName.EXPAND);
     f.checkBoolean("true is not true", false);
@@ -3016,7 +3016,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
         false);
   }
 
-  @Test void testIsTrueOperator() {
+  @Test void isTrueOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_TRUE, VmName.EXPAND);
     f.checkBoolean("true is true", true);
@@ -3024,7 +3024,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("cast(null as boolean) is true", false);
   }
 
-  @Test void testIsNotFalseOperator() {
+  @Test void isNotFalseOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_FALSE, VmName.EXPAND);
     f.checkBoolean("false is not false", false);
@@ -3032,7 +3032,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("cast(null as boolean) is not false", true);
   }
 
-  @Test void testIsFalseOperator() {
+  @Test void isFalseOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_FALSE, VmName.EXPAND);
     f.checkBoolean("false is false", true);
@@ -3040,7 +3040,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("cast(null as boolean) is false", false);
   }
 
-  @Test void testIsNotUnknownOperator() {
+  @Test void isNotUnknownOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_UNKNOWN, VM_EXPAND);
     f.checkBoolean("false is not unknown", true);
@@ -3050,7 +3050,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkFails("^'abc' IS NOT UNKNOWN^", "(?s).*Cannot apply 'IS NOT UNKNOWN'.*", false);
   }
 
-  @Test void testIsUnknownOperator() {
+  @Test void isUnknownOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_UNKNOWN, VM_EXPAND);
     f.checkBoolean("false is unknown", false);
@@ -3060,7 +3060,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkFails("0 = 1 AND ^2 IS UNKNOWN^ AND 3 > 4", "(?s).*Cannot apply 'IS UNKNOWN'.*", false);
   }
 
-  @Test void testIsASetOperator() {
+  @Test void isASetOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_A_SET, VM_EXPAND);
     f.checkBoolean("multiset[1] is a set", true);
@@ -3072,7 +3072,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("multiset['a', 'b', 'a'] is a set", false);
   }
 
-  @Test void testIsNotASetOperator() {
+  @Test void isNotASetOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_A_SET, VM_EXPAND);
     f.checkBoolean("multiset[1] is not a set", false);
@@ -3085,7 +3085,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("multiset['a', 'b', 'a'] is not a set", true);
   }
 
-  @Test void testIntersectOperator() {
+  @Test void intersectOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_INTERSECT, VM_EXPAND);
     f.checkScalar(
@@ -3127,7 +3127,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
         "INTEGER MULTISET NOT NULL");
   }
 
-  @Test void testExceptOperator() {
+  @Test void exceptOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_EXCEPT, VM_EXPAND);
     f.checkScalar(
@@ -3165,24 +3165,24 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("(multiset[1] multiset except multiset[1]) is empty", true);
   }
 
-  @Test void testIsEmptyOperator() {
+  @Test void isEmptyOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_EMPTY, VM_EXPAND);
     f.checkBoolean("multiset[1] is empty", false);
   }
 
-  @Test void testIsNotEmptyOperator() {
+  @Test void isNotEmptyOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_EMPTY, VM_EXPAND);
     f.checkBoolean("multiset[1] is not empty", true);
   }
 
-  @Test void testExistsOperator() {
+  @Test void existsOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXISTS, VM_EXPAND);
   }
 
-  @Test void testNotOperator() {
+  @Test void notOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT, VmName.EXPAND);
     f.checkBoolean("not true", false);
@@ -3191,7 +3191,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("not cast(null as boolean)");
   }
 
-  @Test void testPrefixMinusOperator() {
+  @Test void prefixMinusOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.UNARY_MINUS, VmName.EXPAND);
     f.enableTypeCoercion(false)
@@ -3207,7 +3207,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("-cast(null as tinyint)");
   }
 
-  @Test void testPrefixMinusOperatorIntervals() {
+  @Test void prefixMinusOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar(
         "-interval '-6:2:8' hour to second", "+6:02:08.000000", "INTERVAL HOUR TO SECOND NOT NULL");
@@ -3219,7 +3219,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("-cast(null as interval day to minute)");
   }
 
-  @Test void testPrefixPlusOperator() {
+  @Test void prefixPlusOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.UNARY_PLUS, VM_EXPAND);
     f.checkScalarExact("+1", 1);
@@ -3229,7 +3229,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("+cast(null as tinyint)");
   }
 
-  @Test void testPrefixPlusOperatorIntervals() {
+  @Test void prefixPlusOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar(
         "+interval '-6:2:8' hour to second", "-6:02:08.000000", "INTERVAL HOUR TO SECOND NOT NULL");
@@ -3247,18 +3247,18 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("+cast(null as interval day to minute)");
   }
 
-  @Test void testExplicitTableOperator() {
+  @Test void explicitTableOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXPLICIT_TABLE, VM_EXPAND);
   }
 
-  @Test void testValuesOperator() {
+  @Test void valuesOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.VALUES, VM_EXPAND);
     f.check("select 'abc' from (values(true))", "CHAR(3) NOT NULL", "abc");
   }
 
-  @Test void testNotLikeOperator() {
+  @Test void notLikeOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_LIKE, VM_EXPAND);
     f.checkBoolean("'abc' not like '_b_'", false);
@@ -3268,7 +3268,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("'ab\ncd\nef' not like '%cde%'", true);
   }
 
-  @Test void testRlikeOperator() {
+  @Test void rlikeOperator() {
     SqlOperatorFixture f = fixture().setFor(SqlLibraryOperators.RLIKE, VM_EXPAND);
     checkRlike(f.withLibrary(SqlLibrary.SPARK));
     checkRlike(f.withLibrary(SqlLibrary.HIVE));
@@ -3302,7 +3302,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkFails("^'Merrisa@gmail.com' not rlike 'Merrisa_'^", noNotRlike, false);
   }
 
-  @Test void testLikeEscape() {
+  @Test void likeEscape() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LIKE, VmName.EXPAND);
     f.checkBoolean("'a_c' like 'a#_c' escape '#'", true);
@@ -3315,7 +3315,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkBoolean("'abbc' like 'a\\%c' escape '\\'", false);
   }
 
-  @Test void testIlikeEscape() {
+  @Test void ilikeEscape() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.ILIKE, VmName.EXPAND)
@@ -3331,13 +3331,13 @@ static void checkRlikeFails(SqlOperatorFixture f) {
   }
 
   @Disabled("[CALCITE-525] Exception-handling in built-in functions")
-  @Test void testLikeEscape2() {
+  @Test void likeEscape2() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("'x' not like 'x' escape 'x'", true);
     f.checkBoolean("'xyz' not like 'xyz' escape 'xyz'", true);
   }
 
-  @Test void testLikeOperator() {
+  @Test void likeOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LIKE, VmName.EXPAND);
     f.checkBoolean("''  like ''", true);
@@ -3362,7 +3362,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkBoolean("'ab\ncd\nef' like '%cde%'", false);
   }
 
-  @Test void testIlikeOperator() {
+  @Test void ilikeOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.ILIKE, VmName.EXPAND);
     final String noLike = "No match found for function signature ILIKE";
@@ -3409,14 +3409,14 @@ static void checkRlikeFails(SqlOperatorFixture f) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-1898">[CALCITE-1898] LIKE
    * must match '.' (period) literally</a>.
    */
-  @Test void testLikeDot() {
+  @Test void likeDot() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("'abc' like 'a.c'", false);
     f.checkBoolean("'abcde' like '%c.e'", false);
     f.checkBoolean("'abc.e' like '%c.e'", true);
   }
 
-  @Test void testIlikeDot() {
+  @Test void ilikeDot() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.ILIKE, VmName.EXPAND)
@@ -3427,7 +3427,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkBoolean("'abc.e' ilike '%c.E'", true);
   }
 
-  @Test void testNotSimilarToOperator() {
+  @Test void notSimilarToOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_SIMILAR_TO, VM_EXPAND);
     f.checkBoolean("'ab' not similar to 'a_'", false);
@@ -3438,7 +3438,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkBoolean("cast(null as varchar(3))" + " not similar to cast(null as char(2))", null);
   }
 
-  @Test void testSimilarToOperator() {
+  @Test void similarToOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SIMILAR_TO, VmName.EXPAND);
 
@@ -3628,12 +3628,12 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     }
   }
 
-  @Test void testEscapeOperator() {
+  @Test void escapeOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ESCAPE, VM_EXPAND);
   }
 
-  @Test void testConvertFunc() {
+  @Test void convertFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CONVERT, VM_FENNEL, VM_JAVA);
     f.checkFails("convert('a', utf8, utf10)", "UTF10", false);
@@ -3656,7 +3656,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkType("convert(cast(1 as varchar(2)), utf8, latin1)", "VARCHAR(2) NOT NULL");
   }
 
-  @Test void testTranslateFunc() {
+  @Test void translateFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TRANSLATE, VM_FENNEL, VM_JAVA);
     f.checkFails("translate('a' using utf10)", "UTF10", false);
@@ -3698,7 +3698,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkType("convert(cast(1 as varchar(2)) using latin1)", "VARCHAR(2) NOT NULL");
   }
 
-  @Test void testTranslate3Func() {
+  @Test void translate3Func() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TRANSLATE3);
     f0.checkFails(
         "^translate('aabbcc', 'ab', '+-')^",
@@ -3724,7 +3724,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testOverlayFunc() {
+  @Test void overlayFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OVERLAY, VmName.EXPAND);
     f.checkString("overlay('ABCdef' placing 'abc' from 1)", "abcdef", "VARCHAR(9) NOT NULL");
@@ -3768,7 +3768,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("overlay(x'abcd' placing x'abcd' from cast(null as integer))");
   }
 
-  @Test void testPositionFunc() {
+  @Test void positionFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.POSITION, VmName.EXPAND);
     f.checkScalarExact("position('b' in 'abc')", 2);
@@ -3799,7 +3799,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkScalar("position(cast('a' as char) in cast('bca' as varchar))", 3, "INTEGER NOT NULL");
   }
 
-  @Test void testReplaceFunc() {
+  @Test void replaceFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.REPLACE, VmName.EXPAND);
     f.checkString("REPLACE('ciao', 'ciao', '')", "", "VARCHAR(4) NOT NULL");
@@ -3809,21 +3809,21 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("REPLACE('ciao', 'bella', cast(null as varchar(3)))");
   }
 
-  @Test void testCharLengthFunc() {
+  @Test void charLengthFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CHAR_LENGTH, VmName.EXPAND);
     f.checkScalarExact("char_length('abc')", 3);
     f.checkNull("char_length(cast(null as varchar(1)))");
   }
 
-  @Test void testCharacterLengthFunc() {
+  @Test void characterLengthFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CHARACTER_LENGTH, VmName.EXPAND);
     f.checkScalarExact("CHARACTER_LENGTH('abc')", 3);
     f.checkNull("CHARACTER_LENGTH(cast(null as varchar(1)))");
   }
 
-  @Test void testLengthFunc() {
+  @Test void lengthFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.LENGTH);
     f0.checkFails(
         "^length('hello')^",
@@ -3842,14 +3842,14 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY), consumer);
   }
 
-  @Test void testOctetLengthFunc() {
+  @Test void octetLengthFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OCTET_LENGTH, VmName.EXPAND);
     f.checkScalarExact("OCTET_LENGTH(x'aabbcc')", 3);
     f.checkNull("OCTET_LENGTH(cast(null as varbinary(1)))");
   }
 
-  @Test void testBitLengthFunc() {
+  @Test void bitLengthFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.BIT_LENGTH, VmName.EXPAND);
     f0.checkFails(
@@ -3866,7 +3866,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f1.checkNull("BIT_LENGTH(cast(null as binary))");
   }
 
-  @Test void testAsciiFunc() {
+  @Test void asciiFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ASCII, VmName.EXPAND);
     f.checkScalarExact("ASCII('')", 0);
@@ -3880,7 +3880,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("ASCII(cast(null as varchar(1)))");
   }
 
-  @Test void testToBase64() {
+  @Test void toBase64() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.setFor(SqlLibraryOperators.TO_BASE64);
     f.checkString(
@@ -3938,7 +3938,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkString("to_base64(x'61')", "YQ==", "VARCHAR NOT NULL");
   }
 
-  @Test void testToChar() {
+  @Test void toChar() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.POSTGRESQL);
     f.setFor(SqlLibraryOperators.TO_CHAR);
     f.checkString(
@@ -3947,7 +3947,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
         "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testFromBase64() {
+  @Test void fromBase64() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.FROM_BASE64);
     f0.checkFails(
         "^from_base64('2fjoeiwjfoj==')^",
@@ -3977,7 +3977,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.MYSQL), consumer);
   }
 
-  @Test void testToBase32() {
+  @Test void toBase32() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TO_BASE32);
     f0.checkFails(
         "^to_base32('')^",
@@ -4000,7 +4000,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkString("to_base32('')", "", "VARCHAR NOT NULL");
   }
 
-  @Test void testFromBase32() {
+  @Test void fromBase32() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.FROM_BASE32);
     f0.checkFails(
         "^from_base32('')^",
@@ -4018,7 +4018,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("from_base32(cast (null as varchar))");
   }
 
-  @Test void testMd5() {
+  @Test void md5() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.MD5);
     f0.checkFails("^md5(x'')^", "No match found for function signature MD5\\(<BINARY>\\)", false);
     final List<SqlLibrary> libraries =
@@ -4033,7 +4033,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testSha1() {
+  @Test void sha1() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SHA1);
     f0.checkFails("^sha1(x'')^", "No match found for function signature SHA1\\(<BINARY>\\)", false);
     final List<SqlLibrary> libraries =
@@ -4051,7 +4051,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testSha256() {
+  @Test void sha256() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SHA1);
     f0.checkFails(
         "^sha256(x'')^", "No match found for function signature SHA256\\(<BINARY>\\)", false);
@@ -4080,7 +4080,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testSha512() {
+  @Test void sha512() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SHA1);
     f0.checkFails(
         "^sha512(x'')^", "No match found for function signature SHA512\\(<BINARY>\\)", false);
@@ -4114,7 +4114,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testToHex() {
+  @Test void toHex() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TO_HEX);
     f0.checkFails(
         "^to_hex(x'')^", "No match found for function signature TO_HEX\\(<BINARY>\\)", false);
@@ -4124,7 +4124,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("to_hex(cast(null as varbinary))");
   }
 
-  @Test void testFromHex() {
+  @Test void fromHex() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.FROM_HEX);
     f0.checkFails(
         "^from_hex('')^", "No match found for function signature FROM_HEX\\(<CHARACTER>\\)", false);
@@ -4137,7 +4137,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("from_hex(cast(null as varchar))");
   }
 
-  @Test void testRepeatFunc() {
+  @Test void repeatFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.REPEAT);
     f0.checkFails(
         "^repeat('a', -100)^",
@@ -4158,7 +4158,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.MYSQL), consumer);
   }
 
-  @Test void testSpaceFunc() {
+  @Test void spaceFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.SPACE).withLibrary(SqlLibrary.MYSQL);
     f.checkString("SPACE(-100)", "", "VARCHAR(2000) NOT NULL");
@@ -4169,7 +4169,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("SPACE(cast(null as integer))");
   }
 
-  @Test void testStrcmpFunc() {
+  @Test void strcmpFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.STRCMP).withLibrary(SqlLibrary.MYSQL);
     f.checkString("STRCMP('mytesttext', 'mytesttext')", "0", "INTEGER NOT NULL");
@@ -4179,7 +4179,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("STRCMP(cast(null as varchar(1)), 'mytesttext')");
   }
 
-  @Test void testSoundexFunc() {
+  @Test void soundexFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SOUNDEX);
     f0.checkFails(
         "^soundex('tech on the net')^",
@@ -4204,7 +4204,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testDifferenceFunc() {
+  @Test void differenceFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.DIFFERENCE).withLibrary(SqlLibrary.POSTGRESQL);
     f.checkScalarExact("DIFFERENCE('Miller', 'miller')", 4);
@@ -4219,7 +4219,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("DIFFERENCE(cast(null as varchar(1)), 'muller')");
   }
 
-  @Test void testReverseFunc() {
+  @Test void reverseFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.REVERSE);
     f0.checkFails(
         "^reverse('abc')^",
@@ -4238,7 +4238,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.MYSQL), consumer);
   }
 
-  @Test void testIfFunc() {
+  @Test void ifFunc() {
     final SqlOperatorFixture f = fixture();
     checkIf(f.withLibrary(SqlLibrary.BIG_QUERY));
     checkIf(f.withLibrary(SqlLibrary.HIVE));
@@ -4257,7 +4257,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkScalar("if(nullif(true,true), 5, 10)", 10, "INTEGER NOT NULL");
   }
 
-  @Test void testUpperFunc() {
+  @Test void upperFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.UPPER, VmName.EXPAND);
     f.checkString("upper('a')", "A", "CHAR(1) NOT NULL");
@@ -4267,7 +4267,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("upper(cast(null as varchar(1)))");
   }
 
-  @Test void testLeftFunc() {
+  @Test void leftFunc() {
     final SqlOperatorFixture f0 = fixture();
     final Consumer<SqlOperatorFixture> consumer =
         f -> {
@@ -4290,7 +4290,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.MYSQL, SqlLibrary.POSTGRESQL), consumer);
   }
 
-  @Test void testRightFunc() {
+  @Test void rightFunc() {
     final SqlOperatorFixture f0 = fixture();
     final Consumer<SqlOperatorFixture> consumer =
         f -> {
@@ -4314,7 +4314,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.MYSQL, SqlLibrary.POSTGRESQL), consumer);
   }
 
-  @Test void testRegexpReplaceFunc() {
+  @Test void regexpReplaceFunc() {
     final SqlOperatorFixture f0 = fixture();
     final Consumer<SqlOperatorFixture> consumer =
         f -> {
@@ -4366,7 +4366,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.MYSQL, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testJsonExists() {
+  @Test void jsonExists() {
     // default pathmode the default is: strict mode
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("json_exists('{\"foo\":\"bar\"}', " + "'$.foo')", true);
@@ -4400,7 +4400,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_exists(cast(null as varchar), " + "'lax $.foo1' unknown on error)");
   }
 
-  @Test public void testJsonInsert() {
+  @Test void jsonInsert() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkString("json_insert('10', '$.a', 10, '$.c', '[true]')", "10", "VARCHAR(2000)");
     f.checkString(
@@ -4427,7 +4427,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_insert(cast(null as varchar), '$', 10)");
   }
 
-  @Test public void testJsonReplace() {
+  @Test void jsonReplace() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkString("json_replace('10', '$.a', 10, '$.c', '[true]')", "10", "VARCHAR(2000)");
     f.checkString(
@@ -4453,7 +4453,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_replace(cast(null as varchar), '$', 10)");
   }
 
-  @Test public void testJsonSet() {
+  @Test void jsonSet() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkString("json_set('10', '$.a', 10, '$.c', '[true]')", "10", "VARCHAR(2000)");
     f.checkString(
@@ -4475,7 +4475,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_set(cast(null as varchar), '$', 10)");
   }
 
-  @Test void testJsonValue() {
+  @Test void jsonValue() {
     final SqlOperatorFixture f = fixture();
     if (false) {
       f.checkFails(
@@ -4586,7 +4586,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_value(cast(null as varchar), 'strict $')");
   }
 
-  @Test void testJsonQuery() {
+  @Test void jsonQuery() {
     final SqlOperatorFixture f = fixture();
     // default pathmode the default is: strict mode
     f.checkString(
@@ -4709,7 +4709,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_query(cast(null as varchar), 'lax $')");
   }
 
-  @Test void testJsonPretty() {
+  @Test void jsonPretty() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_pretty('{\"foo\":100}')", "{\n  \"foo\" : 100\n}", "VARCHAR(2000)");
     f.checkString("json_pretty('[1,2,3]')", "[ 1, 2, 3 ]", "VARCHAR(2000)");
@@ -4722,7 +4722,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_pretty(cast(null as varchar))");
   }
 
-  @Test void testJsonStorageSize() {
+  @Test void jsonStorageSize() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_storage_size('[100, \"sakila\", [1, 3, 5], 425.05]')", "29", "INTEGER");
     f.checkString(
@@ -4742,7 +4742,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_storage_size(cast(null as varchar))");
   }
 
-  @Test void testJsonType() {
+  @Test void jsonType() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.JSON_TYPE, VmName.EXPAND);
     f.checkString("json_type('\"1\"')", "STRING", "VARCHAR(20)");
@@ -4763,7 +4763,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_type(cast(null as varchar))");
   }
 
-  @Test void testJsonDepth() {
+  @Test void jsonDepth() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.JSON_DEPTH, VmName.EXPAND);
     f.checkString("json_depth('1')", "1", "INTEGER");
@@ -4786,7 +4786,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_depth(cast(null as varchar))");
   }
 
-  @Test void testJsonLength() {
+  @Test void jsonLength() {
     final SqlOperatorFixture f = fixture();
     // no path context
     f.checkString("json_length('{}')", "0", "INTEGER");
@@ -4828,7 +4828,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_length(cast(null as varchar))");
   }
 
-  @Test void testJsonKeys() {
+  @Test void jsonKeys() {
     final SqlOperatorFixture f = fixture();
     // no path context
     f.checkString("json_keys('{}')", "[]", "VARCHAR(2000)");
@@ -4873,7 +4873,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_keys(cast(null as varchar))");
   }
 
-  @Test void testJsonRemove() {
+  @Test void jsonRemove() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_remove('{\"foo\":100}', '$.foo')", "{}", "VARCHAR(2000)");
     f.checkString(
@@ -4898,7 +4898,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_remove(cast(null as varchar), '$')");
   }
 
-  @Test void testJsonObject() {
+  @Test void jsonObject() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_object()", "{}", "VARCHAR(2000) NOT NULL");
     f.checkString("json_object('foo': 'bar')", "{\"foo\":\"bar\"}", "VARCHAR(2000) NOT NULL");
@@ -4921,7 +4921,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testJsonObjectAgg() {
+  @Test void jsonObjectAgg() {
     final SqlOperatorFixture f = fixture();
     f.checkAggType("json_objectagg('foo': 'bar')", "VARCHAR(2000) NOT NULL");
     f.checkAggType("json_objectagg('foo': null)", "VARCHAR(2000) NOT NULL");
@@ -4947,7 +4947,7 @@ private static void checkIf(SqlOperatorFixture f) {
         isSingle("{\"foo\":\"bar\",\"foo3\":\"bar3\"}"));
   }
 
-  @Test void testJsonValueExpressionOperator() {
+  @Test void jsonValueExpressionOperator() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("'{}' format json", "{}", "ANY NOT NULL");
     f.checkScalar("'[1, 2, 3]' format json", "[1,2,3]", "ANY NOT NULL");
@@ -4957,7 +4957,7 @@ private static void checkIf(SqlOperatorFixture f) {
         .checkFails("^null^ format json", "(?s).*Illegal use of .NULL.*", false);
   }
 
-  @Test void testJsonArray() {
+  @Test void jsonArray() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_array()", "[]", "VARCHAR(2000) NOT NULL");
     f.checkString("json_array('foo')", "[\"foo\"]", "VARCHAR(2000) NOT NULL");
@@ -4971,7 +4971,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "json_array(json_array('foo') format json)", "[[\"foo\"]]", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testJsonArrayAgg() {
+  @Test void jsonArrayAgg() {
     final SqlOperatorFixture f = fixture();
     f.checkAggType("json_arrayagg('foo')", "VARCHAR(2000) NOT NULL");
     f.checkAggType("json_arrayagg(null)", "VARCHAR(2000) NOT NULL");
@@ -4981,7 +4981,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkAgg("json_arrayagg(x absent on null)", values, isSingle("[\"foo\",\"foo3\"]"));
   }
 
-  @Test void testJsonPredicate() {
+  @Test void jsonPredicate() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("'{}' is json value", true);
     f.checkBoolean("'{]' is json value", false);
@@ -5001,7 +5001,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkBoolean("'[]' is not json scalar", true);
   }
 
-  @Test void testCompress() {
+  @Test void compress() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkNull("COMPRESS(NULL)");
     f.checkString("COMPRESS('')", "", "VARBINARY NOT NULL");
@@ -5019,7 +5019,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "COMPRESS('example')", "07000000789c4bad48cc2dc84905000bc002ed", "VARBINARY NOT NULL");
   }
 
-  @Test void testExtractValue() {
+  @Test void extractValue() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkNull("ExtractValue(NULL, '//b')");
     f.checkNull("ExtractValue('', NULL)");
@@ -5037,7 +5037,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkString("ExtractValue('<a><b/></a>', 'count(/a/b)')", "1", "VARCHAR(2000)");
   }
 
-  @Test void testXmlTransform() {
+  @Test void xmlTransform() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.ORACLE);
     f.checkNull("XMLTRANSFORM('', NULL)");
     f.checkNull("XMLTRANSFORM(NULL,'')");
@@ -5077,7 +5077,7 @@ private static void checkIf(SqlOperatorFixture f) {
         sql2, "    Article - My Article    Authors:     - Mr. Foo    - Mr. Bar", "VARCHAR(2000)");
   }
 
-  @Test void testExtractXml() {
+  @Test void extractXml() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.ORACLE);
 
     f.checkFails("\"EXTRACT\"('', '<','a')", "Invalid input for EXTRACT xpath: '.*", true);
@@ -5124,7 +5124,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "VARCHAR(2000)");
   }
 
-  @Test void testExistsNode() {
+  @Test void existsNode() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.ORACLE);
 
     f.checkFails("EXISTSNODE('', '<','a')", "Invalid input for EXISTSNODE xpath: '.*", true);
@@ -5184,7 +5184,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "INTEGER");
   }
 
-  @Test void testLowerFunc() {
+  @Test void lowerFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LOWER, VmName.EXPAND);
 
@@ -5196,7 +5196,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("lower(cast(null as varchar(1)))");
   }
 
-  @Test void testInitcapFunc() {
+  @Test void initcapFunc() {
     // Note: the initcap function is an Oracle defined function and is not
     // defined in the SQL:2003 standard
     // todo: implement in fennel
@@ -5220,7 +5220,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkType("initcap(cast(null as date))", "VARCHAR");
   }
 
-  @Test void testPowerFunc() {
+  @Test void powerFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.POWER, VmName.EXPAND);
     f.checkScalarApprox("power(2,-2)", "DOUBLE NOT NULL", isExactly("0.25"));
@@ -5234,7 +5234,7 @@ private static void checkIf(SqlOperatorFixture f) {
         false);
   }
 
-  @Test void testSqrtFunc() {
+  @Test void sqrtFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SQRT, VmName.EXPAND);
     f.checkType("sqrt(2)", "DOUBLE NOT NULL");
@@ -5255,7 +5255,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("sqrt(cast(null as double))");
   }
 
-  @Test void testExpFunc() {
+  @Test void expFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXP, VM_FENNEL);
     f.checkScalarApprox("exp(2)", "DOUBLE NOT NULL", isWithin(7.389056, 0.000001));
@@ -5264,7 +5264,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("exp(cast(null as double))");
   }
 
-  @Test void testModFunc() {
+  @Test void modFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MOD, VmName.EXPAND);
     f.checkScalarExact("mod(4,2)", 0);
@@ -5285,7 +5285,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "-2");
   }
 
-  @Test void testModFuncNull() {
+  @Test void modFuncNull() {
     final SqlOperatorFixture f = fixture();
     f.checkNull("mod(cast(null as integer),2)");
     f.checkNull("mod(4,cast(null as tinyint))");
@@ -5295,7 +5295,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("mod(4,cast(null as decimal(12,0)))");
   }
 
-  @Test void testModFuncDivByZero() {
+  @Test void modFuncDivByZero() {
     // The extra CASE expression is to fool Janino.  It does constant
     // reduction and will throw the divide by zero exception while
     // compiling the expression.  The test frame work would then issue
@@ -5306,7 +5306,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkFails("mod(3,case 'a' when 'a' then 0 end)", DIVISION_BY_ZERO_MESSAGE, true);
   }
 
-  @Test void testLnFunc() {
+  @Test void lnFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LN, VmName.EXPAND);
     f.checkScalarApprox("ln(2.71828)", "DOUBLE NOT NULL", isWithin(1.0, 0.000001));
@@ -5314,7 +5314,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("ln(cast(null as tinyint))");
   }
 
-  @Test void testLog10Func() {
+  @Test void log10Func() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LOG10, VmName.EXPAND);
     f.checkScalarApprox("log10(10)", "DOUBLE NOT NULL", isWithin(1.0, 0.000001));
@@ -5325,7 +5325,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("log10(cast(null as real))");
   }
 
-  @Test void testLogFunc() {
+  @Test void logFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.LOG, VmName.EXPAND);
     f0.checkFails(
         "^log(100, 10)^",
@@ -5346,7 +5346,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("log(10, cast(null as real))");
   }
 
-  @Test void testRandFunc() {
+  @Test void randFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RAND, VmName.EXPAND);
     f.checkFails("^rand^", "Column 'RAND' not found in any table", false);
@@ -5356,14 +5356,14 @@ private static void checkIf(SqlOperatorFixture f) {
     }
   }
 
-  @Test void testRandSeedFunc() {
+  @Test void randSeedFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RAND, VmName.EXPAND);
     f.checkScalarApprox("rand(1)", "DOUBLE NOT NULL", isWithin(0.6016, 0.0001));
     f.checkScalarApprox("rand(2)", "DOUBLE NOT NULL", isWithin(0.4728, 0.0001));
   }
 
-  @Test void testRandIntegerFunc() {
+  @Test void randIntegerFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RAND_INTEGER, VmName.EXPAND);
     for (int i = 0; i < 100; i++) {
@@ -5372,7 +5372,7 @@ private static void checkIf(SqlOperatorFixture f) {
     }
   }
 
-  @Test void testRandIntegerSeedFunc() {
+  @Test void randIntegerSeedFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RAND_INTEGER, VmName.EXPAND);
     f.checkScalar("rand_integer(1, 11)", 4, "INTEGER NOT NULL");
@@ -5380,7 +5380,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_APPEND} function from Spark. */
-  @Test void testArrayAppendFunc() {
+  @Test void arrayAppendFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_APPEND);
     f0.checkFails(
@@ -5409,7 +5409,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_COMPACT} function from Spark. */
-  @Test void testArrayCompactFunc() {
+  @Test void arrayCompactFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_COMPACT);
     f0.checkFails(
@@ -5426,7 +5426,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_CONCAT} function from BigQuery. */
-  @Test void testArrayConcat() {
+  @Test void arrayConcat() {
     SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.ARRAY_CONCAT).withLibrary(SqlLibrary.BIG_QUERY);
     f.checkFails("^array_concat()^", INVALID_ARGUMENTS_NUMBER, false);
@@ -5444,7 +5444,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_CONTAINS} function from Spark. */
-  @Test void testArrayContainsFunc() {
+  @Test void arrayContainsFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_CONTAINS);
     f0.checkFails(
@@ -5474,7 +5474,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_DISTINCT} function from Spark. */
-  @Test void testArrayDistinctFunc() {
+  @Test void arrayDistinctFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_DISTINCT);
     f0.checkFails(
@@ -5487,7 +5487,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("array_distinct(null)");
   }
 
-  @Test void testArrayJoinFunc() {
+  @Test void arrayJoinFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_JOIN);
     f0.checkFails(
@@ -5519,7 +5519,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_MAX} function from Spark. */
-  @Test void testArrayMaxFunc() {
+  @Test void arrayMaxFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_MAX);
     f0.checkFails(
@@ -5537,7 +5537,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_MIN} function from Spark. */
-  @Test void testArrayMinFunc() {
+  @Test void arrayMinFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_MIN);
     f0.checkFails(
@@ -5554,7 +5554,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_POSITION} function from Spark. */
-  @Test void testArrayPositionFunc() {
+  @Test void arrayPositionFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_POSITION);
     f0.checkFails(
@@ -5578,7 +5578,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_PREPEND} function from Spark. */
-  @Test void testArrayPrependFunc() {
+  @Test void arrayPrependFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_PREPEND);
     f0.checkFails(
@@ -5607,7 +5607,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_REMOVE} function from Spark. */
-  @Test void testArrayRemoveFunc() {
+  @Test void arrayRemoveFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_REMOVE);
     f0.checkFails(
@@ -5645,7 +5645,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_REPEAT} function from Spark. */
-  @Test void testArrayRepeatFunc() {
+  @Test void arrayRepeatFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_REPEAT);
     f0.checkFails(
@@ -5670,7 +5670,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_REVERSE} function from BigQuery. */
-  @Test void testArrayReverseFunc() {
+  @Test void arrayReverseFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_REVERSE);
     f0.checkFails(
@@ -5684,7 +5684,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_SIZE} function from Spark. */
-  @Test void testArraySizeFunc() {
+  @Test void arraySizeFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_SIZE);
     f0.checkFails(
@@ -5699,7 +5699,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_LENGTH} function from BigQuery. */
-  @Test void testArrayLengthFunc() {
+  @Test void arrayLengthFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_LENGTH);
     f0.checkFails(
@@ -5712,7 +5712,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("array_length(null)");
   }
 
-  @Test void testArrayToStringFunc() {
+  @Test void arrayToStringFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_TO_STRING);
     f0.checkFails(
@@ -5744,7 +5744,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_EXCEPT} function from Spark. */
-  @Test void testArrayExceptFunc() {
+  @Test void arrayExceptFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_EXCEPT);
     f0.checkFails(
@@ -5765,7 +5765,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_INTERSECT} function from Spark. */
-  @Test void testArrayIntersectFunc() {
+  @Test void arrayIntersectFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_INTERSECT);
     f0.checkFails(
@@ -5789,7 +5789,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_UNION} function from Spark. */
-  @Test void testArrayUnionFunc() {
+  @Test void arrayUnionFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_UNION);
     f0.checkFails(
@@ -5811,7 +5811,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAYS_OVERLAP} function from Spark. */
-  @Test void testArraysOverlapFunc() {
+  @Test void arraysOverlapFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAYS_OVERLAP);
     f0.checkFails(
@@ -5850,7 +5850,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAYS_ZIP} function from Spark. */
-  @Test void testArraysZipFunc() {
+  @Test void arraysZipFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAYS_ZIP);
     f0.checkFails(
@@ -5915,7 +5915,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code SORT_ARRAY} function from Spark. */
-  @Test void testSortArrayFunc() {
+  @Test void sortArrayFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.SORT_ARRAY);
     f0.checkFails(
@@ -5954,7 +5954,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_CONCAT} function from Spark. */
-  @Test void testMapConcatFunc() {
+  @Test void mapConcatFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_CONCAT);
     f0.checkFails(
@@ -6020,7 +6020,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_ENTRIES} function from Spark. */
-  @Test void testMapEntriesFunc() {
+  @Test void mapEntriesFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_ENTRIES);
     f0.checkFails(
@@ -6040,7 +6040,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_KEYS} function from Spark. */
-  @Test void testMapKeysFunc() {
+  @Test void mapKeysFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_KEYS);
     f0.checkFails(
@@ -6054,7 +6054,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_VALUES} function from Spark. */
-  @Test void testMapValuesFunc() {
+  @Test void mapValuesFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_VALUES);
     f0.checkFails(
@@ -6072,7 +6072,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_FROM_ARRAYS} function from Spark. */
-  @Test void testMapFromArraysFunc() {
+  @Test void mapFromArraysFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_FROM_ARRAYS);
     f0.checkFails(
@@ -6125,7 +6125,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_FROM_ENTRIES} function from Spark. */
-  @Test void testMapFromEntriesFunc() {
+  @Test void mapFromEntriesFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_FROM_ENTRIES);
     f0.checkFails(
@@ -6181,7 +6181,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code STR_TO_MAP} function from Spark. */
-  @Test void testStrToMapFunc() {
+  @Test void strToMapFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.STR_TO_MAP);
     f0.checkFails(
@@ -6233,7 +6233,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code UNIX_SECONDS} and other datetime functions from BigQuery. */
-  @Test void testUnixSecondsFunc() {
+  @Test void unixSecondsFunc() {
     SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.UNIX_SECONDS).withLibrary(SqlLibrary.BIG_QUERY);
     f.checkScalar("unix_seconds(timestamp '1970-01-01 00:00:00')", 0, "BIGINT NOT NULL");
@@ -6255,7 +6255,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkType("CURRENT_DATETIME(CAST(NULL AS VARCHAR(20)))", "TIMESTAMP(0)");
   }
 
-  @Test void testAbsFunc() {
+  @Test void absFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ABS, VmName.EXPAND);
     f.checkScalarExact("abs(-1)", 1);
@@ -6272,7 +6272,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("abs(cast(null as double))");
   }
 
-  @Test void testAbsFuncIntervals() {
+  @Test void absFuncIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("abs(interval '-2' day)", "+2", "INTERVAL DAY NOT NULL");
     f.checkScalar(
@@ -6280,7 +6280,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("abs(cast(null as interval hour))");
   }
 
-  @Test void testAcosFunc() {
+  @Test void acosFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ACOS, VmName.EXPAND);
     f.checkType("acos(0)", "DOUBLE NOT NULL");
@@ -6301,7 +6301,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("acos(cast(null as double))");
   }
 
-  @Test void testAsinFunc() {
+  @Test void asinFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ASIN, VmName.EXPAND);
     f.checkType("asin(0)", "DOUBLE NOT NULL");
@@ -6322,7 +6322,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("asin(cast(null as double))");
   }
 
-  @Test void testAtanFunc() {
+  @Test void atanFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ATAN, VmName.EXPAND);
     f.checkType("atan(2)", "DOUBLE NOT NULL");
@@ -6343,7 +6343,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("atan(cast(null as double))");
   }
 
-  @Test void testAtan2Func() {
+  @Test void atan2Func() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ATAN2, VmName.EXPAND);
     f.checkType("atan2(2, -2)", "DOUBLE NOT NULL");
@@ -6367,7 +6367,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("atan2(1, cast(null as double))");
   }
 
-  @Test void testAcoshFunc() {
+  @Test void acoshFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.ACOSH);
     f0.checkFails(
         "^acosh(1)^", "No match found for function signature ACOSH\\(<NUMERIC>\\)", false);
@@ -6387,7 +6387,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testAsinhFunc() {
+  @Test void asinhFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.ASINH);
     f0.checkFails(
         "^asinh(1)^", "No match found for function signature ASINH\\(<NUMERIC>\\)", false);
@@ -6406,7 +6406,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testAtanhFunc() {
+  @Test void atanhFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.ATANH);
     f0.checkFails(
         "^atanh(1)^", "No match found for function signature ATANH\\(<NUMERIC>\\)", false);
@@ -6431,7 +6431,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testCbrtFunc() {
+  @Test void cbrtFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CBRT, VmName.EXPAND);
     f.checkType("cbrt(1)", "DOUBLE NOT NULL");
@@ -6452,7 +6452,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("cbrt(cast(null as double))");
   }
 
-  @Test void testCosFunc() {
+  @Test void cosFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COS, VmName.EXPAND);
     f.checkType("cos(1)", "DOUBLE NOT NULL");
@@ -6473,7 +6473,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("cos(cast(null as double))");
   }
 
-  @Test void testCoshFunc() {
+  @Test void coshFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.COSH);
     f0.checkFails("^cosh(1)^", "No match found for function signature COSH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6491,7 +6491,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testCotFunc() {
+  @Test void cotFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COT, VmName.EXPAND);
     f.checkType("cot(1)", "DOUBLE NOT NULL");
@@ -6512,7 +6512,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("cot(cast(null as double))");
   }
 
-  @Test void testCothFunc() {
+  @Test void cothFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.COTH);
     f0.checkFails("^coth(1)^", "No match found for function signature COTH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6530,7 +6530,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testCschFunc() {
+  @Test void cschFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.CSCH);
     f0.checkFails("^csch(1)^", "No match found for function signature CSCH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6548,7 +6548,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testCscFunc() {
+  @Test void cscFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.CSC);
     f0.checkFails("^csc(1)^", "No match found for function signature CSC\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6567,7 +6567,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testSecFunc() {
+  @Test void secFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SEC);
     f0.checkFails("^sec(1)^", "No match found for function signature SEC\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6586,7 +6586,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testDegreesFunc() {
+  @Test void degreesFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DEGREES, VmName.EXPAND);
     f.checkType("degrees(1)", "DOUBLE NOT NULL");
@@ -6607,7 +6607,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("degrees(cast(null as double))");
   }
 
-  @Test void testPiFunc() {
+  @Test void piFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PI, VmName.EXPAND);
     f.checkScalarApprox("PI", "DOUBLE NOT NULL", isWithin(3.1415d, 0.0001d));
@@ -6620,7 +6620,7 @@ private static void checkIf(SqlOperatorFixture f) {
         is(false));
   }
 
-  @Test void testRadiansFunc() {
+  @Test void radiansFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RADIANS, VmName.EXPAND);
     f.checkType("radians(42)", "DOUBLE NOT NULL");
@@ -6641,7 +6641,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("radians(cast(null as double))");
   }
 
-  @Test void testPowFunc() {
+  @Test void powFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.POW).withLibrary(SqlLibrary.BIG_QUERY);
     f.checkScalarApprox("pow(2,3)", "DOUBLE NOT NULL", isExactly("8.0"));
@@ -6649,7 +6649,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("pow(cast(null as integer), 2)");
   }
 
-  @Test void testRoundFunc() {
+  @Test void roundFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ROUND, VmName.EXPAND);
     f.checkType("round(42, -1)", "INTEGER NOT NULL");
@@ -6686,7 +6686,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkScalar("round(42.724)", BigDecimal.valueOf(43, 0), "DECIMAL(5, 3) NOT NULL");
   }
 
-  @Test void testSignFunc() {
+  @Test void signFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SIGN, VmName.EXPAND);
     f.checkType("sign(1)", "INTEGER NOT NULL");
@@ -6708,7 +6708,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("sign(cast(null as double))");
   }
 
-  @Test void testSechFunc() {
+  @Test void sechFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SECH);
     f0.checkFails("^sech(1)^", "No match found for function signature SECH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6726,7 +6726,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testSinFunc() {
+  @Test void sinFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SIN, VmName.EXPAND);
     f.checkType("sin(1)", "DOUBLE NOT NULL");
@@ -6747,7 +6747,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("sin(cast(null as double))");
   }
 
-  @Test void testSinhFunc() {
+  @Test void sinhFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SINH);
     f0.checkFails("^sinh(1)^", "No match found for function signature SINH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6765,7 +6765,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testTanFunc() {
+  @Test void tanFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TAN, VmName.EXPAND);
     f.checkType("tan(1)", "DOUBLE NOT NULL");
@@ -6786,7 +6786,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("tan(cast(null as double))");
   }
 
-  @Test void testTanhFunc() {
+  @Test void tanhFunc() {
     SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TANH);
     f0.checkFails("^tanh(1)^", "No match found for function signature TANH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6804,7 +6804,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testTruncFunc() {
+  @Test void truncFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.TRUNC).withLibrary(SqlLibrary.BIG_QUERY);
     f.checkType("trunc(42, -1)", "INTEGER NOT NULL");
@@ -6842,7 +6842,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("trunc(cast(null as double))");
   }
 
-  @Test void testTruncateFunc() {
+  @Test void truncateFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TRUNCATE, VmName.EXPAND);
     f.checkType("truncate(42, -1)", "INTEGER NOT NULL");
@@ -6880,7 +6880,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("truncate(cast(null as double))");
   }
 
-  @Test void testNullifFunc() {
+  @Test void nullifFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NULLIF, VM_EXPAND);
     f.checkNull("nullif(1,1)");
@@ -6912,7 +6912,7 @@ private static void checkIf(SqlOperatorFixture f) {
         false);
   }
 
-  @Test void testNullIfOperatorIntervals() {
+  @Test void nullIfOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("nullif(interval '2' month, interval '3' year)", "+2", "INTERVAL MONTH");
     f.checkScalar(
@@ -6922,7 +6922,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("nullif(interval '3' day, interval '3' day)");
   }
 
-  @Test void testCoalesceFunc() {
+  @Test void coalesceFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COALESCE, VM_EXPAND);
     f.checkString("coalesce('a','b')", "a", "CHAR(1) NOT NULL");
@@ -6935,38 +6935,38 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkType("1 + coalesce('a', 'b', 1, null) + 2", "INTEGER");
   }
 
-  @Test void testUserFunc() {
+  @Test void userFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.USER, VM_FENNEL);
     f.checkString("USER", "sa", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testCurrentUserFunc() {
+  @Test void currentUserFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CURRENT_USER, VM_FENNEL);
     f.checkString("CURRENT_USER", "sa", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testSessionUserFunc() {
+  @Test void sessionUserFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SESSION_USER, VM_FENNEL);
     f.checkString("SESSION_USER", "sa", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testSystemUserFunc() {
+  @Test void systemUserFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SYSTEM_USER, VM_FENNEL);
     String user = System.getProperty("user.name"); // e.g. "jhyde"
     f.checkString("SYSTEM_USER", user, "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testCurrentPathFunc() {
+  @Test void currentPathFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CURRENT_PATH, VM_FENNEL);
     f.checkString("CURRENT_PATH", "", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testCurrentRoleFunc() {
+  @Test void currentRoleFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CURRENT_ROLE, VM_FENNEL);
     // By default, the CURRENT_ROLE function returns
@@ -6974,7 +6974,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkString("CURRENT_ROLE", "", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testCurrentCatalogFunc() {
+  @Test void currentCatalogFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CURRENT_CATALOG, VM_FENNEL);
     // By default, the CURRENT_CATALOG function returns
@@ -6983,11 +6983,11 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   @Tag("slow")
-  @Test void testLocalTimeFuncWithCurrentTime() {
+  @Test void localTimeFuncWithCurrentTime() {
     testLocalTimeFunc(currentTimeString(LOCAL_TZ));
   }
 
-  @Test void testLocalTimeFuncWithFixedTime() {
+  @Test void localTimeFuncWithFixedTime() {
     testLocalTimeFunc(fixedTimeString(LOCAL_TZ));
   }
 
@@ -7010,11 +7010,11 @@ private void testLocalTimeFunc(Pair<String, Hook.Closeable> pair) {
   }
 
   @Tag("slow")
-  @Test void testLocalTimestampFuncWithCurrentTime() {
+  @Test void localTimestampFuncWithCurrentTime() {
     testLocalTimestampFunc(currentTimeString(LOCAL_TZ));
   }
 
-  @Test void testLocalTimestampFuncWithFixedTime() {
+  @Test void localTimestampFuncWithFixedTime() {
     testLocalTimestampFunc(fixedTimeString(LOCAL_TZ));
   }
 
@@ -7042,11 +7042,11 @@ private void testLocalTimestampFunc(Pair<String, Hook.Closeable> pair) {
   }
 
   @Tag("slow")
-  @Test void testCurrentTimeFuncWithCurrentTime() {
+  @Test void currentTimeFuncWithCurrentTime() {
     testCurrentTimeFunc(currentTimeString(CURRENT_TZ));
   }
 
-  @Test void testCurrentTimeFuncWithFixedTime() {
+  @Test void currentTimeFuncWithFixedTime() {
     testCurrentTimeFunc(fixedTimeString(CURRENT_TZ));
   }
 
@@ -7070,11 +7070,11 @@ private void testCurrentTimeFunc(Pair<String, Hook.Closeable> pair) {
   }
 
   @Tag("slow")
-  @Test void testCurrentTimestampFuncWithCurrentTime() {
+  @Test void currentTimestampFuncWithCurrentTime() {
     testCurrentTimestampFunc(currentTimeString(CURRENT_TZ));
   }
 
-  @Test void testCurrentTimestampFuncWithFixedTime() {
+  @Test void currentTimestampFuncWithFixedTime() {
     testCurrentTimestampFunc(fixedTimeString(CURRENT_TZ));
   }
 
@@ -7129,11 +7129,11 @@ private static String toTimeString(TimeZone tz, Calendar cal) {
   }
 
   @Tag("slow")
-  @Test void testCurrentDateFuncWithCurrentTime() {
+  @Test void currentDateFuncWithCurrentTime() {
     testCurrentDateFunc(currentTimeString(LOCAL_TZ));
   }
 
-  @Test void testCurrentDateFuncWithFixedTime() {
+  @Test void currentDateFuncWithFixedTime() {
     testCurrentDateFunc(fixedTimeString(LOCAL_TZ));
   }
 
@@ -7178,7 +7178,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     }
   }
 
-  @Test void testLastDayFunc() {
+  @Test void lastDayFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LAST_DAY, VmName.EXPAND);
     f.checkScalar("last_day(DATE '2019-02-10')", "2019-02-28", "DATE NOT NULL");
@@ -7224,7 +7224,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     f.checkNull("last_day(cast(null as timestamp))");
   }
 
-  @Test void testLpadFunction() {
+  @Test void lpadFunction() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.BIG_QUERY);
     f.setFor(SqlLibraryOperators.LPAD);
     f.check("select lpad('12345', 8, 'a')", "VARCHAR(5) NOT NULL", "aaa12345");
@@ -7251,7 +7251,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
         true);
   }
 
-  @Test void testRpadFunction() {
+  @Test void rpadFunction() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.BIG_QUERY);
     f.setFor(SqlLibraryOperators.RPAD);
     f.check("select rpad('12345', 8, 'a')", "VARCHAR(5) NOT NULL", "12345aaa");
@@ -7279,7 +7279,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
         true);
   }
 
-  @Test void testStrposFunction() {
+  @Test void strposFunction() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.STRPOS);
     f0.checkFails(
         "^strpos('abc', 'a')^",
@@ -7305,7 +7305,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     f.checkNull("STRPOS(x'', null)");
   }
 
-  @Test void testInstrFunction() {
+  @Test void instrFunction() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.CHR, VM_FENNEL, VM_JAVA);
     f0.checkFails(
         "^INSTR('abc', 'a', 1, 1)^",
@@ -7338,7 +7338,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testStartsWithFunction() {
+  @Test void startsWithFunction() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.BIG_QUERY);
     f.setFor(SqlLibraryOperators.STARTS_WITH);
     f.checkBoolean("starts_with('12345', '123')", true);
@@ -7363,7 +7363,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     f.checkBoolean("starts_with(x'', x'')", true);
   }
 
-  @Test void testEndsWithFunction() {
+  @Test void endsWithFunction() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.BIG_QUERY);
     f.setFor(SqlLibraryOperators.ENDS_WITH);
     f.checkBoolean("ends_with('12345', '345')", true);
@@ -7389,7 +7389,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
   }
 
   /** Tests the {@code SPLIT} operator. */
-  @Test void testSplitFunction() {
+  @Test void splitFunction() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SPLIT);
     f0.checkFails(
         "^split('hello')^", "No match found for function signature SPLIT\\(<CHARACTER>\\)", false);
@@ -7419,7 +7419,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
    * SubFunChecker#assertSubFunReturns}, and are called for both {@code SUBSTRING} and {@code
    * SUBSTR}.
    */
-  @Test void testSubstringFunction() {
+  @Test void substringFunction() {
     final SqlOperatorFixture f = fixture();
     checkSubstringFunction(f);
     checkSubstringFunction(f.withConformance(SqlConformanceEnum.BIG_QUERY));
@@ -7462,7 +7462,7 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the non-standard SUBSTR function, that has syntax "SUBSTR(value, start [, length ])", as
    * used in BigQuery.
    */
-  @Test void testBigQuerySubstrFunction() {
+  @Test void bigQuerySubstrFunction() {
     substrChecker(SqlLibrary.BIG_QUERY, SqlLibraryOperators.SUBSTR_BIG_QUERY).check();
   }
 
@@ -7470,7 +7470,7 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the non-standard SUBSTR function, that has syntax "SUBSTR(value, start [, length ])", as
    * used in Oracle.
    */
-  @Test void testMysqlSubstrFunction() {
+  @Test void mysqlSubstrFunction() {
     substrChecker(SqlLibrary.MYSQL, SqlLibraryOperators.SUBSTR_MYSQL).check();
   }
 
@@ -7478,7 +7478,7 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the non-standard SUBSTR function, that has syntax "SUBSTR(value, start [, length ])", as
    * used in Oracle.
    */
-  @Test void testOracleSubstrFunction() {
+  @Test void oracleSubstrFunction() {
     substrChecker(SqlLibrary.ORACLE, SqlLibraryOperators.SUBSTR_ORACLE).check();
   }
 
@@ -7486,7 +7486,7 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the non-standard SUBSTR function, that has syntax "SUBSTR(value, start [, length ])", as
    * used in PostgreSQL.
    */
-  @Test void testPostgresqlSubstrFunction() {
+  @Test void postgresqlSubstrFunction() {
     substrChecker(SqlLibrary.POSTGRESQL, SqlLibraryOperators.SUBSTR_POSTGRESQL).check();
   }
 
@@ -7494,12 +7494,12 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the standard {@code SUBSTRING} function in the mode that has BigQuery's non-standard
    * semantics.
    */
-  @Test void testBigQuerySubstringFunction() {
+  @Test void bigQuerySubstringFunction() {
     substringChecker(SqlConformanceEnum.BIG_QUERY, SqlLibrary.BIG_QUERY).check();
   }
 
   /** Tests the standard {@code SUBSTRING} function in ISO standard semantics. */
-  @Test void testStandardSubstringFunction() {
+  @Test void standardSubstringFunction() {
     substringChecker(SqlConformanceEnum.STRICT_2003, SqlLibrary.POSTGRESQL).check();
   }
 
@@ -7698,7 +7698,7 @@ void assertSubFunReturns(
     }
   }
 
-  @Test void testTrimFunc() {
+  @Test void trimFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TRIM, VmName.EXPAND);
 
@@ -7728,7 +7728,7 @@ void assertSubFunReturns(
     f1.checkString("trim('eh' from 'hehe__hehe')", "__", "VARCHAR(10) NOT NULL");
   }
 
-  @Test void testRtrimFunc() {
+  @Test void rtrimFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.RTRIM, VmName.EXPAND);
     f0.checkFails(
         "^rtrim(' aaa')^", "No match found for function signature RTRIM\\(<CHARACTER>\\)", false);
@@ -7740,7 +7740,7 @@ void assertSubFunReturns(
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testLtrimFunc() {
+  @Test void ltrimFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.LTRIM, VmName.EXPAND);
     f0.checkFails(
         "^ltrim('  aa')^", "No match found for function signature LTRIM\\(<CHARACTER>\\)", false);
@@ -7752,7 +7752,7 @@ void assertSubFunReturns(
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testGreatestFunc() {
+  @Test void greatestFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.GREATEST, VmName.EXPAND);
     f0.checkFails(
         "^greatest('on', 'earth')^",
@@ -7772,7 +7772,7 @@ void assertSubFunReturns(
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testLeastFunc() {
+  @Test void leastFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.LEAST, VmName.EXPAND);
     f0.checkFails(
         "^least('on', 'earth')^",
@@ -7792,7 +7792,7 @@ void assertSubFunReturns(
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testNvlFunc() {
+  @Test void nvlFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.NVL, VmName.EXPAND).withLibrary(SqlLibrary.ORACLE);
     f.checkScalar("nvl(1, 2)", "1", "INTEGER NOT NULL");
@@ -7817,7 +7817,7 @@ void assertSubFunReturns(
    * Tests {@code IFNULL}, which is a synonym for {@code NVL}, and is related to {@code COALESCE}
    * but requires precisely two arguments.
    */
-  @Test void testIfnullFunc() {
+  @Test void ifnullFunc() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.IFNULL, VM_EXPAND);
 
@@ -7841,7 +7841,7 @@ void assertSubFunReturns(
         false);
   }
 
-  @Test void testDecodeFunc() {
+  @Test void decodeFunc() {
     checkDecodeFunc(fixture().withLibrary(SqlLibrary.ORACLE));
   }
 
@@ -7864,7 +7864,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
         "CHAR(1) NOT NULL");
   }
 
-  @Test void testWindow() {
+  @Test void window() {
     final SqlOperatorFixture f = fixture();
     f.check(
         "select sum(1) over (order by x)\n"
@@ -7874,14 +7874,14 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
         1);
   }
 
-  @Test void testElementFunc() {
+  @Test void elementFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ELEMENT, VM_FENNEL, VM_JAVA);
     f.checkString("element(multiset['abc'])", "abc", "CHAR(3) NOT NULL");
     f.checkNull("element(multiset[cast(null as integer)])");
   }
 
-  @Test void testCardinalityFunc() {
+  @Test void cardinalityFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CARDINALITY, VM_FENNEL, VM_JAVA);
     f.checkScalarExact("cardinality(multiset[cast(null as integer),2])", 2);
@@ -7897,7 +7897,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkScalarExact("cardinality(map['foo', 1, 'bar', 2])", 2);
   }
 
-  @Test void testMemberOfOperator() {
+  @Test void memberOfOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MEMBER_OF, VM_FENNEL, VM_JAVA);
     f.checkBoolean("1 member of multiset[1]", true);
@@ -7907,7 +7907,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkBoolean("1.1 member of multiset[cast(null as double)]", false);
   }
 
-  @Test void testMultisetUnionOperator() {
+  @Test void multisetUnionOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_UNION_DISTINCT, VM_FENNEL, VM_JAVA);
     f.checkBoolean(
@@ -7958,7 +7958,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
         "BOOLEAN MULTISET NOT NULL");
   }
 
-  @Test void testMultisetUnionAllOperator() {
+  @Test void multisetUnionAllOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_UNION, VM_FENNEL, VM_JAVA);
     f.checkScalar(
@@ -7999,7 +7999,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
         "BOOLEAN MULTISET NOT NULL");
   }
 
-  @Test void testSubMultisetOfOperator() {
+  @Test void subMultisetOfOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SUBMULTISET_OF, VM_FENNEL, VM_JAVA);
     f.checkBoolean("multiset[2] submultiset of multiset[1]", false);
@@ -8013,7 +8013,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkBoolean("multiset['q', 'a'] submultiset of multiset['a', 'q']", true);
   }
 
-  @Test void testNotSubMultisetOfOperator() {
+  @Test void notSubMultisetOfOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_SUBMULTISET_OF, VM_FENNEL, VM_JAVA);
     f.checkBoolean("multiset[2] not submultiset of multiset[1]", true);
@@ -8027,7 +8027,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkBoolean("multiset['q', 'a'] not submultiset of " + "multiset['a', 'q']", false);
   }
 
-  @Test void testCollectFunc() {
+  @Test void collectFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COLLECT, VM_FENNEL, VM_JAVA);
     f.checkFails("collect(^*^)", "Unknown identifier '\\*'", false);
@@ -8053,7 +8053,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkAgg("collect(DISTINCT x)", values, isSingle(2));
   }
 
-  @Test void testListAggFunc() {
+  @Test void listAggFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LISTAGG, VM_FENNEL, VM_JAVA);
     f.checkFails("listagg(^*^)", "Unknown identifier '\\*'", false);
@@ -8082,7 +8082,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkAgg("listagg(cast(x as CHAR))", values2, isSingle("0,1,2,3"));
   }
 
-  @Test void testStringAggFunc() {
+  @Test void stringAggFunc() {
     final SqlOperatorFixture f = fixture();
     checkStringAggFunc(f.withLibrary(SqlLibrary.POSTGRESQL));
     checkStringAggFunc(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -8126,7 +8126,7 @@ private static void checkStringAggFuncFails(SqlOperatorFixture f) {
         false);
   }
 
-  @Test void testGroupConcatFunc() {
+  @Test void groupConcatFunc() {
     final SqlOperatorFixture f = fixture();
     checkGroupConcatFunc(f.withLibrary(SqlLibrary.MYSQL));
     checkGroupConcatFuncFails(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -8171,7 +8171,7 @@ private static void checkGroupConcatFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testArrayAggFunc() {
+  @Test void arrayAggFunc() {
     final SqlOperatorFixture f = fixture();
     checkArrayAggFunc(f.withLibrary(SqlLibrary.POSTGRESQL));
     checkArrayAggFunc(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -8203,7 +8203,7 @@ private static void checkArrayAggFuncFails(SqlOperatorFixture t) {
     t.checkAggFails("^array_agg(x, ',' order by x desc)^", values, expectedError2, false);
   }
 
-  @Test void testArrayConcatAggFunc() {
+  @Test void arrayConcatAggFunc() {
     final SqlOperatorFixture f = fixture();
     checkArrayConcatAggFunc(f.withLibrary(SqlLibrary.POSTGRESQL));
     checkArrayConcatAggFunc(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -8246,7 +8246,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     t.checkAggFails("^array_concat_agg(x, ',' order by x desc)^", values, expectedError2, false);
   }
 
-  @Test void testFusionFunc() {
+  @Test void fusionFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.FUSION, VM_FENNEL, VM_JAVA);
     f.checkFails("fusion(^*^)", "Unknown identifier '\\*'", false);
@@ -8259,7 +8259,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkAgg("fusion(x)", values2, isSingle("[0, 1, 1, 2]"));
   }
 
-  @Test void testIntersectionFunc() {
+  @Test void intersectionFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.INTERSECTION, VM_FENNEL, VM_JAVA);
     f.checkFails("intersection(^*^)", "Unknown identifier '\\*'", false);
@@ -8275,7 +8275,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkAgg("intersection(x)", values3, isSingle("[0, 1, 1]"));
   }
 
-  @Test void testModeFunc() {
+  @Test void modeFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MODE, VM_EXPAND);
     f.checkFails("mode(^*^)", "Unknown identifier '\\*'", false);
@@ -8308,7 +8308,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkAgg("mode(DISTINCT x)", values, isSingle(0));
   }
 
-  @Test void testYear() {
+  @Test void year() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.YEAR, VM_FENNEL, VM_JAVA);
 
@@ -8316,7 +8316,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("year(cast(null as date))");
   }
 
-  @Test void testQuarter() {
+  @Test void quarter() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.QUARTER, VM_FENNEL, VM_JAVA);
 
@@ -8335,7 +8335,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("quarter(cast(null as date))");
   }
 
-  @Test void testMonth() {
+  @Test void month() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MONTH, VM_FENNEL, VM_JAVA);
 
@@ -8343,35 +8343,35 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("month(cast(null as date))");
   }
 
-  @Test void testWeek() {
+  @Test void week() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.WEEK, VM_FENNEL, VM_JAVA);
     f.checkScalar("week(date '2008-1-23')", "4", "BIGINT NOT NULL");
     f.checkNull("week(cast(null as date))");
   }
 
-  @Test void testDayOfYear() {
+  @Test void dayOfYear() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DAYOFYEAR, VM_FENNEL, VM_JAVA);
     f.checkScalar("dayofyear(date '2008-01-23')", "23", "BIGINT NOT NULL");
     f.checkNull("dayofyear(cast(null as date))");
   }
 
-  @Test void testDayOfMonth() {
+  @Test void dayOfMonth() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DAYOFMONTH, VM_FENNEL, VM_JAVA);
     f.checkScalar("dayofmonth(date '2008-1-23')", "23", "BIGINT NOT NULL");
     f.checkNull("dayofmonth(cast(null as date))");
   }
 
-  @Test void testDayOfWeek() {
+  @Test void dayOfWeek() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DAYOFWEEK, VM_FENNEL, VM_JAVA);
     f.checkScalar("dayofweek(date '2008-1-23')", "4", "BIGINT NOT NULL");
     f.checkNull("dayofweek(cast(null as date))");
   }
 
-  @Test void testHour() {
+  @Test void hour() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.HOUR, VM_FENNEL, VM_JAVA);
 
@@ -8379,7 +8379,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("hour(cast(null as timestamp))");
   }
 
-  @Test void testMinute() {
+  @Test void minute() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MINUTE, VM_FENNEL, VM_JAVA);
 
@@ -8387,7 +8387,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("minute(cast(null as timestamp))");
   }
 
-  @Test void testSecond() {
+  @Test void second() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SECOND, VM_FENNEL, VM_JAVA);
 
@@ -8395,7 +8395,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("second(cast(null as timestamp))");
   }
 
-  @Test void testExtractIntervalYearMonth() {
+  @Test void extractIntervalYearMonth() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8465,7 +8465,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "extract(millennium from " + "interval '2005-3' year(4) to month)", "2", "BIGINT NOT NULL");
   }
 
-  @Test void testExtractIntervalDayTime() {
+  @Test void extractIntervalDayTime() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8560,7 +8560,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testExtractDate() {
+  @Test void extractDate() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8610,7 +8610,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkScalar("extract(millennium from date '2001-01-01')", "3", "BIGINT NOT NULL");
   }
 
-  @Test void testExtractTimestamp() {
+  @Test void extractTimestamp() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8652,7 +8652,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "extract(millennium from timestamp '2000-2-23 12:34:56')", "2", "BIGINT NOT NULL");
   }
 
-  @Test void testExtractInterval() {
+  @Test void extractInterval() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8694,7 +8694,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("extract(month from cast(null as interval year))");
   }
 
-  @Test void testExtractFuncFromDateTime() {
+  @Test void extractFuncFromDateTime() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
     f.checkScalar("extract(year from date '2008-2-23')", "2008", "BIGINT NOT NULL");
@@ -8711,7 +8711,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("extract(nanosecond from cast(null as time))");
   }
 
-  @Test void testExtractWithDatesBeforeUnixEpoch() {
+  @Test void extractWithDatesBeforeUnixEpoch() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar(
         "extract(millisecond from" + " TIMESTAMP '1969-12-31 21:13:17.357')",
@@ -8747,7 +8747,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "BIGINT NOT NULL");
   }
 
-  @Test void testArrayValueConstructor() {
+  @Test void arrayValueConstructor() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ARRAY_VALUE_CONSTRUCTOR, VmName.EXPAND);
     f.checkScalar("Array['foo']", "[foo]", "CHAR(3) NOT NULL ARRAY NOT NULL");
@@ -8761,7 +8761,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
   }
 
   /** Test case for {@link SqlLibraryOperators#ARRAY} (Spark). */
-  @Test void testArrayFunction() {
+  @Test void arrayFunction() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.ARRAY, VmName.EXPAND);
     f.checkFails("^array()^", "No match found for function signature ARRAY\\(\\)", false);
@@ -8781,7 +8781,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * ARRAY, MULTISET functions should return an collection of scalars if a sub-query returns 1
    * column</a>.
    */
-  @Test void testArrayQueryConstructor() {
+  @Test void arrayQueryConstructor() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ARRAY_QUERY, SqlOperatorFixture.VmName.EXPAND);
     f.checkScalar("array(select 1)", "[1]", "INTEGER NOT NULL ARRAY NOT NULL");
@@ -8796,7 +8796,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * ARRAY, MULTISET functions should return an collection of scalars if a sub-query returns 1
    * column</a>.
    */
-  @Test void testMultisetQueryConstructor() {
+  @Test void multisetQueryConstructor() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_QUERY, SqlOperatorFixture.VmName.EXPAND);
     f.checkScalar("multiset(select 1)", "[1]", "INTEGER NOT NULL MULTISET NOT NULL");
@@ -8806,7 +8806,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "[{1, 2}]");
   }
 
-  @Test void testItemOp() {
+  @Test void itemOp() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ITEM, VmName.EXPAND);
     f.checkScalar("ARRAY ['foo', 'bar'][1]", "foo", "CHAR(3)");
@@ -8858,7 +8858,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testOffsetOperator() {
+  @Test void offsetOperator() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.OFFSET);
     f0.checkFails(
@@ -8878,7 +8878,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testOrdinalOperator() {
+  @Test void ordinalOperator() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ORDINAL);
     f0.checkFails(
@@ -8898,7 +8898,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testSafeOffsetOperator() {
+  @Test void safeOffsetOperator() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.SAFE_OFFSET);
     f0.checkFails(
@@ -8920,7 +8920,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testSafeOrdinalOperator() {
+  @Test void safeOrdinalOperator() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.SAFE_ORDINAL);
     f0.checkFails(
@@ -8942,7 +8942,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testMapValueConstructor() {
+  @Test void mapValueConstructor() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MAP_VALUE_CONSTRUCTOR, VM_JAVA);
 
@@ -8961,7 +8961,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "(VARCHAR(10) NOT NULL, INTEGER NOT NULL) MAP NOT NULL");
   }
 
-  @Test void testCeilFunc() {
+  @Test void ceilFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CEIL, VM_FENNEL);
     f.checkScalarApprox("ceil(10.1e0)", "DOUBLE NOT NULL", isExactly(11));
@@ -8973,7 +8973,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("ceiling(cast(null as double))");
   }
 
-  @Test void testCeilFuncInterval() {
+  @Test void ceilFuncInterval() {
     final SqlOperatorFixture f = fixture();
     if (!f.brokenTestsEnabled()) {
       return;
@@ -8989,7 +8989,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("ceil(cast(null as interval year))");
   }
 
-  @Test void testFloorFunc() {
+  @Test void floorFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.FLOOR, VM_FENNEL);
     f.checkScalarApprox("floor(2.5e0)", "DOUBLE NOT NULL", isExactly(2));
@@ -9001,7 +9001,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("floor(cast(null as real))");
   }
 
-  @Test void testBigQueryCeilFunc() {
+  @Test void bigQueryCeilFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.checkType("ceil(cast(3 as tinyint))", "TINYINT NOT NULL");
     final SqlOperatorFixture f =
@@ -9018,7 +9018,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("ceil(cast(null as tinyint))");
   }
 
-  @Test void testBigQueryFloorFunc() {
+  @Test void bigQueryFloorFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.checkType("floor(cast(3 as tinyint))", "TINYINT NOT NULL");
     final SqlOperatorFixture f =
@@ -9035,7 +9035,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("floor(cast(null as tinyint))");
   }
 
-  @Test void testFloorFuncDateTime() {
+  @Test void floorFuncDateTime() {
     final SqlOperatorFixture f = fixture();
     f.enableTypeCoercion(false)
         .checkFails(
@@ -9087,7 +9087,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("floor(cast(null as date) to month)");
   }
 
-  @Test void testCeilFuncDateTime() {
+  @Test void ceilFuncDateTime() {
     final SqlOperatorFixture f = fixture();
     f.enableTypeCoercion(false)
         .checkFails(
@@ -9156,7 +9156,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * Tests {@code FLOOR}, {@code CEIL}, {@code TIMESTAMPADD}, {@code TIMESTAMPDIFF} functions with
    * custom time frames.
    */
-  @Test void testCustomTimeFrame() {
+  @Test void customTimeFrame() {
     final SqlOperatorFixture f =
         fixture()
             .withFactory(
@@ -9254,7 +9254,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
             "INTEGER NOT NULL");
   }
 
-  @Test void testFloorFuncInterval() {
+  @Test void floorFuncInterval() {
     final SqlOperatorFixture f = fixture();
     if (!f.brokenTestsEnabled()) {
       return;
@@ -9297,7 +9297,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("floor(cast(null as interval year))");
   }
 
-  @Test void testTimestampAdd() {
+  @Test void timestampAdd() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TIMESTAMP_ADD, VmName.EXPAND);
     MICROSECOND_VARIANTS.forEach(
@@ -9485,7 +9485,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
                 "timestampadd(" + s + ", -1, time '23:59:59')", "23:59:59", "TIME(0) NOT NULL"));
   }
 
-  @Test void testTimestampAddFractionalSeconds() {
+  @Test void timestampAddFractionalSeconds() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TIMESTAMP_ADD, VmName.EXPAND);
     f.checkType(
@@ -9520,7 +9520,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * Tests {@code TIMESTAMP_ADD}, BigQuery's 2-argument variant of the 3-argument {@code
    * TIMESTAMPADD} function.
    */
-  @Test void testTimestampAdd2() {
+  @Test void timestampAdd2() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIMESTAMP_ADD2);
     f0.checkFails(
         "^timestamp_add(timestamp '2008-12-25 15:30:00', " + "interval 5 minute)^",
@@ -9574,7 +9574,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * TIMESTAMP} values rather than the {@code DATETIME} alias because the operator fixture does not
    * currently support type aliases.
    */
-  @Test void testDatetimeAdd() {
+  @Test void datetimeAdd() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.DATETIME_ADD);
     f0.checkFails(
         "^datetime_add(timestamp '2008-12-25 15:30:00', " + "interval 5 minute)^",
@@ -9627,7 +9627,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * timestamps. In {@code TIMESTAMPDIFF} it is (t2 - t1) while for {@code TIMESTAMP_DIFF} is is (t1
    * - t2).
    */
-  @Test void testTimestampDiff3() {
+  @Test void timestampDiff3() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIMESTAMP_DIFF3);
     f0.checkFails(
         "^timestamp_diff(timestamp '2008-12-25 15:30:00', "
@@ -9794,7 +9794,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * below use {@code TIMESTAMP} values rather than the {@code DATETIME} alias because the operator
    * fixture does not currently support type aliases.
    */
-  @Test void testDatetimeDiff() {
+  @Test void datetimeDiff() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.DATETIME_DIFF);
     f0.checkFails(
         "^datetime_diff(timestamp '2008-12-25 15:30:00', "
@@ -9954,9 +9954,9 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
                 "INTEGER"));
   }
 
-  @ValueSource(booleans = {true, false})
   @ParameterizedTest(name = "CoercionEnabled: {0}")
-  void testTimestampDiff(boolean coercionEnabled) {
+  @ValueSource(booleans = {true, false})
+  void timestampDiff(boolean coercionEnabled) {
     final SqlOperatorFixture f =
         fixture().withValidatorConfig(c -> c.withTypeCoercionEnabled(coercionEnabled));
     f.setFor(SqlStdOperatorTable.TIMESTAMP_DIFF, VmName.EXPAND);
@@ -10163,7 +10163,7 @@ void testTimestampDiff(boolean coercionEnabled) {
                 "INTEGER"));
   }
 
-  @Test void testTimestampSub() {
+  @Test void timestampSub() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIMESTAMP_SUB);
     f0.checkFails(
         "^timestamp_sub(timestamp '2008-12-25 15:30:00', " + "interval 5 minute)^",
@@ -10226,7 +10226,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkNull("timestamp_sub(CAST(NULL AS TIMESTAMP), interval 5 minute)");
   }
 
-  @Test void testTimeSub() {
+  @Test void timeSub() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIME_SUB);
     f0.checkFails(
         "^time_sub(time '15:30:00', " + "interval 5 minute)^",
@@ -10253,7 +10253,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkNull("time_sub(CAST(NULL AS TIME), interval 5 minute)");
   }
 
-  @Test void testDateSub() {
+  @Test void dateSub() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.DATE_SUB);
     f0.checkFails(
         "^date_sub(date '2008-12-25', " + "interval 5 day)^",
@@ -10278,7 +10278,7 @@ void testTimestampDiff(boolean coercionEnabled) {
    * support type aliases, TIMESTAMPs are used in place of DATETIMEs (a Calcite alias of TIMESTAMP)
    * for the function's first argument.
    */
-  @Test void testDatetimeSub() {
+  @Test void datetimeSub() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.DATETIME_SUB);
     f0.checkFails(
         "^datetime_sub(timestamp '2008-12-25 15:30:00', " + "interval 5 minute)^",
@@ -10329,7 +10329,7 @@ void testTimestampDiff(boolean coercionEnabled) {
    * The {@code DATEDIFF} function is implemented in the Babel parser but not the Core parser, and
    * therefore gives validation errors.
    */
-  @Test void testDateDiff() {
+  @Test void dateDiff() {
     final SqlOperatorFixture f = fixture().setFor(SqlLibraryOperators.DATEDIFF);
     f.checkFails(
         "datediff(^\"MONTH\"^, '2019-09-14',  '2019-09-15')",
@@ -10338,7 +10338,7 @@ void testTimestampDiff(boolean coercionEnabled) {
   }
 
   /** Tests BigQuery's {@code TIME_ADD}, which adds an interval to a time expression. */
-  @Test void testTimeAdd() {
+  @Test void timeAdd() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIME_ADD);
     f0.checkFails(
         "^time_add(time '15:30:00', interval 5 minute)^",
@@ -10367,7 +10367,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkNull("time_add(cast(null as time), interval 5 minute)");
   }
 
-  @Test void testTimeDiff() {
+  @Test void timeDiff() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIME_DIFF);
     f0.checkFails(
         "^time_diff(time '15:30:00', " + "time '16:30:00', " + "minute)^",
@@ -10412,7 +10412,7 @@ void testTimestampDiff(boolean coercionEnabled) {
                 "INTEGER"));
   }
 
-  @Test void testTimeTrunc() {
+  @Test void timeTrunc() {
     SqlOperatorFixture nonBigQuery = fixture().setFor(SqlLibraryOperators.TIME_TRUNC);
     nonBigQuery.checkFails(
         "^time_trunc(time '15:30:00', hour)^",
@@ -10434,7 +10434,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkNull("time_trunc(cast(null as time), second)");
   }
 
-  @Test void testTimestampTrunc() {
+  @Test void timestampTrunc() {
     SqlOperatorFixture nonBigQuery = fixture().setFor(SqlLibraryOperators.TIMESTAMP_TRUNC);
     nonBigQuery.checkFails(
         "^timestamp_trunc(timestamp '2012-05-02 15:30:00', hour)^",
@@ -10526,7 +10526,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testDatetimeTrunc() {
+  @Test void datetimeTrunc() {
     SqlOperatorFixture nonBigQuery = fixture().setFor(SqlLibraryOperators.DATETIME_TRUNC);
     nonBigQuery.checkFails(
         "^datetime_trunc(timestamp '2012-05-02 15:30:00', hour)^",
@@ -10604,7 +10604,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testDateTrunc() {
+  @Test void dateTrunc() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.DATE_TRUNC);
     f.checkFails(
@@ -10643,7 +10643,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkScalar("date_trunc(date '2015-02-19', millennium)", "2001-01-01", "DATE NOT NULL");
   }
 
-  @Test void testFormatTime() {
+  @Test void formatTime() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.FORMAT_TIME);
     f.checkFails(
@@ -10660,7 +10660,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         "The time is 34-33", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testFormatDate() {
+  @Test void formatDate() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.FORMAT_DATE);
     f.checkFails(
@@ -10682,7 +10682,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         "The date is: 12/25/08", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testFormatTimestamp() {
+  @Test void formatTimestamp() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.FORMAT_TIMESTAMP);
     f.checkFails(
@@ -10717,7 +10717,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         "The time is: 15:30.123", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testParseDate() {
+  @Test void parseDate() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.PARSE_DATE);
     f.checkScalar(
@@ -10729,7 +10729,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkScalar("PARSE_DATE('%F', '2022-06-01')", "2022-06-01", "DATE NOT NULL");
   }
 
-  @Test void testParseDatetime() {
+  @Test void parseDatetime() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.PARSE_DATETIME);
     f.checkScalar(
@@ -10749,7 +10749,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         "2018-12-19 00:00:00", "TIMESTAMP(0) NOT NULL");
   }
 
-  @Test void testParseTime() {
+  @Test void parseTime() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.PARSE_TIME);
     f.checkScalar("PARSE_TIME('%I:%M:%S', '07:30:00')", "07:30:00", "TIME(0) NOT NULL");
@@ -10758,7 +10758,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkScalar("PARSE_TIME('%I:%M:%S %p', '2:23:38 pm')", "14:23:38", "TIME(0) NOT NULL");
   }
 
-  @Test void testParseTimestamp() {
+  @Test void parseTimestamp() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.PARSE_TIMESTAMP);
     f.checkScalar(
@@ -10772,32 +10772,32 @@ void testTimestampDiff(boolean coercionEnabled) {
         "2008-12-25 07:30:00", "TIMESTAMP_WITH_LOCAL_TIME_ZONE(0) NOT NULL");
   }
 
-  @Test void testDenseRankFunc() {
+  @Test void denseRankFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DENSE_RANK, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testPercentRankFunc() {
+  @Test void percentRankFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PERCENT_RANK, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testRankFunc() {
+  @Test void rankFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RANK, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testCumeDistFunc() {
+  @Test void cumeDistFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CUME_DIST, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testRowNumberFunc() {
+  @Test void rowNumberFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ROW_NUMBER, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testPercentileContFunc() {
+  @Test void percentileContFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PERCENTILE_CONT, VM_FENNEL, VM_JAVA);
     f.checkType("percentile_cont(0.25) within group (order by 1)", "INTEGER NOT NULL");
@@ -10820,7 +10820,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testPercentileDiscFunc() {
+  @Test void percentileDiscFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PERCENTILE_DISC, VM_FENNEL, VM_JAVA);
     f.checkType("percentile_disc(0.25) within group (order by 1)", "INTEGER NOT NULL");
@@ -10843,7 +10843,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testPercentileContBigQueryFunc() {
+  @Test void percentileContBigQueryFunc() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.PERCENTILE_CONT2, SqlOperatorFixture.VmName.EXPAND)
@@ -10858,7 +10858,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testPercentileDiscBigQueryFunc() {
+  @Test void percentileDiscBigQueryFunc() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.PERCENTILE_DISC2, SqlOperatorFixture.VmName.EXPAND)
@@ -10873,7 +10873,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testCountFunc() {
+  @Test void countFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COUNT, VM_EXPAND);
     f.checkType("count(*)", "BIGINT NOT NULL");
@@ -10900,7 +10900,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("COUNT(DISTINCT 123)", stringValues, isSingle(1));
   }
 
-  @Test void testCountifFunc() {
+  @Test void countifFunc() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.COUNTIF, VM_FENNEL, VM_JAVA)
@@ -10928,7 +10928,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("countif(x < 0)", values, isSingle(0));
   }
 
-  @Test void testApproxCountDistinctFunc() {
+  @Test void approxCountDistinctFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COUNT, VM_EXPAND);
     f.checkFails("approx_count_distinct(^*^)", "Unknown identifier '\\*'", false);
@@ -10957,7 +10957,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("APPROX_COUNT_DISTINCT(DISTINCT 123)", stringValues, isSingle(1));
   }
 
-  @Test void testSumFunc() {
+  @Test void sumFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SUM, VM_EXPAND);
     f.checkFails("sum(^*^)", "Unknown identifier '\\*'", false);
@@ -10998,7 +10998,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("sum(DISTINCT x)", values, isSingle(2));
   }
 
-  @Test void testAvgFunc() {
+  @Test void avgFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.AVG, VM_EXPAND);
     f.checkFails("avg(^*^)", "Unknown identifier '\\*'", false);
@@ -11024,7 +11024,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("avg(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)", values, isSingle(-1));
   }
 
-  @Test void testCovarPopFunc() {
+  @Test void covarPopFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COVAR_POP, VM_EXPAND);
     f.checkFails("covar_pop(^*^)", "Unknown identifier '\\*'", false);
@@ -11046,7 +11046,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("covar_pop(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testCovarSampFunc() {
+  @Test void covarSampFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COVAR_SAMP, VM_EXPAND);
     f.checkFails("covar_samp(^*^)", "Unknown identifier '\\*'", false);
@@ -11068,7 +11068,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("covar_samp(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testRegrSxxFunc() {
+  @Test void regrSxxFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.REGR_SXX, VM_EXPAND);
     f.checkFails("regr_sxx(^*^)", "Unknown identifier '\\*'", false);
@@ -11090,7 +11090,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("regr_sxx(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testRegrSyyFunc() {
+  @Test void regrSyyFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.REGR_SYY, VM_EXPAND);
     f.checkFails("regr_syy(^*^)", "Unknown identifier '\\*'", false);
@@ -11112,7 +11112,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("regr_syy(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testStddevPopFunc() {
+  @Test void stddevPopFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.STDDEV_POP, VM_EXPAND);
     f.checkFails("stddev_pop(^*^)", "Unknown identifier '\\*'", false);
@@ -11140,7 +11140,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("stddev_pop(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testStddevSampFunc() {
+  @Test void stddevSampFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.STDDEV_SAMP, VM_EXPAND);
     f.checkFails("stddev_samp(^*^)", "Unknown identifier '\\*'", false);
@@ -11170,7 +11170,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("stddev_samp(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testStddevFunc() {
+  @Test void stddevFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.STDDEV, VM_EXPAND);
     f.checkFails("stddev(^*^)", "Unknown identifier '\\*'", false);
@@ -11190,7 +11190,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("stddev(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testVarPopFunc() {
+  @Test void varPopFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.VAR_POP, VM_EXPAND);
     f.checkFails("var_pop(^*^)", "Unknown identifier '\\*'", false);
@@ -11220,7 +11220,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("var_pop(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testVarSampFunc() {
+  @Test void varSampFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.VAR_SAMP, VM_EXPAND);
     f.checkFails("var_samp(^*^)", "Unknown identifier '\\*'", false);
@@ -11250,7 +11250,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("var_samp(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testVarFunc() {
+  @Test void varFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.VARIANCE, VM_EXPAND);
     f.checkFails("variance(^*^)", "Unknown identifier '\\*'", false);
@@ -11280,7 +11280,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("variance(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testMinFunc() {
+  @Test void minFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MIN, VM_EXPAND);
     f.checkFails("min(^*^)", "Unknown identifier '\\*'", false);
@@ -11305,7 +11305,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("min(DISTINCT x)", values, isSingle("0"));
   }
 
-  @Test void testMaxFunc() {
+  @Test void maxFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MAX, VM_EXPAND);
     f.checkFails("max(^*^)", "Unknown identifier '\\*'", false);
@@ -11330,7 +11330,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("max(DISTINCT x)", values, isSingle("2"));
   }
 
-  @Test void testLastValueFunc() {
+  @Test void lastValueFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LAST_VALUE, VM_EXPAND);
     final String[] values = {"0", "CAST(null AS INTEGER)", "3", "3"};
@@ -11354,7 +11354,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         isSet("foo ", "bar ", "name"));
   }
 
-  @Test void testFirstValueFunc() {
+  @Test void firstValueFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.FIRST_VALUE, VM_EXPAND);
     final String[] values = {"0", "CAST(null AS INTEGER)", "3", "3"};
@@ -11369,7 +11369,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkWinAgg("first_value(x)", values3, "ROWS 3 PRECEDING", "CHAR(4) NOT NULL", isSet("foo "));
   }
 
-  @Test void testEveryFunc() {
+  @Test void everyFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EVERY, VM_EXPAND);
     f.checkFails("every(^*^)", "Unknown identifier '\\*'", false);
@@ -11388,7 +11388,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("every(x = 2)", values, isSingle("false"));
   }
 
-  @Test void testSomeAggFunc() {
+  @Test void someAggFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SOME, VM_EXPAND);
     f.checkFails("some(^*^)", "Unknown identifier '\\*'", false);
@@ -11411,7 +11411,7 @@ void testTimestampDiff(boolean coercionEnabled) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5160">[CALCITE-5160]
    * ANY/SOME, ALL operators should support collection expressions</a>.
    */
-  @Test void testQuantifyCollectionOperators() {
+  @Test void quantifyCollectionOperators() {
     final SqlOperatorFixture f = fixture();
     QUANTIFY_OPERATORS.forEach(operator -> f.setFor(operator, SqlOperatorFixture.VmName.EXPAND));
 
@@ -11503,7 +11503,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         true);
   }
 
-  @Test void testAnyValueFunc() {
+  @Test void anyValueFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ANY_VALUE, VM_EXPAND);
     f.checkFails("any_value(^*^)", "Unknown identifier '\\*'", false);
@@ -11528,7 +11528,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("any_value(DISTINCT x)", values, isSingle("0"));
   }
 
-  @Test void testBoolAndFunc() {
+  @Test void boolAndFunc() {
     final SqlOperatorFixture f = fixture();
     // not in standard dialect
     final String[] values = {"true", "true", "null"};
@@ -11570,7 +11570,7 @@ private static void checkBoolAndFunc(SqlOperatorFixture f) {
     f.checkAgg("bool_and(x)", values4, isNullValue());
   }
 
-  @Test void testBoolOrFunc() {
+  @Test void boolOrFunc() {
     final SqlOperatorFixture f = fixture();
     // not in standard dialect
     final String[] values = {"true", "true", "null"};
@@ -11612,7 +11612,7 @@ private static void checkBoolOrFunc(SqlOperatorFixture f) {
     f.checkAgg("bool_or(x)", values4, isNullValue());
   }
 
-  @Test void testLogicalAndFunc() {
+  @Test void logicalAndFunc() {
     final SqlOperatorFixture f = fixture();
     // not in standard dialect
     final String[] values = {"true", "true", "null"};
@@ -11654,7 +11654,7 @@ private static void checkLogicalAndFunc(SqlOperatorFixture f) {
     f.checkAgg("logical_and(x)", values4, isNullValue());
   }
 
-  @Test void testLogicalOrFunc() {
+  @Test void logicalOrFunc() {
     final SqlOperatorFixture f = fixture();
     // not in standard dialect
     final String[] values = {"true", "true", "null"};
@@ -11696,7 +11696,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
     f.checkAgg("logical_or(x)", values4, isNullValue());
   }
 
-  @Test void testBitAndFunc() {
+  @Test void bitAndFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.BIT_AND, VM_FENNEL, VM_JAVA);
     f.checkFails("bit_and(^*^)", "Unknown identifier '\\*'", false);
@@ -11740,7 +11740,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
         true);
   }
 
-  @Test void testBitOrFunc() {
+  @Test void bitOrFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.BIT_OR, VM_FENNEL, VM_JAVA);
     f.checkFails("bit_or(^*^)", "Unknown identifier '\\*'", false);
@@ -11776,7 +11776,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
     f.checkAgg("bit_or(x)", new String[] {"CAST(x'02' AS BINARY)"}, isSingle("02"));
   }
 
-  @Test void testBitXorFunc() {
+  @Test void bitXorFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.BIT_XOR, VM_FENNEL, VM_JAVA);
     f.checkFails("bit_xor(^*^)", "Unknown identifier '\\*'", false);
@@ -11816,7 +11816,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
         isSingle("02"));
   }
 
-  @Test void testArgMin() {
+  @Test void argMin() {
     final SqlOperatorFixture f0 = fixture().withTester(t -> TESTER);
     final String[] xValues = {"2", "3", "4", "4", "5", "7"};
 
@@ -11846,7 +11846,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
    *   <li>CAST(123.4567891234567 AS FLOAT) fails because the value loses precision.
    * </ul>
    */
-  @Test void testLiteralAtLimit() {
+  @Test void literalAtLimit() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     if (!f.brokenTestsEnabled()) {
@@ -11885,7 +11885,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
    *   <li>CAST(123.4567891234567 AS FLOAT) fails because the value loses precision.
    * </ul>
    */
-  @Test void testLiteralBeyondLimit() {
+  @Test void literalBeyondLimit() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     final List<RelDataType> types = SqlTests.getTypes(f.getFactory().getTypeFactory());
@@ -11925,9 +11925,9 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
     }
   }
 
-  @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastTruncates(CastType castType, SqlOperatorFixture f) {
+  @ParameterizedTest
+  void castTruncates(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     f.checkScalar("CAST('ABCD' AS CHAR(2))", "AB", "CHAR(2) NOT NULL");
     f.checkScalar("CAST('ABCD' AS VARCHAR(2))", "AB", "VARCHAR(2) NOT NULL");
@@ -11960,7 +11960,7 @@ void testCastTruncates(CastType castType, SqlOperatorFixture f) {
    */
   @Disabled("Too slow and not really a unit test")
   @Tag("slow")
-  @Test void testArgumentBounds() {
+  @Test void argumentBounds() {
     final SqlOperatorFixture f = fixture();
     final SqlValidatorImpl validator = (SqlValidatorImpl) f.getFactory().createValidator();
     final SqlValidatorScope scope = validator.getEmptyScope();
@@ -12051,7 +12051,7 @@ void testCastTruncates(CastType castType, SqlOperatorFixture f) {
             // difficult to read since it either contains too much information
             // or very few details.
             Throwable cause = findMostDescriptiveCause(e);
-            LOGGER.info("Failed: " + s + ": " + cause);
+            LOGGER.info("Failed: {}: {}", s, cause);
           }
         }
       }
diff --git a/testkit/src/main/java/org/apache/calcite/test/SqlValidatorFixture.java b/testkit/src/main/java/org/apache/calcite/test/SqlValidatorFixture.java
index e66109bfc..9c2cf83a0 100644
--- a/testkit/src/main/java/org/apache/calcite/test/SqlValidatorFixture.java
+++ b/testkit/src/main/java/org/apache/calcite/test/SqlValidatorFixture.java
@@ -46,14 +46,14 @@
 import org.apache.calcite.util.TestUtil;
 import org.apache.calcite.util.Util;
 
-import com.google.common.base.Preconditions;
-
 import org.hamcrest.Matcher;
 
 import java.nio.charset.Charset;
 import java.util.List;
 import java.util.function.UnaryOperator;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.sql.SqlUtil.stripAs;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -180,7 +180,7 @@ public SqlValidatorFixture withLenientOperatorLookup(boolean lenient) {
   }
 
   public SqlValidatorFixture withWhole(boolean whole) {
-    Preconditions.checkArgument(sap.cursor < 0);
+    checkArgument(sap.cursor < 0);
     final StringAndPos sap = StringAndPos.of("^" + this.sap.sql + "^");
     return new SqlValidatorFixture(tester, factory, sap, expression, whole);
   }
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/CompoundNameColumnResolver.java b/testkit/src/main/java/org/apache/calcite/test/catalog/CompoundNameColumnResolver.java
index b7f739eb7..06f7c40f4 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/CompoundNameColumnResolver.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/CompoundNameColumnResolver.java
@@ -28,11 +28,12 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import static java.util.Map.Entry.comparingByValue;
+
 /**
  * ColumnResolver implementation that resolves CompoundNameColumn by simulating Phoenix behaviors.
  */
@@ -101,7 +102,7 @@ final class CompoundNameColumnResolver implements MockCatalogReader.ColumnResolv
       Map<String, Integer> subMap = groupMap.get(columnName);
       if (subMap != null) {
         PairList<String, Integer> entries = PairList.of(subMap);
-        entries.sort(Comparator.comparingInt(Map.Entry::getValue));
+        entries.sort(comparingByValue());
         ret.add(
             new Pair<>(
                 new RelDataTypeFieldImpl(
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/CountingFactory.java b/testkit/src/main/java/org/apache/calcite/test/catalog/CountingFactory.java
index 877651971..5b8130921 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/CountingFactory.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/CountingFactory.java
@@ -27,8 +27,6 @@
 import org.apache.calcite.sql2rel.InitializerExpressionFactory;
 import org.apache.calcite.sql2rel.NullInitializerExpressionFactory;
 
-import com.google.common.collect.ImmutableList;
-
 import java.math.BigDecimal;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -45,7 +43,7 @@ public class CountingFactory extends NullInitializerExpressionFactory {
   private final List<String> defaultColumns;
 
   CountingFactory(List<String> defaultColumns) {
-    this.defaultColumns = ImmutableList.copyOf(defaultColumns);
+    this.defaultColumns = defaultColumns;
   }
 
   @Override public ColumnStrategy generationStrategy(RelOptTable table, int iColumn) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java b/testkit/src/main/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java
index 310f520e7..56e952508 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java
@@ -46,12 +46,12 @@ class EmpInitializerExpressionFactory extends NullInitializerExpressionFactory {
     switch (iColumn) {
       case 0:
         return rexBuilder.makeExactLiteral(
-            new BigDecimal(123), typeFactory.createSqlType(SqlTypeName.INTEGER));
+            BigDecimal.valueOf(123), typeFactory.createSqlType(SqlTypeName.INTEGER));
       case 1:
         return rexBuilder.makeLiteral("Bob");
       case 5:
         return rexBuilder.makeExactLiteral(
-            new BigDecimal(555), typeFactory.createSqlType(SqlTypeName.INTEGER));
+            BigDecimal.valueOf(555), typeFactory.createSqlType(SqlTypeName.INTEGER));
       default:
         return super.newColumnDefaultValue(table, iColumn, context);
     }
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReader.java b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReader.java
index 6dc407d80..f3dbdb194 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReader.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReader.java
@@ -376,7 +376,7 @@ private MockTable(
       this.names = names;
       this.resolver = resolver;
       this.initializerFactory = initializerFactory;
-      this.wraps = ImmutableList.copyOf(wraps);
+      this.wraps = wraps;
       this.maxRowCount = maxRowCount;
     }
 
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderDynamic.java b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderDynamic.java
index 73e95e57a..e046369b9 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderDynamic.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderDynamic.java
@@ -23,10 +23,11 @@
 import org.apache.calcite.schema.impl.ViewTable;
 import org.apache.calcite.sql.type.SqlTypeName;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.NonNull;
 
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Supplier;
 
@@ -87,9 +88,9 @@ protected MockCatalogReaderDynamic(RelDataTypeFactory typeFactory, boolean caseS
             rootSchema,
             "select n_name from SALES.CUSTOMER",
             custModifiableViewNames.subList(0, 2),
-            Collections.singletonList(custModifiableViewNames.get(2)),
+            ImmutableList.of(custModifiableViewNames.get(2)),
             true);
-    TranslatableTable empModifiableView = custModifiableViewMacro.apply(Collections.emptyList());
+    TranslatableTable empModifiableView = custModifiableViewMacro.apply(ImmutableList.of());
     MockTable mockCustViewTable =
         MockRelViewTable.create(
             (ViewTable) empModifiableView,
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderSimple.java b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderSimple.java
index 7cbd92548..a602dff9a 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderSimple.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderSimple.java
@@ -454,7 +454,7 @@ private void registerStructTypeTables(Fixture fixture) {
             return rexBuilder.makeCall(
                 SqlStdOperatorTable.EQUALS,
                 rexBuilder.makeInputRef(c0Field.getType(), c0Field.getIndex()),
-                rexBuilder.makeExactLiteral(BigDecimal.valueOf(10L), c0Field.getType()));
+                rexBuilder.makeExactLiteral(BigDecimal.TEN, c0Field.getType()));
           }
         };
     structTypeSchema.addTable(Util.last(struct10View.getQualifiedName()));
diff --git a/testkit/src/main/java/org/apache/calcite/test/schemata/bookstore/BookstoreSchema.java b/testkit/src/main/java/org/apache/calcite/test/schemata/bookstore/BookstoreSchema.java
index 2b9fda790..0da60fc86 100644
--- a/testkit/src/main/java/org/apache/calcite/test/schemata/bookstore/BookstoreSchema.java
+++ b/testkit/src/main/java/org/apache/calcite/test/schemata/bookstore/BookstoreSchema.java
@@ -16,9 +16,10 @@
  */
 package org.apache.calcite.test.schemata.bookstore;
 
+import com.google.common.collect.ImmutableList;
+
 import java.math.BigDecimal;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -43,8 +44,8 @@ public final class BookstoreSchema {
             new Coordinate(BigDecimal.valueOf(47.24), BigDecimal.valueOf(6.02)),
             "Besanon",
             "France"),
-        Collections.singletonList(
-            new Book("Les Misrables", 1862, Collections.singletonList(new Page(1, "Contents"))))),
+        ImmutableList.of(
+            new Book("Les Misrables", 1862, ImmutableList.of(new Page(1, "Contents"))))),
     new Author(
         2,
         "Nikos Kazantzakis",
@@ -58,10 +59,8 @@ public final class BookstoreSchema {
                 1946,
                 Arrays.asList(new Page(1, "Contents"), new Page(2, "Acknowledgements"))),
             new Book(
-                "The Last Temptation of Christ",
-                1955,
-                Collections.singletonList(new Page(1, "Contents"))))),
-    new Author(3, "Homer", new Place(null, "Ionia", "Greece"), Collections.emptyList())
+                "The Last Temptation of Christ", 1955, ImmutableList.of(new Page(1, "Contents"))))),
+    new Author(3, "Homer", new Place(null, "Ionia", "Greece"), ImmutableList.of())
   };
 
   /** Author. */
diff --git a/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java b/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java
index d51203e05..e8f87b76d 100644
--- a/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java
+++ b/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableList;
 
 import java.util.Arrays;
-import java.util.Collections;
 
 /**
  * A schema that contains two tables by reflection.
@@ -70,7 +69,7 @@ public class HrSchema {
   public final Department[] depts = {
     new Department(10, "Sales", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(30, "Marketing", ImmutableList.of(), new Location(0, 52)),
-    new Department(40, "HR", Collections.singletonList(emps[1]), null),
+    new Department(40, "HR", ImmutableList.of(emps[1]), null),
   };
   public final Dependent[] dependents = {
     new Dependent(10, "Michael"), new Dependent(10, "Jane"),
diff --git a/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchemaBig.java b/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchemaBig.java
index a862cd283..05a9db780 100644
--- a/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchemaBig.java
+++ b/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchemaBig.java
@@ -19,7 +19,6 @@
 import com.google.common.collect.ImmutableList;
 
 import java.util.Arrays;
-import java.util.Collections;
 
 /** HR schema with more data than in {@link HrSchema}. */
 public class HrSchemaBig {
@@ -80,15 +79,15 @@ public class HrSchemaBig {
   public final Department[] depts = {
     new Department(10, "Sales", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(20, "Marketing", ImmutableList.of(), new Location(0, 52)),
-    new Department(30, "HR", Collections.singletonList(emps[1]), null),
+    new Department(30, "HR", ImmutableList.of(emps[1]), null),
     new Department(40, "Administration", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(50, "Design", ImmutableList.of(), new Location(0, 52)),
-    new Department(60, "IT", Collections.singletonList(emps[1]), null),
+    new Department(60, "IT", ImmutableList.of(emps[1]), null),
     new Department(70, "Production", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(80, "Finance", ImmutableList.of(), new Location(0, 52)),
-    new Department(90, "Accounting", Collections.singletonList(emps[1]), null),
+    new Department(90, "Accounting", ImmutableList.of(emps[1]), null),
     new Department(100, "Research", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(110, "Maintenance", ImmutableList.of(), new Location(0, 52)),
-    new Department(120, "Client Support", Collections.singletonList(emps[1]), null),
+    new Department(120, "Client Support", ImmutableList.of(emps[1]), null),
   };
 }
diff --git a/testkit/src/main/java/org/apache/calcite/util/Smalls.java b/testkit/src/main/java/org/apache/calcite/util/Smalls.java
index 5a3560273..a04840a77 100644
--- a/testkit/src/main/java/org/apache/calcite/util/Smalls.java
+++ b/testkit/src/main/java/org/apache/calcite/util/Smalls.java
@@ -73,17 +73,17 @@
 import java.sql.Timestamp;
 import java.util.AbstractList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Objects;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Holder for various classes and functions used in tests as user-defined functions and so forth.
  */
@@ -597,7 +597,7 @@ public static String eval(@Parameter(name = "o") Object o) {
       if (o == null) {
         return "<null>";
       }
-      return "<" + o.toString() + ">";
+      return "<" + o + ">";
     }
   }
 
@@ -912,7 +912,7 @@ public static long result(long accumulator) {
    */
   public static class MyTwoParamsSumFunctionFilter1 {
     public MyTwoParamsSumFunctionFilter1(FunctionContext fx) {
-      Objects.requireNonNull(fx, "fx");
+      requireNonNull(fx, "fx");
       assert fx.getParameterCount() == 2;
     }
 
@@ -1378,7 +1378,7 @@ public static class SimpleTableMacro implements TableMacro {
     }
 
     @Override public List<FunctionParameter> getParameters() {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
   }
 
diff --git a/testkit/src/main/java/org/apache/calcite/util/TestUtil.java b/testkit/src/main/java/org/apache/calcite/util/TestUtil.java
index 03914e006..9668162d5 100644
--- a/testkit/src/main/java/org/apache/calcite/util/TestUtil.java
+++ b/testkit/src/main/java/org/apache/calcite/util/TestUtil.java
@@ -20,8 +20,6 @@
 import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableSortedSet;
 
-import org.junit.jupiter.api.Assertions;
-
 import java.io.File;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -33,6 +31,9 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.fail;
 
 import static java.util.Objects.requireNonNull;
@@ -73,7 +74,7 @@ private static class ExtraInformation extends Throwable {
   // ~ Methods ----------------------------------------------------------------
 
   public static void assertEqualsVerbose(String expected, String actual) {
-    Assertions.assertEquals(
+    assertEquals(
         expected,
         actual,
         () ->
@@ -248,7 +249,7 @@ public static String correctRoundedFloat(String s) {
     final Matcher m2 = TRAILING_NINE_PATTERN.matcher(s);
     if (m2.matches()) {
       s = s.substring(0, s.length() - m2.group(2).length());
-      if (s.length() > 0) {
+      if (!s.isEmpty()) {
         final char c = s.charAt(s.length() - 1);
         switch (c) {
           case '0':
@@ -298,9 +299,7 @@ static int majorVersionFromString(String version) {
     }
     // probably running on > 8 (just get first integer which is major version)
     Matcher matcher = Pattern.compile("^\\d+").matcher(version);
-    if (!matcher.lookingAt()) {
-      throw new IllegalArgumentException("Can't parse (detect) JDK version from " + version);
-    }
+    checkArgument(matcher.lookingAt(), "Can't parse (detect) JDK version from %s", version);
 
     return Integer.parseInt(matcher.group());
   }
