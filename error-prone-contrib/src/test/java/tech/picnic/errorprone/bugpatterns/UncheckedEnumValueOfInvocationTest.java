package tech.picnic.errorprone.bugpatterns;

import com.google.errorprone.CompilationTestHelper;
import org.junit.jupiter.api.Test;

final class UncheckedEnumValueOfInvocationTest {
  @Test
  void identification() {
    CompilationTestHelper.newInstance(UncheckedEnumValueOfInvocation.class, getClass())
        .expectErrorMessage(
            "INVALID_VALUE",
            m ->
                m.contains("is not a valid value for `Test.A`, possible values: [ONE, TWO, THREE]"))
        .expectErrorMessage(
            "MISSING_VALUE", m -> m.contains("might generate values which are missing in `Test.A`"))
        .expectErrorMessage(
            "AVOID_RAW", m -> m.contains("Avoid passing unchecked arguments to `Enum#valueOf`"))
        .addSourceLines(
            "Test.java",
            "class Test {",
            "  void unsafeCases(String raw, B b) {",
            "    // BUG: Diagnostic matches: INVALID_VALUE",
            "    A.valueOf(\"FOUR\");",
            "    // BUG: Diagnostic matches: INVALID_VALUE",
            "    A.valueOf(A.class, \"FOUR\");",
            "    // BUG: Diagnostic matches: AVOID_RAW",
            "    A.valueOf(raw);",
            "    // BUG: Diagnostic matches: AVOID_RAW",
            "    A.valueOf(A.class, raw);",
            "    // BUG: Diagnostic matches: MISSING_VALUE",
            "    A.valueOf(b.name());",
            "    // BUG: Diagnostic matches: MISSING_VALUE",
            "    A.valueOf(A.class, b.name());",
            "    var name =",
            "        switch (b) {",
            "          // BUG: Diagnostic matches: MISSING_VALUE",
            "          case FOUR -> A.valueOf(b.name());",
            "          // BUG: Diagnostic matches: MISSING_VALUE",
            "          case FIVE -> A.valueOf(A.class, b.name());",
            "          default -> null;",
            "        };",
            "    var toString =",
            "        switch (b) {",
            "          // BUG: Diagnostic matches: MISSING_VALUE",
            "          case FOUR -> A.valueOf(b.toString());",
            "          // BUG: Diagnostic matches: MISSING_VALUE",
            "          case FIVE -> A.valueOf(A.class, b.toString());",
            "          default -> null;",
            "        };",
            "    var defaultCase =",
            "        switch (b) {",
            "          case ONE, FOUR -> null;",
            "          // BUG: Diagnostic matches: MISSING_VALUE",
            "          default -> A.valueOf(b.name());",
            "        };",
            "  }",
            "",
            "  // Following cases are marked as no match",
            "  void safeCases(B b, C c) {",
            "    // Given constant is a valid label for A",
            "    A.valueOf(\"ONE\");",
            "    // Given constant is a valid label for A",
            "    A.valueOf(A.class, \"TWO\");",
            "    var a1 =",
            "        switch (b) {",
            "          // Invocation is protected by case labels",
            "          case ONE, THREE -> A.valueOf(A.class, b.name());",
            "          // Invocation is protected by case label",
            "          case TWO -> A.valueOf(b.name());",
            "          // switch and .name() are on different enums, and A > C",
            "          case FOUR -> A.valueOf(c.name());",
            "          default -> null;",
            "        };",
            "    var defaultCase =",
            "        switch (b) {",
            "          case FOUR, FIVE -> null;",
            "          // Invalid labels are filtered by another case leaving valid cases only",
            "          default -> A.valueOf(b.name());",
            "        };",
            "    // A captures all labels of C",
            "    A.valueOf(c.name());",
            "  }",
            "",
            "  // Following cases are ignored for the sake of brevity",
            "  void ignoredCases() {",
            "    A.valueOf(rawMethod());",
            "    A.valueOf(A.class, rawMethod());",
            "    java.util.List.of(\"\").stream().map(A::valueOf);",
            "  }",
            "",
            "  String rawMethod() {",
            "    return \"FIVE\";",
            "  }",
            "",
            "  enum A {",
            "    ONE,",
            "    TWO,",
            "    THREE",
            "  }",
            "",
            "  enum B {",
            "    ONE,",
            "    TWO,",
            "    THREE,",
            "    FOUR,",
            "    FIVE",
            "  }",
            "",
            "  enum C {",
            "    ONE,",
            "    TWO",
            "  }",
            "",
            "}")
        .doTest();
  }
}
