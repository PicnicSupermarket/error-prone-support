package tech.picnic.errorprone.bugpatterns;

import com.google.errorprone.BugCheckerRefactoringTestHelper;
import com.google.errorprone.BugCheckerRefactoringTestHelper.TestMode;
import com.google.errorprone.CompilationTestHelper;
import org.junit.jupiter.api.Test;

final class JUnitFactoryMethodDeclarationTest {
  @Test
  void identification() {
    CompilationTestHelper.newInstance(JUnitFactoryMethodDeclaration.class, getClass())
        .addSourceLines(
            "A.java",
            "import static org.junit.jupiter.params.provider.Arguments.arguments;",
            "",
            "import java.util.List;",
            "import java.util.stream.Stream;",
            "import org.junit.jupiter.params.ParameterizedTest;",
            "import org.junit.jupiter.params.provider.Arguments;",
            "import org.junit.jupiter.params.provider.MethodSource;",
            "",
            "class A extends SuperA {",
            "  @ParameterizedTest",
            "  // BUG: Diagnostic contains: The test cases should be supplied by a method named",
            "  // `method1TestCases`",
            "  @MethodSource(\"testCasesForMethod1\")",
            "  void method1(int foo, boolean bar, String baz) {}",
            "",
            "  // BUG: Diagnostic contains: The test cases should be supplied by a method named",
            "  // `method1TestCases`",
            "  private static Stream<Arguments> testCasesForMethod1() {",
            "    /* { foo, bar, baz } */",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "",
            "  @ParameterizedTest",
            "  @MethodSource(\"method2TestCases\")",
            "  void method2(int foo, boolean bar, String baz) {}",
            "",
            "  private static Stream<Arguments> method2TestCases() {",
            "    /* { foo, bar, baz } */",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "",
            "  private static void method2TestCases(int i) {}",
            "",
            "  @ParameterizedTest",
            "  @MethodSource(\"method3TestCases\")",
            "  void method3(int foo, boolean bar, String baz) {}",
            "",
            "  private static Stream<Arguments> method3TestCases() {",
            "    // BUG: Diagnostic contains: The return statement should be prefixed by a comment giving the",
            "    // names of the test case parameters",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "",
            "  @ParameterizedTest",
            "  @MethodSource(\"method4TestCases\")",
            "  void method4(int foo, boolean bar, String baz) {}",
            "",
            "  private static Stream<Arguments> method4TestCases() {",
            "    /* { foo, bar, baz } */",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "",
            "  @ParameterizedTest",
            "  @MethodSource(\"testCasesForMethod5\")",
            "  void method5(int foo, boolean bar, String baz) {}",
            "",
            "  void method5TestCases() {}",
            "",
            "  // BUG: Diagnostic contains: The test cases should be supplied by a method named",
            "  // `method5TestCases` (but note that a method named `method5TestCases` is already defined in this",
            "  // class or a supertype)",
            "  private static Stream<Arguments> testCasesForMethod5() {",
            "    /* { foo, bar, baz } */",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "",
            "  @ParameterizedTest",
            "  @MethodSource(\"method6TestCases\")",
            "  void method6(int foo, boolean bar, String baz) {}",
            "",
            "  private static Stream<Arguments> method6TestCases() {",
            "    List<Arguments> arguments = List.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "    /* { foo, bar, baz } */",
            "    return arguments.stream();",
            "  }",
            "",
            "  @ParameterizedTest",
            "  @MethodSource(\"method7TestCases\")",
            "  void method7(int foo, boolean bar, String baz) {}",
            "",
            "  private static Stream<Arguments> method7TestCases() {",
            "    List<Arguments> arguments = List.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "    if (true == true) {",
            "      /* { foo, bar, baz } */",
            "      return arguments.stream();",
            "    }",
            "    // BUG: Diagnostic contains: The return statement should be prefixed by a comment giving the",
            "    // names of the test case parameters",
            "    return arguments.stream();",
            "  }",
            "",
            "  private static Stream<Arguments> method8TestCases() {",
            "    /* { foo, bar, baz } */",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "",
            "  @ParameterizedTest",
            "  @MethodSource(\"method8TestCases\")",
            "  void method8(int foo, boolean bar, String baz) {}",
            "",
            "  private static Stream<Arguments> testCasesForMethod9() {",
            "    /* { foo, bar, baz } */",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "",
            "  @MethodSource(\"testCasesForMethod9\")",
            "  void method9(int foo, boolean bar, String baz) {}",
            "",
            "  @ParameterizedTest",
            "  void method10(int foo, boolean bar, String baz) {}",
            "",
            "  @ParameterizedTest",
            "  @MethodSource(\"testCasesForMethod11\")",
            "  void method11(int foo, boolean bar, String baz) {}",
            "",
            "  @Override",
            "  Stream<Arguments> testCasesForMethod11() {",
            "    /* { foo, bar, baz } */",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "}")
        .addSourceLines(
            "SuperA.java",
            "abstract class SuperA {",
            "  abstract Object testCasesForMethod11();",
            "}")
        .doTest();
  }

  @Test
  void replacement() {
    BugCheckerRefactoringTestHelper.newInstance(JUnitFactoryMethodDeclaration.class, getClass())
        .addInputLines(
            "A.java",
            "import static org.junit.jupiter.params.provider.Arguments.arguments;",
            "",
            "import java.util.stream.Stream;",
            "import org.junit.jupiter.params.ParameterizedTest;",
            "import org.junit.jupiter.params.provider.Arguments;",
            "import org.junit.jupiter.params.provider.MethodSource;",
            "",
            "class A {",
            "  @ParameterizedTest",
            "  @MethodSource(\"testCasesForMethod1\")",
            "  void method1(int foo, boolean bar, String baz) {}",
            "",
            "  private static Stream<Arguments> testCasesForMethod1() {",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "}")
        .addOutputLines(
            "A.java",
            "import static org.junit.jupiter.params.provider.Arguments.arguments;",
            "",
            "import java.util.stream.Stream;",
            "import org.junit.jupiter.params.ParameterizedTest;",
            "import org.junit.jupiter.params.provider.Arguments;",
            "import org.junit.jupiter.params.provider.MethodSource;",
            "",
            "class A {",
            "  @ParameterizedTest",
            "  @MethodSource(\"method1TestCases\")",
            "  void method1(int foo, boolean bar, String baz) {}",
            "",
            "  private static Stream<Arguments> method1TestCases() {",
            "    /* { foo, bar, baz } */",
            "    return Stream.of(arguments(1, true, \"A\"), arguments(2, false, \"B\"));",
            "  }",
            "}")
        .doTest(TestMode.TEXT_MATCH);
  }
}
