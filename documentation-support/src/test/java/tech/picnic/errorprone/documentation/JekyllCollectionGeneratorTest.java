package tech.picnic.errorprone.documentation;

import static com.google.errorprone.BugPattern.SeverityLevel.SUGGESTION;
import static com.google.errorprone.BugPattern.SeverityLevel.WARNING;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.junit.jupiter.params.provider.Arguments.argumentSet;
import static org.junit.jupiter.params.provider.Arguments.arguments;
import static tech.picnic.errorprone.documentation.JekyllCollectionGenerator.BUGPATTERNS_ROOT;
import static tech.picnic.errorprone.documentation.JekyllCollectionGenerator.REFASTER_RULES_ROOT;
import static tech.picnic.errorprone.documentation.JekyllCollectionGenerator.WEBSITE_ROOT;
import static tech.picnic.errorprone.utils.Documentation.BUG_PATTERNS_BASE_URL;

import com.google.common.collect.ImmutableList;
import com.google.errorprone.BugPattern.SeverityLevel;
import com.google.errorprone.annotations.Var;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Locale;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Stream;
import org.intellij.lang.annotations.Language;
import org.junit.jupiter.api.io.TempDir;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import tech.picnic.errorprone.documentation.ProjectInfo.BugPatternInfo;
import tech.picnic.errorprone.documentation.ProjectInfo.BugPatternTestCases;
import tech.picnic.errorprone.documentation.ProjectInfo.BugPatternTestCases.BugPatternTestCase;
import tech.picnic.errorprone.documentation.ProjectInfo.BugPatternTestCases.TestEntry;
import tech.picnic.errorprone.documentation.ProjectInfo.BugPatternTestCases.TestEntry.Identification;
import tech.picnic.errorprone.documentation.ProjectInfo.BugPatternTestCases.TestEntry.Replacement;
import tech.picnic.errorprone.documentation.ProjectInfo.RefasterTestCases;
import tech.picnic.errorprone.documentation.ProjectInfo.RefasterTestCases.RefasterTestCase;

// XXX: `Beta` -> `BetaRules`. And likewise `Alpha` -> `AlphaCheck` or something.
final class JekyllCollectionGeneratorTest {
  private static Stream<Arguments> mainWithInvalidArgsTestCases() {
    return Stream.of(arguments(ImmutableList.of()), arguments(ImmutableList.of("foo", "bar")));
  }

  @MethodSource("mainWithInvalidArgsTestCases")
  @ParameterizedTest
  void mainWithInvalidArgs(ImmutableList<String> args) {
    assertThatThrownBy(() -> JekyllCollectionGenerator.main(args.toArray(String[]::new)))
        .isInstanceOf(IllegalArgumentException.class);
  }

  @MethodSource("mainTestCases")
  @ParameterizedTest
  void main(Function<Path, TestCase> testCaseGenerator, @TempDir Path projectRoot)
      throws IOException {
    TestCase testCase = testCaseGenerator.apply(projectRoot);

    testCase.setUp();

    /*
     * In practise the `website` directory will already be present (containing e.g.
     * non-autogenerated Jekyll configuration), but for this test context it must be created
     * explicitly.
     */
    Files.createDirectories(projectRoot.resolve(WEBSITE_ROOT));

    // XXX: Validate!
    Files.writeString(
        projectRoot.resolve("README.md"),
        "# Test Readme\n\nSome content with link src=\"website/img.png\".\n",
        UTF_8);

    JekyllCollectionGenerator.main(new String[] {projectRoot.toString()});

    testCase.verify();

    // XXX: Validate `website/index.md` contents!
  }

  // XXX: Move up!
  private static Stream<Arguments> mainTestCases() {
    return Stream.of(bugpatternAndRefaster(), onlyBugpattern());
  }

  // XXX: Use `argumentSet`? Rename test cases then.
  private static Arguments bugpatternAndRefaster() {
    return argumentSet(
        "bugpattern-and-refaster",
        (Function<Path, TestCase>)
            root -> {
              ImmutableList<TestInput> inputs =
                  ImmutableList.of(
                      TestInput.create(
                          root, "module-a", JekyllCollectionGeneratorTest::bugPatternAlpha),
                      TestInput.create(
                          root,
                          "module-a",
                          JekyllCollectionGeneratorTest::bugPatternTestCasesAlpha),
                      TestInput.create(
                          root,
                          "module-b",
                          JekyllCollectionGeneratorTest::refasterTestCasesBetaInput),
                      TestInput.create(
                          root,
                          "module-b",
                          JekyllCollectionGeneratorTest::refasterTestCasesBetaOutput));

              ImmutableList<TestOutput> outputs =
                  ImmutableList.of(
                      TestOutput.bugpattern(
                          root,
                          "Alpha",
                          """
                          ---
                          title: Alpha
                          name: Alpha
                          summary: Alpha summary
                          severity: WARNING
                          tags:
                          - AlphaTag
                          source: module-a/src/main/java/alpha/Alpha.java
                          identification:
                          - |
                            // BUG: Diagnostic contains:
                            class A {}
                          replacement:
                          - "-class B {}\\n+class B { /* changed */ }\\n "
                          ---
                          """),
                      TestOutput.refaster(
                          root,
                          "Beta",
                          """
                          ---
                          title: Beta
                          name: Beta
                          severity: SUGGESTION
                          tags:
                          - Simplification
                          source: error-prone-contrib/src/main/java/tech/picnic/errorprone/refasterrules/Beta.java
                          rules:
                          - name: Rule1
                            severity: SUGGESTION
                            tags:
                            - Simplification
                            diff: "-void testRule1() {}\\n+void testRule1() { /* changed */ }\\n "
                          - name: Rule2
                            severity: SUGGESTION
                            tags:
                            - Simplification
                            diff: "-void testRule2() {}\\n+void testRule2() { /* changed */ }\\n "
                          ---
                          """));

              return new TestCase(inputs, outputs);
            });
  }

  private static Arguments onlyBugpattern() {
    return argumentSet(
        "only-bugpattern",
        (Function<Path, TestCase>)
            root -> {
              ImmutableList<TestInput> inputs =
                  ImmutableList.of(
                      new TestInput(
                          resolvePath(root, "module-d", "target", "docs", "bugpattern-Gamma.json"),
                          new BugPatternInfo(
                              root.resolve("module-d/src/main/java/pkg/Gamma.java").toUri(),
                              "pkg.Gamma",
                              "Gamma",
                              ImmutableList.of(),
                              "",
                              ImmutableList.of(),
                              "Gamma summary",
                              "",
                              SUGGESTION,
                              /* canDisable= */ true,
                              ImmutableList.of())),
                      new TestInput(
                          resolvePath(root, "module-d", "target", "docs", "tests-Gamma.json"),
                          new BugPatternTestCases(
                              root.resolve("module-d/src/test/java/pkg/GammaTest.java").toUri(),
                              "pkg.GammaTest",
                              ImmutableList.of(
                                  new BugPatternTestCase(
                                      "pkg.Gamma",
                                      ImmutableList.of(
                                          new Identification(
                                              "G.java",
                                              "// BUG: Diagnostic contains:\nclass G {}\n")))))));

              ImmutableList<TestOutput> outputs =
                  ImmutableList.of(
                      TestOutput.bugpattern(
                          root,
                          "Gamma",
                          """
                          ---
                          title: Gamma
                          name: Gamma
                          summary: Gamma summary
                          severity: SUGGESTION
                          tags: []
                          source: module-d/src/main/java/pkg/Gamma.java
                          identification:
                          - |
                            // BUG: Diagnostic contains:
                            class G {}
                          replacement: []
                          ---
                          """));

              return new TestCase(inputs, outputs);
            });
  }

  // XXX: Logically reorder the methods below.

  // XXX: Introduce another with a different severity level.
  private static BugPatternInfo bugPatternAlpha(Path projectRoot, String module) {
    return bugPattern(projectRoot, module, "Alpha", WARNING);
  }

  private static BugPatternInfo bugPattern(
      Path projectRoot, String module, String name, SeverityLevel severity) {
    String pkg = name.toLowerCase(Locale.ROOT);
    return new BugPatternInfo(
        resolvePath(projectRoot, module, "src", "main", "java", pkg, name + ".java").toUri(),
        String.join(".", pkg, name),
        name,
        ImmutableList.of("Alternative" + name),
        BUG_PATTERNS_BASE_URL + name,
        ImmutableList.of(name + "Tag"),
        name + " summary",
        name + " explanation",
        severity,
        /* canDisable= */ true,
        ImmutableList.of(SuppressWarnings.class.getCanonicalName()));
  }

  // XXX: Add variant
  private static BugPatternTestCases bugPatternTestCasesAlpha(Path projectRoot, String module) {
    return bugPatternTestCases(
        projectRoot, module, "Alpha", identificationTestA(), replacementTestB());
  }

  // XXX: Say something about odd variants not being tested. Can we instead disallow those? Drop the
  // inner `ImmutableList.of`.
  private static BugPatternTestCases bugPatternTestCases(
      Path projectRoot, String module, String name, TestEntry... testEntries) {
    String pkg = name.toLowerCase(Locale.ROOT);
    String typeName = name + "Test";
    return new BugPatternTestCases(
        resolvePath(projectRoot, module, "src", "test", "java", pkg, typeName + ".java").toUri(),
        String.join(".", pkg, typeName),
        ImmutableList.of(
            new BugPatternTestCase(
                String.join(".", pkg, name), ImmutableList.copyOf(testEntries))));
  }

  private static Identification identificationTestA() {
    return new Identification(
        "A.java",
        """
		// BUG: Diagnostic contains:
		class A {}
		""");
  }

  private static Replacement replacementTestB() {
    return new Replacement(
        "B.java",
        """
		class B {}
		""",
        """
		class B { /* changed */ }
		""");
  }

  private static RefasterTestCases refasterTestCasesBetaInput(Path projectRoot, String module) {
    return refasterTestCasesInput(
        projectRoot,
        module,
        "Beta",
        /* isInput= */ true,
        refasterTestCaseInputRule1(),
        refasterTestCaseInputRule2());
  }

  private static RefasterTestCases refasterTestCasesBetaOutput(Path projectRoot, String module) {
    return refasterTestCasesInput(
        projectRoot,
        module,
        "Beta",
        /* isInput= */ false,
        refasterTestCaseOutputRule1(),
        refasterTestCaseOutputRule2());
  }

  private static RefasterTestCases refasterTestCasesInput(
      Path projectRoot,
      String module,
      String name,
      boolean isInput,
      RefasterTestCase... testCases) {
    String pkg = name.toLowerCase(Locale.ROOT);
    String typeName = name + "Test" + (isInput ? "Input" : "Output");
    return new RefasterTestCases(
        resolvePath(projectRoot, module, "src", "test", "resources", pkg, typeName + ".java")
            .toUri(),
        name,
        isInput,
        ImmutableList.copyOf(testCases));
  }

  private static RefasterTestCase refasterTestCaseInputRule1() {
    return new RefasterTestCase("Rule1", "void testRule1() {}\n");
  }

  private static RefasterTestCase refasterTestCaseOutputRule1() {
    return new RefasterTestCase("Rule1", "void testRule1() { /* changed */ }\n");
  }

  private static RefasterTestCase refasterTestCaseInputRule2() {
    return new RefasterTestCase("Rule2", "void testRule2() {}\n");
  }

  private static RefasterTestCase refasterTestCaseOutputRule2() {
    return new RefasterTestCase("Rule2", "void testRule2() { /* changed */ }\n");
  }

  private static Path resolvePath(Path root, String... paths) {
    @Var Path result = root;
    for (String p : paths) {
      result = result.resolve(p);
    }
    return result;
  }

  private record TestCase(ImmutableList<TestInput> inputs, ImmutableList<TestOutput> outputs) {
    void setUp() throws IOException {
      for (TestInput input : inputs()) {
        input.writeFile();
      }
    }

    void verify() {
      assertThat(outputs()).allSatisfy(TestOutput::verify);
    }
  }

  // XXX: Replace remaining `new TestInput` calls.
  private record TestInput(Path path, ProjectInfo info) {
    static TestInput create(
        Path projectRoot, String module, BiFunction<Path, String, ProjectInfo> projectInfoFactory) {
      ProjectInfo projectInfo = projectInfoFactory.apply(projectRoot, module);
      String fileName = "input-%s.json".formatted(Path.of(projectInfo.source()).getFileName());
      return new TestInput(
          resolvePath(projectRoot, module, "target", "docs", fileName), projectInfo);
    }

    void writeFile() throws IOException {
      Files.createDirectories(path().getParent());
      Json.write(path(), info());
    }
  }

  private record TestOutput(Path path, @Language("yaml") String content) {
    static TestOutput bugpattern(Path projectRoot, String name, @Language("yaml") String content) {
      return create(projectRoot.resolve(BUGPATTERNS_ROOT), name, content);
    }

    static TestOutput refaster(Path projectRoot, String name, @Language("yaml") String content) {
      return create(projectRoot.resolve(REFASTER_RULES_ROOT), name, content);
    }

    private static TestOutput create(
        Path directory, String name, @Language("yaml") String content) {
      return new TestOutput(
          directory.resolve(name + ".md"), content.replace("\n", System.lineSeparator()));
    }

    void verify() {
      assertThat(path()).content(UTF_8).isEqualTo(content());
    }
  }
}
